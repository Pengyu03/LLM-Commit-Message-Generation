{"diff_id": 281, "repo": "Jackett/Jackett\n", "sha": "bf7d36669ba05ec453257f9ec24068d003a871b8\n", "time": "2019-11-28T17:53:12Z\n", "diff": "mmm a / src / Jackett . Common / Indexers / TransmitheNet . cs <nl> ppp b / src / Jackett . Common / Indexers / TransmitheNet . cs <nl> protected override async Task < IEnumerable < ReleaseInfo > > PerformQuery ( TorznabQuer <nl> await DoLogin ( ) ; <nl> } <nl> <nl> - string Url ; <nl> - if ( string . IsNullOrEmpty ( query . GetQueryString ( ) ) ) <nl> - Url = SearchUrl ; <nl> - else <nl> - { <nl> - Url = $ \" { SearchUrl } & searchtext = { WebUtility . UrlEncode ( query . GetQueryString ( ) ) } \" ; <nl> - } <nl> + / / # 6413 <nl> + / / string Url ; <nl> + / / if ( string . IsNullOrEmpty ( query . GetQueryString ( ) ) ) <nl> + / / Url = SearchUrl ; <nl> + / / else <nl> + / / { <nl> + string Url = $ \" { SearchUrl } & searchtext = { WebUtility . UrlEncode ( query . GetQueryString ( ) ) } \" ; <nl> + / / } <nl> <nl> var response = await RequestStringWithCookiesAndRetry ( Url ) ; <nl> List < ReleaseInfo > releases = ParseResponse ( response . Content ) ; <nl>\n", "msg": "transmitthenet : Add daily show support for NEB . Resolves\n"}
{"diff_id": 354, "repo": "dotnet/runtime\n", "sha": "9f8f7cf0f1e3b8f6965205a63ebcc694ddafb22c\n", "time": "2016-05-31T22:15:08Z\n", "diff": "mmm a / src / installer / DependencyContextTests . cs <nl> ppp b / src / installer / DependencyContextTests . cs <nl> private DependencyContext BuildTestContext ( ) <nl> new RuntimeFallbacks ( \" win8 - x64 \" , \" win8 \" , \" win7 - x64 \" , \" win7 \" , \" win - x64 \" , \" win \" , \" any \" , \" base \" ) , <nl> new RuntimeFallbacks ( \" win7 - x64 \" , \" win7 \" , \" win - x64 \" , \" win \" , \" any \" , \" base \" ) , <nl> new RuntimeFallbacks ( \" ubuntu - x64 \" , \" ubuntu \" , \" linux - x64 \" , \" linux \" , \" unix \" , \" any \" , \" base \" ) , <nl> + new RuntimeFallbacks ( \" ubuntu . 16 . 04 - x64 \" , \" ubuntu \" , \" linux - x64 \" , \" linux \" , \" unix \" , \" any \" , \" base \" ) , <nl> new RuntimeFallbacks ( \" rhel - x64 \" , \" rhel \" , \" linux - x64 \" , \" linux \" , \" unix \" , \" any \" , \" base \" ) , <nl> new RuntimeFallbacks ( \" osx - x64 \" , \" osx \" , \" unix \" , \" any \" , \" base \" ) , <nl> } ) ; <nl>\n", "msg": "Adding docker files , modifying scripts and code to handle ubuntu 16 . 04\n"}
{"diff_id": 427, "repo": "migueldeicaza/gui.cs\n", "sha": "c597d601a3220cceff4e686311119c030ee70c9e\n", "time": "2020-08-07T15:17:18Z\n", "diff": "mmm a / UnitTests / ViewTests . cs <nl> ppp b / UnitTests / ViewTests . cs <nl> public void Multi_Thread_Toplevels ( ) <nl> <nl> int count = 0 , count1 = 0 , count2 = 0 ; <nl> bool log = false , log1 = false , log2 = false ; <nl> + bool fromTopStillKnowFirstIsRunning = false ; <nl> + bool fromTopStillKnowSecondIsRunning = false ; <nl> + bool fromFirstStillKnowSecondIsRunning = false ; <nl> <nl> Application . MainLoop . AddTimeout ( TimeSpan . FromMilliseconds ( 100 ) , ( _ ) = > { <nl> count + + ; <nl> if ( count1 = = 5 ) { <nl> log1 = true ; <nl> } <nl> + if ( count1 > 13 & & count < 15 ) { <nl> + fromTopStillKnowFirstIsRunning = true ; <nl> + } <nl> + if ( count2 > 6 & & count2 < 8 ) { <nl> + fromTopStillKnowSecondIsRunning = true ; <nl> + } <nl> if ( count = = 30 ) { <nl> Assert . Equal ( 30 , count ) ; <nl> Assert . Equal ( 20 , count1 ) ; <nl> public void Multi_Thread_Toplevels ( ) <nl> Assert . True ( log1 ) ; <nl> Assert . True ( log2 ) ; <nl> <nl> + Assert . True ( fromTopStillKnowFirstIsRunning ) ; <nl> + Assert . True ( fromTopStillKnowSecondIsRunning ) ; <nl> + Assert . True ( fromFirstStillKnowSecondIsRunning ) ; <nl> + <nl> Application . RequestStop ( ) ; <nl> return false ; <nl> } <nl> void FirstDialogToplevel ( ) <nl> if ( count2 = = 5 ) { <nl> log2 = true ; <nl> } <nl> + if ( count2 > 3 & & count2 < 5 ) { <nl> + fromFirstStillKnowSecondIsRunning = true ; <nl> + } <nl> if ( count1 = = 20 ) { <nl> Assert . Equal ( 20 , count1 ) ; <nl> Application . RequestStop ( ) ; <nl>\n", "msg": "Added more conditions to sure it act as expected .\n"}
{"diff_id": 461, "repo": "dotnet/aspnetcore\n", "sha": "591d6c13ec665d9ac0ab71056c04841530804841\n", "time": "2019-08-16T20:47:32Z\n", "diff": "mmm a / src / Shared / BenchmarkRunner / DefaultCoreConfig . cs <nl> ppp b / src / Shared / BenchmarkRunner / DefaultCoreConfig . cs <nl> public DefaultCoreConfig ( ) <nl> Add ( Job . Core <nl> # if NETCOREAPP2_1 <nl> . With ( CsProjCoreToolchain . From ( NetCoreAppSettings . NetCoreApp21 ) ) <nl> - # else <nl> + # elif NETCOREAPP3_0 <nl> . With ( CsProjCoreToolchain . From ( new NetCoreAppSettings ( \" netcoreapp3 . 0 \" , null , \" . NET Core 3 . 0 \" ) ) ) <nl> + # elif NETCOREAPP5_0 <nl> + . With ( CsProjCoreToolchain . From ( new NetCoreAppSettings ( \" netcoreapp5 . 0 \" , null , \" . NET Core 5 . 0 \" ) ) ) <nl> + # else <nl> + # error Target frameworks need to be updated . <nl> # endif <nl> . With ( new GcMode { Server = true } ) <nl> . With ( RunStrategy . Throughput ) ) ; <nl>\n", "msg": "Add support for netcoreapp5 . 0 to micro benchmarks ( dotnet / extensions )\n"}
{"diff_id": 742, "repo": "MonoGame/MonoGame\n", "sha": "b60a4788fd1c0bfe1e3f954096ca85a870d2252c\n", "time": "2015-03-16T03:02:49Z\n", "diff": "mmm a / MonoGame . Framework / Input / Touch / TouchPanelCapabilities . cs <nl> ppp b / MonoGame . Framework / Input / Touch / TouchPanelCapabilities . cs <nl> internal void Initialize ( ) <nl> <nl> # if WINDOWS_STOREAPP <nl> / / Is a touch device present ? <nl> - var caps = new Windows . Devices . Input . TouchCapabilities ( ) ; <nl> - isConnected = caps . TouchPresent ! = 0 ; <nl> - <nl> / / Iterate through all pointer devices and find the maximum number of concurrent touches possible <nl> maximumTouchCount = 0 ; <nl> var pointerDevices = Windows . Devices . Input . PointerDevice . GetPointerDevices ( ) ; <nl> foreach ( var pointerDevice in pointerDevices ) <nl> + { <nl> maximumTouchCount = Math . Max ( maximumTouchCount , ( int ) pointerDevice . MaxContacts ) ; <nl> + <nl> + if ( pointerDevice . PointerDeviceType = = Windows . Devices . Input . PointerDeviceType . Touch ) <nl> + isConnected = true ; <nl> + } <nl> # elif WINDOWS <nl> maximumTouchCount = GetSystemMetrics ( SM_MAXIMUMTOUCHES ) ; <nl> isConnected = ( maximumTouchCount > 0 ) ; <nl>\n", "msg": "Fixed touch capability on Windows 8 when multiple input devices are present\n"}
{"diff_id": 884, "repo": "ServiceStack/ServiceStack\n", "sha": "0dc6c0ba3c31340db63de947784b0154ddbc8e1a\n", "time": "2015-10-20T21:53:00Z\n", "diff": "mmm a / src / ServiceStack . Razor / ViewPageBase . cs <nl> ppp b / src / ServiceStack . Razor / ViewPageBase . cs <nl> public virtual object ExecuteService < T > ( Func < T , object > fn ) <nl> <nl> public bool IsError <nl> { <nl> - get { return ModelError ! = null ; } <nl> + get { return ModelError ! = null | | GetErrorStatus ( ) ! = null ; } <nl> } <nl> <nl> public object ModelError { get ; set ; } <nl> public bool IsPostBack <nl> public ResponseStatus GetErrorStatus ( ) <nl> { <nl> var errorStatus = this . Request . GetItem ( HtmlFormat . ErrorStatusKey ) ; <nl> - return errorStatus as ResponseStatus ; <nl> + return errorStatus as ResponseStatus <nl> + ? ? GetResponseStatus ( ModelError ) ; <nl> + } <nl> + <nl> + private static ResponseStatus GetResponseStatus ( object response ) <nl> + { <nl> + if ( response = = null ) <nl> + return null ; <nl> + <nl> + var status = response as ResponseStatus ; <nl> + if ( status ! = null ) <nl> + return status ; <nl> + <nl> + var hasResponseStatus = response as IHasResponseStatus ; <nl> + if ( hasResponseStatus ! = null ) <nl> + return hasResponseStatus . ResponseStatus ; <nl> + <nl> + var propertyInfo = response . GetType ( ) . GetPropertyInfo ( \" ResponseStatus \" ) ; <nl> + if ( propertyInfo = = null ) <nl> + return null ; <nl> + <nl> + return propertyInfo . GetProperty ( response ) as ResponseStatus ; <nl> } <nl> <nl> public MvcHtmlString GetErrorMessage ( ) <nl> public void RedirectIfNotAuthenticated ( string redirectUrl = null ) <nl> <nl> public bool RenderErrorIfAny ( ) <nl> { <nl> - if ( ! IsError ) return false ; <nl> + var html = GetErrorHtml ( GetErrorStatus ( ) ) ; <nl> + if ( html = = null ) <nl> + return false ; <nl> + <nl> + WriteLiteral ( html ) ; <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + public MvcHtmlString GetErrorHtml ( ) <nl> + { <nl> + return MvcHtmlString . Create ( GetErrorHtml ( GetErrorStatus ( ) ) ? ? \" \" ) ; <nl> + } <nl> + <nl> + private string GetErrorHtml ( ResponseStatus responseStatus ) <nl> + { <nl> + if ( responseStatus = = null ) return null ; <nl> <nl> - var responseStatus = GetErrorStatus ( ) ; <nl> var stackTrace = responseStatus . StackTrace ! = null <nl> ? \" < pre > \" + responseStatus . StackTrace + \" < / pre > \" <nl> : \" \" ; <nl> <nl> - WriteLiteral ( @ \" <nl> - < div id = \" \" error - response \" \" class = \" \" alert alert - danger \" \" > <nl> - < h4 > \" + <nl> - responseStatus . ErrorCode + \" : \" + <nl> - responseStatus . Message + @ \" <nl> - < / h4 > \" + <nl> - stackTrace + <nl> - \" < / div > \" ) ; <nl> - <nl> - return true ; <nl> + var html = @ \" <nl> + < div id = \" \" error - response \" \" class = \" \" alert alert - danger \" \" > <nl> + < h4 > \" + <nl> + responseStatus . ErrorCode + \" : \" + <nl> + responseStatus . Message + @ \" <nl> + < / h4 > \" + <nl> + stackTrace + <nl> + \" < / div > \" ; <nl> + return html ; <nl> } <nl> } <nl> } <nl> \\ No newline at end of file <nl>\n", "msg": "Add GetErrorHtml and expand GetErrorStatus to check ModelError for ResponseStatus\n"}
{"diff_id": 1012, "repo": "dotnet/roslyn\n", "sha": "7c9ceac4354facec99b935b2a14c3b8aca9717b5\n", "time": "2020-11-09T19:16:13Z\n", "diff": "mmm a / src / VisualStudio / Core / Def / ExternalAccess / VSTypeScript / Api / VSTypeScriptContainedDocumentWrapper . cs <nl> ppp b / src / VisualStudio / Core / Def / ExternalAccess / VSTypeScript / Api / VSTypeScriptContainedDocumentWrapper . cs <nl> <nl> <nl> # pragma warning disable CS0618 / / Type or member is obsolete <nl> <nl> + using System ; <nl> using Microsoft . CodeAnalysis ; <nl> + using Microsoft . VisualStudio . LanguageServices . Implementation . ProjectSystem ; <nl> using Microsoft . VisualStudio . LanguageServices . Implementation . Venus ; <nl> using Microsoft . VisualStudio . Text ; <nl> using Microsoft . VisualStudio . TextManager . Interop ; <nl> public ITextBuffer SubjectBuffer <nl> <nl> public IVsContainedLanguageHost Host <nl> = > _underlyingObject . ContainedLanguageHost ; <nl> + <nl> + [ Obsolete ( \" Remove once TypeScript has stopped using this . \" ) ] <nl> + internal AbstractProject Project <nl> + = > _underlyingObject . Project ; <nl> + <nl> + [ Obsolete ( \" Remove once TypeScript has stopped using this . \" ) ] <nl> + internal IVisualStudioHostDocument HostDocument <nl> + = > _underlyingObject ; <nl> } <nl> } <nl>\n", "msg": "Re - add members to be removed to avoid API break\n"}
{"diff_id": 1072, "repo": "reactiveui/ReactiveUI\n", "sha": "98909e31136bdac99e8c2c503d54cf90eba69c9c\n", "time": "2013-03-08T10:01:37Z\n", "diff": "mmm a / ReactiveUI . Cocoa / KVOObservableForProperty . cs <nl> ppp b / ReactiveUI . Cocoa / KVOObservableForProperty . cs <nl> <nl> using System . Reactive . Linq ; <nl> using System . Reflection ; <nl> using ReactiveUI ; <nl> + using System . Runtime . InteropServices ; <nl> <nl> # if UIKIT <nl> using MonoTouch . UIKit ; <nl> public int GetAffinityForObject ( Type type , bool beforeChanged = false ) <nl> var bobs = new BlockObserveValueDelegate ( ( key , s , _ ) = > { <nl> subj . OnNext ( new ObservedChange < object , object > ( ) { Sender = s , PropertyName = propertyName } ) ; <nl> } ) ; <nl> + var pin = GCHandle . Alloc ( bobs ) ; <nl> <nl> obj . AddObserver ( bobs , ( NSString ) findCocoaNameFromNetName ( sender . GetType ( ) , propertyName ) , beforeChanged ? NSKeyValueObservingOptions . Old : NSKeyValueObservingOptions . New , IntPtr . Zero ) ; <nl> return Disposable . Create ( ( ) = > { <nl> obj . RemoveObserver ( bobs , ( NSString ) propertyName ) ; <nl> + pin . Free ( ) ; <nl> } ) ; <nl> } ) ; <nl> } <nl>\n", "msg": "Retain handles on KVO callback so the GC doesn ' t take it back\n"}
{"diff_id": 1332, "repo": "dotnet/aspnetcore\n", "sha": "aaae435cc3d30228a499aabc099ebc4c300ab4b8\n", "time": "2014-04-11T00:22:55Z\n", "diff": "mmm a / src / MusicStore / Controllers / StoreManagerController . cs <nl> ppp b / src / MusicStore / Controllers / StoreManagerController . cs <nl> public IActionResult Edit ( Album album ) <nl> / / <nl> / / GET : / StoreManager / Delete / 5 <nl> <nl> + [ HttpGet ] <nl> public IActionResult Delete ( int id = 0 ) <nl> { <nl> Album album = db . Albums . Single ( a = > a . AlbumId = = id ) ; <nl>\n", "msg": "Adding a [ HttpGet ] attribute to enable the Delete album from the store functionality .\n"}
{"diff_id": 1971, "repo": "mono/mono\n", "sha": "12d2fc51c5691557a5141199692d64f358da347a\n", "time": "2001-08-20T07:58:31Z\n", "diff": "mmm a / mcs / class / corlib / System . Security . Cryptography / DES . cs <nl> ppp b / mcs / class / corlib / System . Security . Cryptography / DES . cs <nl> <nl> <nl> namespace System . Security . Cryptography { <nl> <nl> - <nl> internal sealed class DESCore { <nl> <nl> internal static readonly int KEY_BIT_SIZE = 64 ; <nl> internal sealed class DESCore { <nl> <nl> <nl> private static uint [ ] spBoxes ; <nl> - private static byte [ ] ipTab ; <nl> - private static byte [ ] fpTab ; <nl> + private static int [ ] ipTab ; <nl> + private static int [ ] fpTab ; <nl> <nl> <nl> static DESCore ( ) <nl> internal DESCore ( ) <nl> <nl> <nl> <nl> - private static void InitPermutationTable ( byte [ ] pBits , out byte [ ] permTab ) <nl> + private static void InitPermutationTable ( byte [ ] pBits , out int [ ] permTab ) <nl> { <nl> - permTab = new byte [ 8 * 2 * 8 * 2 * ( 64 / 8 ) ] ; <nl> + permTab = new int [ 8 * 2 * 8 * 2 * ( 64 / 32 ) ] ; <nl> <nl> for ( int i = 0 ; i < 16 ; i + + ) { <nl> for ( int j = 0 ; j < 16 ; j + + ) { <nl> - int offs = ( i < < 7 ) + ( j < < 3 ) ; <nl> + int offs = ( i < < 5 ) + ( j < < 1 ) ; <nl> for ( int n = 0 ; n < 64 ; n + + ) { <nl> int bitNum = ( int ) pBits [ n ] ; <nl> if ( ( bitNum > > 2 = = i ) & & <nl> 0 ! = ( j & ( 8 > > ( bitNum & 3 ) ) ) ) { <nl> - permTab [ offs + ( n > > 3 ) ] | = ( byte ) ( 0x80 > > ( n & 7 ) ) ; <nl> + permTab [ offs + ( n > > ( 3 + 2 ) ) ] | = ( int ) ( ( 0x80808080 & ( 0xFF < < ( n & ( 3 < < 3 ) ) ) ) > > ( n & 7 ) ) ; <nl> } <nl> } <nl> } <nl> private uint CipherFunct ( uint r , int n ) <nl> } <nl> <nl> <nl> - / * <nl> - private static void Permutation ( byte [ ] input , byte [ ] output , byte [ ] permTab ) <nl> + private static void Permutation ( byte [ ] input , byte [ ] _output , int [ ] permTab , bool preSwap ) <nl> { <nl> - Array . Clear ( output , 0 , BLOCK_BYTE_SIZE ) ; <nl> <nl> - for ( int i = 0 , indx = 0 ; i < BLOCK_BYTE_SIZE * 2 ; i + = 2 , indx + + ) { <nl> - int offs1 = ( i < < 7 ) + ( ( ( ( int ) ( input [ indx ] ) > > 4 ) ) < < 3 ) ; <nl> - int offs2 = ( ( i + 1 ) < < 7 ) + ( ( ( ( int ) input [ indx ] ) & 0xF ) < < 3 ) ; <nl> + if ( preSwap ) BSwap ( input ) ; <nl> <nl> - for ( int j = 0 ; j < 8 ; j + + ) { <nl> - output [ j ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - } <nl> + byte [ ] output = _output ; <nl> + <nl> + int offs1 = ( ( ( int ) ( input [ 0 ] ) > > 4 ) ) < < 1 ; <nl> + int offs2 = ( 1 < < 5 ) + ( ( ( ( int ) input [ 0 ] ) & 0xF ) < < 1 ) ; <nl> + <nl> + int d1 = permTab [ offs1 + + ] | permTab [ offs2 + + ] ; <nl> + int d2 = permTab [ offs1 ] | permTab [ offs2 ] ; <nl> + <nl> + <nl> + int max = BLOCK_BYTE_SIZE < < 1 ; <nl> + for ( int i = 2 , indx = 1 ; i < max ; i + = 2 , indx + + ) { <nl> + int ii = ( int ) input [ indx ] ; <nl> + offs1 = ( i < < 5 ) + ( ( ii > > 4 ) < < 1 ) ; <nl> + offs2 = ( ( i + 1 ) < < 5 ) + ( ( ii & 0xF ) < < 1 ) ; <nl> + <nl> + d1 | = permTab [ offs1 + + ] | permTab [ offs2 + + ] ; <nl> + d2 | = permTab [ offs1 ] | permTab [ offs2 ] ; <nl> } <nl> - } <nl> - * / <nl> <nl> - private static void Permutation ( byte [ ] input , byte [ ] _output , byte [ ] permTab ) <nl> - { <nl> - byte [ ] output = _output ; <nl> - Array . Clear ( output , 0 , BLOCK_BYTE_SIZE ) ; <nl> - <nl> - int offs1 = ( ( ( int ) ( input [ 0 ] ) > > 4 ) ) < < 3 ; <nl> - int offs2 = ( 1 < < 7 ) + ( ( ( ( int ) input [ 0 ] ) & 0xF ) < < 3 ) ; <nl> - <nl> - output [ 0 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 1 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 2 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 3 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 4 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 5 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 6 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 7 ] | = ( byte ) ( permTab [ offs1 ] | permTab [ offs2 ] ) ; <nl> - <nl> - for ( int i = 2 , indx = 1 ; i < BLOCK_BYTE_SIZE * 2 ; i + = 2 , indx + + ) { <nl> - offs1 = ( i < < 7 ) + ( ( ( ( int ) ( input [ indx ] ) > > 4 ) ) < < 3 ) ; <nl> - offs2 = ( ( i + 1 ) < < 7 ) + ( ( ( ( int ) input [ indx ] ) & 0xF ) < < 3 ) ; <nl> - <nl> - output [ 0 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 1 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 2 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 3 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 4 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 5 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 6 ] | = ( byte ) ( permTab [ offs1 + + ] | permTab [ offs2 + + ] ) ; <nl> - output [ 7 ] | = ( byte ) ( permTab [ offs1 ] | permTab [ offs2 ] ) ; <nl> + if ( preSwap ) { <nl> + output [ 0 ] = ( byte ) ( d1 ) ; <nl> + output [ 1 ] = ( byte ) ( d1 > > 8 ) ; <nl> + output [ 2 ] = ( byte ) ( d1 > > 16 ) ; <nl> + output [ 3 ] = ( byte ) ( d1 > > 24 ) ; <nl> + output [ 4 ] = ( byte ) ( d2 ) ; <nl> + output [ 5 ] = ( byte ) ( d2 > > 8 ) ; <nl> + output [ 6 ] = ( byte ) ( d2 > > 16 ) ; <nl> + output [ 7 ] = ( byte ) ( d2 > > 24 ) ; <nl> + } else { <nl> + output [ 0 ] = ( byte ) ( d1 > > 24 ) ; <nl> + output [ 1 ] = ( byte ) ( d1 > > 16 ) ; <nl> + output [ 2 ] = ( byte ) ( d1 > > 8 ) ; <nl> + output [ 3 ] = ( byte ) ( d1 ) ; <nl> + output [ 4 ] = ( byte ) ( d2 > > 24 ) ; <nl> + output [ 5 ] = ( byte ) ( d2 > > 16 ) ; <nl> + output [ 6 ] = ( byte ) ( d2 > > 8 ) ; <nl> + output [ 7 ] = ( byte ) ( d2 ) ; <nl> } <nl> } <nl> <nl> <nl> <nl> <nl> - private void BSwap ( ) <nl> + private static void BSwap ( byte [ ] byteBuff ) <nl> { <nl> byte t ; <nl> <nl> - / / byte [ ] byteBuff = this . byteBuff ; <nl> - <nl> t = byteBuff [ 0 ] ; <nl> byteBuff [ 0 ] = byteBuff [ 3 ] ; <nl> byteBuff [ 3 ] = t ; <nl> internal void Encrypt ( byte [ ] block , byte [ ] output ) <nl> byte [ ] byteBuff = this . byteBuff ; <nl> uint [ ] dwordBuff = this . dwordBuff ; <nl> <nl> - Permutation ( block , byteBuff , ipTab ) ; <nl> + Permutation ( block , byteBuff , ipTab , false ) ; <nl> <nl> - <nl> - BSwap ( ) ; <nl> Buffer . BlockCopy ( byteBuff , 0 , dwordBuff , 0 , BLOCK_BYTE_SIZE ) ; <nl> <nl> + uint d0 = dwordBuff [ 0 ] ; <nl> + uint d1 = dwordBuff [ 1 ] ; <nl> + <nl> / / 16 rounds <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 0 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 1 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 2 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 3 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 4 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 5 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 6 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 7 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 8 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 9 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 10 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 11 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 12 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 13 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 14 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 15 ) ; <nl> - <nl> - <nl> - uint t = dwordBuff [ 0 ] ; <nl> - dwordBuff [ 0 ] = dwordBuff [ 1 ] ; <nl> - dwordBuff [ 1 ] = t ; <nl> + d0 ^ = CipherFunct ( d1 , 0 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 1 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 2 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 3 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 4 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 5 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 6 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 7 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 8 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 9 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 10 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 11 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 12 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 13 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 14 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 15 ) ; <nl> + <nl> + <nl> + dwordBuff [ 0 ] = d1 ; <nl> + dwordBuff [ 1 ] = d0 ; <nl> Buffer . BlockCopy ( dwordBuff , 0 , byteBuff , 0 , BLOCK_BYTE_SIZE ) ; <nl> - BSwap ( ) ; <nl> <nl> - Permutation ( byteBuff , dest , fpTab ) ; <nl> + Permutation ( byteBuff , dest , fpTab , true ) ; <nl> } <nl> <nl> <nl> internal void Decrypt ( byte [ ] block , byte [ ] output ) <nl> byte [ ] byteBuff = this . byteBuff ; <nl> uint [ ] dwordBuff = this . dwordBuff ; <nl> <nl> - Permutation ( block , byteBuff , ipTab ) ; <nl> + Permutation ( block , byteBuff , ipTab , false ) ; <nl> <nl> - BSwap ( ) ; <nl> Buffer . BlockCopy ( byteBuff , 0 , dwordBuff , 0 , BLOCK_BYTE_SIZE ) ; <nl> <nl> - uint t = dwordBuff [ 0 ] ; <nl> - dwordBuff [ 0 ] = dwordBuff [ 1 ] ; <nl> - dwordBuff [ 1 ] = t ; <nl> + uint d1 = dwordBuff [ 0 ] ; <nl> + uint d0 = dwordBuff [ 1 ] ; <nl> <nl> / / 16 rounds in reverse order <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 15 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 14 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 13 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 12 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 11 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 10 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 9 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 8 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 7 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 6 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 5 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 4 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 3 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 2 ) ; <nl> - dwordBuff [ 1 ] ^ = CipherFunct ( dwordBuff [ 0 ] , 1 ) ; <nl> - dwordBuff [ 0 ] ^ = CipherFunct ( dwordBuff [ 1 ] , 0 ) ; <nl> - <nl> + d1 ^ = CipherFunct ( d0 , 15 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 14 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 13 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 12 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 11 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 10 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 9 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 8 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 7 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 6 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 5 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 4 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 3 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 2 ) ; <nl> + d1 ^ = CipherFunct ( d0 , 1 ) ; <nl> + d0 ^ = CipherFunct ( d1 , 0 ) ; <nl> + <nl> + dwordBuff [ 0 ] = d0 ; <nl> + dwordBuff [ 1 ] = d1 ; <nl> <nl> <nl> Buffer . BlockCopy ( dwordBuff , 0 , byteBuff , 0 , BLOCK_BYTE_SIZE ) ; <nl> - BSwap ( ) ; <nl> <nl> - Permutation ( byteBuff , dest , fpTab ) ; <nl> + Permutation ( byteBuff , dest , fpTab , true ) ; <nl> } <nl> <nl> <nl>\n", "msg": "Encryption core is approximately 30 % faster than previous version .\n"}
{"diff_id": 1999, "repo": "dotnet/roslyn\n", "sha": "d07aecda92c8c54d5b36d9f53e4e2c9604a78698\n", "time": "2020-02-20T23:53:54Z\n", "diff": "mmm a / src / Features / Core / Portable / AddDebuggerDisplay / AbstractAddDebuggerDisplayCodeRefactoringProvider . cs <nl> ppp b / src / Features / Core / Portable / AddDebuggerDisplay / AbstractAddDebuggerDisplayCodeRefactoringProvider . cs <nl> public override async Task ComputeRefactoringsAsync ( CodeRefactoringContext conte <nl> <nl> var typeSymbol = ( ITypeSymbol ) semanticModel . GetDeclaredSymbol ( type , context . CancellationToken ) ; <nl> <nl> - var debuggerDisplayAttributeClass = semanticModel . Compilation . GetTypeByMetadataName ( \" System . Diagnostics . DebuggerDisplayAttribute \" ) ; <nl> - <nl> - if ( typeSymbol . GetAttributes ( ) <nl> - . Select ( data = > data . AttributeClass ) <nl> - . Contains ( debuggerDisplayAttributeClass ) ) <nl> + if ( IsClassOrStruct ( typeSymbol ) & & ! HasDebuggerDisplayAttribute ( typeSymbol , semanticModel . Compilation ) ) <nl> { <nl> - return ; <nl> + context . RegisterRefactoring ( new MyCodeAction ( <nl> + FeaturesResources . Add_DebuggerDisplay , <nl> + cancellationToken = > ApplyAsync ( context . Document , type , cancellationToken ) ) ) ; <nl> } <nl> + } <nl> <nl> + private static bool IsClassOrStruct ( ITypeSymbol typeSymbol ) <nl> + { <nl> switch ( typeSymbol . TypeKind ) <nl> { <nl> case TypeKind . Class : <nl> case TypeKind . Struct : <nl> - context . RegisterRefactoring ( new MyCodeAction ( <nl> - FeaturesResources . Add_DebuggerDisplay , <nl> - cancellationToken = > ApplyAsync ( context . Document , type , cancellationToken ) ) ) ; <nl> - break ; <nl> + return true ; <nl> + default : <nl> + return false ; <nl> } <nl> } <nl> <nl> + private static bool HasDebuggerDisplayAttribute ( ITypeSymbol typeSymbol , Compilation compilation ) <nl> + { <nl> + return typeSymbol . GetAttributes ( ) <nl> + . Select ( data = > data . AttributeClass ) <nl> + . Contains ( compilation . GetTypeByMetadataName ( \" System . Diagnostics . DebuggerDisplayAttribute \" ) ) ; <nl> + } <nl> + <nl> private async Task < Document > ApplyAsync ( Document document , TTypeDeclarationSyntax type , CancellationToken cancellationToken ) <nl> { <nl> var syntaxRoot = await document . GetSyntaxRootAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl>\n", "msg": "Extract methods for clarity and do the less expensive check first\n"}
{"diff_id": 2034, "repo": "neuecc/UniRx\n", "sha": "c279c29cb0bf2b7c90a17dc3867d6bb1cb4ee3c6\n", "time": "2014-06-20T19:20:36Z\n", "diff": "mmm a / Assets / UniRx / Scripts / UnityEngineBridge / ObservableWWW . cs <nl> ppp b / Assets / UniRx / Scripts / UnityEngineBridge / ObservableWWW . cs <nl> public static IObservable < byte [ ] > GetAndGetBytes ( string url , Hash headers = null <nl> { <nl> return Observable . FromCoroutine < byte [ ] > ( ( observer , cancellation ) = > FetchBytes ( new WWW ( url , null , ( headers ? ? new Hash ( ) ) ) , observer , progress , cancellation ) ) ; <nl> } <nl> + public static IObservable < WWW > GetWWW ( string url , Hash headers = null , IProgress < float > progress = null ) <nl> + { <nl> + return Observable . FromCoroutine < WWW > ( ( observer , cancellation ) = > Fetch ( new WWW ( url , null , ( headers ? ? new Hash ( ) ) ) , observer , progress , cancellation ) ) ; <nl> + } <nl> <nl> public static IObservable < string > Post ( string url , WWWForm content , IProgress < float > progress = null ) <nl> { <nl> public static IObservable < byte [ ] > PostAndGetBytes ( string url , WWWForm content , H <nl> return Observable . FromCoroutine < byte [ ] > ( ( observer , cancellation ) = > FetchBytes ( new WWW ( url , content . data , MergeHash ( content . headers , headers ) ) , observer , progress , cancellation ) ) ; <nl> } <nl> <nl> + public static IObservable < WWW > PostWWW ( string url , WWWForm content , IProgress < float > progress = null ) <nl> + { <nl> + return Observable . FromCoroutine < WWW > ( ( observer , cancellation ) = > Fetch ( new WWW ( url , content ) , observer , progress , cancellation ) ) ; <nl> + } <nl> + <nl> + public static IObservable < WWW > PostWWW ( string url , WWWForm content , Hash headers , IProgress < float > progress = null ) <nl> + { <nl> + return Observable . FromCoroutine < WWW > ( ( observer , cancellation ) = > Fetch ( new WWW ( url , content . data , MergeHash ( content . headers , headers ) ) , observer , progress , cancellation ) ) ; <nl> + } <nl> + <nl> static Hash MergeHash ( Hash source1 , Hash source2 ) <nl> { <nl> foreach ( HashEntry item in source2 ) <nl> static Hash MergeHash ( Hash source1 , Hash source2 ) <nl> return source1 ; <nl> } <nl> <nl> + static IEnumerator Fetch ( WWW www , IObserver < WWW > observer , IProgress < float > reportProgress , CancellationToken cancel ) <nl> + { <nl> + using ( www ) <nl> + { <nl> + while ( ! www . isDone & & ! cancel . IsCancellationRequested ) <nl> + { <nl> + if ( reportProgress ! = null ) <nl> + { <nl> + try <nl> + { <nl> + reportProgress . Report ( www . progress ) ; <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + observer . OnError ( ex ) ; <nl> + yield break ; <nl> + } <nl> + } <nl> + yield return null ; <nl> + } <nl> + <nl> + if ( cancel . IsCancellationRequested ) yield break ; <nl> + <nl> + if ( ! string . IsNullOrEmpty ( www . error ) ) <nl> + { <nl> + observer . OnError ( new WWWErrorException ( www ) ) ; <nl> + } <nl> + else <nl> + { <nl> + observer . OnNext ( www ) ; <nl> + observer . OnCompleted ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> static IEnumerator FetchText ( WWW www , IObserver < string > observer , IProgress < float > reportProgress , CancellationToken cancel ) <nl> { <nl> using ( www ) <nl> static IEnumerator FetchText ( WWW www , IObserver < string > observer , IProgress < floa <nl> <nl> if ( ! string . IsNullOrEmpty ( www . error ) ) <nl> { <nl> - observer . OnError ( new WWWErrorException ( www . error , www . responseHeaders ) ) ; <nl> + observer . OnError ( new WWWErrorException ( www ) ) ; <nl> } <nl> else <nl> { <nl> static IEnumerator FetchBytes ( WWW www , IObserver < byte [ ] > observer , IProgress < flo <nl> <nl> if ( ! string . IsNullOrEmpty ( www . error ) ) <nl> { <nl> - observer . OnError ( new WWWErrorException ( www . error , www . responseHeaders ) ) ; <nl> + observer . OnError ( new WWWErrorException ( www ) ) ; <nl> } <nl> else <nl> { <nl> public class WWWErrorException : Exception <nl> public bool HasResponse { get ; private set ; } <nl> public System . Net . HttpStatusCode StatusCode { get ; private set ; } <nl> public System . Collections . Generic . Dictionary < string , string > ResponseHeaders { get ; private set ; } <nl> + public WWW WWW { get ; private set ; } <nl> <nl> - public WWWErrorException ( string errorMessage , System . Collections . Generic . Dictionary < string , string > responseHeaders ) <nl> + public WWWErrorException ( WWW www ) <nl> { <nl> - this . RawErrorMessage = errorMessage ; <nl> - this . ResponseHeaders = responseHeaders ; <nl> + this . WWW = www ; <nl> + this . RawErrorMessage = www . error ; <nl> + this . ResponseHeaders = www . responseHeaders ; <nl> this . HasResponse = false ; <nl> <nl> - var splitted = errorMessage . Split ( ' ' ) ; <nl> + var splitted = RawErrorMessage . Split ( ' ' ) ; <nl> if ( splitted . Length ! = 0 ) <nl> { <nl> int statusCode ; <nl>\n", "msg": "add Observable . GetWWW / PostWWW ( returns IObservable < WWW > for detailed control )\n"}
{"diff_id": 2376, "repo": "dotnet/roslyn\n", "sha": "a06657dff44aba8002e1d11d3fac0f2196e0d019\n", "time": "2015-12-09T22:28:51Z\n", "diff": "mmm a / src / Workspaces / Core / Portable / FindSymbols / SymbolTree / SymbolTreeInfo . cs <nl> ppp b / src / Workspaces / Core / Portable / FindSymbols / SymbolTree / SymbolTreeInfo . cs <nl> private static void GenerateNodes ( INamespaceSymbol globalNamespace , List < Node > l <nl> } <nl> } <nl> <nl> + private static readonly Func < ISymbol , bool > IgnoreSymbol = <nl> + s = > ! s . CanBeReferencedByName | | s . DeclaredAccessibility = = Accessibility . Private ; <nl> + <nl> / / generate nodes for symbols that share the same name , and all their descendants <nl> private static void GenerateNodes ( string name , int parentIndex , IEnumerable < INamespaceOrTypeSymbol > symbolsWithSameName , List < Node > list ) <nl> { <nl> / / Don ' t bother adding entries for names that can ' t even be referenced in code . <nl> / / Also , don ' t bother if all the symbols with this name are private . <nl> - if ( ! symbolsWithSameName . Any ( s = > s . CanBeReferencedByName ) | | <nl> - symbolsWithSameName . All ( s = > s . DeclaredAccessibility = = Accessibility . Private ) ) <nl> + if ( symbolsWithSameName . All ( IgnoreSymbol ) ) <nl> { <nl> return ; <nl> } <nl>\n", "msg": "Produce less lambdas . Only iterate over the collection once .\n"}
{"diff_id": 2521, "repo": "icsharpcode/ILSpy\n", "sha": "e320819103a1417bc9e9dc182175ab07ed0b5502\n", "time": "2020-08-27T14:25:43Z\n", "diff": "mmm a / ICSharpCode . Decompiler / IL / Transforms / SwitchOnStringTransform . cs <nl> ppp b / ICSharpCode . Decompiler / IL / Transforms / SwitchOnStringTransform . cs <nl> bool AddSwitchSection ( string value , ILInstruction inst ) <nl> return false ; <nl> / / extract all cases and add them to the values list . <nl> ILInstruction nextCaseBlock ; <nl> - while ( ( nextCaseBlock = MatchCaseBlock ( currentCaseBlock , switchValueVar , out string value , out bool emptyStringEqualsNull , out ILInstruction block ) ) ! = null ) { <nl> + do { <nl> + nextCaseBlock = MatchCaseBlock ( currentCaseBlock , switchValueVar , out string value , out bool emptyStringEqualsNull , out ILInstruction block ) ; <nl> + if ( nextCaseBlock = = null ) <nl> + break ; <nl> if ( emptyStringEqualsNull & & string . IsNullOrEmpty ( value ) ) { <nl> if ( ! AddSwitchSection ( null , block ) ) <nl> return false ; <nl> bool AddSwitchSection ( string value , ILInstruction inst ) <nl> return false ; <nl> } <nl> currentCaseBlock = nextCaseBlock as Block ; <nl> - if ( currentCaseBlock = = null ) <nl> - break ; <nl> - } <nl> + } while ( currentCaseBlock ! = null ) ; <nl> <nl> / / We didn ' t find enough cases , exit <nl> if ( values . Count < 3 ) <nl>\n", "msg": "Formatting change : while - condition loop to do - while loop .\n"}
{"diff_id": 2656, "repo": "OpenRA/OpenRA\n", "sha": "aecfff905d98e9d2ef9bcf432dec626f7f3365a9\n", "time": "2017-05-28T12:02:18Z\n", "diff": "mmm a / OpenRA . Mods . Common / Traits / Modifiers / FrozenUnderFog . cs <nl> ppp b / OpenRA . Mods . Common / Traits / Modifiers / FrozenUnderFog . cs <nl> <nl> namespace OpenRA . Mods . Common . Traits <nl> { <nl> [ Desc ( \" This actor will remain visible ( but not updated visually ) under fog , once discovered . \" ) ] <nl> - public class FrozenUnderFogInfo : ITraitInfo , Requires < BuildingInfo > , IDefaultVisibilityInfo <nl> + public class FrozenUnderFogInfo : ITraitInfo , Requires < BuildingInfo > , IDefaultVisibilityInfo , IRulesetLoaded <nl> { <nl> [ Desc ( \" Players with these stances can always see the actor . \" ) ] <nl> public readonly Stance AlwaysVisibleStances = Stance . Ally ; <nl> <nl> + void IRulesetLoaded < ActorInfo > . RulesetLoaded ( Ruleset rules , ActorInfo info ) <nl> + { <nl> + if ( ! info . HasTraitInfo < SelectableInfo > ( ) & & ! info . HasTraitInfo < IAutoSelectionSizeInfo > ( ) ) <nl> + throw new YamlException ( \" Cannot create a frozen actor for actor type ' { 0 } ' with empty bounds ( no selection size given ) . \" . F ( info . Name ) ) ; <nl> + } <nl> + <nl> public object Create ( ActorInitializer init ) { return new FrozenUnderFog ( init , this ) ; } <nl> } <nl> <nl> public FrozenUnderFog ( ActorInitializer init , FrozenUnderFogInfo info ) <nl> footprint = footprintCells . SelectMany ( c = > map . ProjectedCellsCovering ( c . ToMPos ( map ) ) ) . ToArray ( ) ; <nl> } <nl> <nl> - public void Created ( Actor self ) <nl> + void INotifyCreated . Created ( Actor self ) <nl> { <nl> frozenStates = new PlayerDictionary < FrozenState > ( self . World , ( player , playerIndex ) = > <nl> { <nl>\n", "msg": "Throw a more detailed error message when creating invalid frozen actors\n"}
{"diff_id": 2747, "repo": "dotnet/maui\n", "sha": "317f1533e92c582eb5b30797955e64254b73d50f\n", "time": "2018-06-28T17:30:19Z\n", "diff": "mmm a / Xamarin . Forms . Core . UITests . Shared / UITestCategories . cs <nl> ppp b / Xamarin . Forms . Core . UITests . Shared / UITestCategories . cs <nl> internal static class UITestCategories <nl> public const string Gestures = \" Gestures \" ; <nl> public const string Navigation = \" Navigation \" ; <nl> public const string Effects = \" Effects \" ; <nl> - public const string Animation = \" Animation \" ; <nl> <nl> public const string ManualReview = \" ManualReview \" ; <nl> public const string Performance = \" Performance \" ; <nl>\n", "msg": "[ Build ] Fix merge , remove category Aniamtion\n"}
{"diff_id": 2901, "repo": "migueldeicaza/gui.cs\n", "sha": "787d65b1617d8d9db323b998771a5cb4c09f06e0\n", "time": "2020-02-29T16:51:49Z\n", "diff": "mmm a / Terminal . Gui / Views / ListView . cs <nl> ppp b / Terminal . Gui / Views / ListView . cs <nl> public override bool ProcessKey ( KeyEvent kb ) <nl> switch ( kb . Key ) { <nl> case Key . CursorUp : <nl> case Key . ControlP : <nl> - if ( selected > 0 ) { <nl> - selected - - ; <nl> - if ( selected < top ) <nl> - top = selected ; <nl> - if ( SelectedChanged ! = null ) <nl> - SelectedChanged ( ) ; <nl> - SetNeedsDisplay ( ) ; <nl> - } <nl> - return true ; <nl> + return MoveUp ( ) ; <nl> <nl> case Key . CursorDown : <nl> case Key . ControlN : <nl> - if ( selected + 1 < source . Count ) { <nl> - selected + + ; <nl> - if ( selected > = top + Frame . Height ) <nl> - top + + ; <nl> - if ( SelectedChanged ! = null ) <nl> - SelectedChanged ( ) ; <nl> - SetNeedsDisplay ( ) ; <nl> - } <nl> - return true ; <nl> + return MoveDown ( ) ; <nl> <nl> case Key . ControlV : <nl> case Key . PageDown : <nl> - var n = ( selected + Frame . Height ) ; <nl> - if ( n > source . Count ) <nl> - n = source . Count - 1 ; <nl> - if ( n ! = selected ) { <nl> - selected = n ; <nl> - if ( source . Count > = Frame . Height ) <nl> - top = selected ; <nl> - else <nl> - top = 0 ; <nl> - if ( SelectedChanged ! = null ) <nl> - SelectedChanged ( ) ; <nl> - SetNeedsDisplay ( ) ; <nl> - } <nl> - return true ; <nl> + return MovePageDown ( ) ; <nl> <nl> case Key . PageUp : <nl> - n = ( selected - Frame . Height ) ; <nl> - if ( n < 0 ) <nl> - n = 0 ; <nl> - if ( n ! = selected ) { <nl> - selected = n ; <nl> - top = selected ; <nl> - if ( SelectedChanged ! = null ) <nl> - SelectedChanged ( ) ; <nl> - SetNeedsDisplay ( ) ; <nl> - } <nl> - return true ; <nl> + return MovePageUp ( ) ; <nl> <nl> case Key . Space : <nl> - if ( allowsMarking ) { <nl> - Source . SetMark ( SelectedItem , ! Source . IsMarked ( SelectedItem ) ) ; <nl> - SetNeedsDisplay ( ) ; <nl> + if ( MarkUnmarkRow ( ) ) <nl> return true ; <nl> - } <nl> - break ; <nl> + else <nl> + break ; <nl> } <nl> return base . ProcessKey ( kb ) ; <nl> } <nl> <nl> + public virtual bool MarkUnmarkRow ( ) { <nl> + if ( allowsMarking ) { <nl> + Source . SetMark ( SelectedItem , ! Source . IsMarked ( SelectedItem ) ) ; <nl> + SetNeedsDisplay ( ) ; <nl> + return true ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + <nl> + public virtual bool MovePageUp ( ) { <nl> + int n = ( selected - Frame . Height ) ; <nl> + if ( n < 0 ) <nl> + n = 0 ; <nl> + if ( n ! = selected ) { <nl> + selected = n ; <nl> + top = selected ; <nl> + if ( SelectedChanged ! = null ) <nl> + SelectedChanged ( ) ; <nl> + SetNeedsDisplay ( ) ; <nl> + } <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + public virtual bool MovePageDown ( ) { <nl> + var n = ( selected + Frame . Height ) ; <nl> + if ( n > source . Count ) <nl> + n = source . Count - 1 ; <nl> + if ( n ! = selected ) { <nl> + selected = n ; <nl> + if ( source . Count > = Frame . Height ) <nl> + top = selected ; <nl> + else <nl> + top = 0 ; <nl> + if ( SelectedChanged ! = null ) <nl> + SelectedChanged ( ) ; <nl> + SetNeedsDisplay ( ) ; <nl> + } <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + public virtual bool MoveDown ( ) { <nl> + if ( selected + 1 < source . Count ) { <nl> + selected + + ; <nl> + if ( selected > = top + Frame . Height ) <nl> + top + + ; <nl> + if ( SelectedChanged ! = null ) <nl> + SelectedChanged ( ) ; <nl> + SetNeedsDisplay ( ) ; <nl> + } <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + public virtual bool MoveUp ( ) { <nl> + if ( selected > 0 ) { <nl> + selected - - ; <nl> + if ( selected < top ) <nl> + top = selected ; <nl> + if ( SelectedChanged ! = null ) <nl> + SelectedChanged ( ) ; <nl> + SetNeedsDisplay ( ) ; <nl> + } <nl> + <nl> + return true ; <nl> + } <nl> + <nl> / / / < summary > <nl> / / / Positions the cursor in this view <nl> / / / < / summary > <nl>\n", "msg": "extract methods on ListView to make it controlable from other controls ( )\n"}
{"diff_id": 2971, "repo": "dotnet/efcore\n", "sha": "48fca1e1388adee8b463cdb6a8bbfeafafcbf031\n", "time": "2020-03-24T12:15:39Z\n", "diff": "mmm a / src / EFCore . SqlServer / Extensions / SqlServerDbFunctionsExtensions . cs <nl> ppp b / src / EFCore . SqlServer / Extensions / SqlServerDbFunctionsExtensions . cs <nl> public static class SqlServerDbFunctionsExtensions <nl> / / / < param name = \" _ \" > The DbFunctions instance . < / param > <nl> / / / < param name = \" arg \" > The value to be examined for data length . < / param > <nl> / / / < returns > The number of bytes in the input value . < / returns > <nl> - public static long ? DataLength ( <nl> + public static int ? DataLength ( <nl> [ CanBeNull ] this DbFunctions _ , <nl> [ CanBeNull ] string arg ) <nl> = > throw new InvalidOperationException ( SqlServerStrings . FunctionOnClient ( nameof ( DataLength ) ) ) ; <nl> public static class SqlServerDbFunctionsExtensions <nl> / / / < param name = \" _ \" > The DbFunctions instance . < / param > <nl> / / / < param name = \" arg \" > The value to be examined for data length . < / param > <nl> / / / < returns > The number of bytes in the input value . < / returns > <nl> - public static long ? DataLength ( <nl> + public static int ? DataLength ( <nl> [ CanBeNull ] this DbFunctions _ , <nl> bool ? arg ) <nl> = > throw new InvalidOperationException ( SqlServerStrings . FunctionOnClient ( nameof ( DataLength ) ) ) ; <nl> public static class SqlServerDbFunctionsExtensions <nl> / / / < param name = \" _ \" > The DbFunctions instance . < / param > <nl> / / / < param name = \" arg \" > The value to be examined for data length . < / param > <nl> / / / < returns > The number of bytes in the input value . < / returns > <nl> - public static long ? DataLength ( <nl> + public static int ? DataLength ( <nl> [ CanBeNull ] this DbFunctions _ , <nl> double ? arg ) <nl> = > throw new InvalidOperationException ( SqlServerStrings . FunctionOnClient ( nameof ( DataLength ) ) ) ; <nl> public static class SqlServerDbFunctionsExtensions <nl> / / / < param name = \" _ \" > The DbFunctions instance . < / param > <nl> / / / < param name = \" arg \" > The value to be examined for data length . < / param > <nl> / / / < returns > The number of bytes in the input value . < / returns > <nl> - public static long ? DataLength ( <nl> + public static int ? DataLength ( <nl> [ CanBeNull ] this DbFunctions _ , <nl> decimal ? arg ) <nl> = > throw new InvalidOperationException ( SqlServerStrings . FunctionOnClient ( nameof ( DataLength ) ) ) ; <nl> public static class SqlServerDbFunctionsExtensions <nl> / / / < param name = \" _ \" > The DbFunctions instance . < / param > <nl> / / / < param name = \" arg \" > The value to be examined for data length . < / param > <nl> / / / < returns > The number of bytes in the input value . < / returns > <nl> - public static long ? DataLength ( <nl> + public static int ? DataLength ( <nl> [ CanBeNull ] this DbFunctions _ , <nl> DateTime ? arg ) <nl> = > throw new InvalidOperationException ( SqlServerStrings . FunctionOnClient ( nameof ( DataLength ) ) ) ; <nl> public static class SqlServerDbFunctionsExtensions <nl> / / / < param name = \" _ \" > The DbFunctions instance . < / param > <nl> / / / < param name = \" arg \" > The value to be examined for data length . < / param > <nl> / / / < returns > The number of bytes in the input value . < / returns > <nl> - public static long ? DataLength ( <nl> + public static int ? DataLength ( <nl> [ CanBeNull ] this DbFunctions _ , <nl> TimeSpan ? arg ) <nl> = > throw new InvalidOperationException ( SqlServerStrings . FunctionOnClient ( nameof ( DataLength ) ) ) ; <nl> public static class SqlServerDbFunctionsExtensions <nl> / / / < param name = \" _ \" > The DbFunctions instance . < / param > <nl> / / / < param name = \" arg \" > The value to be examined for data length . < / param > <nl> / / / < returns > The number of bytes in the input value . < / returns > <nl> - public static long ? DataLength ( <nl> + public static int ? DataLength ( <nl> [ CanBeNull ] this DbFunctions _ , <nl> DateTimeOffset ? arg ) <nl> = > throw new InvalidOperationException ( SqlServerStrings . FunctionOnClient ( nameof ( DataLength ) ) ) ; <nl> public static class SqlServerDbFunctionsExtensions <nl> / / / < param name = \" _ \" > The DbFunctions instance . < / param > <nl> / / / < param name = \" arg \" > The value to be examined for data length . < / param > <nl> / / / < returns > The number of bytes in the input value . < / returns > <nl> - public static long ? DataLength ( <nl> + public static int ? DataLength ( <nl> [ CanBeNull ] this DbFunctions _ , <nl> [ CanBeNull ] byte [ ] arg ) <nl> = > throw new InvalidOperationException ( SqlServerStrings . FunctionOnClient ( nameof ( DataLength ) ) ) ; <nl> public static class SqlServerDbFunctionsExtensions <nl> / / / < param name = \" _ \" > The DbFunctions instance . < / param > <nl> / / / < param name = \" arg \" > The value to be examined for data length . < / param > <nl> / / / < returns > The number of bytes in the input value . < / returns > <nl> - public static long ? DataLength ( <nl> + public static int ? DataLength ( <nl> [ CanBeNull ] this DbFunctions _ , <nl> Guid ? arg ) <nl> = > throw new InvalidOperationException ( SqlServerStrings . FunctionOnClient ( nameof ( DataLength ) ) ) ; <nl>\n", "msg": "Changed long ? to int ? for DataLength function\n"}
{"diff_id": 3033, "repo": "winsw/winsw\n", "sha": "ddf9d4b2bf73e1457dde3990ba7af6838bbd6333\n", "time": "2011-10-27T16:19:11Z\n", "diff": "mmm a / ServiceDescriptor . cs <nl> ppp b / ServiceDescriptor . cs <nl> private string AppendTags ( string tagName ) <nl> <nl> foreach ( XmlNode argument in dom . SelectNodes ( \" / / \" + tagName ) ) <nl> { <nl> - string token = argument . InnerText ; <nl> + string token = Environment . ExpandEnvironmentVariables ( argument . InnerText ) ; <nl> <nl> if ( token . StartsWith ( \" \\ \" \" ) & & token . EndsWith ( \" \\ \" \" ) ) <nl> { <nl> private string AppendTags ( string tagName ) <nl> arguments + = \" \" + token ; <nl> } <nl> <nl> - return Environment . ExpandEnvironmentVariables ( arguments ) ; <nl> + return arguments ; <nl> } <nl> } <nl> <nl>\n", "msg": "env variable expansion needs to happen first if we want to really detect\n"}
{"diff_id": 3130, "repo": "dotnet/roslyn\n", "sha": "4e57a00aa88337e1454d4710d708712ac727b845\n", "time": "2014-08-18T17:08:06Z\n", "diff": "mmm a / Src / Compilers / CSharp / Test / Emit / Emit / EditAndContinue / EditAndContinueTests . cs <nl> ppp b / Src / Compilers / CSharp / Test / Emit / Emit / EditAndContinue / EditAndContinueTests . cs <nl> . maxstack 1 <nl> / / / Reuse existing anonymous types . <nl> / / / < / summary > <nl> [ WorkItem ( 825903 , \" DevDiv \" ) ] <nl> - [ Fact ] <nl> + [ Fact ( Skip = \" 1008057 \" ) ] <nl> public void AnonymousTypes ( ) <nl> { <nl> var source0 = <nl>\n", "msg": "exclude broken test . bug filed . ( changeset 1318072 )\n"}
{"diff_id": 3493, "repo": "ServiceStack/ServiceStack\n", "sha": "5feae757e8961a65150b6c2fb61f96620c8138a7\n", "time": "2017-03-25T05:31:55Z\n", "diff": "mmm a / src / ServiceStack . Client / AsyncServiceClient . cs <nl> ppp b / src / ServiceStack . Client / AsyncServiceClient . cs <nl> private void ResponseCallback < T > ( IAsyncResult asyncResult ) <nl> { <nl> if ( RefreshToken ! = null ) <nl> { <nl> - var refreshRequest = new GetAccessToken { RefreshToken = RefreshToken } ; <nl> + var refreshRequest = new GetAccessToken { RefreshToken = RefreshToken } ; <nl> var uri = this . RefreshTokenUri ? ? this . BaseUri . CombineWith ( refreshRequest . ToPostUrl ( ) ) ; <nl> - var tokenResponse = uri . PostJsonToUrl ( refreshRequest ) . FromJson < GetAccessTokenResponse > ( ) ; <nl> + <nl> + GetAccessTokenResponse tokenResponse ; <nl> + try <nl> + { <nl> + tokenResponse = uri . PostJsonToUrl ( refreshRequest ) . FromJson < GetAccessTokenResponse > ( ) ; <nl> + } <nl> + catch ( WebException refreshEx ) <nl> + { <nl> + var webServiceEx = ServiceClientBase . ToWebServiceException ( refreshEx , <nl> + stream = > StreamDeserializer ( typeof ( T ) , stream ) , <nl> + ContentType ) ; <nl> + <nl> + if ( webServiceEx ! = null ) <nl> + throw new RefreshTokenException ( webServiceEx ) ; <nl> + <nl> + throw new RefreshTokenException ( refreshEx . Message , refreshEx ) ; <nl> + } <nl> + <nl> var accessToken = tokenResponse ? . AccessToken ; <nl> if ( string . IsNullOrEmpty ( accessToken ) ) <nl> - throw new Exception ( \" Could not retrieve new AccessToken from : \" + uri ) ; <nl> + throw new RefreshTokenException ( \" Could not retrieve new AccessToken from : \" + uri ) ; <nl> <nl> - var refreshClient = requestState . WebRequest = ( HttpWebRequest ) WebRequest . Create ( requestState . Url ) ; <nl> + var refreshClient = requestState . WebRequest = <nl> + ( HttpWebRequest ) WebRequest . Create ( requestState . Url ) ; <nl> if ( this . CookieContainer . GetTokenCookie ( BaseUri ) ! = null ) <nl> { <nl> this . CookieContainer . SetTokenCookie ( accessToken , BaseUri ) ; <nl> private void ResponseCallback < T > ( IAsyncResult asyncResult ) <nl> <nl> OnAuthenticationRequired ? . Invoke ( ) ; <nl> <nl> - requestState . WebRequest = ( HttpWebRequest ) WebRequest . Create ( requestState . Url ) ; <nl> + requestState . WebRequest = ( HttpWebRequest ) WebRequest . Create ( requestState . Url ) ; <nl> <nl> if ( StoreCookies ) <nl> requestState . WebRequest . CookieContainer = CookieContainer ; <nl> private void ResponseCallback < T > ( IAsyncResult asyncResult ) <nl> requestState . HttpMethod , requestState . Request , <nl> requestState , requestState . WebRequest ) ; <nl> } <nl> + catch ( WebServiceException rethrow ) <nl> + { <nl> + requestState . HandleError ( default ( T ) , rethrow ) ; <nl> + } <nl> catch ( Exception / * subEx * / ) <nl> { <nl> HandleResponseError ( ex , requestState ) ; <nl>\n", "msg": "Change AsyncServiceClient to throw RefreshTokenException when error retrieving RefreshToken\n"}
{"diff_id": 3750, "repo": "OpenRA/OpenRA\n", "sha": "7656ad3d125e20d29ddb197a10469e372505340e\n", "time": "2015-08-02T15:26:15Z\n", "diff": "mmm a / OpenRA . Mods . Common / Scripting / Global / LightingGlobal . cs <nl> ppp b / OpenRA . Mods . Common / Scripting / Global / LightingGlobal . cs <nl> public void Flash ( string type = null , int ticks = - 1 ) <nl> <nl> public double Red <nl> { <nl> - get { return hasLighting ? lighting . Red : 0d ; } <nl> + get { return hasLighting ? lighting . Red : 1d ; } <nl> set { if ( hasLighting ) lighting . Red = ( float ) value ; } <nl> } <nl> <nl> public double Green <nl> { <nl> - get { return hasLighting ? lighting . Green : 0d ; } <nl> + get { return hasLighting ? lighting . Green : 1d ; } <nl> set { if ( hasLighting ) lighting . Green = ( float ) value ; } <nl> } <nl> <nl> public double Blue <nl> { <nl> - get { return hasLighting ? lighting . Blue : 0d ; } <nl> + get { return hasLighting ? lighting . Blue : 1d ; } <nl> set { if ( hasLighting ) lighting . Blue = ( float ) value ; } <nl> } <nl> <nl> public double Ambient <nl> { <nl> - get { return hasLighting ? lighting . Ambient : 0d ; } <nl> + get { return hasLighting ? lighting . Ambient : 1d ; } <nl> set { if ( hasLighting ) lighting . Ambient = ( float ) value ; } <nl> } <nl> } <nl>\n", "msg": "Use a default of 1d instead of 0d in LightingGlobal if the necessary trait doesn ' t exist\n"}
{"diff_id": 4034, "repo": "mono/mono\n", "sha": "09e2f61b588664af5c9baccf50c7c088dbf805dc\n", "time": "2004-10-05T08:42:20Z\n", "diff": "mmm a / mcs / class / Managed . Windows . Forms / System . Windows . Forms / ToolBarButton . cs <nl> ppp b / mcs / class / Managed . Windows . Forms / System . Windows . Forms / ToolBarButton . cs <nl> <nl> / / OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , OUT OF OR IN CONNECTION <nl> / / WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE . <nl> / / <nl> - / / Copyright ( C ) 2004 Novell , Inc . <nl> + / / Copyright ( C ) 2004 Novell , Inc . ( http : / / www . novell . com ) <nl> / / <nl> / / Authors : <nl> / / Ravindra ( rkumar @ novell . com ) <nl> <nl> / / - DropDownMenu <nl> / / - Adding a button to two toolbars <nl> / / <nl> - / / $ Revision : 1 . 7 $ <nl> + / / $ Revision : 1 . 8 $ <nl> / / $ Modtime : $ <nl> / / $ Log : ToolBarButton . cs , v $ <nl> + / / Revision 1 . 8 2004 / 10 / 05 08 : 42 : 20 ravindra <nl> + / / Added an internal member dd_pressed to handle clicks on DropDown arrow . <nl> + / / <nl> / / Revision 1 . 7 2004 / 09 / 09 11 : 23 : 05 ravindra <nl> / / Changes in ToolBarButton need to make it ' s parent redraw . <nl> / / <nl> public class ToolBarButton : Component <nl> { <nl> # region instance variable <nl> / / private ContextMenu menu ; / / NotImplemented <nl> + internal bool dd_pressed = false ; / / flag to check for a mouse down on dropdown rect <nl> private bool enabled = true ; <nl> private int imageIndex = - 1 ; <nl> private ToolBar parent ; <nl>\n", "msg": "Added an internal member dd_pressed to handle clicks on DropDown arrow .\n"}
{"diff_id": 4252, "repo": "mono/mono\n", "sha": "122b56052bf83f7a74f18b855edce7fbd7d50e54\n", "time": "2011-01-21T12:48:09Z\n", "diff": "mmm a / mcs / class / corlib / System . Threading . Tasks / ThreadWorker . cs <nl> ppp b / mcs / class / corlib / System . Threading . Tasks / ThreadWorker . cs <nl> bool WorkerMethod ( ) <nl> ThreadWorker [ ] others , <nl> ManualResetEvent evt ) <nl> { <nl> + / / Before anything , we try to execute the self task as it may be the simplest way to unlock <nl> + / / the situation <nl> + self . Execute ( autoReference ! = null ? autoReference . ChildWorkAdder : ( Action < Task > ) null ) ; <nl> + if ( predicateEvt . IsSet ) <nl> + return ; <nl> + <nl> const int stage1 = 5 , stage2 = 0 ; <nl> int tries = 8 ; <nl> WaitHandle [ ] handles = null ; <nl> Watch watch = Watch . StartNew ( ) ; <nl> if ( millisecondsTimeout = = - 1 ) <nl> millisecondsTimeout = int . MaxValue ; <nl> + bool aggressive = false ; <nl> <nl> while ( ! predicateEvt . IsSet & & watch . ElapsedMilliseconds < millisecondsTimeout ) { <nl> Task value ; <nl> bool WorkerMethod ( ) <nl> if ( autoReference ! = null ) { <nl> while ( autoReference . dDeque . PopBottom ( out value ) = = PopResult . Succeed & & value ! = null ) { <nl> evt . Set ( ) ; <nl> - if ( CheckTaskFitness ( self , value ) ) <nl> + if ( CheckTaskFitness ( self , value ) | | aggressive ) <nl> value . Execute ( autoReference . ChildWorkAdder ) ; <nl> else { <nl> sharedWorkQueue . TryAdd ( value ) ; <nl> bool WorkerMethod ( ) <nl> / / Dequeue only one item as we have restriction <nl> while ( - - count > = 0 & & sharedWorkQueue . TryTake ( out value ) & & value ! = null ) { <nl> evt . Set ( ) ; <nl> - if ( CheckTaskFitness ( self , value ) ) <nl> + if ( CheckTaskFitness ( self , value ) | | aggressive ) <nl> value . Execute ( null ) ; <nl> else { <nl> if ( autoReference = = null ) <nl> bool WorkerMethod ( ) <nl> <nl> if ( other . dDeque . PopTop ( out value ) = = PopResult . Succeed & & value ! = null ) { <nl> evt . Set ( ) ; <nl> - if ( CheckTaskFitness ( self , value ) ) <nl> + if ( CheckTaskFitness ( self , value ) | | aggressive ) <nl> value . Execute ( null ) ; <nl> else { <nl> if ( autoReference = = null ) <nl> bool WorkerMethod ( ) <nl> return ; <nl> } <nl> <nl> + / * Waiting is split in 4 phases <nl> + * - until stage 1 we simply yield the thread to let others add data <nl> + * - between stage 1 and stage2 we use ManualResetEventSlim light waiting mechanism <nl> + * - after stage2 we fall back to the heavier WaitHandle waiting mechanism <nl> + * - if really the situation isn ' t evolving after a couple of sleep , we disable <nl> + * task fitness check altogether <nl> + * / <nl> if ( - - tries > stage1 ) <nl> Thread . Yield ( ) ; <nl> else if ( tries > = stage2 ) <nl> bool WorkerMethod ( ) <nl> if ( tries = = stage2 - 1 ) <nl> handles = new [ ] { predicateEvt . WaitHandle , evt } ; <nl> WaitHandle . WaitAny ( handles , ComputeTimeout ( 1000 , millisecondsTimeout , watch ) ) ; <nl> + if ( tries = = stage2 - 10 ) <nl> + aggressive = true ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Add a last resort mode to ThreadWorker participative waiting to prevent some deadlock for now\n"}
{"diff_id": 4401, "repo": "dotnet/runtime\n", "sha": "397bbac3e226d3e3152e05de8d4ce0d355403df1\n", "time": "2016-08-30T20:47:09Z\n", "diff": "mmm a / src / libraries / System . Collections / src / System / Collections / Generic / Queue . cs <nl> ppp b / src / libraries / System . Collections / src / System / Collections / Generic / Queue . cs <nl> IEnumerator IEnumerable . GetEnumerator ( ) <nl> } <nl> <nl> / / Removes the object at the head of the queue and returns it . If the queue <nl> - / / is empty , this method simply returns null . <nl> + / / is empty , this method throws an <nl> + / / InvalidOperationException . <nl> / / / < include file = ' doc \\ Queue . uex ' path = ' docs / doc [ @ for = \" Queue . Dequeue \" ] / * ' / > <nl> public T Dequeue ( ) <nl> { <nl>\n", "msg": "Changing Dequeue method commend to reflect method behaviour . Dequeue throws InvalidOperationException when queue is empty\n"}
{"diff_id": 4445, "repo": "mono/mono\n", "sha": "bc4942ad5125cb2bc17ccaa169fe3d0962624ab6\n", "time": "2006-01-13T18:38:19Z\n", "diff": "mmm a / mcs / class / Managed . Windows . Forms / System . Windows . Forms / TreeView . cs <nl> ppp b / mcs / class / Managed . Windows . Forms / System . Windows . Forms / TreeView . cs <nl> private void HScrollBarValueChanged ( object sender , EventArgs e ) <nl> } <nl> <nl> private void MouseWheelHandler ( object sender , MouseEventArgs e ) { <nl> - int scroll_to ; <nl> - <nl> if ( vbar = = null | | ! vbar . Visible ) { <nl> return ; <nl> } <nl> <nl> if ( e . Delta < 0 ) { <nl> - / / Scrolling down \" SystemInformation . MouseWheelScrollLines \" <nl> - / / FIXME - put logic here <nl> - scroll_to = Math . Min ( vbar . Value + SystemInformation . MouseWheelScrollLines , vbar . Maximum ) ; <nl> + vbar . Value = Math . Min ( vbar . Value + SystemInformation . MouseWheelScrollLines , vbar . Maximum ) ; <nl> } else { <nl> - / / Scrolling up \" SystemInformation . MouseWheelScrollLines \" <nl> - / / FIXME - put logic here <nl> - scroll_to = Math . Max ( 0 , vbar . Value - SystemInformation . MouseWheelScrollLines ) ; <nl> + vbar . Value = Math . Max ( 0 , vbar . Value - SystemInformation . MouseWheelScrollLines ) ; <nl> } <nl> - <nl> - vbar . Value = scroll_to ; <nl> } <nl> <nl> private void FontChangedHandler ( object sender , EventArgs e ) <nl>\n", "msg": "- Shouldn ' t put fixme notes in if it doesn ' t need fixing . Also simplified a bit\n"}
{"diff_id": 4647, "repo": "StackExchange/StackExchange.Redis\n", "sha": "6af707740563cdef124ccf2376c679d1d5417aef\n", "time": "2016-07-03T22:47:12Z\n", "diff": "mmm a / StackExchange . Redis . Tests / TestBase . cs <nl> ppp b / StackExchange . Redis . Tests / TestBase . cs <nl> protected IServer GetServer ( ConnectionMultiplexer muxer ) <nl> bool checkConnect = true , bool pause = true , string failMessage = null , <nl> string channelPrefix = null , bool useSharedSocketManager = true , Proxy ? proxy = null ) <nl> { <nl> - if ( pause ) Thread . Sleep ( 500 ) ; / / get a lot of glitches when hammering new socket creations etc ; pace it out a bit <nl> + if ( pause ) Thread . Sleep ( 250 ) ; / / get a lot of glitches when hammering new socket creations etc ; pace it out a bit <nl> string configuration = GetConfiguration ( ) ; <nl> var config = ConfigurationOptions . Parse ( configuration ) ; <nl> if ( disabledCommands ! = null & & disabledCommands . Length ! = 0 ) <nl>\n", "msg": "Shorten test durations quite a bit , half the pause\n"}
{"diff_id": 5020, "repo": "ppy/osu\n", "sha": "7272ba2f1b5429a9fffdb0999d9c4324922b47ff\n", "time": "2018-03-19T11:06:44Z\n", "diff": "mmm a / osu . Game / Skinning / SkinManager . cs <nl> ppp b / osu . Game / Skinning / SkinManager . cs <nl> public List < SkinInfo > GetAllUsableSkins ( ) <nl> Name = archive . Name <nl> } ; <nl> <nl> + protected override void Populate ( SkinInfo model , ArchiveReader archive ) <nl> + { <nl> + base . Populate ( model , archive ) ; <nl> + populate ( model ) ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Populate a < see cref = \" SkinInfo \" / > from its < see cref = \" SkinConfiguration \" / > ( if possible ) . <nl> + / / / < / summary > <nl> + / / / < param name = \" model \" > < / param > <nl> + private void populate ( SkinInfo model ) <nl> + { <nl> + Skin reference = GetSkin ( model ) ; <nl> + if ( ! string . IsNullOrEmpty ( reference . Configuration . SkinInfo . Name ) ) <nl> + { <nl> + model . Name = reference . Configuration . SkinInfo . Name ; <nl> + model . Creator = reference . Configuration . SkinInfo . Creator ; <nl> + } <nl> + else <nl> + { <nl> + model . Name = model . Name . Replace ( \" . osk \" , \" \" ) ; <nl> + model . Creator = \" Unknown \" ; <nl> + } <nl> + } <nl> + <nl> / / / < summary > <nl> / / / Retrieve a < see cref = \" Skin \" / > instance for the provided < see cref = \" SkinInfo \" / > <nl> / / / < / summary > <nl> public SkinManager ( Storage storage , DatabaseContextFactory contextFactory , IIpcH <nl> if ( skin . SkinInfo ! = CurrentSkinInfo . Value ) <nl> throw new InvalidOperationException ( $ \" Setting { nameof ( CurrentSkin ) } ' s value directly is not supported . Use { nameof ( CurrentSkinInfo ) } instead . \" ) ; <nl> } ; <nl> + <nl> + / / migrate older imports which didn ' t have access to skin . ini <nl> + using ( ContextFactory . GetForWrite ( ) ) <nl> + { <nl> + foreach ( var skinInfo in ModelStore . ConsumableItems . Where ( s = > s . Name . EndsWith ( \" . osk \" ) ) ) <nl> + { <nl> + populate ( skinInfo ) ; <nl> + Update ( skinInfo ) ; <nl> + } <nl> + } <nl> } <nl> <nl> / / / < summary > <nl>\n", "msg": "Add migration for skins which didn ' t get a proper name assigned\n"}
{"diff_id": 5185, "repo": "dotnet/runtime\n", "sha": "39b7dece7ab3c73f78de81eb332662d36bcfe055\n", "time": "2015-09-13T23:00:15Z\n", "diff": "mmm a / src / mono / msvc / scripts / genproj . cs <nl> ppp b / src / mono / msvc / scripts / genproj . cs <nl> class MsbuildGenerator { <nl> public const string profile_2_0 = \" _2_0 \" ; <nl> public const string profile_3_5 = \" _3_5 \" ; <nl> public const string profile_4_0 = \" _4_0 \" ; <nl> - public const string profile_4_5 = \" _4_5 \" ; <nl> + public const string profile_4_x = \" _4_x \" ; <nl> <nl> static void Usage ( ) <nl> { <nl> public VsCsproj Generate ( Dictionary < string , MsbuildGenerator > projects , bool sho <nl> } else if ( response . Contains ( profile_4_0 ) ) { <nl> fx_version = \" 4 . 0 \" ; <nl> profile = \" net_4_0 \" ; <nl> - } else if ( response . Contains ( profile_4_5 ) ) { <nl> + } else if ( response . Contains ( profile_4_x ) ) { <nl> fx_version = \" 4 . 5 \" ; <nl> - profile = \" net_4_5 \" ; <nl> + profile = \" net_4_x \" ; <nl> } <nl> } <nl> / / <nl> public static string GetRelativePath ( string from , string to ) <nl> <nl> MsbuildGenerator GetMatchingCsproj ( string dllReferenceName , Dictionary < string , MsbuildGenerator > projects , bool explicitPath = false ) <nl> { <nl> - / / libDir would be \" . / . . / . . / class / lib / net_4_5 for example <nl> + / / libDir would be \" . / . . / . . / class / lib / net_4_x for example <nl> / / project <nl> if ( ! dllReferenceName . EndsWith ( \" . dll \" ) ) <nl> dllReferenceName + = \" . dll \" ; <nl> static IEnumerable < XElement > GetProjects ( bool full = false ) <nl> / / The next ones are to make debugging easier for now <nl> if ( profile = = \" basic \" ) <nl> continue ; <nl> - if ( profile ! = \" net_4_5 \" | | library . Contains ( \" tests \" ) ) <nl> + if ( profile ! = \" net_4_x \" | | library . Contains ( \" tests \" ) ) <nl> continue ; <nl> <nl> yield return project ; <nl> static void Main ( string [ ] args ) <nl> Func < MsbuildGenerator . VsCsproj , bool > additionalFilter ; <nl> additionalFilter = fullSolutions ? ( Func < MsbuildGenerator . VsCsproj , bool > ) null : IsCommonLibrary ; <nl> <nl> - FillSolution ( four_five_sln_gen , MsbuildGenerator . profile_4_5 , projects . Values , additionalFilter ) ; <nl> + FillSolution ( four_five_sln_gen , MsbuildGenerator . profile_4_x , projects . Values , additionalFilter ) ; <nl> <nl> var sb = new StringBuilder ( ) ; <nl> sb . AppendLine ( \" WARNING : Skipped some project references , apparent duplicates in order . xml : \" ) ; <nl> static void Main ( string [ ] args ) <nl> } <nl> Console . WriteLine ( sb . ToString ( ) ) ; <nl> <nl> - WriteSolution ( four_five_sln_gen , MakeSolutionName ( MsbuildGenerator . profile_4_5 ) ) ; <nl> + WriteSolution ( four_five_sln_gen , MakeSolutionName ( MsbuildGenerator . profile_4_x ) ) ; <nl> <nl> if ( makefileDeps ) { <nl> const string classDirPrefix = \" . / . . / . . / \" ; <nl>\n", "msg": "[ genproj ] Update the generator to handle the net_4_x profile .\n"}
{"diff_id": 5221, "repo": "OpenRA/OpenRA\n", "sha": "800f6adc2121412e5dfb4c1c3a77c1cf67c502fc\n", "time": "2017-09-22T11:29:15Z\n", "diff": "mmm a / OpenRA . Mods . Common / Traits / Render / WithSpriteTurret . cs <nl> ppp b / OpenRA . Mods . Common / Traits / Render / WithSpriteTurret . cs <nl> public WithSpriteTurret ( Actor self , WithSpriteTurretInfo info ) <nl> t . QuantizedFacings = DefaultAnimation . CurrentSequence . Facings ; <nl> } <nl> <nl> - WVec TurretOffset ( Actor self ) <nl> + protected virtual WVec TurretOffset ( Actor self ) <nl> { <nl> if ( ! Info . Recoils ) <nl> return t . Position ( self ) ; <nl>\n", "msg": "Made WithSpriteTurret . TurretOffset protected virtual to be overridden by mod traits .\n"}
{"diff_id": 5384, "repo": "nopSolutions/nopCommerce\n", "sha": "f758626726ed8c79913448012f73b046f8d42ae6\n", "time": "2020-12-24T10:38:54Z\n", "diff": "mmm a / src / Tests / Nop . Tests / BaseNopTest . cs <nl> ppp b / src / Tests / Nop . Tests / BaseNopTest . cs <nl> <nl> using Nop . Core . Caching ; <nl> using Nop . Core . ComponentModel ; <nl> using Nop . Core . Configuration ; <nl> + using Nop . Core . Domain . Catalog ; <nl> using Nop . Core . Domain . Customers ; <nl> + using Nop . Core . Domain . Media ; <nl> using Nop . Core . Events ; <nl> using Nop . Core . Infrastructure ; <nl> using Nop . Data ; <nl> <nl> using Nop . Web . Framework . Themes ; <nl> using Nop . Web . Framework . UI ; <nl> using Nop . Web . Infrastructure . Installation ; <nl> + using SixLabors . ImageSharp ; <nl> + using SixLabors . ImageSharp . PixelFormats ; <nl> + using SixLabors . ImageSharp . Processing ; <nl> using IAuthenticationService = Nop . Services . Authentication . IAuthenticationService ; <nl> using Task = System . Threading . Tasks . Task ; <nl> <nl> static BaseNopTest ( ) <nl> services . AddTransient < IShippingPluginManager , ShippingPluginManager > ( ) ; <nl> services . AddTransient < ITaxPluginManager , TaxPluginManager > ( ) ; <nl> <nl> - services . AddTransient < IPictureService , PictureService > ( ) ; <nl> + services . AddTransient < IPictureService , TestPictureService > ( ) ; <nl> <nl> / / register all settings <nl> var settings = typeFinder . FindClassesOfType ( typeof ( ISettings ) , false ) . ToList ( ) ; <nl> public async Task < Customer > GetAuthenticatedCustomerAsync ( ) <nl> } <nl> } <nl> <nl> + protected class TestPictureService : PictureService <nl> + { <nl> + public TestPictureService ( INopDataProvider dataProvider , IDownloadService downloadService , <nl> + IHttpContextAccessor httpContextAccessor , INopFileProvider fileProvider , <nl> + IProductAttributeParser productAttributeParser , IRepository < Picture > pictureRepository , <nl> + IRepository < PictureBinary > pictureBinaryRepository , <nl> + IRepository < ProductPicture > productPictureRepository , ISettingService settingService , <nl> + IUrlRecordService urlRecordService , IWebHelper webHelper , MediaSettings mediaSettings ) : base ( <nl> + dataProvider , downloadService , httpContextAccessor , fileProvider , productAttributeParser , <nl> + pictureRepository , pictureBinaryRepository , productPictureRepository , settingService , urlRecordService , <nl> + webHelper , mediaSettings ) <nl> + { <nl> + } <nl> + <nl> + / / Travis doesn ' t support named semaphore , that ' s why we use implementation without it <nl> + public override async Task < ( string Url , Picture Picture ) > GetPictureUrlAsync ( Picture picture , <nl> + int targetSize = 0 , <nl> + bool showDefaultPicture = true , <nl> + string storeLocation = null , <nl> + PictureType defaultPictureType = PictureType . Entity ) <nl> + { <nl> + if ( picture = = null ) <nl> + return showDefaultPicture <nl> + ? ( await GetDefaultPictureUrlAsync ( targetSize , defaultPictureType , storeLocation ) , null ) <nl> + : ( string . Empty , ( Picture ) null ) ; <nl> + <nl> + byte [ ] pictureBinary = null ; <nl> + if ( picture . IsNew ) <nl> + { <nl> + await DeletePictureThumbsAsync ( picture ) ; <nl> + pictureBinary = await LoadPictureBinaryAsync ( picture ) ; <nl> + <nl> + if ( ( pictureBinary ? . Length ? ? 0 ) = = 0 ) <nl> + return showDefaultPicture <nl> + ? ( await GetDefaultPictureUrlAsync ( targetSize , defaultPictureType , storeLocation ) , picture ) <nl> + : ( string . Empty , picture ) ; <nl> + <nl> + / / we do not validate picture binary here to ensure that no exception ( \" Parameter is not valid \" ) will be thrown <nl> + picture = await UpdatePictureAsync ( picture . Id , <nl> + pictureBinary , <nl> + picture . MimeType , <nl> + picture . SeoFilename , <nl> + picture . AltAttribute , <nl> + picture . TitleAttribute , <nl> + false , <nl> + false ) ; <nl> + } <nl> + <nl> + var seoFileName = picture . SeoFilename ; / / = GetPictureSeName ( picture . SeoFilename ) ; / / just for sure <nl> + <nl> + var lastPart = await GetFileExtensionFromMimeTypeAsync ( picture . MimeType ) ; <nl> + string thumbFileName ; <nl> + if ( targetSize = = 0 ) <nl> + thumbFileName = ! string . IsNullOrEmpty ( seoFileName ) <nl> + ? $ \" { picture . Id : 0000000 } _ { seoFileName } . { lastPart } \" <nl> + : $ \" { picture . Id : 0000000 } . { lastPart } \" ; <nl> + else <nl> + thumbFileName = ! string . IsNullOrEmpty ( seoFileName ) <nl> + ? $ \" { picture . Id : 0000000 } _ { seoFileName } _ { targetSize } . { lastPart } \" <nl> + : $ \" { picture . Id : 0000000 } _ { targetSize } . { lastPart } \" ; <nl> + <nl> + var thumbFilePath = await GetThumbLocalPathAsync ( thumbFileName ) ; <nl> + <nl> + if ( await GeneratedThumbExistsAsync ( thumbFilePath , thumbFileName ) ) <nl> + return ( await GetThumbUrlAsync ( thumbFileName , storeLocation ) , picture ) ; <nl> + <nl> + / / check , if the file was created , while we were waiting for the release of the mutex . <nl> + if ( ! await GeneratedThumbExistsAsync ( thumbFilePath , thumbFileName ) ) <nl> + { <nl> + pictureBinary ? ? = await LoadPictureBinaryAsync ( picture ) ; <nl> + <nl> + if ( ( pictureBinary ? . Length ? ? 0 ) = = 0 ) <nl> + return showDefaultPicture <nl> + ? ( await GetDefaultPictureUrlAsync ( targetSize , defaultPictureType , storeLocation ) , <nl> + picture ) <nl> + : ( string . Empty , picture ) ; <nl> + <nl> + byte [ ] pictureBinaryResized ; <nl> + if ( targetSize ! = 0 ) <nl> + { <nl> + / / resizing required <nl> + using var image = Image . Load < Rgba32 > ( pictureBinary , out var imageFormat ) ; <nl> + image . Mutate ( imageProcess = > imageProcess . Resize ( new ResizeOptions <nl> + { <nl> + Mode = ResizeMode . Max , Size = CalculateDimensions ( image . Size ( ) , targetSize ) <nl> + } ) ) ; <nl> + <nl> + pictureBinaryResized = await EncodeImageAsync ( image , imageFormat ) ; <nl> + } <nl> + else <nl> + / / create a copy of pictureBinary <nl> + pictureBinaryResized = pictureBinary . ToArray ( ) ; <nl> + <nl> + await SaveThumbAsync ( thumbFilePath , thumbFileName , picture . MimeType , pictureBinaryResized ) ; <nl> + } <nl> + <nl> + return ( await GetThumbUrlAsync ( thumbFileName , storeLocation ) , picture ) ; <nl> + } <nl> + } <nl> + <nl> # endregion <nl> } <nl> } <nl> \\ No newline at end of file <nl>\n", "msg": "Prevented using named semaphore in test , because Travis doesn ' t support it\n"}
{"diff_id": 5431, "repo": "NancyFx/Nancy\n", "sha": "636f5200d502a4615a9f393a63c246c15f1c75a2\n", "time": "2013-01-20T04:06:14Z\n", "diff": "mmm a / src / Nancy / TinyIoc / TinyIoC . cs <nl> ppp b / src / Nancy / TinyIoc / TinyIoC . cs <nl> public MultiRegisterOptions RegisterMultiple ( Type registrationType , IEnumerable < <nl> throw new ArgumentException ( String . Format ( \" types : The type { 0 } is not assignable from { 1 } \" , registrationType . FullName , type . FullName ) ) ; <nl> <nl> if ( implementationTypes . Count ( ) ! = implementationTypes . Distinct ( ) . Count ( ) ) <nl> - throw new ArgumentException ( \" types : The same implementation type cannot be specificed multiple times \" ) ; <nl> + { <nl> + var queryForDuplicatedTypes = from i in implementationTypes <nl> + group i by i <nl> + into j <nl> + where j . Count ( ) > 1 <nl> + select j . Key . FullName ; <nl> + <nl> + var fullNamesOfDuplicatedTypes = string . Join ( \" , \\ n \" , queryForDuplicatedTypes ) ; <nl> + <nl> + throw new ArgumentException ( \" types : The same implementation type cannot be specificed multiple times \\ n \\ n \" + fullNamesOfDuplicatedTypes ) ; <nl> + } <nl> <nl> var registerOptions = new List < RegisterOptions > ( ) ; <nl> <nl>\n", "msg": "updated exception message to include types that were duplicated\n"}
{"diff_id": 5469, "repo": "ppy/osu\n", "sha": "1f04dd9adabe868b2ab0a6f04b3dac072554f990\n", "time": "2018-06-17T13:08:13Z\n", "diff": "mmm a / osu . Game . Tests / Visual / TestCaseChatLink . cs <nl> ppp b / osu . Game . Tests / Visual / TestCaseChatLink . cs <nl> private void load ( OsuColour colours ) <nl> var chatManager = new ChannelManager ( ) ; <nl> chatManager . AvailableChannels . Add ( new Channel { Name = \" # english \" } ) ; <nl> chatManager . AvailableChannels . Add ( new Channel { Name = \" # japanese \" } ) ; <nl> - dependencies . Cache ( chatManager ) ; <nl> + Dependencies . Cache ( chatManager ) ; <nl> <nl> - dependencies . Cache ( new ChatOverlay ( ) ) ; <nl> + Dependencies . Cache ( new ChatOverlay ( ) ) ; <nl> <nl> testLinksGeneral ( ) ; <nl> testEcho ( ) ; <nl>\n", "msg": "Cache the dependencies using the static method of the class Dependencies .\n"}
{"diff_id": 5763, "repo": "mono/mono\n", "sha": "982cad2e22ef04460f5b4d411c6b95219358b04a\n", "time": "2001-10-01T13:12:32Z\n", "diff": "mmm a / mcs / class / corlib / Linux / Linux . cs <nl> ppp b / mcs / class / corlib / Linux / Linux . cs <nl> public int SetLengthFile ( IntPtr handle , long length ) <nl> public void FlushFile ( IntPtr handle , byte [ ] byteBuf ) <nl> { <nl> WriteFile ( handle , byteBuf , 0 , byteBuf . Length ) ; <nl> - _fflush ( handle ) ; <nl> } <nl> <nl> public IntPtr OpenFile ( string path , FileMode mode , FileAccess access , FileShare share ) <nl> public long SeekFile ( IntPtr handle , long offset , SeekOrigin origin ) <nl> { <nl> switch ( origin ) { <nl> case SeekOrigin . End : <nl> - return _fseek ( handle , ( int ) offset , SEEK_END ) ; <nl> + return _lseek ( handle , ( int ) offset , SEEK_END ) ; <nl> case SeekOrigin . Current : <nl> - return _fseek ( handle , ( int ) offset , SEEK_CUR ) ; <nl> + return _lseek ( handle , ( int ) offset , SEEK_CUR ) ; <nl> default : <nl> - return _fseek ( handle , ( int ) offset , SEEK_SET ) ; <nl> + return _lseek ( handle , ( int ) offset , SEEK_SET ) ; <nl> } <nl> <nl> } <nl> public long FileLength ( IntPtr handle ) <nl> [ DllImport ( \" libc \" , EntryPoint = \" ftruncate \" , CharSet = CharSet . Ansi ) ] <nl> private unsafe static extern int _ftruncate ( IntPtr fd , int count ) ; <nl> <nl> - [ DllImport ( \" libc \" , EntryPoint = \" fseek \" , CharSet = CharSet . Ansi ) ] <nl> - private unsafe static extern int _fseek ( IntPtr fd , int offset , int whence ) ; <nl> + [ DllImport ( \" libc \" , EntryPoint = \" lseek \" , CharSet = CharSet . Ansi ) ] <nl> + private unsafe static extern int _lseek ( IntPtr fd , int offset , int whence ) ; <nl> <nl> [ DllImport ( \" libc \" , EntryPoint = \" fflush \" , CharSet = CharSet . Ansi ) ] <nl> private unsafe static extern int _fflush ( IntPtr fd ) ; <nl>\n", "msg": "No need to flush a filehandle ( and anyway you can ' t since fflush\n"}
{"diff_id": 5857, "repo": "ServiceStack/ServiceStack\n", "sha": "4fcbe189c0a1b027d03027d44da88f6545916f1b\n", "time": "2014-11-17T08:28:24Z\n", "diff": "mmm a / src / ServiceStack / NativeTypes / TypeScript / TypeScriptGenerator . cs <nl> ppp b / src / ServiceStack / NativeTypes / TypeScript / TypeScriptGenerator . cs <nl> public string GetCode ( MetadataTypes metadata , IRequest request ) <nl> sb . AppendLine ( \" declare module ServiceStack \" ) ; <nl> sb . AppendLine ( \" { \" ) ; <nl> sb = sb . Indent ( ) ; <nl> + <nl> sb . AppendLine ( \" interface IReturnVoid { } \" ) ; <nl> sb . AppendLine ( \" interface IReturn < T > { } \" ) ; <nl> + <nl> sb = sb . UnIndent ( ) ; <nl> sb . AppendLine ( \" } \" ) ; <nl> sb . AppendLine ( ) ; <nl> public string GetCode ( MetadataTypes metadata , IRequest request ) <nl> sb . AppendLine ( \" declare module { 0 } \" . Fmt ( globalNamespace . SafeToken ( ) ) ) ; <nl> sb . AppendLine ( \" { \" ) ; <nl> <nl> - / / sb . AppendLine ( ) ; <nl> - / / foreach ( var ns in namespaces ) <nl> - / / { <nl> - / / sb . AppendLine ( \" / / import { 0 } ; \" . Fmt ( ns ) ) ; <nl> - / / } <nl> - <nl> / / ServiceStack core interfaces <nl> foreach ( var type in allTypes ) <nl> { <nl> public string GetCode ( MetadataTypes metadata , IRequest request ) <nl> } <nl> <nl> sb . AppendLine ( ) ; <nl> + sb . AppendLine ( \" } \" ) ; <nl> <nl> return sb . ToString ( ) ; <nl> } <nl> public string GetCode ( MetadataTypes metadata , IRequest request ) <nl> <nl> / / : BaseClass , Interfaces <nl> if ( type . Inherits ! = null ) <nl> - extends . Add ( Type ( type . Inherits ) ) ; <nl> + extends . Add ( Type ( type . Inherits ) . InheritedType ( ) ) ; <nl> <nl> if ( options . ImplementsFn ! = null ) <nl> { <nl> public string Type ( MetadataTypeName typeName ) <nl> return Type ( typeName . Name , typeName . GenericArgs ) ; <nl> } <nl> <nl> + public static HashSet < string > ArrayTypes = new HashSet < string > <nl> + { <nl> + \" List ` 1 \" , <nl> + \" IEnumerable ` 1 \" , <nl> + \" ICollection ` 1 \" , <nl> + \" HashSet ` 1 \" , <nl> + \" Queue ` 1 \" , <nl> + \" Stack ` 1 \" , <nl> + \" IEnumerable \" , <nl> + } ; <nl> + <nl> + public static HashSet < string > DictionaryTypes = new HashSet < string > <nl> + { <nl> + \" Dictionary ` 2 \" , <nl> + \" IDictionary ` 2 \" , <nl> + \" IOrderedDictionary ` 2 \" , <nl> + \" OrderedDictionary \" , <nl> + \" StringDictionary \" , <nl> + \" IDictionary \" , <nl> + \" IOrderedDictionary \" , <nl> + } ; <nl> + <nl> public string Type ( string type , string [ ] genericArgs ) <nl> { <nl> + IDictionary < string , string > d ; <nl> if ( genericArgs ! = null ) <nl> { <nl> if ( type = = \" Nullable ` 1 \" ) <nl> - return \" { 0 } ? \" . Fmt ( TypeAlias ( genericArgs [ 0 ] . TrimStart ( ' \\ ' ' ) ) ) ; <nl> - if ( type = = \" List ` 1 \" | | type = = \" IEnumerable ` 1 \" | | type = = \" ICollection ` 1 \" ) <nl> - return \" { 0 } [ ] \" . Fmt ( TypeAlias ( genericArgs [ 0 ] . TrimStart ( ' \\ ' ' ) ) ) ; <nl> - if ( type = = \" Dictionary ` 2 \" | | type = = \" IDictionary ` 2 \" ) <nl> - return \" { { [ index : { 0 } ] : { 1 } ; } } \" . Fmt ( TypeAlias ( genericArgs [ 0 ] . TrimStart ( ' \\ ' ' ) ) , TypeAlias ( genericArgs [ 1 ] . TrimStart ( ' \\ ' ' ) ) ) ; <nl> + return \" { 0 } ? \" . Fmt ( TypeAlias ( genericArgs [ 0 ] . GenericArg ( ) ) ) ; <nl> + if ( ArrayTypes . Contains ( type ) ) <nl> + return \" { 0 } [ ] \" . Fmt ( TypeAlias ( genericArgs [ 0 ] . GenericArg ( ) ) ) ; <nl> + if ( DictionaryTypes . Contains ( type ) ) <nl> + return \" { { [ index : { 0 } ] : { 1 } ; } } \" . Fmt ( TypeAlias ( genericArgs [ 0 ] . GenericArg ( ) ) , TypeAlias ( genericArgs [ 1 ] . TrimStart ( ' \\ ' ' ) ) ) ; <nl> <nl> var parts = type . Split ( ' ` ' ) ; <nl> if ( parts . Length > 1 ) <nl> public string Type ( string type , string [ ] genericArgs ) <nl> if ( args . Length > 0 ) <nl> args . Append ( \" , \" ) ; <nl> <nl> - args . Append ( TypeAlias ( arg . TrimStart ( ' \\ ' ' ) ) ) ; <nl> + args . Append ( TypeAlias ( arg . GenericArg ( ) ) ) ; <nl> } <nl> <nl> var typeName = TypeAlias ( type ) ; <nl> public bool AppendDataMember ( StringBuilderWrapper sb , MetadataDataMember dmMeta , <nl> return true ; <nl> } <nl> } <nl> + <nl> + public static class TypeScriptGeneratorExtensions <nl> + { <nl> + public static string GenericArg ( this string arg ) <nl> + { <nl> + return arg . TrimStart ( ' \\ ' ' ) ; <nl> + } <nl> + <nl> + / / TypeScript doesn ' t support short - hand T [ ] notation in extension list <nl> + public static string InheritedType ( this string type ) <nl> + { <nl> + var arrParts = type . SplitOnFirst ( ' [ ' ) ; <nl> + return arrParts . Length > 1 <nl> + ? \" Array < { 0 } > \" . Fmt ( arrParts [ 0 ] ) <nl> + : type ; <nl> + } <nl> + } <nl> } <nl> \\ No newline at end of file <nl>\n", "msg": "Add user modifyable list of Array and Dictionary types , handle extending array types and wrap generic args\n"}
{"diff_id": 5869, "repo": "icsharpcode/ILSpy\n", "sha": "112142f1475e980b8b0d0e7f32d082556eb56728\n", "time": "2017-09-12T21:06:10Z\n", "diff": "mmm a / ICSharpCode . Decompiler / CSharp / Transforms / IntroduceUsingDeclarations . cs <nl> ppp b / ICSharpCode . Decompiler / CSharp / Transforms / IntroduceUsingDeclarations . cs <nl> namespace ICSharpCode . Decompiler . CSharp . Transforms <nl> / / / < / summary > <nl> public class IntroduceUsingDeclarations : IAstTransform <nl> { <nl> - public bool FullyQualifyAmbiguousTypeNames = true ; <nl> - <nl> public void Run ( AstNode rootNode , TransformContext context ) <nl> { <nl> / / First determine all the namespaces that need to be imported : <nl> public void Run ( AstNode rootNode , TransformContext context ) <nl> <nl> var usingScope = new UsingScope ( ) ; <nl> <nl> - var insertionPoint = rootNode . Children . LastOrDefault ( n = > n is PreProcessorDirective p & & p . Type = = PreProcessorDirectiveType . Define ) ; <nl> - <nl> - / / Now add using declarations for those namespaces : <nl> - foreach ( string ns in requiredImports . ImportedNamespaces . OrderByDescending ( n = > n ) ) { <nl> - / / we go backwards ( OrderByDescending ) through the list of namespaces because we insert them backwards <nl> - / / ( always inserting at the start of the list ) <nl> - string [ ] parts = ns . Split ( ' . ' ) ; <nl> - AstType nsType = new SimpleType ( parts [ 0 ] ) ; <nl> - for ( int i = 1 ; i < parts . Length ; i + + ) { <nl> - nsType = new MemberType { Target = nsType , MemberName = parts [ i ] } ; <nl> - } <nl> - if ( FullyQualifyAmbiguousTypeNames ) { <nl> - var reference = nsType . ToTypeReference ( NameLookupMode . TypeInUsingDeclaration ) as TypeOrNamespaceReference ; <nl> - if ( reference ! = null ) <nl> - usingScope . Usings . Add ( reference ) ; <nl> + if ( context . Settings . UsingDeclarations ) { <nl> + var insertionPoint = rootNode . Children . LastOrDefault ( n = > n is PreProcessorDirective p & & p . Type = = PreProcessorDirectiveType . Define ) ; <nl> + <nl> + / / Now add using declarations for those namespaces : <nl> + foreach ( string ns in requiredImports . ImportedNamespaces . OrderByDescending ( n = > n ) ) { <nl> + / / we go backwards ( OrderByDescending ) through the list of namespaces because we insert them backwards <nl> + / / ( always inserting at the start of the list ) <nl> + string [ ] parts = ns . Split ( ' . ' ) ; <nl> + AstType nsType = new SimpleType ( parts [ 0 ] ) ; <nl> + for ( int i = 1 ; i < parts . Length ; i + + ) { <nl> + nsType = new MemberType { Target = nsType , MemberName = parts [ i ] } ; <nl> + } <nl> + if ( context . Settings . FullyQualifyAmbiguousTypeNames ) { <nl> + var reference = nsType . ToTypeReference ( NameLookupMode . TypeInUsingDeclaration ) as TypeOrNamespaceReference ; <nl> + if ( reference ! = null ) <nl> + usingScope . Usings . Add ( reference ) ; <nl> + } <nl> + rootNode . InsertChildAfter ( insertionPoint , new UsingDeclaration { Import = nsType } , SyntaxTree . MemberRole ) ; <nl> } <nl> - rootNode . InsertChildAfter ( insertionPoint , new UsingDeclaration { Import = nsType } , SyntaxTree . MemberRole ) ; <nl> } <nl> - <nl> - if ( ! FullyQualifyAmbiguousTypeNames ) <nl> + <nl> + if ( ! context . Settings . FullyQualifyAmbiguousTypeNames ) <nl> return ; <nl> <nl> / / verify that the SimpleTypes refer to the correct type ( no ambiguities ) <nl>\n", "msg": "Handle Settings . UsingDeclarations and Settings . FullyQualifyAmbiguousTypeNames correctly .\n"}
{"diff_id": 5983, "repo": "OpenRA/OpenRA\n", "sha": "dab53f403d82451396613233765edbe378c13f35\n", "time": "2015-08-31T19:43:19Z\n", "diff": "mmm a / OpenRA . Game / Traits / World / ActorMap . cs <nl> ppp b / OpenRA . Game / Traits / World / ActorMap . cs <nl> <nl> # endregion <nl> <nl> using System ; <nl> + using System . Collections ; <nl> using System . Collections . Generic ; <nl> using System . Drawing ; <nl> using System . Linq ; <nl> public ActorMap ( World world , ActorMapInfo info ) <nl> actorShouldBeRemoved = removeActorPosition . Contains ; <nl> } <nl> <nl> + sealed class UnitsAtEnumerator : IEnumerator < Actor > <nl> + { <nl> + InfluenceNode node ; <nl> + public UnitsAtEnumerator ( InfluenceNode node ) { this . node = node ; } <nl> + public void Reset ( ) { throw new NotSupportedException ( ) ; } <nl> + public Actor Current { get ; private set ; } <nl> + object IEnumerator . Current { get { return Current ; } } <nl> + public void Dispose ( ) { } <nl> + public bool MoveNext ( ) <nl> + { <nl> + while ( node ! = null ) <nl> + { <nl> + Current = node . Actor ; <nl> + node = node . Next ; <nl> + if ( ! Current . Disposed ) <nl> + return true ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + } <nl> + <nl> + sealed class UnitsAtEnumerable : IEnumerable < Actor > <nl> + { <nl> + readonly InfluenceNode node ; <nl> + public UnitsAtEnumerable ( InfluenceNode node ) { this . node = node ; } <nl> + public IEnumerator < Actor > GetEnumerator ( ) { return new UnitsAtEnumerator ( node ) ; } <nl> + IEnumerator IEnumerable . GetEnumerator ( ) { return GetEnumerator ( ) ; } <nl> + } <nl> + <nl> public IEnumerable < Actor > GetUnitsAt ( CPos a ) <nl> { <nl> var uv = a . ToMPos ( map ) ; <nl> if ( ! influence . Contains ( uv ) ) <nl> - yield break ; <nl> - <nl> - for ( var i = influence [ uv ] ; i ! = null ; i = i . Next ) <nl> - if ( ! i . Actor . Disposed ) <nl> - yield return i . Actor ; <nl> + return Enumerable . Empty < Actor > ( ) ; <nl> + return new UnitsAtEnumerable ( influence [ uv ] ) ; <nl> } <nl> <nl> public IEnumerable < Actor > GetUnitsAt ( CPos a , SubCell sub ) <nl>\n", "msg": "Provide a hand - written enumerator for ActorMap . GetUnitsAt ( CPos ) .\n"}
{"diff_id": 6059, "repo": "ppy/osu\n", "sha": "667fdb907cb56e6ad5fb5d4f616e1c8a23d85710\n", "time": "2020-01-23T09:21:16Z\n", "diff": "mmm a / osu . Game / Overlays / Comments / CommentsContainer . cs <nl> ppp b / osu . Game / Overlays / Comments / CommentsContainer . cs <nl> public void ShowComments ( CommentableType type , long id ) <nl> { <nl> this . type = type ; <nl> this . id = id ; <nl> - Sort . TriggerChange ( ) ; <nl> + refetchComments ( ) ; <nl> } <nl> <nl> private void refetchComments ( ) <nl>\n", "msg": "Call the method directly rather that trigger a bindable\n"}
{"diff_id": 6112, "repo": "dotnet/aspnetcore\n", "sha": "63e818b2fed8c4c9797f04176808819484acb9a8\n", "time": "2016-03-02T22:36:54Z\n", "diff": "mmm a / src / Microsoft . AspNetCore . Mvc . Localization / Internal / MvcLocalizationServices . cs <nl> ppp b / src / Microsoft . AspNetCore . Mvc . Localization / Internal / MvcLocalizationServices . cs <nl> public static class MvcLocalizationServices <nl> Action < LocalizationOptions > setupAction ) <nl> { <nl> AddMvcLocalizationServices ( services , format , setupAction ) ; <nl> - <nl> - services . AddLocalization ( setupAction ) ; <nl> + <nl> + if ( setupAction = = null ) <nl> + { <nl> + services . AddLocalization ( ) ; <nl> + } <nl> + else <nl> + { <nl> + services . AddLocalization ( setupAction ) ; <nl> + } <nl> } <nl> <nl> / / To enable unit testing only ' MVC ' specific services <nl>\n", "msg": "[ Fixes ] React to changes in Localization .\n"}
{"diff_id": 6208, "repo": "Humanizr/Humanizer\n", "sha": "35c3d55602c7ec9aa9036c489010d05049adb314\n", "time": "2016-03-24T19:49:41Z\n", "diff": "mmm a / src / Humanizer / Inflections / Vocabularies . cs <nl> ppp b / src / Humanizer / Inflections / Vocabularies . cs <nl> private static Vocabulary BuildDefault ( ) <nl> _default . AddPlural ( \" ( buffal | tomat | volcan | ech | embarg | her | mosquit | potat | torped | vet ) o $ \" , \" $ 1oes \" ) ; <nl> _default . AddPlural ( \" ( [ ti ] ) um $ \" , \" $ 1a \" ) ; <nl> _default . AddPlural ( \" sis $ \" , \" ses \" ) ; <nl> - _default . AddPlural ( \" ( ? : ( [ ^ f ] ) fe | ( [ lr ] ) f ) $ \" , \" $ 1 $ 2ves \" ) ; <nl> + _default . AddPlural ( \" ( ? : ( [ ^ f ] ) fe | ( [ lr ] ) f ) $ \" , \" $ 1 $ 2ves \" ) ; / / e . g . ' safe ' or ' dwarf ' <nl> _default . AddPlural ( \" ( hive ) $ \" , \" $ 1s \" ) ; <nl> _default . AddPlural ( \" ( [ ^ aeiouy ] | qu ) y $ \" , \" $ 1ies \" ) ; <nl> _default . AddPlural ( \" ( x | ch | ss | sh ) $ \" , \" $ 1es \" ) ; <nl> private static Vocabulary BuildDefault ( ) <nl> _default . AddPlural ( \" ( buz | blit | walt ) z $ \" , \" $ 1zes \" ) ; <nl> _default . AddPlural ( \" ( campus ) $ \" , \" $ 1es \" ) ; <nl> _default . AddPlural ( \" ^ is $ \" , \" are \" ) ; <nl> + _default . AddPlural ( \" ( hoo | lea | loa | thie ) f $ \" , \" $ 1ves \" ) ; <nl> <nl> _default . AddSingular ( \" s $ \" , \" \" ) ; <nl> _default . AddSingular ( \" ( n ) ews $ \" , \" $ 1ews \" ) ; <nl> private static Vocabulary BuildDefault ( ) <nl> _default . AddSingular ( \" ( [ ^ f ] ) ves $ \" , \" $ 1fe \" ) ; <nl> _default . AddSingular ( \" ( hive ) s $ \" , \" $ 1 \" ) ; <nl> _default . AddSingular ( \" ( tive ) s $ \" , \" $ 1 \" ) ; <nl> - _default . AddSingular ( \" ( [ lr ] ) ves $ \" , \" $ 1f \" ) ; <nl> + _default . AddSingular ( \" ( [ lr ] | hoo | lea | loa | thie ) ves $ \" , \" $ 1f \" ) ; <nl> _default . AddSingular ( \" ( [ ^ aeiouy ] | qu ) ies $ \" , \" $ 1y \" ) ; <nl> _default . AddSingular ( \" ( s ) eries $ \" , \" $ 1eries \" ) ; <nl> _default . AddSingular ( \" ( m ) ovies $ \" , \" $ 1ovie \" ) ; <nl>\n", "msg": "Add new pluralization rules for words ending ' f ' that go to ' ves ' to the default vocabulary .\n"}
{"diff_id": 6414, "repo": "OpenRA/OpenRA\n", "sha": "7438af82660deff0ef12a68880c028b1ea910186\n", "time": "2018-09-14T16:55:58Z\n", "diff": "mmm a / OpenRA . Mods . Common / Widgets / Logic / Installation / DownloadPackageLogic . cs <nl> ppp b / OpenRA . Mods . Common / Widgets / Logic / Installation / DownloadPackageLogic . cs <nl> void ShowDownloadDialog ( ) <nl> <nl> if ( i . TotalBytesToReceive < 0 ) <nl> { <nl> - dataTotal = float . NaN ; <nl> - dataReceived = i . BytesReceived ; <nl> - dataSuffix = SizeSuffixes [ 0 ] ; <nl> + mag = ( int ) Math . Log ( i . BytesReceived , 1024 ) ; <nl> + dataReceived = i . BytesReceived / ( float ) ( 1L < < ( mag * 10 ) ) ; <nl> + dataSuffix = SizeSuffixes [ mag ] ; <nl> <nl> - getStatusText = ( ) = > \" Downloading from { 2 } { 0 : 0 . 00 } { 1 } ( unknown size ) \" . F ( dataReceived , <nl> + getStatusText = ( ) = > \" Downloading from { 2 } { 0 : 0 . 00 } { 1 } \" . F ( dataReceived , <nl> dataSuffix , <nl> downloadHost ? ? \" unknown host \" ) ; <nl> progressBar . Indeterminate = true ; <nl>\n", "msg": "Improve status line display for unknown - size downloads .\n"}
{"diff_id": 6449, "repo": "dnSpy/dnSpy\n", "sha": "40f43a7c17e2bf90e2fe941d6c71d14eeb7ce2a3\n", "time": "2019-06-22T08:02:52Z\n", "diff": "mmm a / dnSpy / dnSpy / Search / FilterSearcher . cs <nl> ppp b / dnSpy / dnSpy / Search / FilterSearcher . cs <nl> <nl> using System . Collections . Generic ; <nl> using System . Diagnostics ; <nl> using System . Linq ; <nl> + using System . Text ; <nl> using System . Windows . Threading ; <nl> using dnlib . DotNet ; <nl> using dnlib . DotNet . Emit ; <nl> sealed class FilterSearcher { <nl> return ; <nl> CheckCustomAttributes ( ownerModule , type , nsOwner ) ; <nl> <nl> - if ( res . IsMatch & & ( IsMatch ( type . FullName , type ) | | IsMatch ( type . Name , type ) ) ) { <nl> + if ( res . IsMatch & & ( IsMatch ( FixTypeName ( type . FullName ) , type ) | | IsMatch ( FixTypeName ( type . Name ) , type ) ) ) { <nl> options . OnMatch ( new SearchResult { <nl> Context = options . Context , <nl> Object = type , <nl> sealed class FilterSearcher { <nl> } <nl> } <nl> <nl> + static string FixTypeName ( string name ) { <nl> + int i ; <nl> + for ( i = 0 ; i < name . Length ; i + + ) { <nl> + var c = name [ i ] ; <nl> + if ( c = = ' / ' | | c = = ' ` ' ) <nl> + break ; <nl> + } <nl> + if ( i = = name . Length ) <nl> + return name ; <nl> + var sb = new StringBuilder ( ) ; <nl> + sb . Append ( name , 0 , i ) ; <nl> + for ( ; i < name . Length ; i + + ) { <nl> + var c = name [ i ] ; <nl> + switch ( c ) { <nl> + case ' / ' : <nl> + sb . Append ( ' . ' ) ; <nl> + break ; <nl> + case ' ` ' : <nl> + / / Ignore ` 1 , ` 2 etc ( generic types ) <nl> + while ( + + i < name . Length & & char . IsDigit ( name [ i ] ) ) <nl> + ; <nl> + break ; <nl> + default : <nl> + sb . Append ( c ) ; <nl> + break ; <nl> + } <nl> + } <nl> + return sb . ToString ( ) ; <nl> + } <nl> + <nl> void Search ( IDsDocument ownerModule , TypeDef type ) { <nl> var res = options . Filter . GetResult ( type ) ; <nl> if ( res . FilterType = = FilterType . Hide ) <nl> return ; <nl> CheckCustomAttributes ( ownerModule , type , type . DeclaringType ) ; <nl> <nl> - if ( res . IsMatch & & ( IsMatch ( type . FullName , type ) | | IsMatch ( type . Name , type ) ) ) { <nl> + if ( res . IsMatch & & ( IsMatch ( FixTypeName ( type . FullName ) , type ) | | IsMatch ( FixTypeName ( type . Name ) , type ) ) ) { <nl> options . OnMatch ( new SearchResult { <nl> Context = options . Context , <nl> Object = type , <nl> sealed class FilterSearcher { <nl> bool CheckMatch ( MethodDef method ) { <nl> if ( IsMatch ( method . Name , method ) ) <nl> return true ; <nl> - if ( IsMatch ( method . DeclaringType . FullName + \" . \" + method . Name . String , method ) ) <nl> + if ( IsMatch ( FixTypeName ( method . DeclaringType . FullName ) + \" . \" + method . Name . String , method ) ) <nl> return true ; <nl> <nl> if ( method . ImplMap is ImplMap im ) { <nl> sealed class FilterSearcher { <nl> bool CheckMatch ( FieldDef field ) { <nl> if ( IsMatch ( field . Name , field ) ) <nl> return true ; <nl> - if ( IsMatch ( field . DeclaringType . FullName + \" . \" + field . Name . String , field ) ) <nl> + if ( IsMatch ( FixTypeName ( field . DeclaringType . FullName ) + \" . \" + field . Name . String , field ) ) <nl> return true ; <nl> <nl> if ( field . ImplMap is ImplMap im ) { <nl> sealed class FilterSearcher { <nl> bool CheckMatch ( PropertyDef prop ) { <nl> if ( IsMatch ( prop . Name , prop ) ) <nl> return true ; <nl> - if ( IsMatch ( prop . DeclaringType . FullName + \" . \" + prop . Name . String , prop ) ) <nl> + if ( IsMatch ( FixTypeName ( prop . DeclaringType . FullName ) + \" . \" + prop . Name . String , prop ) ) <nl> return true ; <nl> <nl> return false ; <nl> sealed class FilterSearcher { <nl> bool CheckMatch ( EventDef evt ) { <nl> if ( IsMatch ( evt . Name , evt ) ) <nl> return true ; <nl> - if ( IsMatch ( evt . DeclaringType . FullName + \" . \" + evt . Name . String , evt ) ) <nl> + if ( IsMatch ( FixTypeName ( evt . DeclaringType . FullName ) + \" . \" + evt . Name . String , evt ) ) <nl> return true ; <nl> <nl> return false ; <nl>\n", "msg": "Update type searcher to fix type name before comparing it\n"}
{"diff_id": 7248, "repo": "jellyfin/jellyfin\n", "sha": "2e43a0746c37396946330107bdb158e80bc4f22b\n", "time": "2013-09-03T14:33:40Z\n", "diff": "mmm a / MediaBrowser . Server . Implementations / Sorting / AlbumArtistComparer . cs <nl> ppp b / MediaBrowser . Server . Implementations / Sorting / AlbumArtistComparer . cs <nl> <nl> -  using MediaBrowser . Controller . Entities ; <nl> +  using System . Linq ; <nl> + using MediaBrowser . Controller . Entities ; <nl> using MediaBrowser . Controller . Entities . Audio ; <nl> using MediaBrowser . Controller . Sorting ; <nl> using MediaBrowser . Model . Querying ; <nl> private string GetValue ( BaseItem x ) <nl> { <nl> var audio = x as Audio ; <nl> <nl> - return audio = = null ? string . Empty : audio . AlbumArtist ; <nl> + if ( audio ! = null ) <nl> + { <nl> + return audio . AlbumArtist ; <nl> + } <nl> + <nl> + var album = x as MusicAlbum ; <nl> + <nl> + if ( album ! = null ) <nl> + { <nl> + var song = album . RecursiveChildren <nl> + . OfType < Audio > ( ) <nl> + . FirstOrDefault ( i = > ! string . IsNullOrEmpty ( i . AlbumArtist ) ) ; <nl> + <nl> + if ( song ! = null ) <nl> + { <nl> + return song . AlbumArtist ; <nl> + } <nl> + } <nl> + <nl> + return null ; <nl> } <nl> <nl> / / / < summary > <nl>\n", "msg": "fixes - Add more sort orders to web client album page\n"}
{"diff_id": 7328, "repo": "ShareX/ShareX\n", "sha": "876a6f0fcc57c72ded75c625a4ae45b0a53ab51c\n", "time": "2016-03-16T10:06:56Z\n", "diff": "mmm a / ShareX / WorkerTask . cs <nl> ppp b / ShareX / WorkerTask . cs <nl> public static WorkerTask CreateDownloadUploadTask ( string url , TaskSettings taskS <nl> filename = URLHelpers . GetFileName ( filename ) ; <nl> filename = Helpers . GetValidFileName ( filename ) ; <nl> <nl> + if ( task . Info . TaskSettings . UploadSettings . FileUploadUseNamePattern ) <nl> + { <nl> + string ext = Path . GetExtension ( filename ) ; <nl> + filename = TaskHelpers . GetFilename ( task . Info . TaskSettings , ext ) ; <nl> + } <nl> + <nl> if ( string . IsNullOrEmpty ( filename ) ) <nl> { <nl> return null ; <nl>\n", "msg": "fixed : Use name pattern in url download & upload\n"}
{"diff_id": 7425, "repo": "jellyfin/jellyfin\n", "sha": "cee587d6e358cbb16b8cd27b55f492c145476c5a\n", "time": "2020-04-27T01:25:57Z\n", "diff": "mmm a / MediaBrowser . MediaEncoding / Encoder / MediaEncoder . cs <nl> ppp b / MediaBrowser . MediaEncoding / Encoder / MediaEncoder . cs <nl> public void SetFFmpegPath ( ) <nl> SetAvailableEncoders ( validator . GetEncoders ( ) ) ; <nl> } <nl> <nl> - _logger . LogInformation ( \" FFmpeg : { 0 } : { 1 } \" , EncoderLocation , _ffmpegPath ? ? string . Empty ) ; <nl> + _logger . LogInformation ( \" FFmpeg : { EncoderLocation } : { FfmpegPath } \" , EncoderLocation , _ffmpegPath ? ? string . Empty ) ; <nl> } <nl> <nl> / / / < summary > <nl> public void UpdateEncoderPath ( string path , string pathType ) <nl> { <nl> string newPath ; <nl> <nl> - _logger . LogInformation ( \" Attempting to update encoder path to { 0 } . pathType : { 1 } \" , path ? ? string . Empty , pathType ? ? string . Empty ) ; <nl> + _logger . LogInformation ( \" Attempting to update encoder path to { Path } . pathType : { PathType } \" , path ? ? string . Empty , pathType ? ? string . Empty ) ; <nl> <nl> if ( ! string . Equals ( pathType , \" custom \" , StringComparison . OrdinalIgnoreCase ) ) <nl> { <nl> private bool ValidatePath ( string path , FFmpegLocation location ) <nl> <nl> if ( ! rc ) <nl> { <nl> - _logger . LogWarning ( \" FFmpeg : { 0 } : Failed version check : { 1 } \" , location , path ) ; <nl> + _logger . LogWarning ( \" FFmpeg : { Location } : Failed version check : { Path } \" , location , path ) ; <nl> } <nl> <nl> / / ToDo - Enable the ffmpeg validator . At the moment any version can be used . <nl> private bool ValidatePath ( string path , FFmpegLocation location ) <nl> } <nl> else <nl> { <nl> - _logger . LogWarning ( \" FFmpeg : { 0 } : File not found : { 1 } \" , location , path ) ; <nl> + _logger . LogWarning ( \" FFmpeg : { Location } : File not found : { Path } \" , location , path ) ; <nl> } <nl> } <nl> <nl> return rc ; <nl> } <nl> <nl> - private string GetEncoderPathFromDirectory ( string path , string filename ) <nl> + private string GetEncoderPathFromDirectory ( string path , string filename , bool recursive = false ) <nl> { <nl> try <nl> { <nl> - var files = _fileSystem . GetFilePaths ( path ) ; <nl> + var files = _fileSystem . GetFilePaths ( path , recursive ) ; <nl> <nl> var excludeExtensions = new [ ] { \" . c \" } ; <nl> <nl> private string GetEncoderPathFromDirectory ( string path , string filename ) <nl> / / / < returns > < / returns > <nl> private string ExistsOnSystemPath ( string fileName ) <nl> { <nl> - string inJellyfinPath = GetEncoderPathFromDirectory ( System . AppContext . BaseDirectory , fileName ) ; <nl> + var inJellyfinPath = GetEncoderPathFromDirectory ( AppContext . BaseDirectory , fileName , recursive : true ) ; <nl> if ( ! string . IsNullOrEmpty ( inJellyfinPath ) ) <nl> { <nl> return inJellyfinPath ; <nl> public IEnumerable < string > GetPrimaryPlaylistVobFiles ( string path , IIsoMount iso <nl> return minSizeVobs . Count = = 0 ? vobs . Select ( i = > i . FullName ) : minSizeVobs . Select ( i = > i . FullName ) ; <nl> } <nl> <nl> - _logger . LogWarning ( \" Could not determine vob file list for { 0 } using DvdLib . Will scan using file sizes . \" , path ) ; <nl> + _logger . LogWarning ( \" Could not determine vob file list for { Path } using DvdLib . Will scan using file sizes . \" , path ) ; <nl> } <nl> <nl> var files = allVobs <nl>\n", "msg": "Try harder to find ffmpeg in app directory . While here do some cleanup\n"}
{"diff_id": 7533, "repo": "OpenRA/OpenRA\n", "sha": "f191babec8c5fc5cc35e4291383dbc33c08638a7\n", "time": "2014-12-13T16:04:00Z\n", "diff": "mmm a / OpenRA . Mods . Common / ServerTraits / PlayerPinger . cs <nl> ppp b / OpenRA . Mods . Common / ServerTraits / PlayerPinger . cs <nl> public void Tick ( S server ) <nl> { <nl> isInitialPing = false ; <nl> lastPing = Game . RunTime ; <nl> - foreach ( var c in server . Conns . ToList ( ) ) <nl> + <nl> + if ( server . LobbyInfo . IsSinglePlayer & & server . Conns . Any ( ) & & server . GetClient ( server . Conns . First ( ) ) . IpAddress = = \" 127 . 0 . 0 . 1 \" ) <nl> { <nl> - if ( c . TimeSinceLastResponse < ConnTimeout ) <nl> - { <nl> + foreach ( var c in server . Conns . ToList ( ) ) <nl> server . SendOrderTo ( c , \" Ping \" , Game . RunTime . ToString ( ) ) ; <nl> - if ( ! c . TimeoutMessageShown & & c . TimeSinceLastResponse > PingInterval * 2 ) <nl> + } <nl> + else <nl> + { <nl> + foreach ( var c in server . Conns . ToList ( ) ) <nl> + { <nl> + if ( c . TimeSinceLastResponse < ConnTimeout ) <nl> { <nl> - server . SendMessage ( server . GetClient ( c ) . Name + \" is experiencing connection problems . \" ) ; <nl> - c . TimeoutMessageShown = true ; <nl> + server . SendOrderTo ( c , \" Ping \" , Game . RunTime . ToString ( ) ) ; <nl> + if ( ! c . TimeoutMessageShown & & c . TimeSinceLastResponse > PingInterval * 2 ) <nl> + { <nl> + server . SendMessage ( server . GetClient ( c ) . Name + \" is experiencing connection problems . \" ) ; <nl> + c . TimeoutMessageShown = true ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + server . SendMessage ( server . GetClient ( c ) . Name + \" has been dropped after timing out . \" ) ; <nl> + server . DropClient ( c , - 1 ) ; <nl> } <nl> } <nl> - else <nl> - { <nl> - server . SendMessage ( server . GetClient ( c ) . Name + \" has been dropped after timing out . \" ) ; <nl> - server . DropClient ( c , - 1 ) ; <nl> - } <nl> - } <nl> - } <nl> <nl> - if ( Game . RunTime - lastConnReport > ConnReportInterval ) <nl> - { <nl> - lastConnReport = Game . RunTime ; <nl> + if ( Game . RunTime - lastConnReport > ConnReportInterval ) <nl> + { <nl> + lastConnReport = Game . RunTime ; <nl> <nl> - var timeouts = server . Conns <nl> - . Where ( c = > c . TimeSinceLastResponse > ConnReportInterval & & c . TimeSinceLastResponse < ConnTimeout ) <nl> - . OrderBy ( c = > c . TimeSinceLastResponse ) ; <nl> + var timeouts = server . Conns <nl> + . Where ( c = > c . TimeSinceLastResponse > ConnReportInterval & & c . TimeSinceLastResponse < ConnTimeout ) <nl> + . OrderBy ( c = > c . TimeSinceLastResponse ) ; <nl> <nl> - foreach ( var c in timeouts ) <nl> - server . SendMessage ( \" { 0 } will be dropped in { 1 } seconds . \" . F ( <nl> - server . GetClient ( c ) . Name , ( ConnTimeout - c . TimeSinceLastResponse ) / 1000 ) ) ; <nl> + foreach ( var c in timeouts ) <nl> + server . SendMessage ( \" { 0 } will be dropped in { 1 } seconds . \" . F ( <nl> + server . GetClient ( c ) . Name , ( ConnTimeout - c . TimeSinceLastResponse ) / 1000 ) ) ; <nl> + } <nl> + } <nl> } <nl> } <nl> } <nl>\n", "msg": "Fix : Game can no longer drop you in a single player game .\n"}
{"diff_id": 7766, "repo": "mono/mono\n", "sha": "b10b7ce8a514eae1c3c5cde0f1ea3a53d6d329d8\n", "time": "2016-05-02T22:10:26Z\n", "diff": "mmm a / mcs / class / referencesource / mscorlib / system / globalization / charunicodeinfo . cs <nl> ppp b / mcs / class / referencesource / mscorlib / system / globalization / charunicodeinfo . cs <nl> unsafe private static ushort EndianSwap ( ushort value ) <nl> return ( value ) ; <nl> } <nl> <nl> + unsafe private static double EndianSwap ( double value ) <nl> + { <nl> + if ( ! BitConverter . IsLittleEndian ) { <nl> + byte * ptr = ( byte * ) & value ; <nl> + double res ; <nl> + byte * buf = ( byte * ) & res ; <nl> + ushort t = sizeof ( double ) - 1 ; <nl> + <nl> + for ( ushort i = 0 ; i < sizeof ( double ) ; i + + ) <nl> + buf [ t - i ] = ptr [ i ] ; <nl> + <nl> + return ( res ) ; <nl> + } else <nl> + return ( value ) ; <nl> + } <nl> + <nl> <nl> / / We need to allocate the underlying table that provides us with the information that we <nl> / / use . We allocate this once in the class initializer and then we don ' t need to worry <nl> internal static bool IsWhiteSpace ( char c ) <nl> } <nl> return ( ( ( double * ) s_pNumericValues ) [ pBytePtr [ ( ch & 0x000f ) ] ] ) ; <nl> # else <nl> - return ( ( ( double * ) s_pNumericValues ) [ pBytePtr [ ( ch & 0x000f ) ] ] ) ; <nl> + return EndianSwap ( ( ( double * ) s_pNumericValues ) [ pBytePtr [ ( ch & 0x000f ) ] ] ) ; <nl> # endif <nl> } <nl> <nl>\n", "msg": "Add BE support for Doubles , missed from 41a6d3d6a5432b964b6f8439b6375ffad6f2e6cb\n"}
{"diff_id": 8050, "repo": "ppy/osu\n", "sha": "75a5691c5fe94523ff5530df53358ed5934a1703\n", "time": "2019-01-08T23:51:49Z\n", "diff": "mmm a / osu . Game . Rulesets . Catch / Difficulty / CatchPerformanceCalculator . cs <nl> ppp b / osu . Game . Rulesets . Catch / Difficulty / CatchPerformanceCalculator . cs <nl> <nl> - / / Copyright ( c ) 2007 - 2019 ppy Pty Ltd < contact @ ppy . sh > . <nl> + / / Copyright ( c ) 2007 - 2018 ppy Pty Ltd < contact @ ppy . sh > . <nl> / / Licensed under the MIT Licence - https : / / raw . githubusercontent . com / ppy / osu / master / LICENCE <nl> <nl> using System ; <nl> public override double Calculate ( Dictionary < string , double > categoryDifficulty = <nl> } <nl> <nl> private float accuracy ( ) = > totalHits ( ) = = 0 ? 0 : MathHelper . Clamp ( ( float ) totalSuccessfulHits ( ) / totalHits ( ) , 0f , 1f ) ; <nl> - private int totalHits ( ) = > countMeh + countGood + countGreat + countMiss ; / / TODO : not counting katu <nl> + private int totalHits ( ) = > countMeh + countGood + countGreat + countMiss ; <nl> private int totalSuccessfulHits ( ) = > countMeh + countGood + countGreat ; <nl> private int totalComboHits ( ) = > countMeh + countGood + countGreat ; <nl> } <nl>\n", "msg": "Set license header year to 2018 , remove old TODO comment\n"}
{"diff_id": 8251, "repo": "mRemoteNG/mRemoteNG\n", "sha": "3af3074ab9c72036d19bba1ad41c396ef9246908\n", "time": "2016-05-24T22:56:56Z\n", "diff": "mmm a / mRemoteV1 / UI / Forms / frmOptions . cs <nl> ppp b / mRemoteV1 / UI / Forms / frmOptions . cs <nl> <nl> -  using System ; <nl> +  using mRemoteNG . App ; <nl> + using mRemoteNG . UI . Forms . OptionsPages ; <nl> + using System ; <nl> using System . Collections . Generic ; <nl> using System . Diagnostics ; <nl> using System . Linq ; <nl> using System . Windows . Forms ; <nl> - using mRemoteNG . App ; <nl> - using mRemoteNG . UI . Forms . OptionsPages ; <nl> <nl> namespace mRemoteNG . UI . Forms <nl> { <nl> public partial class frmOptions : Form <nl> { <nl> - <nl> private Dictionary < string , OptionsPage > _pages ; <nl> private ImageList _pageIconImageList ; <nl> <nl> public frmOptions ( ) <nl> <nl> private void frmOptions_Load ( object sender , EventArgs e ) <nl> { <nl> - / / Load all the controls in memory <nl> CompileListOfOptionsPages ( ) ; <nl> Runtime . FontOverride ( this ) ; <nl> SetImageListForListView ( ) ; <nl> private void frmOptions_Load ( object sender , EventArgs e ) <nl> SetInitiallyActivatedPage ( ) ; <nl> } <nl> <nl> - private void AddOptionsPagesToListView ( ) <nl> - { <nl> - foreach ( var page in _pages . Select ( keyValuePair = > keyValuePair . Value ) ) <nl> - { <nl> - page . LoadSettings ( ) ; <nl> - _pageIconImageList . Images . Add ( page . PageName , page . PageIcon ) ; <nl> - var item = new ListViewItem ( page . PageName , page . PageName ) ; <nl> - item . Tag = page . GetType ( ) . Name ; <nl> - lstOptionPages . Items . Add ( item ) ; <nl> - } <nl> - } <nl> - <nl> - private void SetImageListForListView ( ) <nl> - { <nl> - _pageIconImageList = new ImageList { ColorDepth = ColorDepth . Depth32Bit } ; <nl> - lstOptionPages . LargeImageList = _pageIconImageList ; <nl> - lstOptionPages . SmallImageList = _pageIconImageList ; <nl> - } <nl> - <nl> private void CompileListOfOptionsPages ( ) <nl> { <nl> _pages = new Dictionary < string , OptionsPage > ( ) ; <nl> private void CompileListOfOptionsPages ( ) <nl> _pages . Add ( typeof ( AdvancedPage ) . Name , new AdvancedPage ( ) ) ; <nl> } <nl> <nl> + private void SetImageListForListView ( ) <nl> + { <nl> + _pageIconImageList = new ImageList { ColorDepth = ColorDepth . Depth32Bit } ; <nl> + lstOptionPages . LargeImageList = _pageIconImageList ; <nl> + lstOptionPages . SmallImageList = _pageIconImageList ; <nl> + } <nl> + <nl> + private void AddOptionsPagesToListView ( ) <nl> + { <nl> + foreach ( var page in _pages . Select ( keyValuePair = > keyValuePair . Value ) ) <nl> + { <nl> + page . LoadSettings ( ) ; <nl> + _pageIconImageList . Images . Add ( page . PageName , page . PageIcon ) ; <nl> + var item = new ListViewItem ( page . PageName , page . PageName ) ; <nl> + item . Tag = page . GetType ( ) . Name ; <nl> + lstOptionPages . Items . Add ( item ) ; <nl> + } <nl> + } <nl> + <nl> private void SetInitiallyActivatedPage ( ) <nl> { <nl> lstOptionPages . Items [ 0 ] . Selected = true ; <nl> private void btnOK_Click ( object sender , EventArgs e ) <nl> { <nl> Debug . WriteLine ( page . PageName ) ; <nl> page . SaveSettings ( ) ; <nl> - <nl> } <nl> Debug . WriteLine ( AppDomain . CurrentDomain . SetupInformation . ConfigurationFile ) ; <nl> - mRemoteNG . Settings . Default . Save ( ) ; <nl> - <nl> - <nl> + Settings . Default . Save ( ) ; <nl> } <nl> <nl> private void lstOptionPages_ItemSelectionChanged ( object sender , ListViewItemSelectionChangedEventArgs e ) <nl> { <nl> - <nl> pnlMain . Controls . Clear ( ) ; <nl> <nl> var page = _pages [ ( string ) e . Item . Tag ] ; <nl> if ( page ! = null ) <nl> - { <nl> pnlMain . Controls . Add ( page ) ; <nl> - } <nl> } <nl> } <nl> - } <nl> + } <nl> \\ No newline at end of file <nl>\n", "msg": "Minor cleanup of frmOptions code ( deleted dead space , reorder usings , reorder functions based on call order )\n"}
{"diff_id": 8262, "repo": "Sonarr/Sonarr\n", "sha": "c9ff55f6011a1f1d6766494b1bc3c5f2ca67bc4a\n", "time": "2018-02-27T21:41:42Z\n", "diff": "mmm a / src / NzbDrone . Console / ConsoleApp . cs <nl> ppp b / src / NzbDrone . Console / ConsoleApp . cs <nl> public static void Main ( string [ ] args ) <nl> try <nl> { <nl> var startupArgs = new StartupContext ( args ) ; <nl> - NzbDroneLogger . Register ( startupArgs , false , true ) ; <nl> + try <nl> + { <nl> + NzbDroneLogger . Register ( startupArgs , false , true ) ; <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + System . Console . WriteLine ( \" NLog Exception : \" + ex . ToString ( ) ) ; <nl> + throw ; <nl> + } <nl> Bootstrap . Start ( startupArgs , new ConsoleAlerts ( ) ) ; <nl> } <nl> catch ( SonarrStartupException ex ) <nl>\n", "msg": "Added console logging in case NLog fails to initialize .\n"}
{"diff_id": 8374, "repo": "Sonarr/Sonarr\n", "sha": "970006a4fe2480bfe9eb9d272335fd3f09cbd900\n", "time": "2017-08-01T23:01:58Z\n", "diff": "mmm a / src / NzbDrone . Core / Download / TrackedDownloads / TrackedDownloadService . cs <nl> ppp b / src / NzbDrone . Core / Download / TrackedDownloads / TrackedDownloadService . cs <nl> public TrackedDownload TrackDownload ( DownloadClientDefinition downloadClient , Do <nl> <nl> if ( existingItem ! = null & & existingItem . State ! = TrackedDownloadStage . Downloading ) <nl> { <nl> + LogItemChange ( existingItem , existingItem . DownloadItem , downloadItem ) ; <nl> + <nl> existingItem . DownloadItem = downloadItem ; <nl> return existingItem ; <nl> } <nl> public TrackedDownload TrackDownload ( DownloadClientDefinition downloadClient , Do <nl> <nl> if ( trackedDownload . RemoteEpisode = = null ) <nl> { <nl> + _logger . Trace ( \" No Episode found for download ' { 0 } ' , not tracking . \" , trackedDownload . DownloadItem . Title ) ; <nl> + <nl> return null ; <nl> } <nl> } <nl> public TrackedDownload TrackDownload ( DownloadClientDefinition downloadClient , Do <nl> return null ; <nl> } <nl> <nl> + LogItemChange ( trackedDownload , existingItem ? . DownloadItem , trackedDownload . DownloadItem ) ; <nl> + <nl> _cache . Set ( trackedDownload . DownloadItem . DownloadId , trackedDownload ) ; <nl> return trackedDownload ; <nl> } <nl> <nl> + private void LogItemChange ( TrackedDownload trackedDownload , DownloadClientItem existingItem , DownloadClientItem downloadItem ) <nl> + { <nl> + if ( existingItem = = null | | <nl> + existingItem . Status ! = downloadItem . Status | | <nl> + existingItem . CanBeRemoved ! = downloadItem . CanBeRemoved | | <nl> + existingItem . CanMoveFiles ! = downloadItem . CanMoveFiles ) <nl> + { <nl> + _logger . Debug ( \" Tracking ' { 0 } : { 1 } ' : ClientState = { 2 } { 3 } SonarrStage = { 4 } Episode = ' { 5 } ' OutputPath = { 6 } . \" , <nl> + downloadItem . DownloadClient , downloadItem . Title , <nl> + downloadItem . Status , downloadItem . CanBeRemoved ? \" \" : <nl> + downloadItem . CanMoveFiles ? \" ( busy ) \" : \" ( readonly ) \" , <nl> + trackedDownload . State , <nl> + trackedDownload . RemoteEpisode ? . ParsedEpisodeInfo , <nl> + downloadItem . OutputPath ) ; <nl> + } <nl> + } <nl> + <nl> private static TrackedDownloadStage GetStateFromHistory ( HistoryEventType eventType ) <nl> { <nl> switch ( eventType ) <nl>\n", "msg": "Added a bit more logging for Tracked Downloads .\n"}
{"diff_id": 8462, "repo": "icsharpcode/ILSpy\n", "sha": "8e634bc23c867d98ec961078cf47c9d0aef80f5b\n", "time": "2017-10-02T21:33:49Z\n", "diff": "mmm a / ICSharpCode . Decompiler / CSharp / ExpressionBuilder . cs <nl> ppp b / ICSharpCode . Decompiler / CSharp / ExpressionBuilder . cs <nl> TranslatedExpression HandleCompoundAssignment ( CompoundAssignmentInstruction inst <nl> } else { <nl> switch ( op ) { <nl> case AssignmentOperatorType . Add : <nl> - case AssignmentOperatorType . Subtract : <nl> - value = value . ConvertTo ( target . Type . GetEnumUnderlyingType ( ) , this , inst . CheckForOverflow ) ; <nl> - break ; <nl> + case AssignmentOperatorType . Subtract : { <nl> + IType targetType = NullableType . GetUnderlyingType ( target . Type ) . GetEnumUnderlyingType ( ) ; <nl> + if ( NullableType . IsNullable ( value . Type ) ) { <nl> + targetType = NullableType . Create ( compilation , targetType ) ; <nl> + } <nl> + value = value . ConvertTo ( targetType , this , inst . CheckForOverflow ) ; <nl> + break ; <nl> + } <nl> case AssignmentOperatorType . Multiply : <nl> case AssignmentOperatorType . Divide : <nl> case AssignmentOperatorType . Modulus : <nl> case AssignmentOperatorType . BitwiseAnd : <nl> case AssignmentOperatorType . BitwiseOr : <nl> - case AssignmentOperatorType . ExclusiveOr : <nl> - value = value . ConvertTo ( target . Type , this , inst . CheckForOverflow ) ; <nl> - break ; <nl> + case AssignmentOperatorType . ExclusiveOr : { <nl> + IType targetType = NullableType . GetUnderlyingType ( target . Type ) ; <nl> + if ( NullableType . IsNullable ( value . Type ) ) { <nl> + targetType = NullableType . Create ( compilation , targetType ) ; <nl> + } <nl> + value = value . ConvertTo ( targetType , this , inst . CheckForOverflow ) ; <nl> + break ; <nl> + } <nl> } <nl> resultExpr = new AssignmentExpression ( target . Expression , op , value . Expression ) <nl> . WithILInstruction ( inst ) <nl> TranslatedExpression HandleCompoundAssignment ( CompoundAssignmentInstruction inst <nl> <nl> TranslatedExpression HandleCompoundShift ( CompoundAssignmentInstruction inst , AssignmentOperatorType op ) <nl> { <nl> + Debug . Assert ( inst . CompoundAssignmentType = = CompoundAssignmentType . EvaluatesToNewValue ) ; <nl> var target = Translate ( inst . Target ) ; <nl> var value = Translate ( inst . Value ) ; <nl> <nl>\n", "msg": "[ nullables ] Fix unnecessary casts in nullable compound assignments .\n"}
{"diff_id": 8527, "repo": "nopSolutions/nopCommerce\n", "sha": "bd5beeb9ff58b64d4a0c6fed52f55892763560ba\n", "time": "2013-02-25T11:35:04Z\n", "diff": "mmm a / src / Presentation / Nop . Web / Global . asax . cs <nl> ppp b / src / Presentation / Nop . Web / Global . asax . cs <nl> protected void Application_Error ( Object sender , EventArgs e ) <nl> var httpException = exception as HttpException ; <nl> if ( httpException ! = null & & httpException . GetHttpCode ( ) = = 404 ) <nl> { <nl> - Response . Clear ( ) ; <nl> - Server . ClearError ( ) ; <nl> - Response . TrySkipIisCustomErrors = true ; <nl> + var webHelper = EngineContext . Current . Resolve < IWebHelper > ( ) ; <nl> + if ( ! webHelper . IsStaticResource ( this . Request ) ) <nl> + { <nl> + Response . Clear ( ) ; <nl> + Server . ClearError ( ) ; <nl> + Response . TrySkipIisCustomErrors = true ; <nl> <nl> - / / Call target Controller and pass the routeData . <nl> - IController errorController = EngineContext . Current . Resolve < Nop . Web . Controllers . CommonController > ( ) ; <nl> + / / Call target Controller and pass the routeData . <nl> + IController errorController = EngineContext . Current . Resolve < Nop . Web . Controllers . CommonController > ( ) ; <nl> <nl> - var routeData = new RouteData ( ) ; <nl> - routeData . Values . Add ( \" controller \" , \" Common \" ) ; <nl> - routeData . Values . Add ( \" action \" , \" PageNotFound \" ) ; <nl> + var routeData = new RouteData ( ) ; <nl> + routeData . Values . Add ( \" controller \" , \" Common \" ) ; <nl> + routeData . Values . Add ( \" action \" , \" PageNotFound \" ) ; <nl> <nl> - errorController . Execute ( new RequestContext ( new HttpContextWrapper ( Context ) , routeData ) ) ; <nl> + errorController . Execute ( new RequestContext ( new HttpContextWrapper ( Context ) , routeData ) ) ; <nl> + } <nl> } <nl> } <nl> <nl>\n", "msg": "Further changes on 404 error processing ( ignore static resources )\n"}
{"diff_id": 8543, "repo": "mono/mono\n", "sha": "5e76deaf725cc8dd29f71aecd0b7a0622f5e165c\n", "time": "2014-06-04T10:17:35Z\n", "diff": "mmm a / mcs / class / System . Web . Extensions / Test / System . Web . Script . Serialization / JavaScriptSerializerTest . cs <nl> ppp b / mcs / class / System . Web . Extensions / Test / System . Web . Script . Serialization / JavaScriptSerializerTest . cs <nl> public void DeserializeDictionaryOfArrayList ( ) <nl> var ret2vad = ( IDictionary < string , object > ) ret2va [ 0 ] ; <nl> Assert . AreEqual ( \" subval \" , ret2vad [ \" subkey \" ] , \" # 2 . 4 \" ) ; <nl> } <nl> + <nl> + class ClassWithNullableEnum <nl> + { <nl> + public MyEnum ? Value { get ; set ; } <nl> + } <nl> + <nl> + [ Test ] <nl> + public void DeserializeNullableEnum ( ) <nl> + { <nl> + var jsonValues = new Dictionary < string , MyEnum ? > { <nl> + { \" { \\ \" Value \\ \" : 0 } \" , MyEnum . AAA } , <nl> + { \" { \\ \" Value \\ \" : \\ \" 0 \\ \" } \" , MyEnum . AAA } , <nl> + { \" { \\ \" Value \\ \" : null } \" , null } <nl> + } ; <nl> + <nl> + var ser = new JavaScriptSerializer ( ) ; <nl> + <nl> + foreach ( var kv in jsonValues ) <nl> + { <nl> + var obj = ser . Deserialize < ClassWithNullableEnum > ( kv . Key ) ; <nl> + Assert . AreEqual ( kv . Value , obj . Value ) ; <nl> + } <nl> + } <nl> } <nl> } <nl>\n", "msg": "Test JavaScriptSerializer . Deserialize with nullable enums . Covers .\n"}
{"diff_id": 8735, "repo": "ppy/osu\n", "sha": "c9723352977ecf57fbe8cfb579d8497482dd42a8\n", "time": "2017-05-22T06:25:37Z\n", "diff": "mmm a / osu . Game . Rulesets . Mania / UI / Column . cs <nl> ppp b / osu . Game . Rulesets . Mania / UI / Column . cs <nl> public Column ( IEnumerable < ControlPoint > timingChanges ) <nl> Name = \" Hit objects \" , <nl> RelativeSizeAxes = Axes . Both , <nl> } , <nl> + / / For column lighting , we need to capture input events before the notes <nl> + new InputTarget <nl> + { <nl> + KeyDown = onKeyDown , <nl> + KeyUp = onKeyUp <nl> + } <nl> } <nl> } , <nl> new Container <nl> public Color4 AccentColour <nl> } <nl> } <nl> <nl> - public void Add ( DrawableHitObject < ManiaHitObject , ManiaJudgement > hitObject ) <nl> - { <nl> - ControlPointContainer . Add ( hitObject ) ; <nl> - } <nl> + public void Add ( DrawableHitObject < ManiaHitObject , ManiaJudgement > hitObject ) = > ControlPointContainer . Add ( hitObject ) ; <nl> <nl> - protected override bool OnKeyDown ( InputState state , KeyDownEventArgs args ) <nl> + private bool onKeyDown ( InputState state , KeyDownEventArgs args ) <nl> { <nl> if ( args . Repeat ) <nl> return false ; <nl> protected override bool OnKeyDown ( InputState state , KeyDownEventArgs args ) <nl> return false ; <nl> } <nl> <nl> - protected override bool OnKeyUp ( InputState state , KeyUpEventArgs args ) <nl> + private bool onKeyUp ( InputState state , KeyUpEventArgs args ) <nl> { <nl> if ( args . Key = = Key ) <nl> { <nl> protected override bool OnKeyUp ( InputState state , KeyUpEventArgs args ) <nl> <nl> return false ; <nl> } <nl> + <nl> + / / / < summary > <nl> + / / / This is a simple container which delegates various input events that have to be captured before the notes . <nl> + / / / < / summary > <nl> + private class InputTarget : Container <nl> + { <nl> + public Func < InputState , KeyDownEventArgs , bool > KeyDown ; <nl> + public Func < InputState , KeyUpEventArgs , bool > KeyUp ; <nl> + <nl> + public InputTarget ( ) <nl> + { <nl> + RelativeSizeAxes = Axes . Both ; <nl> + AlwaysPresent = true ; <nl> + Alpha = 0 ; <nl> + } <nl> + <nl> + protected override bool OnKeyDown ( InputState state , KeyDownEventArgs args ) = > KeyDown ? . Invoke ( state , args ) ? ? false ; <nl> + protected override bool OnKeyUp ( InputState state , KeyUpEventArgs args ) = > KeyUp ? . Invoke ( state , args ) ? ? false ; <nl> + } <nl> } <nl> } <nl>\n", "msg": "Add InputTarget to capture input from columns before hit objects .\n"}
{"diff_id": 8858, "repo": "dotnet/roslyn\n", "sha": "92b90ec1a3369bc52a89b9a67a20bc5d64b7988f\n", "time": "2017-03-18T01:31:17Z\n", "diff": "mmm a / src / EditorFeatures / Core / Implementation / Suggestions / SuggestedActionsSource . cs <nl> ppp b / src / EditorFeatures / Core / Implementation / Suggestions / SuggestedActionsSource . cs <nl> private static SuggestedActionSetPriority GetSuggestedActionSetPriority ( CodeActi <nl> <nl> var filteredRefactorings = FilterOnUIThread ( refactorings , workspace ) ; <nl> <nl> - return filteredRefactorings . SelectAsArray ( r = > OrganizeRefactorings ( workspace , r ) ) ; <nl> + return filteredRefactorings . SelectAsArray ( <nl> + r = > OrganizeRefactorings ( workspace , r , selection . Value . ToSpan ( ) ) ) ; <nl> } <nl> <nl> return ImmutableArray < SuggestedActionSet > . Empty ; <nl> private static SuggestedActionSetPriority GetSuggestedActionSetPriority ( CodeActi <nl> / / / Priority for all < see cref = \" SuggestedActionSet \" / > s containing refactorings is set to < see cref = \" SuggestedActionSetPriority . Low \" / > <nl> / / / and should show up after fixes but before suppression fixes in the light bulb menu . <nl> / / / < / remarks > <nl> - private SuggestedActionSet OrganizeRefactorings ( Workspace workspace , CodeRefactoring refactoring ) <nl> + private SuggestedActionSet OrganizeRefactorings ( <nl> + Workspace workspace , CodeRefactoring refactoring , Span applicableSpan ) <nl> { <nl> var refactoringSuggestedActions = ArrayBuilder < SuggestedAction > . GetInstance ( ) ; <nl> <nl> private SuggestedActionSet OrganizeRefactorings ( Workspace workspace , CodeRefacto <nl> } <nl> <nl> return new SuggestedActionSet ( <nl> - refactoringSuggestedActions . ToImmutableAndFree ( ) , SuggestedActionSetPriority . Low ) ; <nl> + refactoringSuggestedActions . ToImmutableAndFree ( ) , <nl> + SuggestedActionSetPriority . Low , <nl> + applicableSpan ) ; <nl> } <nl> <nl> public async Task < bool > HasSuggestedActionsAsync ( ISuggestedActionCategorySet requestedActionCategories , SnapshotSpan range , CancellationToken cancellationToken ) <nl>\n", "msg": "Provide an appropriate span for refactorings so we can better prioritize them against fixes of the same priority .\n"}
{"diff_id": 8878, "repo": "ppy/osu\n", "sha": "fe2ea17e7f8a4ef7952409ac82be57c20d42d687\n", "time": "2018-05-15T02:42:40Z\n", "diff": "mmm a / osu . Game / Rulesets / Scoring / Legacy / LegacyScoreParser . cs <nl> ppp b / osu . Game / Rulesets / Scoring / Legacy / LegacyScoreParser . cs <nl> public LegacyScoreParser ( RulesetStore rulesets , BeatmapManager beatmaps ) <nl> this . beatmaps = beatmaps ; <nl> } <nl> <nl> + protected LegacyScoreParser ( ) <nl> + { <nl> + } <nl> + <nl> private IBeatmap currentBeatmap ; <nl> private Ruleset currentRuleset ; <nl> <nl> public Score Parse ( Stream stream ) <nl> <nl> using ( SerializationReader sr = new SerializationReader ( stream ) ) <nl> { <nl> - score = new Score { Ruleset = rulesets . GetRuleset ( sr . ReadByte ( ) ) } ; <nl> - currentRuleset = score . Ruleset . CreateInstance ( ) ; <nl> + currentRuleset = GetRuleset ( sr . ReadByte ( ) ) ; <nl> + score = new Score { Ruleset = currentRuleset . RulesetInfo } ; <nl> <nl> / * score . Pass = true ; * / <nl> var version = sr . ReadInt32 ( ) ; <nl> <nl> / * score . FileChecksum = * / <nl> - var beatmapHash = sr . ReadString ( ) ; <nl> - score . Beatmap = beatmaps . QueryBeatmap ( b = > b . MD5Hash = = beatmapHash ) ; <nl> - currentBeatmap = beatmaps . GetWorkingBeatmap ( score . Beatmap ) . Beatmap ; <nl> + currentBeatmap = GetBeatmap ( sr . ReadString ( ) ) . Beatmap ; <nl> + score . Beatmap = currentBeatmap . BeatmapInfo ; <nl> <nl> / * score . PlayerName = * / <nl> score . User = new User { Username = sr . ReadString ( ) } ; <nl> private ReplayFrame convertFrame ( LegacyReplayFrame legacyFrame ) <nl> <nl> return frame ; <nl> } <nl> + <nl> + protected virtual Ruleset GetRuleset ( int rulesetId ) = > rulesets . GetRuleset ( rulesetId ) . CreateInstance ( ) ; <nl> + protected virtual WorkingBeatmap GetBeatmap ( string md5Hash ) = > beatmaps . GetWorkingBeatmap ( beatmaps . QueryBeatmap ( b = > b . MD5Hash = = md5Hash ) ) ; <nl> } <nl> } <nl>\n", "msg": "Allow subclasses of LegacyScoreParser to specify beatmap / ruleset retrieval\n"}
{"diff_id": 8952, "repo": "nopSolutions/nopCommerce\n", "sha": "313c2e7ef1ec88da08eb47a629f1a8f54999fec9\n", "time": "2016-07-28T08:09:13Z\n", "diff": "mmm a / src / Libraries / Nop . Services / Common / PdfService . cs <nl> ppp b / src / Libraries / Nop . Services / Common / PdfService . cs <nl> public virtual void PrintPackagingSlipsToPdf ( Stream stream , IList < Shipment > ship <nl> if ( shipments = = null ) <nl> throw new ArgumentNullException ( \" shipments \" ) ; <nl> <nl> - var lang = _languageService . GetLanguageById ( languageId ) ; <nl> - if ( lang = = null ) <nl> - throw new ArgumentException ( string . Format ( \" Cannot load language . ID = { 0 } \" , languageId ) ) ; <nl> - <nl> var pageSize = PageSize . A4 ; <nl> <nl> if ( _pdfSettings . LetterPageSizeEnabled ) <nl> public virtual void PrintPackagingSlipsToPdf ( Stream stream , IList < Shipment > ship <nl> { <nl> var order = shipment . Order ; <nl> <nl> - if ( languageId = = 0 ) <nl> - { <nl> - lang = _languageService . GetLanguageById ( order . CustomerLanguageId ) ; <nl> - if ( lang = = null | | ! lang . Published ) <nl> - lang = _workContext . WorkingLanguage ; <nl> - } <nl> + var lang = _languageService . GetLanguageById ( languageId = = 0 ? order . CustomerLanguageId : languageId ) ; <nl> + if ( lang = = null | | ! lang . Published ) <nl> + lang = _workContext . WorkingLanguage ; <nl> <nl> var addressTable = new PdfPTable ( 1 ) ; <nl> if ( lang . Rtl ) <nl>\n", "msg": "Further changes on printing of PDF packaging slips in customer language ( sometimes an exception has been thrown )\n"}
{"diff_id": 9374, "repo": "dotnet/roslyn\n", "sha": "aa7c9046f2c5adeb371367c45cdace91c74853dd\n", "time": "2017-05-23T21:59:37Z\n", "diff": "mmm a / src / Features / Core / Portable / Diagnostics / EngineV2 / DiagnosticIncrementalAnalyzer . StateManager . cs <nl> ppp b / src / Features / Core / Portable / Diagnostics / EngineV2 / DiagnosticIncrementalAnalyzer . StateManager . cs <nl> public StateSet GetOrCreateStateSet ( Project project , DiagnosticAnalyzer analyzer <nl> / / / < / summary > <nl> public ImmutableArray < StateSet > CreateBuildOnlyProjectStateSet ( Project project ) <nl> { <nl> + if ( ! project . SupportsCompilation ) <nl> + { <nl> + / / languages which don ' t use our compilation model but diagnostic framework , <nl> + / / all their analyzer should be host analyzers . return all host analyzers <nl> + / / for the language <nl> + return _hostStates . GetOrCreateStateSets ( project . Language ) . ToImmutableArray ( ) ; <nl> + } <nl> + <nl> / / create project analyzer reference identity map <nl> var referenceIdentities = project . AnalyzerReferences . Select ( r = > _analyzerManager . GetAnalyzerReferenceIdentity ( r ) ) . ToSet ( ) ; <nl> <nl>\n", "msg": "tweak how we merge build and live errors for language such as F #\n"}
{"diff_id": 9802, "repo": "gitextensions/gitextensions\n", "sha": "16e05944cb5abae511342f5fda6b5a2554c17ac2\n", "time": "2011-11-10T23:32:46Z\n", "diff": "mmm a / GitUI / FormRemotes . cs <nl> ppp b / GitUI / FormRemotes . cs <nl> private void LoadSshKeyClick ( object sender , EventArgs e ) <nl> } <nl> <nl> private void TestConnectionClick ( object sender , EventArgs e ) <nl> - { <nl> + { <nl> + System . Uri uri = new System . Uri ( Url . Text ) ; <nl> + string sshURL = \" \" ; <nl> + if ( uri . Scheme = = \" ssh \" ) <nl> + { <nl> + if ( ! string . IsNullOrEmpty ( uri . UserInfo ) ) <nl> + sshURL = uri . UserInfo + \" @ \" ; <nl> + sshURL + = uri . Host + \" : \" + uri . LocalPath . Substring ( 1 ) ; <nl> + } <nl> + else <nl> + sshURL = Url . Text ; <nl> Settings . Module . RunRealCmdDetached ( <nl> - \" cmd . exe \" , <nl> - string . Format ( \" / k \\ \" \\ \" { 0 } \\ \" - T \\ \" { 1 } \\ \" \\ \" \" , Settings . Plink , Url . Text ) ) ; <nl> + \" cmd . exe \" , <nl> + string . Format ( \" / k \\ \" \\ \" { 0 } \\ \" - T \\ \" { 1 } \\ \" \\ \" \" , Settings . Plink , sshURL ) ) ; <nl> } <nl> <nl> private void PruneClick ( object sender , EventArgs e ) <nl>\n", "msg": "Fixed the Test Connection functionality of the Manage Remotes UI .\n"}
{"diff_id": 9927, "repo": "ServiceStack/ServiceStack\n", "sha": "6212578b2188407b7709acc1b5b54f0a00fd8c4f\n", "time": "2019-02-08T00:35:21Z\n", "diff": "mmm a / src / ServiceStack / AppUtils . cs <nl> ppp b / src / ServiceStack / AppUtils . cs <nl> public static T NewScope < T > ( this IServiceProvider services , Func < IServiceScope , <nl> } ) ; <nl> } <nl> <nl> - public static string IdentityUserRolesByIdSql { get ; set ; } = @ \" SELECT r . Name <nl> - FROM AspNetUsers u <nl> - INNER JOIN AspNetUserRoles ur ON ( u . Id = ur . UserId ) <nl> - INNER JOIN AspNetRoles r ON ( r . Id = ur . RoleId ) <nl> - WHERE u . Id = @ userId \" ; <nl> + const string IdentityUserRolesByIdSql = @ \" SELECT r . Name <nl> + FROM AspNetUsers u <nl> + INNER JOIN AspNetUserRoles ur ON ( u . Id = ur . UserId ) <nl> + INNER JOIN AspNetRoles r ON ( r . Id = ur . RoleId ) <nl> + WHERE u . Id = @ userId \" ; <nl> <nl> - public static List < string > GetUserRolesById ( this IDbConnection db , string userId ) <nl> + public static List < string > GetUserRolesById ( this IDbConnection db , string userId ) = > <nl> + db . GetUserRolesById ( userId , IdentityUserRolesByIdSql ) ; <nl> + <nl> + public static List < string > GetUserRolesById ( this IDbConnection db , string userId , string sqlGetUserRoles ) <nl> { <nl> var roles = new List < string > ( ) ; <nl> using ( var cmd = db . CreateCommand ( ) ) <nl> { <nl> - cmd . CommandText = IdentityUserRolesByIdSql ; <nl> + cmd . CommandText = sqlGetUserRoles ; <nl> var p = cmd . CreateParameter ( ) ; <nl> p . ParameterName = nameof ( userId ) ; <nl> p . DbType = DbType . String ; <nl>\n", "msg": "Add API to specify SQL to use to fetch Identity User Roles\n"}
{"diff_id": 9979, "repo": "ppy/osu\n", "sha": "42a06a54ffb3779c7079e0b8cbd934e7d204fe77\n", "time": "2019-10-14T22:08:23Z\n", "diff": "mmm a / osu . Game . Tests / Visual / Online / TestSceneShowMoreButton . cs <nl> ppp b / osu . Game . Tests / Visual / Online / TestSceneShowMoreButton . cs <nl> <nl>  / / Copyright ( c ) ppy Pty Ltd < contact @ ppy . sh > . Licensed under the MIT Licence . <nl> / / See the LICENCE file in the repository root for full licence text . <nl> <nl> - using osu . Game . Overlays . Profile . Sections ; <nl> using System ; <nl> using System . Collections . Generic ; <nl> using osu . Framework . Graphics ; <nl> using osu . Game . Graphics . UserInterface ; <nl> + using osu . Framework . Allocation ; <nl> + using osu . Game . Graphics ; <nl> <nl> namespace osu . Game . Tests . Visual . Online <nl> { <nl> public class TestSceneShowMoreButton : OsuTestScene <nl> <nl> public TestSceneShowMoreButton ( ) <nl> { <nl> - ProfileShowMoreButton button = null ; <nl> + TestButton button = null ; <nl> <nl> int fireCount = 0 ; <nl> <nl> - Add ( button = new ProfileShowMoreButton <nl> + Add ( button = new TestButton <nl> { <nl> Anchor = Anchor . Centre , <nl> Origin = Anchor . Centre , <nl> public TestSceneShowMoreButton ( ) <nl> AddAssert ( \" action fired twice \" , ( ) = > fireCount = = 2 ) ; <nl> AddAssert ( \" is in loading state \" , ( ) = > button . IsLoading ) ; <nl> } <nl> + <nl> + private class TestButton : ShowMoreButton <nl> + { <nl> + [ BackgroundDependencyLoader ] <nl> + private void load ( OsuColour colors ) <nl> + { <nl> + IdleColour = colors . YellowDark ; <nl> + HoverColour = colors . Yellow ; <nl> + ChevronIconColour = colors . Red ; <nl> + } <nl> + } <nl> } <nl> } <nl>\n", "msg": "Don ' t use ProfileShowMoreButton in the test scene to avoid confusion\n"}
{"diff_id": 10213, "repo": "dotnet/runtime\n", "sha": "ec50587e8de438782691f73d04646516a273f99c\n", "time": "2015-07-08T21:25:49Z\n", "diff": "mmm a / src / libraries / Common / src / Interop / Unix / System . Security . Cryptography . Native / Interop . NativeCrypto . cs <nl> ppp b / src / libraries / Common / src / Interop / Unix / System . Security . Cryptography . Native / Interop . NativeCrypto . cs <nl> internal static partial class NativeCrypto <nl> <nl> internal static byte [ ] GetAsn1StringBytes ( IntPtr asn1 ) <nl> { <nl> - return GetDynamicBuffer ( GetAsn1StringBytes , asn1 ) ; <nl> + return GetDynamicBuffer ( ( ptr , buf , i ) = > GetAsn1StringBytes ( ptr , buf , i ) , asn1 ) ; <nl> } <nl> <nl> internal static byte [ ] GetX509Thumbprint ( SafeX509Handle x509 ) <nl> { <nl> - return GetDynamicBuffer ( GetX509Thumbprint , x509 ) ; <nl> + return GetDynamicBuffer ( ( handle , buf , i ) = > GetX509Thumbprint ( handle , buf , i ) , x509 ) ; <nl> } <nl> <nl> internal static byte [ ] GetX509NameRawBytes ( IntPtr x509Name ) <nl> { <nl> - return GetDynamicBuffer ( GetX509NameRawBytes , x509Name ) ; <nl> + return GetDynamicBuffer ( ( ptr , buf , i ) = > GetX509NameRawBytes ( ptr , buf , i ) , x509Name ) ; <nl> } <nl> <nl> internal static byte [ ] GetX509PublicKeyParameterBytes ( SafeX509Handle x509 ) <nl> { <nl> - return GetDynamicBuffer ( GetX509PublicKeyParameterBytes , x509 ) ; <nl> + return GetDynamicBuffer ( ( handle , buf , i ) = > GetX509PublicKeyParameterBytes ( handle , buf , i ) , x509 ) ; <nl> } <nl> <nl> internal static void SetX509ChainVerifyTime ( SafeX509StoreCtxHandle ctx , DateTime verifyTime ) <nl>\n", "msg": "Call GetDynamicBuffer with lambdas instead of implicit delegates to reduce GC noise .\n"}
{"diff_id": 10329, "repo": "dotnet/maui\n", "sha": "2f22897900a7b08eb3a1c89508dcdeb4075de7e4\n", "time": "2018-04-11T15:35:50Z\n", "diff": "mmm a / Xamarin . Forms . Platform . UAP / PlatformUWP . cs <nl> ppp b / Xamarin . Forms . Platform . UAP / PlatformUWP . cs <nl> namespace Xamarin . Forms . Platform . UWP <nl> public abstract partial class Platform <nl> { <nl> internal static StatusBar MobileStatusBar = > ApiInformation . IsTypePresent ( \" Windows . UI . ViewManagement . StatusBar \" ) ? StatusBar . GetForCurrentView ( ) : null ; <nl> + static Task < bool > s_currentAlert ; <nl> <nl> IToolbarProvider _toolbarProvider ; <nl> <nl> static async void OnPageAlert ( Page sender , AlertArguments options ) <nl> if ( options . Accept ! = null ) <nl> alertDialog . PrimaryButtonText = options . Accept ; <nl> <nl> - ContentDialogResult result = await alertDialog . ShowAsync ( ) ; <nl> + if ( s_currentAlert ! = null ) <nl> + { <nl> + await s_currentAlert ; <nl> + } <nl> + <nl> + s_currentAlert = ShowAlert ( alertDialog ) ; <nl> + options . SetResult ( await s_currentAlert ) ; <nl> + s_currentAlert = null ; <nl> + } <nl> + <nl> + static async Task < bool > ShowAlert ( ContentDialog alert ) <nl> + { <nl> + ContentDialogResult result = await alert . ShowAsync ( ) ; <nl> <nl> - if ( result = = ContentDialogResult . Secondary ) <nl> - options . SetResult ( false ) ; <nl> - else if ( result = = ContentDialogResult . Primary ) <nl> - options . SetResult ( true ) ; <nl> + return result = = ContentDialogResult . Primary ; <nl> } <nl> <nl> void ClearCommandBar ( ) <nl>\n", "msg": "Only display one alert at a time on UWP ; fixes\n"}
{"diff_id": 10489, "repo": "dotnet/runtime\n", "sha": "00a578ee70d1801b7e749cc1b213a178fa2c68b7\n", "time": "2018-12-17T17:18:26Z\n", "diff": "mmm a / src / libraries / Microsoft . Extensions . DependencyInjection / tests / Common / src / LoggedTest / LoggedTestBase . cs <nl> ppp b / src / libraries / Microsoft . Extensions . DependencyInjection / tests / Common / src / LoggedTest / LoggedTestBase . cs <nl> <nl> using System . Linq ; <nl> using System . Reflection ; <nl> using System . Runtime . CompilerServices ; <nl> + using System . Runtime . ExceptionServices ; <nl> using Microsoft . Extensions . DependencyInjection ; <nl> using Xunit . Abstractions ; <nl> <nl> namespace Microsoft . Extensions . Logging . Testing <nl> { <nl> public class LoggedTestBase : ILoggedTest <nl> { <nl> + private ExceptionDispatchInfo _initializationException ; <nl> + <nl> private IDisposable _testLog ; <nl> <nl> / / Obsolete but keeping for back compat <nl> public IDisposable StartLog ( out ILoggerFactory loggerFactory , LogLevel minLogLev <nl> <nl> public virtual void Initialize ( MethodInfo methodInfo , object [ ] testMethodArguments , ITestOutputHelper testOutputHelper ) <nl> { <nl> - TestOutputHelper = testOutputHelper ; <nl> - <nl> - var classType = GetType ( ) ; <nl> - var logLevelAttribute = methodInfo . GetCustomAttribute < LogLevelAttribute > ( ) <nl> - ? ? methodInfo . DeclaringType . GetCustomAttribute < LogLevelAttribute > ( ) <nl> - ? ? methodInfo . DeclaringType . Assembly . GetCustomAttribute < LogLevelAttribute > ( ) ; <nl> - var testName = testMethodArguments . Aggregate ( methodInfo . Name , ( a , b ) = > $ \" { a } - { ( b ? ? \" null \" ) } \" ) ; <nl> - <nl> - var useShortClassName = methodInfo . DeclaringType . GetCustomAttribute < ShortClassNameAttribute > ( ) <nl> - ? ? methodInfo . DeclaringType . Assembly . GetCustomAttribute < ShortClassNameAttribute > ( ) ; <nl> - / / internal for testing <nl> - ResolvedTestClassName = useShortClassName = = null ? classType . FullName : classType . Name ; <nl> - <nl> - _testLog = AssemblyTestLog <nl> - . ForAssembly ( classType . GetTypeInfo ( ) . Assembly ) <nl> - . StartTestLog ( <nl> - TestOutputHelper , <nl> - ResolvedTestClassName , <nl> - out var loggerFactory , <nl> - logLevelAttribute ? . LogLevel ? ? LogLevel . Debug , <nl> - out var resolvedTestName , <nl> - out var logOutputDirectory , <nl> - testName ) ; <nl> - <nl> - ResolvedLogOutputDirectory = logOutputDirectory ; <nl> - ResolvedTestMethodName = resolvedTestName ; <nl> - <nl> - LoggerFactory = loggerFactory ; <nl> - Logger = loggerFactory . CreateLogger ( classType ) ; <nl> + try <nl> + { <nl> + TestOutputHelper = testOutputHelper ; <nl> + <nl> + var classType = GetType ( ) ; <nl> + var logLevelAttribute = methodInfo . GetCustomAttribute < LogLevelAttribute > ( ) <nl> + ? ? methodInfo . DeclaringType . GetCustomAttribute < LogLevelAttribute > ( ) <nl> + ? ? methodInfo . DeclaringType . Assembly . GetCustomAttribute < LogLevelAttribute > ( ) ; <nl> + var testName = testMethodArguments . Aggregate ( methodInfo . Name , ( a , b ) = > $ \" { a } - { ( b ? ? \" null \" ) } \" ) ; <nl> + <nl> + var useShortClassName = methodInfo . DeclaringType . GetCustomAttribute < ShortClassNameAttribute > ( ) <nl> + ? ? methodInfo . DeclaringType . Assembly . GetCustomAttribute < ShortClassNameAttribute > ( ) ; <nl> + / / internal for testing <nl> + ResolvedTestClassName = useShortClassName = = null ? classType . FullName : classType . Name ; <nl> + <nl> + _testLog = AssemblyTestLog <nl> + . ForAssembly ( classType . GetTypeInfo ( ) . Assembly ) <nl> + . StartTestLog ( <nl> + TestOutputHelper , <nl> + ResolvedTestClassName , <nl> + out var loggerFactory , <nl> + logLevelAttribute ? . LogLevel ? ? LogLevel . Debug , <nl> + out var resolvedTestName , <nl> + out var logOutputDirectory , <nl> + testName ) ; <nl> + <nl> + ResolvedLogOutputDirectory = logOutputDirectory ; <nl> + ResolvedTestMethodName = resolvedTestName ; <nl> + <nl> + LoggerFactory = loggerFactory ; <nl> + Logger = loggerFactory . CreateLogger ( classType ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + _initializationException = ExceptionDispatchInfo . Capture ( e ) ; <nl> + } <nl> } <nl> <nl> - public virtual void Dispose ( ) = > _testLog . Dispose ( ) ; <nl> + public virtual void Dispose ( ) <nl> + { <nl> + _initializationException ? . Throw ( ) ; <nl> + _testLog . Dispose ( ) ; <nl> + } <nl> } <nl> } <nl>\n", "msg": "Capture LoggedTest . Initialize exception and re - trow in Dispose ( dotnet / Extensions )\n"}
{"diff_id": 10547, "repo": "aspnetboilerplate/aspnetboilerplate\n", "sha": "3771911df3bbeb55705d54a7968f5ae7797e4eb5\n", "time": "2020-03-23T01:55:03Z\n", "diff": "mmm a / src / Abp / Runtime / Caching / AbpCacheBase . cs <nl> ppp b / src / Abp / Runtime / Caching / AbpCacheBase . cs <nl> public virtual TValue Get ( TKey key , Func < TKey , TValue > factory ) <nl> } <nl> <nl> var generatedValue = factory ( key ) ; <nl> - if ( generatedValue ! = null ) <nl> + if ( ! EqualityComparer < TValue > . Default . Equals ( generatedValue , default ) ) <nl> { <nl> try <nl> { <nl> public virtual TValue [ ] Get ( TKey [ ] keys , Func < TKey , TValue > factory ) <nl> { <nl> var key = keys [ i ] ; <nl> var generatedValue = factory ( key ) ; <nl> - if ( generatedValue ! = null ) <nl> + if ( ! EqualityComparer < TValue > . Default . Equals ( generatedValue , default ) ) <nl> { <nl> generated . Add ( new KeyValuePair < TKey , TValue > ( key , generatedValue ) ) ; <nl> } <nl> public virtual async Task < TValue > GetAsync ( TKey key , Func < TKey , Task < TValue > > fa <nl> if ( ! result . HasValue ) <nl> { <nl> var generatedValue = await factory ( key ) ; <nl> - if ( generatedValue ! = null ) <nl> + if ( ! EqualityComparer < TValue > . Default . Equals ( generatedValue , default ) ) <nl> { <nl> try <nl> { <nl> public virtual async Task < TValue [ ] > GetAsync ( TKey [ ] keys , Func < TKey , Task < TValue <nl> { <nl> var key = keys [ i ] ; <nl> var generatedValue = await factory ( key ) ; <nl> - if ( generatedValue ! = null ) <nl> + if ( ! EqualityComparer < TValue > . Default . Equals ( generatedValue , default ) ) <nl> { <nl> generated . Add ( new KeyValuePair < TKey , TValue > ( key , generatedValue ) ) ; <nl> } <nl>\n", "msg": "use default value of generic type to determine caching of generated value\n"}
{"diff_id": 10601, "repo": "dotnet/roslyn\n", "sha": "dfd7a70e30f6c36641d74ea71e88f5e39e05a3dd\n", "time": "2017-06-14T21:29:18Z\n", "diff": "mmm a / src / Compilers / Core / Portable / Operations / OperationKind . cs <nl> ppp b / src / Compilers / Core / Portable / Operations / OperationKind . cs <nl> public enum OperationKind <nl> AddressOfExpression = 0x203 , <nl> / / / < summary > Indicates an < see cref = \" IPointerIndirectionReferenceExpression \" / > . < / summary > <nl> PointerIndirectionReferenceExpression = 0x204 , <nl> + / / 0x205 is open for future use . <nl> / / / < summary > Indicates an < see cref = \" IIncrementExpression \" / > . < / summary > <nl> IncrementExpression = 0x206 , <nl> <nl>\n", "msg": "Added comment that operationkind 0x205 is open for future usage .\n"}
{"diff_id": 10786, "repo": "hbons/SparkleShare\n", "sha": "5f1fa163df93d1f290e0936d4c72209458596b17\n", "time": "2011-05-11T13:48:27Z\n", "diff": "mmm a / SparkleShare / SparkleController . cs <nl> ppp b / SparkleShare / SparkleController . cs <nl> public void GenerateKeyPair ( ) <nl> process . StartInfo . UseShellExecute = false ; <nl> process . StartInfo . RedirectStandardOutput = true ; <nl> process . StartInfo . FileName = \" ssh - keygen \" ; <nl> - <nl> + <nl> / / - t is the crypto type <nl> / / - P is the password ( none ) <nl> / / - f is the file name to store the private key in <nl> process . StartInfo . Arguments = \" - t rsa - P \\ \" \\ \" - f \" + key_file_name ; <nl> - process . Start ( ) ; <nl> <nl> process . Exited + = delegate { <nl> SparkleHelpers . DebugInfo ( \" Config \" , \" Created private key ' \" + key_file_name + \" ' \" ) ; <nl> public void GenerateKeyPair ( ) <nl> File . Copy ( key_file_path + \" . pub \" , <nl> Path . Combine ( SparklePath , UserName + \" ' s key . txt \" ) ) ; <nl> } ; <nl> + <nl> + process . Start ( ) ; <nl> + process . WaitForExit ( ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "controller : block on GenerateKeyPair . eliminates race condition on first setup\n"}
{"diff_id": 11254, "repo": "dotnet/maui\n", "sha": "7f7c9744f56cf9f74280ee27b8d8d36474188d45\n", "time": "2020-12-17T19:43:56Z\n", "diff": "mmm a / Xamarin . Forms . Core / RadioButtonGroup . cs <nl> ppp b / Xamarin . Forms . Core / RadioButtonGroup . cs <nl> public static string GetGroupName ( BindableObject b ) <nl> return ( string ) b . GetValue ( GroupNameProperty ) ; <nl> } <nl> <nl> + public static void SetGroupName ( BindableObject bindable , string groupName ) <nl> + { <nl> + bindable . SetValue ( GroupNameProperty , groupName ) ; <nl> + } <nl> + <nl> public static readonly BindableProperty SelectedValueProperty = <nl> BindableProperty . Create ( \" SelectedValue \" , typeof ( object ) , typeof ( Layout < View > ) , null , <nl> defaultBindingMode : BindingMode . TwoWay , <nl> public static object GetSelectedValue ( BindableObject bindableObject ) <nl> return bindableObject . GetValue ( SelectedValueProperty ) ; <nl> } <nl> <nl> + public static void SetSelectedValue ( BindableObject bindable , object selectedValue ) <nl> + { <nl> + bindable . SetValue ( SelectedValueProperty , selectedValue ) ; <nl> + } <nl> + <nl> internal static void UpdateRadioButtonGroup ( RadioButton radioButton ) <nl> { <nl> string groupName = radioButton . GroupName ; <nl>\n", "msg": "Added setters to RadioButtonGroup GroupName and SelectedValue ( ) fixes\n"}
{"diff_id": 11334, "repo": "MonoGame/MonoGame\n", "sha": "c5aeeb607928facab1e5e3669ab9f99e1593e9a3\n", "time": "2016-02-25T01:43:55Z\n", "diff": "mmm a / MonoGame . Framework . Content . Pipeline / Graphics / BitmapContent . cs <nl> ppp b / MonoGame . Framework . Content . Pipeline / Graphics / BitmapContent . cs <nl> public int Height <nl> { <nl> return height ; <nl> } <nl> - set <nl> + protected set <nl> { <nl> if ( value < = 0 ) <nl> throw new ArgumentOutOfRangeException ( \" height \" ) ; <nl> public int Width <nl> { <nl> return width ; <nl> } <nl> - set <nl> + protected set <nl> { <nl> if ( value < = 0 ) <nl> throw new ArgumentOutOfRangeException ( \" width \" ) ; <nl>\n", "msg": "Make BitmapContent Width and Height setters protected . Fixes .\n"}
{"diff_id": 11402, "repo": "ServiceStack/ServiceStack\n", "sha": "994c94126f4cb8b579a5fbc9ff85289c8e1942f0\n", "time": "2013-05-28T14:40:44Z\n", "diff": "mmm a / src / ServiceStack . ServiceInterface / Cors / CorsFeature . cs <nl> ppp b / src / ServiceStack . ServiceInterface / Cors / CorsFeature . cs <nl> <nl> + using System . Collections . Generic ; <nl> using ServiceStack . Common . Web ; <nl> using ServiceStack . WebHost . Endpoints ; <nl> <nl> public class CorsFeature : IPlugin <nl> private readonly bool allowCredentials ; <nl> <nl> private static bool isInstalled = false ; <nl> + private readonly IList < string > allowOriginWhitelist ; <nl> <nl> / / / < summary > <nl> / / / Represents a default constructor with Allow Origin equals to \" * \" , Allowed GET , POST , PUT , DELETE , OPTIONS request and allowed \" Content - Type \" header . <nl> public CorsFeature ( string allowedOrigins = \" * \" , string allowedMethods = DefaultM <nl> this . allowedHeaders = allowedHeaders ; <nl> this . allowCredentials = allowCredentials ; <nl> } <nl> + <nl> + public CorsFeature ( IList < string > allowOriginWhitelist , string allowedMethods = DefaultMethods , string allowedHeaders = DefaultHeaders , bool allowCredentials = false ) <nl> + { <nl> + this . allowedMethods = allowedMethods ; <nl> + this . allowedHeaders = allowedHeaders ; <nl> + this . allowCredentials = allowCredentials ; <nl> + this . allowOriginWhitelist = allowOriginWhitelist ; <nl> + } <nl> <nl> public void Register ( IAppHost appHost ) <nl> { <nl> if ( isInstalled ) return ; <nl> isInstalled = true ; <nl> <nl> - if ( ! string . IsNullOrEmpty ( allowedOrigins ) ) <nl> + if ( ! string . IsNullOrEmpty ( allowedOrigins ) & & allowOriginWhitelist = = null ) <nl> appHost . Config . GlobalResponseHeaders . Add ( HttpHeaders . AllowOrigin , allowedOrigins ) ; <nl> if ( ! string . IsNullOrEmpty ( allowedMethods ) ) <nl> appHost . Config . GlobalResponseHeaders . Add ( HttpHeaders . AllowMethods , allowedMethods ) ; <nl> public void Register ( IAppHost appHost ) <nl> appHost . Config . GlobalResponseHeaders . Add ( HttpHeaders . AllowHeaders , allowedHeaders ) ; <nl> if ( allowCredentials ) <nl> appHost . Config . GlobalResponseHeaders . Add ( HttpHeaders . AllowCredentials , \" true \" ) ; <nl> + <nl> + if ( allowOriginWhitelist ! = null ) <nl> + { <nl> + appHost . RequestFilters . Add ( ( httpReq , httpRes , requestDto ) = > <nl> + { <nl> + var origin = httpReq . Headers . Get ( \" Origin \" ) ; <nl> + if ( allowOriginWhitelist . Contains ( origin ) ) <nl> + { <nl> + httpRes . AddHeader ( HttpHeaders . AllowOrigin , origin ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> } <nl> } <nl> } <nl> \\ No newline at end of file <nl>\n", "msg": "Added allowed origin ' whitelist ' functionality to CorsFeature\n"}
{"diff_id": 11411, "repo": "dotnet/roslyn\n", "sha": "a0fb58c6fe89395e3a1cebd5f7846210afb30a39\n", "time": "2019-01-08T23:25:32Z\n", "diff": "mmm a / src / EditorFeatures / CSharp / CompleteStatement / CompleteStatementCommandHandler . cs <nl> ppp b / src / EditorFeatures / CSharp / CompleteStatement / CompleteStatementCommandHandler . cs <nl> private static bool SemiColonIsMissing ( SyntaxNode currentNode ) <nl> case SyntaxKind . AddAccessorDeclaration : <nl> return ( ( AccessorDeclarationSyntax ) currentNode ) . SemicolonToken . IsMissing ; <nl> default : <nl> + / / At this point , the node should be empty or its children should not end with a semicolon . <nl> + Debug . Assert ( ! currentNode . ChildNodesAndTokens ( ) . Any ( ) <nl> + | | ! currentNode . ChildNodesAndTokens ( ) . Last ( ) . IsKind ( SyntaxKind . SemicolonToken ) ) ; <nl> return false ; <nl> } <nl> } <nl>\n", "msg": "Add an assertion that SemiColonIsMissing explicitly lists all cases\n"}
{"diff_id": 11554, "repo": "dotnet/runtime\n", "sha": "794cab8327cfdfaf28e43716925f4c3b53396ed3\n", "time": "2018-12-15T17:04:35Z\n", "diff": "mmm a / src / libraries / System . Net . Security / src / System / Net / Security / SslState . cs <nl> ppp b / src / libraries / System . Net . Security / src / System / Net / Security / SslState . cs <nl> private void HandleQueuedCallback ( ref object queuedStateRequest ) <nl> return ; <nl> } <nl> queuedStateRequest = null ; <nl> - <nl> + <nl> switch ( obj ) <nl> { <nl> case LazyAsyncResult lazy : <nl> private void HandleQueuedCallback ( ref object queuedStateRequest ) <nl> break ; <nl> case TaskCompletionSource < int > taskCompletionSource when taskCompletionSource . Task . AsyncState ! = null : <nl> Memory < byte > array = ( Memory < byte > ) taskCompletionSource . Task . AsyncState ; <nl> - taskCompletionSource . SetResult ( CheckOldKeyDecryptedData ( array ) ) ; <nl> + int oldKeyResult = - 1 ; <nl> + try <nl> + { <nl> + oldKeyResult = CheckOldKeyDecryptedData ( array ) ; <nl> + } <nl> + catch ( Exception exc ) <nl> + { <nl> + taskCompletionSource . SetException ( exc ) ; <nl> + break ; <nl> + } <nl> + taskCompletionSource . SetResult ( oldKeyResult ) ; <nl> break ; <nl> case TaskCompletionSource < int > taskCompletionSource : <nl> taskCompletionSource . SetResult ( 0 ) ; <nl>\n", "msg": "catch exception in ssl handshake so it can be propagated to async caller ( dotnet / corefx )\n"}
{"diff_id": 11883, "repo": "hbons/SparkleShare\n", "sha": "c767dbc30277d0c3cf4475d729b8465f9d85b8c9\n", "time": "2011-09-05T01:02:15Z\n", "diff": "mmm a / SparkleLib / SparkleHelpers . cs <nl> ppp b / SparkleLib / SparkleHelpers . cs <nl> <nl> <nl> using System ; <nl> using System . IO ; <nl> + using System . Text . RegularExpressions ; <nl> <nl> namespace SparkleLib { <nl> <nl> public static DateTime UnixTimestampToDateTime ( int timestamp ) <nl> DateTime unix_epoch = new DateTime ( 1970 , 1 , 1 , 0 , 0 , 0 , 0 ) ; <nl> return unix_epoch . AddSeconds ( timestamp ) ; <nl> } <nl> + <nl> + / / Gets the relative path of two hirarchical absolute paths <nl> + public static string DiffPaths ( string target , string source ) { <nl> + return target . Replace ( source + Path . DirectorySeparatorChar , \" \" ) ; <nl> + } <nl> } <nl> } <nl>\n", "msg": "Added a new helper function for getting a relative - to - repostory path\n"}
{"diff_id": 11990, "repo": "mRemoteNG/mRemoteNG\n", "sha": "45b207f39952461121e2b7d630828d8048de604b\n", "time": "2016-09-22T18:06:18Z\n", "diff": "mmm a / mRemoteV1 / UI / Window / ConnectionTreeWindow . cs <nl> ppp b / mRemoteV1 / UI / Window / ConnectionTreeWindow . cs <nl> private void SetModelUpdateHandlers ( ) <nl> { <nl> _puttySessionsManager . PuttySessionsCollectionChanged + = ( sender , args ) = > RefreshTreeObjects ( GetRootPuttyNodes ( ) . ToList ( ) ) ; <nl> ConnectionTreeModel . CollectionChanged + = HandleCollectionChanged ; <nl> + ConnectionTreeModel . PropertyChanged + = HandleCollectionPropertyChanged ; <nl> + } <nl> + <nl> + private void HandleCollectionPropertyChanged ( object sender , PropertyChangedEventArgs propertyChangedEventArgs ) <nl> + { <nl> + if ( propertyChangedEventArgs . PropertyName ! = \" Name \" ) return ; <nl> + var senderAsConnectionInfo = sender as ConnectionInfo ; <nl> + if ( senderAsConnectionInfo ! = null ) <nl> + RefreshTreeObject ( senderAsConnectionInfo ) ; <nl> } <nl> <nl> private void PopulateTreeView ( ) <nl>\n", "msg": "Added property changed event handler to the connection tree . Model property updates will now be immediately reflected by the tree view\n"}
{"diff_id": 12026, "repo": "ppy/osu\n", "sha": "c57fecd1fc4379b7d15e58c5612e8c425ddea375\n", "time": "2020-10-20T03:43:57Z\n", "diff": "mmm a / osu . Game / Screens / Play / HUDOverlay . cs <nl> ppp b / osu . Game / Screens / Play / HUDOverlay . cs <nl> protected override void Update ( ) <nl> { <nl> base . Update ( ) ; <nl> <nl> - / / for now align with the accuracy counter . eventually this will be user customisable . <nl> + / / HACK : for now align with the accuracy counter . <nl> + / / this is done for the sake of hacky legacy skins which extend the health bar to take up the full screen area . <nl> + / / it only works with the default skin due to padding offsetting it * just enough * to coexist . <nl> topRightElements . Y = ToLocalSpace ( AccuracyCounter . Drawable . ScreenSpaceDrawQuad . BottomRight ) . Y ; <nl> <nl> bottomRightElements . Y = - Progress . Height ; <nl>\n", "msg": "Update comment to make it clear this is a hack\n"}
{"diff_id": 12307, "repo": "AvaloniaUI/Avalonia\n", "sha": "055115415c4aaad19f755aa525e778014444ec67\n", "time": "2019-11-25T12:11:29Z\n", "diff": "mmm a / src / Avalonia . Controls / Application . cs <nl> ppp b / src / Avalonia . Controls / Application . cs <nl> public class Application : AvaloniaObject , IDataContextProvider , IGlobalDataTemp <nl> / / / Defines the < see cref = \" DataContext \" / > property . <nl> / / / < / summary > <nl> public static readonly StyledProperty < object > DataContextProperty = <nl> - AvaloniaProperty . Register < Application , object > ( <nl> - nameof ( DataContext ) ) ; <nl> + StyledElement . DataContextProperty . AddOwner < Application > ( ) ; <nl> <nl> / / / < inheritdoc / > <nl> public event EventHandler < ResourcesChangedEventArgs > ResourcesChanged ; <nl>\n", "msg": "Application class uses AddOwner instead of making its own version of datacontext property .\n"}
{"diff_id": 12597, "repo": "ppy/osu\n", "sha": "d0122b935edd00a514d4bc0088ab2a2dee5cd3a0\n", "time": "2020-02-15T10:40:59Z\n", "diff": "mmm a / osu . Game / Online / Multiplayer / Room . cs <nl> ppp b / osu . Game / Online / Multiplayer / Room . cs <nl> public void CopyFrom ( Room other ) <nl> if ( DateTimeOffset . Now > = EndDate . Value ) <nl> Status . Value = new RoomStatusEnded ( ) ; <nl> <nl> - foreach ( var removedItem in Playlist . Except ( other . Playlist ) . ToArray ( ) ) <nl> - Playlist . Remove ( removedItem ) ; <nl> + / / transfer local beatmaps across to ensure we have Metadata available ( CreateRoomRequest does not give us metadata as expected ) <nl> + foreach ( var item in other . Playlist ) <nl> + { <nl> + var localItem = Playlist . FirstOrDefault ( i = > i . BeatmapID = = item . BeatmapID ) ; <nl> + <nl> + if ( localItem ! = null ) <nl> + { <nl> + item . Beatmap . Value . Metadata = localItem . Beatmap . Value . Metadata ; <nl> + } <nl> + } <nl> + <nl> + foreach ( var removeableItem in Playlist . Except ( other . Playlist ) . ToArray ( ) ) <nl> + Playlist . Remove ( removeableItem ) ; <nl> + <nl> Playlist . AddRange ( other . Playlist . Except ( Playlist ) . ToArray ( ) ) ; <nl> <nl> foreach ( var removedItem in Participants . Except ( other . Participants ) . ToArray ( ) ) <nl>\n", "msg": "Transfer metadata to ensure present on creating a new match\n"}
{"diff_id": 12622, "repo": "dotnet/maui\n", "sha": "8dab20543c829f6cda4b09a8659b753f35ae0a0a\n", "time": "2018-03-28T05:27:11Z\n", "diff": "mmm a / Xamarin . Forms . Platform . Android / Renderers / DatePickerRenderer . cs <nl> ppp b / Xamarin . Forms . Platform . Android / Renderers / DatePickerRenderer . cs <nl> internal override void OnFocusChangeRequested ( object sender , VisualElement . Focus <nl> } <nl> } <nl> <nl> - void CreateDatePickerDialog ( int year , int month , int day ) <nl> + protected virtual DatePickerDialog CreateDatePickerDialog ( int year , int month , int day ) <nl> { <nl> DatePicker view = Element ; <nl> - _dialog = new DatePickerDialog ( Context , ( o , e ) = > <nl> + var dialog = new DatePickerDialog ( Context , ( o , e ) = > <nl> { <nl> view . Date = e . Date ; <nl> ( ( IElementController ) view ) . SetValueFromRenderer ( VisualElement . IsFocusedPropertyKey , false ) ; <nl> Control . ClearFocus ( ) ; <nl> <nl> if ( Forms . IsLollipopOrNewer ) <nl> - _dialog . CancelEvent - = OnCancelButtonClicked ; <nl> + dialog . CancelEvent - = OnCancelButtonClicked ; <nl> <nl> - _dialog = null ; <nl> + dialog = null ; <nl> } , year , month , day ) ; <nl> + <nl> + return dialog ; <nl> } <nl> <nl> void DeviceInfoPropertyChanged ( object sender , PropertyChangedEventArgs e ) <nl> void DeviceInfoPropertyChanged ( object sender , PropertyChangedEventArgs e ) <nl> if ( currentDialog ! = null & & currentDialog . IsShowing ) <nl> { <nl> currentDialog . Dismiss ( ) ; <nl> - CreateDatePickerDialog ( currentDialog . DatePicker . Year , currentDialog . DatePicker . Month , currentDialog . DatePicker . DayOfMonth ) ; <nl> + _dialog = CreateDatePickerDialog ( currentDialog . DatePicker . Year , currentDialog . DatePicker . Month , currentDialog . DatePicker . DayOfMonth ) ; <nl> _dialog . Show ( ) ; <nl> } <nl> } <nl> void OnTextFieldClicked ( ) <nl> DatePicker view = Element ; <nl> ( ( IElementController ) view ) . SetValueFromRenderer ( VisualElement . IsFocusedPropertyKey , true ) ; <nl> <nl> - CreateDatePickerDialog ( view . Date . Year , view . Date . Month - 1 , view . Date . Day ) ; <nl> + _dialog = CreateDatePickerDialog ( view . Date . Year , view . Date . Month - 1 , view . Date . Day ) ; <nl> <nl> UpdateMinimumDate ( ) ; <nl> UpdateMaximumDate ( ) ; <nl>\n", "msg": "[ Android ] Added ability to override CreateDatePickerDialog on the DatePickerRenderer so it can be customised .\n"}
{"diff_id": 12708, "repo": "StackExchange/Dapper\n", "sha": "48c111acf94693cc6f6e849bc4e40e21fcc61610\n", "time": "2013-12-20T23:29:01Z\n", "diff": "mmm a / Dapper . Contrib / SqlMapperExtensions . cs <nl> ppp b / Dapper . Contrib / SqlMapperExtensions . cs <nl> public interface IProxy <nl> <nl> private static readonly Dictionary < string , ISqlAdapter > AdapterDictionary = new Dictionary < string , ISqlAdapter > ( ) { <nl> { \" sqlconnection \" , new SqlServerAdapter ( ) } , <nl> - { \" npgsqlconnection \" , new PostgresAdapter ( ) } <nl> + { \" npgsqlconnection \" , new PostgresAdapter ( ) } , <nl> + { \" sqliteconnection \" , new SQLiteAdapter ( ) } <nl> } ; <nl> <nl> private static IEnumerable < PropertyInfo > KeyPropertiesCache ( Type type ) <nl> public int Insert ( IDbConnection connection , IDbTransaction transaction , int ? com <nl> } <nl> return id ; <nl> } <nl> - } <nl> \\ No newline at end of file <nl> + } <nl> + <nl> + public class SQLiteAdapter : ISqlAdapter <nl> + { <nl> + public int Insert ( IDbConnection connection , IDbTransaction transaction , int ? commandTimeout , String tableName , string columnList , string parameterList , IEnumerable < PropertyInfo > keyProperties , object entityToInsert ) <nl> + { <nl> + string cmd = String . Format ( \" insert into { 0 } ( { 1 } ) values ( { 2 } ) \" , tableName , columnList , parameterList ) ; <nl> + <nl> + connection . Execute ( cmd , entityToInsert , transaction : transaction , commandTimeout : commandTimeout ) ; <nl> + <nl> + var r = connection . Query ( \" select last_insert_rowid ( ) id \" , transaction : transaction , commandTimeout : commandTimeout ) ; <nl> + int id = ( int ) r . First ( ) . id ; <nl> + if ( keyProperties . Any ( ) ) <nl> + keyProperties . First ( ) . SetValue ( entityToInsert , id , null ) ; <nl> + return id ; <nl> + } <nl> + <nl> + <nl> + <nl> + } <nl>\n", "msg": "Add SQLiteAdapter . Dapper . Contrib inserts now works with sqlite .\n"}
{"diff_id": 12749, "repo": "ppy/osu\n", "sha": "52c7ed99607028bef24a0f13073638866e09931f\n", "time": "2019-06-13T10:46:48Z\n", "diff": "mmm a / osu . Game / Online / API / APIDownloadRequest . cs <nl> ppp b / osu . Game / Online / API / APIDownloadRequest . cs <nl> public abstract class APIDownloadRequest : APIRequest <nl> { <nl> private string filename ; <nl> <nl> + / / / < summary > <nl> + / / / Sets the extension of the file outputted by this request . <nl> + / / / < / summary > <nl> + protected virtual string FileExtension { get ; } = @ \" . tmp \" ; <nl> + <nl> protected override WebRequest CreateWebRequest ( ) <nl> { <nl> - var request = new FileWebRequest ( filename = Path . GetTempFileName ( ) , Uri ) ; <nl> + var file = Path . GetTempFileName ( ) ; <nl> + <nl> + File . Move ( file , filename = Path . ChangeExtension ( file , FileExtension ) ) ; <nl> + <nl> + var request = new FileWebRequest ( filename , Uri ) ; <nl> request . DownloadProgress + = request_Progress ; <nl> return request ; <nl> } <nl>\n", "msg": "Add ability to change the flie extension of API download requests\n"}
{"diff_id": 13043, "repo": "dotnet/runtime\n", "sha": "d6de7761e77a4828235cb90ee1768fac67898fce\n", "time": "2016-03-31T18:45:31Z\n", "diff": "mmm a / src / libraries / System . Linq . Expressions / src / System / Linq / Expressions / SwitchExpression . cs <nl> ppp b / src / libraries / System . Linq . Expressions / src / System / Linq / Expressions / SwitchExpression . cs <nl> public static SwitchExpression Switch ( Type type , Expression switchValue , Express <nl> } <nl> } <nl> } <nl> + <nl> + / / if we have a non - boolean user - defined equals , we don ' t want it . <nl> + if ( comparison . ReturnType ! = typeof ( bool ) ) <nl> + { <nl> + throw Error . EqualityMustReturnBoolean ( comparison ) ; <nl> + } <nl> } <nl> else if ( caseList . Count ! = 0 ) <nl> { <nl> public static SwitchExpression Switch ( Type type , Expression switchValue , Express <nl> ValidateSwitchCaseType ( defaultBody , customType , resultType , nameof ( defaultBody ) ) ; <nl> } <nl> <nl> - / / if we have a non - boolean user - defined equals , we don ' t want it . <nl> - if ( comparison ! = null & & comparison . ReturnType ! = typeof ( bool ) ) <nl> - { <nl> - throw Error . EqualityMustReturnBoolean ( comparison ) ; <nl> - } <nl> - <nl> return new SwitchExpression ( resultType , switchValue , defaultBody , comparison , caseList ) ; <nl> } <nl> <nl>\n", "msg": "Move error check around to reduce tests required .\n"}
{"diff_id": 13397, "repo": "dotnet/roslyn\n", "sha": "f54f0834033332e20db39f670db51940d26cd764\n", "time": "2016-10-20T17:41:22Z\n", "diff": "mmm a / src / Workspaces / CoreTest / SolutionTests / SolutionTests . cs <nl> ppp b / src / Workspaces / CoreTest / SolutionTests / SolutionTests . cs <nl> public void TestRecoverableSyntaxTreeCSharp ( ) <nl> } <nl> <nl> [ MethodImpl ( MethodImplOptions . NoInlining ) ] <nl> - [ Fact , Trait ( Traits . Feature , Traits . Features . Workspace ) ] <nl> + [ Fact ( Skip = \" https : / / github . com / dotnet / roslyn / issues / 13433 \" ) , Trait ( Traits . Feature , Traits . Features . Workspace ) ] <nl> public void TestRecoverableSyntaxTreeVisualBasic ( ) <nl> { <nl> var pid = ProjectId . CreateNewId ( ) ; <nl>\n", "msg": "Skip flaky SolutionTests . TestRecoverableSyntaxTreeVisualBasic until is resolved .\n"}
{"diff_id": 13649, "repo": "OpenRA/OpenRA\n", "sha": "4a12b78f14cd8bd8ec85d02c119dfb1f2d5c352f\n", "time": "2010-11-23T00:59:43Z\n", "diff": "mmm a / OpenRA . Game / Network / Order . cs <nl> ppp b / OpenRA . Game / Network / Order . cs <nl> public static bool HasField ( this OrderFields of , OrderFields f ) <nl> } <nl> } <nl> <nl> + public sealed class _Order <nl> + { <nl> + public string OrderString ; <nl> + public Actor Subject ; <nl> + public Actor TargetActor ; <nl> + public int2 TargetLocation ; <nl> + public string TargetString ; <nl> + public bool Queued ; <nl> + public int2 ExtraLocation ; <nl> + <nl> + public static implicit operator Order ( _Order o ) <nl> + { <nl> + return new Order ( o . OrderString , <nl> + o . Subject , <nl> + o . TargetActor , <nl> + o . TargetLocation , <nl> + o . TargetString , <nl> + o . Queued , <nl> + o . ExtraLocation ) ; <nl> + } <nl> + } <nl> + <nl> public sealed class Order <nl> { <nl> public readonly string OrderString ; <nl>\n", "msg": "experiment - - _Order is a mutable builder - object for Order , implicitly convertible\n"}
{"diff_id": 13757, "repo": "reactiveui/ReactiveUI\n", "sha": "8b975772db703de3aa07496c010384c3d76dd239\n", "time": "2012-12-05T04:15:40Z\n", "diff": "mmm a / ReactiveUI / PropertyBinding . cs <nl> ppp b / ReactiveUI / PropertyBinding . cs <nl> static BindingMixins ( ) <nl> binderImplementation = new PropertyBinderImplementation ( ) ; <nl> } <nl> <nl> - public static IDisposable Bind < TViewModel , TView , TProp > ( <nl> + public static IDisposable Bind < TViewModel , TView , TVMProp , TVProp > ( <nl> this TView view , <nl> TViewModel viewModel , <nl> - Expression < Func < TViewModel , TProp > > vmProperty , <nl> - Expression < Func < TView , TProp > > viewProperty ) <nl> + Expression < Func < TViewModel , TVMProp > > vmProperty , <nl> + Expression < Func < TView , TVProp > > viewProperty ) <nl> where TViewModel : class <nl> where TView : IViewFor <nl> { <nl> static BindingMixins ( ) <nl> return binderImplementation . Bind < TViewModel , TView , TProp , TProp , Unit > ( viewModel , view , vmProperty , null , null , null ) ; <nl> } <nl> <nl> - public static IDisposable Bind < TViewModel , TView , TProp , TDontCare > ( <nl> + public static IDisposable Bind < TViewModel , TView , TVMProp , TVProp , TDontCare > ( <nl> this TView view , <nl> TViewModel viewModel , <nl> - Expression < Func < TViewModel , TProp > > vmProperty , <nl> - Expression < Func < TView , TProp > > viewProperty , <nl> + Expression < Func < TViewModel , TVMProp > > vmProperty , <nl> + Expression < Func < TView , TVProp > > viewProperty , <nl> IObservable < TDontCare > signalViewUpdate ) <nl> where TViewModel : class <nl> where TView : IViewFor <nl>\n", "msg": "Fix type - conversion types for two - way binds\n"}
{"diff_id": 13783, "repo": "mono/mono\n", "sha": "0237ddc8e0a974365ad8a01f65b9cdcfe824d806\n", "time": "2014-07-21T00:54:16Z\n", "diff": "mmm a / mcs / class / System . Web / System . Web / MimeTypes . cs <nl> ppp b / mcs / class / System . Web / System . Web / MimeTypes . cs <nl> static MimeTypes ( ) <nl> mimeTypes . Add ( \" htx \" , \" text / html \" ) ; <nl> mimeTypes . Add ( \" ice \" , \" x - conference / x - cooltalk \" ) ; <nl> mimeTypes . Add ( \" ico \" , \" image / x - icon \" ) ; <nl> + mimeTypes . Add ( \" ics \" , \" text / calendar \" ) ; <nl> mimeTypes . Add ( \" idc \" , \" text / plain \" ) ; <nl> mimeTypes . Add ( \" ief \" , \" image / ief \" ) ; <nl> mimeTypes . Add ( \" iefs \" , \" image / ief \" ) ; <nl> static MimeTypes ( ) <nl> mimeTypes . Add ( \" mme \" , \" application / base64 \" ) ; <nl> mimeTypes . Add ( \" mny \" , \" application / x - msmoney \" ) ; <nl> mimeTypes . Add ( \" mod \" , \" audio / mod \" ) ; <nl> - mimeTypes . Add ( \" moov \" , \" video / quicktime \" ) ; <nl> + mimeTypes . Add ( \" mov \" , \" video / quicktime \" ) ; <nl> mimeTypes . Add ( \" movie \" , \" video / x - sgi - movie \" ) ; <nl> mimeTypes . Add ( \" mov \" , \" video / quicktime \" ) ; <nl> mimeTypes . Add ( \" mp2 \" , \" video / mpeg \" ) ; <nl> - mimeTypes . Add ( \" mp3 \" , \" audio / mpeg3 \" ) ; <nl> + mimeTypes . Add ( \" mp3 \" , \" audio / mpeg \" ) ; <nl> mimeTypes . Add ( \" mp4 \" , \" video / mp4 \" ) ; <nl> / / mimeTypes . Add ( \" mp4a \" , \" audio / mp4 \" ) ; / / A common but unofficial alternative to m4a <nl> mimeTypes . Add ( \" mpa \" , \" audio / mpeg \" ) ; <nl>\n", "msg": "[ System . Web ] Fixed some mime types\n"}
{"diff_id": 14096, "repo": "SignalR/SignalR\n", "sha": "33fae17ebc6aad213e5182e394d8d74db3c395d0\n", "time": "2012-01-12T18:19:06Z\n", "diff": "mmm a / SignalR . AspNet / AspNetResponse . cs <nl> ppp b / SignalR . AspNet / AspNetResponse . cs <nl> public string ContentType <nl> <nl> public Task WriteAsync ( string data ) <nl> { <nl> - _context . Response . Write ( data ) ; <nl> - return TaskAsyncHelper . Empty ; <nl> + return TaskAsyncHelper . FromMethod ( ( response , value ) = > response . Write ( value ) , _context . Response , data ) ; <nl> } <nl> <nl> public Task EndAsync ( string data ) <nl>\n", "msg": "Instead of returning an empty Task from the AspNetResponse . WriteAsync method , return a task that represents the sync write operation .\n"}
{"diff_id": 14447, "repo": "ServiceStack/ServiceStack\n", "sha": "1dc74183b8aa2ffbcd2cb420874d28647a02ea92\n", "time": "2012-09-08T10:30:18Z\n", "diff": "mmm a / src / ServiceStack . Common / ReflectionExtensions . cs <nl> ppp b / src / ServiceStack . Common / ReflectionExtensions . cs <nl> <nl> using System ; <nl> + using System . Diagnostics ; <nl> + using System . Linq ; <nl> using System . Reflection ; <nl> using ServiceStack . Common . Utils ; <nl> <nl> public static bool IsDynamic ( this Assembly assembly ) <nl> # endif <nl> } <nl> <nl> + public static bool IsDebugBuild ( this Assembly assembly ) <nl> + { <nl> + return assembly . GetCustomAttributes ( false ) <nl> + . OfType < DebuggableAttribute > ( ) <nl> + . Select ( attr = > attr . IsJITTrackingEnabled ) <nl> + . FirstOrDefault ( ) ; <nl> + } <nl> } <nl> } <nl> <nl>\n", "msg": "Automatically set Config . DebugMode based on debug build of AppHost assembly .\n"}
{"diff_id": 14540, "repo": "gitextensions/gitextensions\n", "sha": "0ba1641eaab992cbbfd688c01a6f3c6f2464fd6e\n", "time": "2013-02-08T22:13:28Z\n", "diff": "mmm a / GitUI / FormCommit . cs <nl> ppp b / GitUI / FormCommit . cs <nl> private void CommitMessageToolStripMenuItemDropDownOpening ( object sender , EventA <nl> AddCommitMessageToMenu ( Module . GetPreviousCommitMessage ( 1 ) ) ; <nl> AddCommitMessageToMenu ( Module . GetPreviousCommitMessage ( 2 ) ) ; <nl> AddCommitMessageToMenu ( Module . GetPreviousCommitMessage ( 3 ) ) ; <nl> + <nl> + commitMessageToolStripMenuItem . DropDownItems . AddRange ( new ToolStripItem [ ] { <nl> + toolStripMenuItem1 , <nl> + generateListOfChangesInSubmodulesChangesToolStripMenuItem } ) ; <nl> } <nl> <nl> private void AddCommitMessageToMenu ( string commitMessage ) <nl>\n", "msg": "Menu item \" Generate list of changes in submodules \" fixed\n"}
{"diff_id": 15062, "repo": "mono/mono\n", "sha": "48a5bbeb932ec2a33dfd6ec45a8830e679a56025\n", "time": "2011-09-06T21:54:11Z\n", "diff": "mmm a / mcs / class / corlib / System . Threading . Tasks / TaskFactory . cs <nl> ppp b / mcs / class / corlib / System . Threading . Tasks / TaskFactory . cs <nl> public Task ContinueWhenAny ( Task [ ] tasks , Action < Task > continuationAction , Task <nl> { <nl> var ourTasks = ( Task [ ] ) tasks . Clone ( ) ; <nl> AtomicBoolean trigger = new AtomicBoolean ( ) ; <nl> - Task commonContinuation = new Task ( null ) ; <nl> + var commonContinuation = new TaskCompletionSource < object > ( ) ; <nl> + Action < Task > continuationFunc = t = > commonContinuation . SetResult ( null ) ; <nl> <nl> foreach ( Task t in ourTasks ) { <nl> Task cont = new Task ( ( o ) = > continuationAction ( ( Task ) o ) , t , cancellationToken , creationOptions , t ) ; <nl> t . ContinueWithCore ( cont , continuationOptions , scheduler , trigger . TrySet ) ; <nl> - cont . ContinueWithCore ( commonContinuation , TaskContinuationOptions . None , scheduler ) ; <nl> + cont . ContinueWith ( continuationFunc ) ; <nl> } <nl> <nl> - return commonContinuation ; <nl> + return commonContinuation . Task ; <nl> } <nl> <nl> public Task ContinueWhenAny < TAntecedentResult > ( Task < TAntecedentResult > [ ] tasks , <nl>\n", "msg": "Use a TaskCompletionSource in non - generic ContinueWhenAny case . Fix .\n"}
{"diff_id": 15344, "repo": "mono/mono\n", "sha": "aa155736de34b551381181a926f73ea818568a22\n", "time": "2011-11-08T12:56:40Z\n", "diff": "mmm a / mcs / class / corlib / System . Collections . Generic / Dictionary . cs <nl> ppp b / mcs / class / corlib / System . Collections . Generic / Dictionary . cs <nl> void CopyToCheck ( Array array , int index ) <nl> throw new ArgumentException ( \" Destination array cannot hold the requested elements ! \" ) ; <nl> } <nl> <nl> - delegate TRet Transform < TRet > ( TKey key , TValue value ) ; <nl> + void CopyKeys ( TKey [ ] array , int index ) <nl> + { <nl> + for ( int i = 0 ; i < touchedSlots ; i + + ) { <nl> + if ( ( linkSlots [ i ] . HashCode & HASH_FLAG ) ! = 0 ) <nl> + array [ index + + ] = keySlots [ i ] ; <nl> + } <nl> + } <nl> <nl> - void Do_CopyTo < TRet , TElem > ( TElem [ ] array , int index , Transform < TRet > transform ) <nl> - where TRet : TElem <nl> + void CopyValues ( TValue [ ] array , int index ) <nl> { <nl> for ( int i = 0 ; i < touchedSlots ; i + + ) { <nl> if ( ( linkSlots [ i ] . HashCode & HASH_FLAG ) ! = 0 ) <nl> - array [ index + + ] = transform ( keySlots [ i ] , valueSlots [ i ] ) ; <nl> + array [ index + + ] = valueSlots [ i ] ; <nl> } <nl> } <nl> <nl> + delegate TRet Transform < TRet > ( TKey key , TValue value ) ; <nl> + <nl> + <nl> static KeyValuePair < TKey , TValue > make_pair ( TKey key , TValue value ) <nl> { <nl> return new KeyValuePair < TKey , TValue > ( key , value ) ; <nl> static TValue pick_value ( TKey key , TValue value ) <nl> void CopyTo ( KeyValuePair < TKey , TValue > [ ] array , int index ) <nl> { <nl> CopyToCheck ( array , index ) ; <nl> - Do_CopyTo < KeyValuePair < TKey , TValue > , KeyValuePair < TKey , TValue > > ( array , index , make_pair ) ; <nl> + for ( int i = 0 ; i < touchedSlots ; i + + ) { <nl> + if ( ( linkSlots [ i ] . HashCode & HASH_FLAG ) ! = 0 ) <nl> + array [ index + + ] = new KeyValuePair < TKey , TValue > ( keySlots [ i ] , valueSlots [ i ] ) ; <nl> + } <nl> } <nl> <nl> void Do_ICollectionCopyTo < TRet > ( Array array , int index , Transform < TRet > transform ) <nl> void Do_ICollectionCopyTo < TRet > ( Array array , int index , Transform < TRet > transfo <nl> / / BOOTSTRAP : gmcs 2 . 4 . x seems to have trouble compiling the alternative <nl> throw new Exception ( ) ; <nl> # else <nl> - Do_CopyTo ( ( object [ ] ) array , index , transform ) ; <nl> + object [ ] dest = ( object [ ] ) array ; <nl> + for ( int i = 0 ; i < touchedSlots ; i + + ) { <nl> + if ( ( linkSlots [ i ] . HashCode & HASH_FLAG ) ! = 0 ) <nl> + dest [ index + + ] = transform ( keySlots [ i ] , valueSlots [ i ] ) ; <nl> + } <nl> # endif <nl> <nl> } catch ( Exception e ) { <nl> void ICollection . CopyTo ( Array array , int index ) <nl> CopyToCheck ( array , index ) ; <nl> DictionaryEntry [ ] entries = array as DictionaryEntry [ ] ; <nl> if ( entries ! = null ) { <nl> - Do_CopyTo ( entries , index , delegate ( TKey key , TValue value ) { return new DictionaryEntry ( key , value ) ; } ) ; <nl> + for ( int i = 0 ; i < touchedSlots ; i + + ) { <nl> + if ( ( linkSlots [ i ] . HashCode & HASH_FLAG ) ! = 0 ) <nl> + entries [ index + + ] = new DictionaryEntry ( keySlots [ i ] , valueSlots [ i ] ) ; <nl> + } <nl> return ; <nl> } <nl> <nl> public KeyCollection ( Dictionary < TKey , TValue > dictionary ) <nl> public void CopyTo ( TKey [ ] array , int index ) <nl> { <nl> dictionary . CopyToCheck ( array , index ) ; <nl> - dictionary . Do_CopyTo < TKey , TKey > ( array , index , pick_key ) ; <nl> + dictionary . CopyKeys ( array , index ) ; <nl> } <nl> <nl> public Enumerator GetEnumerator ( ) <nl> public ValueCollection ( Dictionary < TKey , TValue > dictionary ) <nl> public void CopyTo ( TValue [ ] array , int index ) <nl> { <nl> dictionary . CopyToCheck ( array , index ) ; <nl> - dictionary . Do_CopyTo < TValue , TValue > ( array , index , pick_value ) ; <nl> + dictionary . CopyValues ( array , index ) ; <nl> } <nl> <nl> public Enumerator GetEnumerator ( ) <nl>\n", "msg": "Workaround AOT limitation for bug . Patch by Rodrigo Kumpera\n"}
{"diff_id": 15362, "repo": "dotnet/aspnetcore\n", "sha": "575daeb0d6120084f29f04ab394dd9922cd30b4d\n", "time": "2014-05-12T05:44:34Z\n", "diff": "mmm a / src / Microsoft . AspNet . Mvc . Core / Rendering / Html / HtmlHelper . cs <nl> ppp b / src / Microsoft . AspNet . Mvc . Core / Rendering / Html / HtmlHelper . cs <nl> protected virtual HtmlString GenerateDisplayText ( ModelMetadata metadata ) <nl> / / parameters . Also reachable in the even - more - unusual case that user called another BeginForm ( ) <nl> / / overload with default argument values . <nl> var request = ViewContext . HttpContext . Request ; <nl> - formAction = request . PathBase . Add ( request . Path ) . Add ( request . QueryString ) ; <nl> + formAction = request . PathBase + request . Path + request . QueryString ; <nl> } <nl> else <nl> { <nl>\n", "msg": "Use ` + ` rather than explicit ` PathString . Add ( ) ` overloads\n"}
{"diff_id": 15711, "repo": "ppy/osu\n", "sha": "8fd04cb47bd9260e52e6280e31aeab43d385408b\n", "time": "2018-11-29T04:20:37Z\n", "diff": "mmm a / osu . Game . Rulesets . Mania / UI / ManiaPlayfield . cs <nl> ppp b / osu . Game . Rulesets . Mania / UI / ManiaPlayfield . cs <nl> <nl> using osu . Framework . Graphics . Containers ; <nl> using System ; <nl> using System . Collections . Generic ; <nl> + using System . Linq ; <nl> using osu . Game . Rulesets . Mania . Beatmaps ; <nl> using osu . Game . Rulesets . Mania . Objects ; <nl> using osu . Game . Rulesets . Objects . Drawables ; <nl> public class ManiaPlayfield : ScrollingPlayfield <nl> { <nl> private readonly List < ManiaStage > stages = new List < ManiaStage > ( ) ; <nl> <nl> + public override bool ReceivePositionalInputAt ( Vector2 screenSpacePos ) = > stages . Any ( s = > s . ReceivePositionalInputAt ( screenSpacePos ) ) ; <nl> + <nl> public ManiaPlayfield ( List < StageDefinition > stageDefinitions ) <nl> { <nl> if ( stageDefinitions = = null ) <nl>\n", "msg": "Fix mania placement blueprints appearing outside valid stage placement area\n"}
{"diff_id": 16048, "repo": "unoplatform/uno\n", "sha": "1c00df80113cc970a7606a3f57409d88b73641bf\n", "time": "2019-06-17T14:12:28Z\n", "diff": "mmm a / src / Uno . UWPSyncGenerator / DocGenerator . cs <nl> ppp b / src / Uno . UWPSyncGenerator / DocGenerator . cs <nl> void BuildMemberLists ( ) <nl> var methods = view . UAPSymbol . GetMembers ( ) . OfType < IMethodSymbol > ( ) . Where ( m = > m . MethodKind = = MethodKind . Ordinary ) . Select ( m = > GetAllMatchingMethods ( view , m ) ) . ToArray ( ) ; <nl> var events = view . UAPSymbol . GetMembers ( ) . OfType < IEventSymbol > ( ) . Select ( e = > GetAllMatchingEvents ( view , e ) ) . ToArray ( ) ; <nl> <nl> + var allMethods = view . UAPSymbol . GetMembers ( ) . OfType < IMethodSymbol > ( ) . ToArray ( ) ; <nl> + var allMethodNames = allMethods . Select ( m = > m . Name ) . ToArray ( ) ; <nl> + var methodNames = view . UAPSymbol <nl> + . GetMembers ( ) <nl> + . OfType < IMethodSymbol > ( ) <nl> + . Where ( m = > m . MethodKind = = MethodKind . Ordinary & & <nl> + ! ( m . Name . StartsWith ( \" add_ \" ) | | m . Name . StartsWith ( \" remove_ \" ) ) / / Filter out explicit event add / remove methods ( associated with routed events ) . These should already be filtered out by the MethodKind . Ordinary check but for some reason , on the build server only , aren ' t . <nl> + ) <nl> + . Select ( m = > m . Name ) <nl> + . ToArray ( ) ; <nl> + <nl> AppendImplementedMembers ( \" properties \" , properties ) ; <nl> AppendImplementedMembers ( \" methods \" , methods ) ; <nl> AppendImplementedMembers ( \" events \" , events ) ; <nl>\n", "msg": "Docs - tentative fix for unwanted event add and remove methods\n"}
{"diff_id": 16117, "repo": "ShareX/ShareX\n", "sha": "1c297dc90819dee7ec15246663d115152260eaf1\n", "time": "2016-06-07T21:55:52Z\n", "diff": "mmm a / ShareX . HelpersLib / Forms / ScreenTearingTestForm . cs <nl> ppp b / ShareX . HelpersLib / Forms / ScreenTearingTestForm . cs <nl> namespace ShareX . HelpersLib <nl> public class ScreenTearingTestForm : Form <nl> { <nl> private Rectangle screenRectangle , screenRectangle0Based ; <nl> - private TextureBrush brush ; <nl> - private Timer timer ; <nl> - private Stopwatch stopwatch ; <nl> + private Timer drawTimer ; <nl> + private Stopwatch animationTime ; <nl> private TimeSpan lastElapsed ; <nl> - private float animationSpeed = 200 ; <nl> + private int rectangleSize = 50 ; <nl> + private float animationSpeed = 500 , minSpeed = 100 , maxSpeed = 2000 , speedChange = 50 ; <nl> + private float currentPosition ; <nl> <nl> public ScreenTearingTestForm ( ) <nl> { <nl> public ScreenTearingTestForm ( ) <nl> AutoScaleMode = AutoScaleMode . Font ; <nl> StartPosition = FormStartPosition . Manual ; <nl> Bounds = screenRectangle ; <nl> + Cursor = Cursors . Hand ; <nl> FormBorderStyle = FormBorderStyle . None ; <nl> Icon = ShareXResources . Icon ; <nl> SetStyle ( ControlStyles . OptimizedDoubleBuffer | ControlStyles . UserPaint | ControlStyles . AllPaintingInWmPaint , true ) ; <nl> public ScreenTearingTestForm ( ) <nl> <nl> ResumeLayout ( false ) ; <nl> <nl> - brush = CreateVerticalLineBrush ( 50 , screenRectangle . Height , Color . Black , Color . White ) ; <nl> + animationTime = Stopwatch . StartNew ( ) ; <nl> <nl> - stopwatch = Stopwatch . StartNew ( ) ; <nl> - <nl> - timer = new Timer { Interval = 10 } ; <nl> - timer . Tick + = timer_Tick ; <nl> - timer . Start ( ) ; <nl> + drawTimer = new Timer { Interval = 5 } ; <nl> + drawTimer . Tick + = timer_Tick ; <nl> + drawTimer . Start ( ) ; <nl> } <nl> <nl> protected override void OnShown ( EventArgs e ) <nl> protected override void OnKeyUp ( KeyEventArgs e ) <nl> base . OnKeyUp ( e ) ; <nl> } <nl> <nl> + protected override void OnMouseWheel ( MouseEventArgs e ) <nl> + { <nl> + if ( e . Delta > 0 ) <nl> + { <nl> + animationSpeed = ( animationSpeed + speedChange ) . Between ( minSpeed , maxSpeed ) ; <nl> + } <nl> + else if ( e . Delta < 0 ) <nl> + { <nl> + animationSpeed = ( animationSpeed - speedChange ) . Between ( minSpeed , maxSpeed ) ; <nl> + } <nl> + <nl> + base . OnMouseWheel ( e ) ; <nl> + } <nl> + <nl> protected override void OnMouseUp ( MouseEventArgs e ) <nl> { <nl> Close ( ) ; <nl> protected override void OnPaintBackground ( PaintEventArgs e ) <nl> protected override void OnPaint ( PaintEventArgs e ) <nl> { <nl> Graphics g = e . Graphics ; <nl> - g . InterpolationMode = InterpolationMode . NearestNeighbor ; <nl> g . SmoothingMode = SmoothingMode . HighSpeed ; <nl> <nl> - g . FillRectangle ( brush , screenRectangle0Based ) ; <nl> - <nl> - TimeSpan elapsed = stopwatch . Elapsed - lastElapsed ; <nl> + g . Clear ( Color . White ) ; <nl> <nl> - float x = ( float ) ( elapsed . TotalSeconds * animationSpeed ) ; <nl> - brush . TranslateTransform ( x , 0 ) ; <nl> - <nl> - lastElapsed = stopwatch . Elapsed ; <nl> - } <nl> + int nextPosition = rectangleSize * 2 ; <nl> + int startOffset = ( int ) ( currentPosition % nextPosition ) ; <nl> <nl> - private TextureBrush CreateVerticalLineBrush ( int size , int height , Color color1 , Color color2 ) <nl> - { <nl> - using ( Bitmap bmp = new Bitmap ( size * 2 , height ) ) <nl> - using ( Graphics g = Graphics . FromImage ( bmp ) ) <nl> + for ( int x = startOffset - rectangleSize ; x < screenRectangle . Width ; x + = nextPosition ) <nl> { <nl> - g . SmoothingMode = SmoothingMode . HighSpeed ; <nl> + g . FillRectangle ( Brushes . Black , x , 0 , rectangleSize , screenRectangle . Height ) ; <nl> + } <nl> <nl> - using ( Brush brush1 = new SolidBrush ( color1 ) ) <nl> - { <nl> - g . FillRectangle ( brush1 , 0 , 0 , size , height ) ; <nl> - } <nl> + TimeSpan elapsed = animationTime . Elapsed - lastElapsed ; <nl> <nl> - using ( Brush brush2 = new SolidBrush ( color2 ) ) <nl> - { <nl> - g . FillRectangle ( brush2 , size , 0 , size , height ) ; <nl> - } <nl> + currentPosition + = ( float ) ( elapsed . TotalSeconds * animationSpeed ) ; <nl> <nl> - return new TextureBrush ( bmp , WrapMode . Tile ) ; <nl> - } <nl> + lastElapsed = animationTime . Elapsed ; <nl> } <nl> <nl> protected override void Dispose ( bool disposing ) <nl> { <nl> - if ( timer ! = null ) timer . Dispose ( ) ; <nl> - if ( brush ! = null ) brush . Dispose ( ) ; <nl> + if ( drawTimer ! = null ) drawTimer . Dispose ( ) ; <nl> <nl> base . Dispose ( disposing ) ; <nl> } <nl>\n", "msg": "Improved screen tearing test speed and added mouse wheel animation speed control\n"}
{"diff_id": 16341, "repo": "NancyFx/Nancy\n", "sha": "0dca244fc5dcf78586fd00cab3d4730dae71ab5b\n", "time": "2015-08-18T05:13:14Z\n", "diff": "mmm a / src / Nancy / StaticConfiguration . cs <nl> ppp b / src / Nancy / StaticConfiguration . cs <nl> var assembliesInDebug <nl> [ Description ( \" Enable request tracing . \" ) ] <nl> public static bool EnableRequestTracing { get ; set ; } <nl> <nl> + / / / < summary > <nl> + / / / Gets or sets a value indicating whether or not to disable request stream switching <nl> + / / / < / summary > <nl> + public static bool ? DisableRequestStreamSwitching { get ; set ; } <nl> + <nl> public static class Caching <nl> { <nl> private static bool ? enableRuntimeViewDiscovery ; <nl>\n", "msg": "ADDED : property to StaticConfiguration that allows request stream switching configuration\n"}
{"diff_id": 16366, "repo": "ppy/osu\n", "sha": "b4052a099f3d27bab3597a2e4ea068ae3f5c26fe\n", "time": "2017-05-03T03:30:03Z\n", "diff": "mmm a / osu . Desktop . VisualTests / Tests / TestCaseManiaPlayfield . cs <nl> ppp b / osu . Desktop . VisualTests / Tests / TestCaseManiaPlayfield . cs <nl> <nl> using osu . Framework . Graphics . Primitives ; <nl> using osu . Framework . Input ; <nl> using OpenTK . Input ; <nl> + using osu . Game . Rulesets . UI ; <nl> + using osu . Framework . Allocation ; <nl> + using osu . Framework . Extensions . IEnumerableExtensions ; <nl> <nl> namespace osu . Desktop . VisualTests . Tests <nl> { <nl> internal class TestCaseManiaPlayfield : TestCase <nl> { <nl> public override string Description = > @ \" Mania playfield \" ; <nl> <nl> - private FlowContainer < Column > columns ; <nl> + protected override double TimePerAction = > 200 ; <nl> <nl> public override void Reset ( ) <nl> { <nl> base . Reset ( ) ; <nl> <nl> - Add ( new Container <nl> + int max_columns = 9 ; <nl> + <nl> + for ( int i = 1 ; i < = max_columns ; i + + ) <nl> { <nl> - Anchor = Anchor . Centre , <nl> - Origin = Anchor . Centre , <nl> - RelativeSizeAxes = Axes . Y , <nl> - AutoSizeAxes = Axes . X , <nl> - Children = new Drawable [ ] <nl> + int tempI = i ; <nl> + <nl> + AddStep ( $ @ \" { i } column \" + ( i > 1 ? \" s \" : \" \" ) , ( ) = > <nl> { <nl> - new Box <nl> - { <nl> - RelativeSizeAxes = Axes . Both , <nl> - Colour = Color4 . Black <nl> - } , <nl> - columns = new FillFlowContainer < Column > <nl> + Clear ( ) ; <nl> + Add ( new ManiaPlayfield ( tempI ) <nl> { <nl> - RelativeSizeAxes = Axes . Y , <nl> - AutoSizeAxes = Axes . X , <nl> - Direction = FillDirection . Horizontal , <nl> - Padding = new MarginPadding { Left = 1 , Right = 1 } , <nl> - Spacing = new Vector2 ( 1 , 0 ) <nl> - } <nl> - } <nl> + Anchor = Anchor . Centre , <nl> + Origin = Anchor . Centre <nl> + } ) ; <nl> + } ) ; <nl> + <nl> + AddStep ( $ \" Trigger keys down \" , ( ) = > ( ( ManiaPlayfield ) Children . First ( ) ) . Columns . Children . ForEach ( triggerKeyDown ) ) ; <nl> + AddStep ( $ \" Trigger keys up \" , ( ) = > ( ( ManiaPlayfield ) Children . First ( ) ) . Columns . Children . ForEach ( triggerKeyUp ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void triggerKeyDown ( Column column ) <nl> + { <nl> + column . TriggerKeyDown ( new InputState ( ) , new KeyDownEventArgs <nl> + { <nl> + Key = column . Key , <nl> + Repeat = false <nl> } ) ; <nl> + } <nl> <nl> - var colours = new Color4 [ ] <nl> + private void triggerKeyUp ( Column column ) <nl> + { <nl> + column . TriggerKeyUp ( new InputState ( ) , new KeyUpEventArgs <nl> { <nl> - new Color4 ( 187 , 17 , 119 , 255 ) , <nl> - new Color4 ( 96 , 204 , 0 , 255 ) , <nl> - new Color4 ( 17 , 136 , 170 , 255 ) <nl> - } ; <nl> + Key = column . Key <nl> + } ) ; <nl> + } <nl> + } <nl> <nl> - var keys = new Key [ ] { Key . S , Key . D , Key . F , Key . Space , Key . J , Key . K , Key . L } ; <nl> + public class ManiaPlayfield : Container <nl> + { <nl> + public readonly FlowContainer < Column > Columns ; <nl> <nl> - int num_columns = 7 ; <nl> - int half_columns = num_columns / 2 ; <nl> + public ManiaPlayfield ( int columnCount ) <nl> + { <nl> + if ( columnCount > 9 ) <nl> + throw new ArgumentException ( $ @ \" { columnCount } columns is not supported . \" ) ; <nl> + if ( columnCount < = 0 ) <nl> + throw new ArgumentException ( $ @ \" Can ' t have zero or fewer columns . \" ) ; <nl> <nl> - for ( int i = 0 ; i < num_columns ; i + + ) <nl> + RelativeSizeAxes = Axes . Y ; <nl> + AutoSizeAxes = Axes . X ; <nl> + <nl> + Children = new Drawable [ ] <nl> { <nl> - columns . Add ( new Column <nl> + new Box <nl> { <nl> - Key = keys [ i ] <nl> - } ) ; <nl> - } <nl> + RelativeSizeAxes = Axes . Both , <nl> + Colour = Color4 . Black <nl> + } , <nl> + Columns = new FillFlowContainer < Column > <nl> + { <nl> + RelativeSizeAxes = Axes . Y , <nl> + AutoSizeAxes = Axes . X , <nl> + Direction = FillDirection . Horizontal , <nl> + Padding = new MarginPadding { Left = 1 , Right = 1 } , <nl> + Spacing = new Vector2 ( 1 , 0 ) <nl> + } <nl> + } ; <nl> <nl> - for ( int i = 0 ; i < half_columns ; i + + ) <nl> + for ( int i = 0 ; i < columnCount ; i + + ) <nl> + Columns . Add ( new Column ( ) ) ; <nl> + } <nl> + <nl> + [ BackgroundDependencyLoader ] <nl> + private void load ( OsuColour colours ) <nl> + { <nl> + var columnColours = new Color4 [ ] <nl> { <nl> - Color4 accent = colours [ i % 2 ] ; <nl> - columns . Children . ElementAt ( i ) . AccentColour = accent ; <nl> - columns . Children . ElementAt ( num_columns - 1 - i ) . AccentColour = accent ; <nl> + colours . RedDark , <nl> + colours . GreenDark , <nl> + colours . BlueDark / / Special column <nl> + } ; <nl> + <nl> + int columnCount = Columns . Children . Count ( ) ; <nl> + int halfColumns = columnCount / 2 ; <nl> + <nl> + var keys = new Key [ ] { Key . A , Key . S , Key . D , Key . F , Key . Space , Key . J , Key . K , Key . L , Key . Semicolon } ; <nl> + <nl> + for ( int i = 0 ; i < halfColumns ; i + + ) <nl> + { <nl> + Column leftColumn = Columns . Children . ElementAt ( i ) ; <nl> + Column rightColumn = Columns . Children . ElementAt ( columnCount - 1 - i ) ; <nl> + <nl> + Color4 accent = columnColours [ i % 2 ] ; <nl> + leftColumn . AccentColour = rightColumn . AccentColour = accent ; <nl> + leftColumn . Key = keys [ keys . Length / 2 - halfColumns + i ] ; <nl> + rightColumn . Key = keys [ keys . Length / 2 + halfColumns - i ] ; <nl> } <nl> <nl> - bool hasSpecial = half_columns * 2 < num_columns ; <nl> + bool hasSpecial = halfColumns * 2 < columnCount ; <nl> if ( hasSpecial ) <nl> { <nl> - Column specialColumn = columns . Children . ElementAt ( half_columns ) ; <nl> + Column specialColumn = Columns . Children . ElementAt ( halfColumns ) ; <nl> specialColumn . IsSpecialColumn = true ; <nl> - specialColumn . AccentColour = colours [ 2 ] ; <nl> + specialColumn . AccentColour = columnColours [ 2 ] ; <nl> + specialColumn . Key = keys [ keys . Length / 2 ] ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Create ManiaPlayfield , support up to 9 columns , improve testcase automation .\n"}
{"diff_id": 16542, "repo": "ShareX/ShareX\n", "sha": "aad7c0376387ddc35caa186b321af416c29760e1\n", "time": "2016-03-24T19:03:10Z\n", "diff": "mmm a / ShareX . HelpersLib / Helpers / Helpers . cs <nl> ppp b / ShareX . HelpersLib / Helpers / Helpers . cs <nl> public static string GetProperName ( string name ) <nl> return sb . ToString ( ) ; <nl> } <nl> <nl> - public static void OpenFolder ( string folderPath ) <nl> + public static void OpenFile ( string filePath ) <nl> { <nl> - if ( ! string . IsNullOrEmpty ( folderPath ) ) <nl> + if ( ! string . IsNullOrEmpty ( filePath ) & & File . Exists ( filePath ) ) <nl> { <nl> - if ( Directory . Exists ( folderPath ) ) <nl> - { <nl> - Process . Start ( \" explorer . exe \" , folderPath ) ; <nl> - } <nl> - else <nl> + TaskEx . Run ( ( ) = > <nl> { <nl> - MessageBox . Show ( Resources . Helpers_OpenFolder_Folder_not_exist_ + \" \\ r \\ n \" + folderPath , \" ShareX \" , MessageBoxButtons . OK , MessageBoxIcon . Information ) ; <nl> - } <nl> + try <nl> + { <nl> + Process . Start ( filePath ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + DebugHelper . WriteException ( e , $ \" OpenFile ( { filePath } ) failed \" ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + else <nl> + { <nl> + MessageBox . Show ( Resources . Helpers_OpenFile_File_not_exist_ + Environment . NewLine + filePath , \" ShareX \" , MessageBoxButtons . OK , MessageBoxIcon . Information ) ; <nl> + } <nl> + } <nl> + <nl> + public static void OpenFolder ( string folderPath ) <nl> + { <nl> + if ( ! string . IsNullOrEmpty ( folderPath ) & & Directory . Exists ( folderPath ) ) <nl> + { <nl> + Process . Start ( \" explorer . exe \" , folderPath ) ; <nl> + } <nl> + else <nl> + { <nl> + MessageBox . Show ( Resources . Helpers_OpenFolder_Folder_not_exist_ + Environment . NewLine + folderPath , \" ShareX \" , MessageBoxButtons . OK , MessageBoxIcon . Information ) ; <nl> } <nl> } <nl> <nl> public static void OpenFolderWithFile ( string filePath ) <nl> { <nl> if ( ! string . IsNullOrEmpty ( filePath ) & & File . Exists ( filePath ) ) <nl> { <nl> - Process . Start ( \" explorer . exe \" , string . Format ( \" / select , \\ \" { 0 } \\ \" \" , filePath ) ) ; <nl> + Process . Start ( \" explorer . exe \" , $ \" / select , \\ \" { filePath } \\ \" \" ) ; <nl> + } <nl> + else <nl> + { <nl> + MessageBox . Show ( Resources . Helpers_OpenFile_File_not_exist_ + Environment . NewLine + filePath , \" ShareX \" , MessageBoxButtons . OK , MessageBoxIcon . Information ) ; <nl> } <nl> } <nl> <nl> public static bool IsDefaultInstallDir ( ) <nl> return Application . ExecutablePath . StartsWith ( path ) ; <nl> } <nl> <nl> - public static void OpenFile ( string filepath ) <nl> - { <nl> - if ( ! string . IsNullOrEmpty ( filepath ) & & File . Exists ( filepath ) ) <nl> - { <nl> - TaskEx . Run ( ( ) = > <nl> - { <nl> - try <nl> - { <nl> - Process . Start ( filepath ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - DebugHelper . WriteException ( e , string . Format ( \" OpenFile ( { 0 } ) failed \" , filepath ) ) ; <nl> - } <nl> - } ) ; <nl> - } <nl> - } <nl> - <nl> public static bool IsValidIPAddress ( string ip ) <nl> { <nl> if ( string . IsNullOrEmpty ( ip ) ) return false ; <nl>\n", "msg": "Added message box to open file , folder functions to notify user if file or folder is not exist\n"}
{"diff_id": 16961, "repo": "icsharpcode/ILSpy\n", "sha": "bf174236186494e161d7f822f0d7502ccd667232\n", "time": "2018-10-08T11:11:28Z\n", "diff": "mmm a / ICSharpCode . Decompiler / IL / ControlFlow / SwitchAnalysis . cs <nl> ppp b / ICSharpCode . Decompiler / IL / ControlFlow / SwitchAnalysis . cs <nl> bool AnalyzeBlock ( Block block , LongSet inputValues , bool tailOnly = false ) <nl> if ( ! ( tailOnly | | block . Instructions . Count = = 2 ) ) <nl> return false ; <nl> trueValues = trueValues . IntersectWith ( inputValues ) ; <nl> + if ( trueValues . SetEquals ( inputValues ) | | trueValues . IsEmpty ) <nl> + return false ; <nl> Block trueBlock ; <nl> if ( trueInst . MatchBranch ( out trueBlock ) & & AnalyzeBlock ( trueBlock , trueValues ) ) { <nl> / / OK , true block was further analyzed . <nl>\n", "msg": "Abort SwitchAnalysis on duplicate condition ( redundant code )\n"}
{"diff_id": 17126, "repo": "dotnet/runtime\n", "sha": "af182648703229e26e3ade53ef709c1a0d5646a3\n", "time": "2017-03-02T21:04:35Z\n", "diff": "mmm a / src / libraries / System . Linq . Expressions / tests / ListInit / ListInitExpressionTests . cs <nl> ppp b / src / libraries / System . Linq . Expressions / tests / ListInit / ListInitExpressionTests . cs <nl> public static void Add ( string value ) <nl> } <nl> } <nl> <nl> + private class AnyTypeList : IEnumerable < object > <nl> + { <nl> + private readonly List < object > _inner = new List < object > ( ) ; <nl> + <nl> + public void Add < T > ( T item ) = > _inner . Add ( item ) ; <nl> + <nl> + public void AddIntRegardless < T > ( int item ) = > _inner . Add ( item ) ; <nl> + <nl> + public IEnumerator < object > GetEnumerator ( ) = > _inner . GetEnumerator ( ) ; <nl> + <nl> + IEnumerator IEnumerable . GetEnumerator ( ) = > GetEnumerator ( ) ; <nl> + } <nl> + <nl> [ Fact ] <nl> public void NullNewMethod ( ) <nl> { <nl> public void StaticAddMethodOnType ( ) <nl> Assert . Throws < ArgumentException > ( \" addMethod \" , ( ) = > Expression . ElementInit ( adder , Enumerable . Repeat ( Expression . Constant ( \" \" ) , 1 ) ) ) ; <nl> } <nl> <nl> + [ Fact ] <nl> + public void AdderOnWrongType ( ) <nl> + { <nl> + / / This logically includes cases of methods of open generic types , since the NewExpression cannot be of such a type . <nl> + NewExpression newExp = Expression . New ( typeof ( List < int > ) ) ; <nl> + MethodInfo adder = typeof ( HashSet < int > ) . GetMethod ( nameof ( HashSet < int > . Add ) ) ; <nl> + Assert . Throws < ArgumentException > ( null , ( ) = > Expression . ListInit ( newExp , adder , Expression . Constant ( 0 ) ) ) ; <nl> + } <nl> + <nl> + [ Fact ] <nl> + public void OpenGenericAddMethod ( ) <nl> + { <nl> + NewExpression newExp = Expression . New ( typeof ( AnyTypeList ) ) ; <nl> + MethodInfo adder = typeof ( AnyTypeList ) . GetMethod ( nameof ( AnyTypeList . Add ) ) ; <nl> + Assert . Throws < ArgumentException > ( ( ) = > Expression . ListInit ( newExp , adder , Expression . Constant ( 0 ) ) ) ; <nl> + adder = typeof ( AnyTypeList ) . GetMethod ( nameof ( AnyTypeList . Add ) ) . MakeGenericMethod ( typeof ( List < int > ) ) ; <nl> + Assert . Throws < ArgumentException > ( ( ) = > Expression . ListInit ( newExp , adder , Expression . Constant ( 0 ) ) ) ; <nl> + adder = typeof ( AnyTypeList ) . GetMethod ( nameof ( AnyTypeList . AddIntRegardless ) ) ; <nl> + Assert . Throws < ArgumentException > ( \" addMethod \" , ( ) = > Expression . ListInit ( newExp , adder , Expression . Constant ( 0 ) ) ) ; <nl> + adder = typeof ( AnyTypeList ) . GetMethod ( nameof ( AnyTypeList . AddIntRegardless ) ) . MakeGenericMethod ( typeof ( List < > ) ) ; <nl> + Assert . Throws < ArgumentException > ( \" addMethod \" , ( ) = > Expression . ListInit ( newExp , adder , Expression . Constant ( 0 ) ) ) ; <nl> + } <nl> + <nl> + [ Theory , ClassData ( typeof ( CompilationTypes ) ) ] <nl> + public void GenericAddMethod ( bool useInterpreter ) <nl> + { <nl> + NewExpression newExp = Expression . New ( typeof ( AnyTypeList ) ) ; <nl> + MethodInfo adder = typeof ( AnyTypeList ) . GetMethod ( nameof ( AnyTypeList . Add ) ) . MakeGenericMethod ( typeof ( int ) ) ; <nl> + Expression < Func < AnyTypeList > > lambda = <nl> + Expression . Lambda < Func < AnyTypeList > > ( <nl> + Expression . ListInit ( <nl> + newExp , adder , Expression . Constant ( 3 ) , Expression . Constant ( 2 ) , Expression . Constant ( 1 ) ) ) ; <nl> + Func < AnyTypeList > func = lambda . Compile ( useInterpreter ) ; <nl> + Assert . Equal ( new object [ ] { 3 , 2 , 1 } , func ( ) ) ; <nl> + } <nl> + <nl> [ Fact ] <nl> public void InitializersWrappedExactly ( ) <nl> { <nl>\n", "msg": "Add tests of ListInit validation against generic methods .\n"}
{"diff_id": 17161, "repo": "mono/mono\n", "sha": "a4208b4290a89c01726f86415b1a13b7e58d2093\n", "time": "2011-08-05T15:44:50Z\n", "diff": "mmm a / mcs / class / Mono . Data . Tds / Mono . Data . Tds . Protocol / TdsComm . cs <nl> ppp b / mcs / class / Mono . Data . Tds / Mono . Data . Tds . Protocol / TdsComm . cs <nl> internal sealed class TdsComm <nl> byte [ ] outBuffer ; <nl> int outBufferLength ; <nl> int nextOutBufferIndex = 0 ; <nl> + bool lsb ; <nl> <nl> byte [ ] inBuffer ; <nl> int inBufferLength ; <nl> internal sealed class TdsComm <nl> byte [ ] tmpBuf = new byte [ 8 ] ; <nl> byte [ ] resBuffer = new byte [ 256 ] ; <nl> <nl> - int packetsSent = 0 ; <nl> + int packetsSent ; <nl> int packetsReceived = 0 ; <nl> <nl> Socket socket ; <nl> public TdsComm ( string dataSource , int port , int packetSize , int timeout , TdsVer <nl> outBufferLength = packetSize ; <nl> inBufferLength = packetSize ; <nl> <nl> + lsb = true ; <nl> + <nl> IPEndPoint endPoint ; <nl> bool have_exception = false ; <nl> <nl> public TdsComm ( string dataSource , int port , int packetSize , int timeout , TdsVer <nl> } <nl> if ( ! socket . Connected ) <nl> throw new TdsInternalException ( \" Server does not exist or connection refused . \" , null ) ; <nl> + packetsSent = 1 ; <nl> } <nl> <nl> # endregion / / Constructors <nl> public TdsComm ( string dataSource , int port , int packetSize , int timeout , TdsVer <nl> set { packetSize = value ; } <nl> } <nl> <nl> + public bool TdsByteOrder { <nl> + get { return ! lsb ; } <nl> + set { lsb = ! value ; } <nl> + } <nl> # endregion / / Properties <nl> <nl> # region Methods <nl> public void SendIfFull ( ) <nl> } <nl> } <nl> <nl> + public void SendIfFull ( int reserve ) <nl> + { <nl> + if ( nextOutBufferIndex + reserve > outBufferLength ) { <nl> + SendPhysicalPacket ( false ) ; <nl> + nextOutBufferIndex = headerLength ; <nl> + } <nl> + } <nl> <nl> public void Append ( object o ) <nl> { <nl> public void Append ( object o ) <nl> Append ( ( byte ) 0 ) ; <nl> return ; <nl> } <nl> + <nl> switch ( Type . GetTypeCode ( o . GetType ( ) ) ) { <nl> case TypeCode . Byte : <nl> Append ( ( byte ) o ) ; <nl> public void Append ( DateTime t , int bytes ) <nl> } <nl> } <nl> <nl> - <nl> public void Append ( byte [ ] b ) <nl> { <nl> Append ( b , b . Length , ( byte ) 0 ) ; <nl> public void Append ( byte [ ] b , int len , byte pad ) <nl> } <nl> } <nl> <nl> + private void AppendInternal ( short s ) <nl> + { <nl> + if ( ! lsb ) { <nl> + outBuffer [ nextOutBufferIndex + + ] = ( byte ) ( ( ( byte ) ( s > > 8 ) ) & 0xff ) ; <nl> + outBuffer [ nextOutBufferIndex + + ] = ( byte ) ( ( byte ) ( s & 0xff ) ) ; <nl> + } else { <nl> + outBuffer [ nextOutBufferIndex + + ] = ( byte ) ( ( byte ) ( s & 0xff ) ) ; <nl> + outBuffer [ nextOutBufferIndex + + ] = ( byte ) ( ( ( byte ) ( s > > 8 ) ) & 0xff ) ; <nl> + } <nl> + } <nl> + <nl> public void Append ( short s ) <nl> { <nl> - if ( ! BitConverter . IsLittleEndian ) <nl> - Append ( Swap ( BitConverter . GetBytes ( s ) ) , sizeof ( short ) , ( byte ) 0 ) ; <nl> - else <nl> - Append ( BitConverter . GetBytes ( s ) , sizeof ( short ) , ( byte ) 0 ) ; <nl> + SendIfFull ( sizeof ( short ) ) ; <nl> + AppendInternal ( s ) ; <nl> } <nl> <nl> public void Append ( ushort s ) <nl> { <nl> - if ( ! BitConverter . IsLittleEndian ) <nl> - Append ( Swap ( BitConverter . GetBytes ( s ) ) , sizeof ( short ) , ( byte ) 0 ) ; <nl> - else <nl> - Append ( BitConverter . GetBytes ( s ) , sizeof ( short ) , ( byte ) 0 ) ; <nl> + SendIfFull ( sizeof ( short ) ) ; <nl> + AppendInternal ( ( short ) s ) ; <nl> + } <nl> + <nl> + private void AppendInternal ( int i ) <nl> + { <nl> + if ( ! lsb ) { <nl> + AppendInternal ( ( short ) ( ( ( short ) ( i > > 16 ) ) & 0xffff ) ) ; <nl> + AppendInternal ( ( short ) ( ( short ) ( i & 0xffff ) ) ) ; <nl> + } else { <nl> + AppendInternal ( ( short ) ( ( short ) ( i & 0xffff ) ) ) ; <nl> + AppendInternal ( ( short ) ( ( ( short ) ( i > > 16 ) ) & 0xffff ) ) ; <nl> + } <nl> } <nl> <nl> public void Append ( int i ) <nl> { <nl> - if ( ! BitConverter . IsLittleEndian ) <nl> - Append ( Swap ( BitConverter . GetBytes ( i ) ) , sizeof ( int ) , ( byte ) 0 ) ; <nl> - else <nl> - Append ( BitConverter . GetBytes ( i ) , sizeof ( int ) , ( byte ) 0 ) ; <nl> + SendIfFull ( sizeof ( int ) ) ; <nl> + AppendInternal ( i ) ; <nl> } <nl> <nl> public void Append ( string s ) <nl> { <nl> - if ( tdsVersion < TdsVersion . tds70 ) <nl> + if ( tdsVersion < TdsVersion . tds70 ) { <nl> Append ( encoder . GetBytes ( s ) ) ; <nl> - else <nl> - foreach ( char c in s ) <nl> - if ( ! BitConverter . IsLittleEndian ) <nl> - Append ( Swap ( BitConverter . GetBytes ( c ) ) ) ; <nl> - else <nl> - Append ( BitConverter . GetBytes ( c ) ) ; <nl> + } else { <nl> + int cindex = 0 , index ; <nl> + int ssize = sizeof ( short ) ; <nl> + int lenToWrite = s . Length * ssize ; <nl> + / / if nextOutBufferLength points to the last buffer in outBuffer , <nl> + / / we would get a DivisionByZero while calculating remBufLen <nl> + if ( outBufferLength - nextOutBufferIndex < ssize ) <nl> + SendIfFull ( ssize ) ; <nl> + <nl> + int remBufLen = outBufferLength - nextOutBufferIndex ; <nl> + int count = lenToWrite / remBufLen ; <nl> + <nl> + if ( lenToWrite % remBufLen > 0 ) <nl> + count + + ; <nl> + <nl> + for ( int i = 0 ; i < count ; i + + ) { <nl> + index = System . Math . Min ( remBufLen / ssize , lenToWrite / ssize ) ; <nl> + for ( int j = 0 ; j < index * ssize ; j + = 2 , cindex + + ) <nl> + AppendInternal ( ( short ) s [ cindex ] ) ; <nl> + <nl> + lenToWrite - = index * ssize ; <nl> + / / Just make sure to flush the buffer <nl> + SendIfFull ( ( lenToWrite + 1 ) * ssize ) ; <nl> + } <nl> + } <nl> } <nl> <nl> / / Appends with padding <nl> public byte [ ] Append ( string s , int len , byte pad ) <nl> <nl> public void Append ( double value ) <nl> { <nl> - if ( ! BitConverter . IsLittleEndian ) <nl> + if ( ! lsb ) <nl> Append ( Swap ( BitConverter . GetBytes ( value ) ) , sizeof ( double ) , ( byte ) 0 ) ; <nl> else <nl> Append ( BitConverter . GetBytes ( value ) , sizeof ( double ) , ( byte ) 0 ) ; <nl> public void Append ( double value ) <nl> <nl> public void Append ( float value ) <nl> { <nl> - if ( ! BitConverter . IsLittleEndian ) <nl> + if ( ! lsb ) <nl> Append ( Swap ( BitConverter . GetBytes ( value ) ) , sizeof ( float ) , ( byte ) 0 ) ; <nl> else <nl> Append ( BitConverter . GetBytes ( value ) , sizeof ( float ) , ( byte ) 0 ) ; <nl> public void Append ( float value ) <nl> <nl> public void Append ( long l ) <nl> { <nl> - if ( ! BitConverter . IsLittleEndian ) <nl> - Append ( Swap ( BitConverter . GetBytes ( l ) ) , sizeof ( long ) , ( byte ) 0 ) ; <nl> - else <nl> - Append ( BitConverter . GetBytes ( l ) , sizeof ( long ) , ( byte ) 0 ) ; <nl> + SendIfFull ( sizeof ( long ) ) ; <nl> + if ( ! lsb ) { <nl> + AppendInternal ( ( int ) ( ( ( int ) ( l > > 32 ) ) & 0xffffffff ) ) ; <nl> + AppendInternal ( ( int ) ( ( int ) ( l & 0xffffffff ) ) ) ; <nl> + } else { <nl> + AppendInternal ( ( int ) ( ( int ) ( l & 0xffffffff ) ) ) ; <nl> + AppendInternal ( ( int ) ( ( ( int ) ( l > > 32 ) ) & 0xffffffff ) ) ; <nl> + } <nl> } <nl> <nl> public void Append ( decimal d , int bytes ) <nl> { <nl> int [ ] arr = Decimal . GetBits ( d ) ; <nl> byte sign = ( d > 0 ? ( byte ) 1 : ( byte ) 0 ) ; <nl> + SendIfFull ( bytes ) ; <nl> Append ( sign ) ; <nl> - Append ( arr [ 0 ] ) ; <nl> - Append ( arr [ 1 ] ) ; <nl> - Append ( arr [ 2 ] ) ; <nl> - Append ( ( int ) 0 ) ; <nl> + AppendInternal ( arr [ 0 ] ) ; <nl> + AppendInternal ( arr [ 1 ] ) ; <nl> + AppendInternal ( arr [ 2 ] ) ; <nl> + AppendInternal ( ( int ) 0 ) ; <nl> } <nl> <nl> public void Close ( ) <nl> public void SendPacket ( ) <nl> / / Reset connection - reset flag to false - as any exception would anyway close <nl> / / the whole connection <nl> connReset = false ; <nl> + packetsSent = 1 ; <nl> } <nl> <nl> private void SendPhysicalPacket ( bool isLastSegment ) <nl> private void SendPhysicalPacket ( bool isLastSegment ) <nl> Store ( 2 , ( short ) nextOutBufferIndex ) ; <nl> Store ( 4 , ( byte ) 0 ) ; <nl> Store ( 5 , ( byte ) 0 ) ; <nl> - Store ( 6 , ( byte ) ( tdsVersion = = TdsVersion . tds70 ? 0x1 : 0x0 ) ) ; <nl> + if ( tdsVersion > = TdsVersion . tds70 ) <nl> + Store ( 6 , ( byte ) packetsSent ) ; <nl> + else <nl> + Store ( 6 , ( byte ) 0 ) ; <nl> Store ( 7 , ( byte ) 0 ) ; <nl> <nl> stream . Write ( outBuffer , 0 , nextOutBufferIndex ) ; <nl>\n", "msg": "Revert \" revert change from https : / / github . com / flutos / mono / commit / 124c0ce55f13ca67cf8f7641a9bb3b034ac7dd5e # mcs / class / Mono . Data . Tds / Mono . Data . Tds . Protocol since it makes the sqlserver calls unstable \"\n"}
{"diff_id": 17339, "repo": "dotnet/roslyn\n", "sha": "1cc00037f60b401354cdadc1b183182a2d2ad6c7\n", "time": "2014-06-06T01:33:42Z\n", "diff": "mmm a / Src / Compilers / Core / Source / Serialization / ConcurrentRecordingObjectBinder . cs <nl> ppp b / Src / Compilers / Core / Source / Serialization / ConcurrentRecordingObjectBinder . cs <nl> public override void Record ( object instance ) <nl> { <nl> if ( HasConstructor ( type ) ) <nl> { <nl> - Debug . Assert ( this . typeMap . ContainsKey ( new TypeKey ( type . GetTypeInfo ( ) . Assembly . FullName , type . FullName ) ) ) ; <nl> return ; <nl> } <nl> <nl>\n", "msg": "removed assert since there is a chance where entry in the typemap might not be there yet in concurrent case\n"}
{"diff_id": 17340, "repo": "MonoGame/MonoGame\n", "sha": "9f7fd21ce8877e35c79ffc33dd204e2cc42aed15\n", "time": "2012-12-29T16:29:30Z\n", "diff": "mmm a / MonoGame . Framework / iOS / Media / VideoPlayer . cs <nl> ppp b / MonoGame . Framework / iOS / Media / VideoPlayer . cs <nl> <nl> / / # endregion License <nl> <nl> using System ; <nl> - using Microsoft . Xna . Framework . Content ; <nl> using Microsoft . Xna . Framework . Graphics ; <nl> using MonoTouch . MediaPlayer ; <nl> using MonoTouch . Foundation ; <nl> namespace Microsoft . Xna . Framework . Media <nl> { <nl> public sealed class VideoPlayer <nl> { <nl> - private Game _game ; <nl> + private Video _video ; <nl> + private MediaState _state ; <nl> + private bool _isLooped ; <nl> + private Game _game ; <nl> private iOSGamePlatform _platform ; <nl> - private MediaState _state ; <nl> - private ContentManager contentManager ; <nl> - <nl> - public bool IsLooped { get ; private set ; } <nl> - <nl> - public MediaState State <nl> - { <nl> - get { return _state ; } <nl> - private set <nl> - { <nl> - if ( _state ! = value ) <nl> - { <nl> - _state = value ; <nl> - if ( this . StateChanged ! = null ) <nl> - StateChanged ( this , EventArgs . Empty ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - public Video Video { get ; private set ; } <nl> - <nl> - public event EventHandler < EventArgs > StateChanged ; <nl> <nl> public VideoPlayer ( ) <nl> { <nl> public void Pause ( ) <nl> throw new NotImplementedException ( ) ; <nl> } <nl> <nl> + public MediaState State <nl> + { <nl> + get <nl> + { <nl> + return _state ; <nl> + } <nl> + } <nl> <nl> private NSObject _playbackDidFinishObserver ; <nl> private void PlayVideo ( ) <nl> private void PlayVideo ( ) <nl> _playbackDidFinishObserver = NSNotificationCenter . DefaultCenter . AddObserver ( <nl> MPMoviePlayerController . PlaybackDidFinishNotification , OnStop ) ; <nl> <nl> - Video . MovieView . MoviePlayer . RepeatMode = IsLooped ? MPMovieRepeatMode . One : MPMovieRepeatMode . None ; <nl> + _video . MovieView . MoviePlayer . RepeatMode = _isLooped ? MPMovieRepeatMode . One : MPMovieRepeatMode . None ; <nl> <nl> - _platform . ViewController . PresentModalViewController ( Video . MovieView , animated : false ) ; <nl> - Video . MovieView . MoviePlayer . Play ( ) ; <nl> + _platform . ViewController . PresentModalViewController ( _video . MovieView , animated : false ) ; <nl> + _video . MovieView . MoviePlayer . Play ( ) ; <nl> } <nl> <nl> - public void Play ( Video video ) <nl> + public void Play ( Microsoft . Xna . Framework . Media . Video video ) <nl> { <nl> - Video = video ; <nl> + _video = video ; <nl> PlayVideo ( ) ; <nl> } <nl> - <nl> - public void Play ( string path ) <nl> - { <nl> - this . contentManager = new ContentManager ( _game . Services ) ; <nl> - this . Play ( contentManager . Load < Video > ( path ) ) ; <nl> - this . StateChanged + = UnloadVideo ; <nl> - } <nl> <nl> private void OnStop ( NSNotification e ) <nl> { <nl> public void Stop ( ) <nl> _playbackDidFinishObserver = null ; <nl> } <nl> <nl> - Video . MovieView . MoviePlayer . Stop ( ) ; <nl> + _video . MovieView . MoviePlayer . Stop ( ) ; <nl> _state = MediaState . Stopped ; <nl> _platform . IsPlayingVideo = false ; <nl> _platform . ViewController . DismissModalViewControllerAnimated ( false ) ; <nl> } <nl> <nl> - private void UnloadVideo ( object sender , EventArgs args ) <nl> + public bool IsLooped <nl> + { <nl> + get <nl> + { <nl> + return _isLooped ; <nl> + } <nl> + set <nl> + { <nl> + _isLooped = value ; <nl> + } <nl> + } <nl> + <nl> + public Microsoft . Xna . Framework . Media . Video Video <nl> { <nl> - if ( this . State = = MediaState . Stopped ) <nl> + get <nl> { <nl> - this . contentManager . Dispose ( ) ; <nl> - this . contentManager = null ; <nl> + return _video ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Reverting to original iOS video player as it was not used anymore\n"}
{"diff_id": 17461, "repo": "dotnet/roslyn\n", "sha": "e5c4f7f610ffe079f8e1c2d48476c3372cda5799\n", "time": "2018-03-20T20:51:19Z\n", "diff": "mmm a / src / EditorFeatures / Core / Implementation / ForegroundNotification / ForegroundNotificationService . cs <nl> ppp b / src / EditorFeatures / Core / Implementation / ForegroundNotification / ForegroundNotificationService . cs <nl> public void RegisterNotification ( Func < bool > action , int delay , IAsyncToken async <nl> _workQueue . Enqueue ( new PendingWork ( current + delay , action , asyncToken , cancellationToken ) ) ; <nl> } <nl> <nl> + internal void ReleaseCancelledItems ( ) = > _workQueue . ReleaseCancelledItems ( ) ; <nl> + <nl> public bool IsEmpty_TestOnly = > _workQueue . IsEmpty ; <nl> <nl> private async Task ProcessAsync ( ) <nl> private PendingWork Dequeue_NoLock ( ) <nl> <nl> return work ; <nl> } <nl> + <nl> + internal void ReleaseCancelledItems ( ) <nl> + { <nl> + var removedItems = new LinkedList < PendingWork > ( ) ; <nl> + <nl> + lock ( _gate ) <nl> + { <nl> + for ( LinkedListNode < PendingWork > current = _list . First , next = current ? . Next ; <nl> + current ! = null ; <nl> + current = next , next = current ? . Next ) <nl> + { <nl> + if ( current . Value . CancellationToken . IsCancellationRequested ) <nl> + { <nl> + _list . Remove ( current ) ; <nl> + removedItems . AddLast ( current ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / / Dispose of the async tokens outside the lock <nl> + foreach ( var pendingWork in removedItems ) <nl> + { <nl> + pendingWork . AsyncToken ? . Dispose ( ) ; <nl> + } <nl> + } <nl> } <nl> } <nl> } <nl>\n", "msg": "Add ForegroundNotificationService . ReleaseCancelledItems to immediately clear cancelled operations\n"}
{"diff_id": 18093, "repo": "dotnet/aspnetcore\n", "sha": "744c9c47b45ae5160f59adcffb7efb7d235e2d37\n", "time": "2015-04-09T18:01:40Z\n", "diff": "mmm a / src / Microsoft . AspNet . Razor . Runtime / TagHelpers / DefaultTagHelperContent . cs <nl> ppp b / src / Microsoft . AspNet . Razor . Runtime / TagHelpers / DefaultTagHelperContent . cs <nl> public override TagHelperContent Append ( string value ) <nl> } <nl> <nl> / / / < inheritdoc / > <nl> - public override TagHelperContent AppendFormat ( string format , object arg0 ) <nl> + public override TagHelperContent AppendFormat ( [ NotNull ] string format , object arg0 ) <nl> { <nl> _buffer . Add ( string . Format ( format , arg0 ) ) ; <nl> return this ; <nl> } <nl> <nl> / / / < inheritdoc / > <nl> - public override TagHelperContent AppendFormat ( string format , object arg0 , object arg1 ) <nl> + public override TagHelperContent AppendFormat ( [ NotNull ] string format , object arg0 , object arg1 ) <nl> { <nl> _buffer . Add ( string . Format ( format , arg0 , arg1 ) ) ; <nl> return this ; <nl> } <nl> <nl> / / / < inheritdoc / > <nl> - public override TagHelperContent AppendFormat ( string format , object arg0 , object arg1 , object arg2 ) <nl> + public override TagHelperContent AppendFormat ( [ NotNull ] string format , object arg0 , object arg1 , object arg2 ) <nl> { <nl> _buffer . Add ( string . Format ( format , arg0 , arg1 , arg2 ) ) ; <nl> return this ; <nl> public override TagHelperContent AppendFormat ( [ NotNull ] string format , params ob <nl> } <nl> <nl> / / / < inheritdoc / > <nl> - public override TagHelperContent AppendFormat ( IFormatProvider provider , string format , object arg0 ) <nl> + public override TagHelperContent AppendFormat ( <nl> + [ NotNull ] IFormatProvider provider , <nl> + [ NotNull ] string format , <nl> + object arg0 ) <nl> { <nl> _buffer . Add ( string . Format ( provider , format , arg0 ) ) ; <nl> return this ; <nl> public override TagHelperContent AppendFormat ( IFormatProvider provider , string f <nl> <nl> / / / < inheritdoc / > <nl> public override TagHelperContent AppendFormat ( <nl> - IFormatProvider provider , <nl> - string format , <nl> + [ NotNull ] IFormatProvider provider , <nl> + [ NotNull ] string format , <nl> object arg0 , <nl> object arg1 ) <nl> { <nl> public override TagHelperContent AppendFormat ( IFormatProvider provider , string f <nl> <nl> / / / < inheritdoc / > <nl> public override TagHelperContent AppendFormat ( <nl> - IFormatProvider provider , <nl> - string format , <nl> + [ NotNull ] IFormatProvider provider , <nl> + [ NotNull ] string format , <nl> object arg0 , <nl> object arg1 , <nl> object arg2 ) <nl> public override TagHelperContent AppendFormat ( IFormatProvider provider , string f <nl> <nl> / / / < inheritdoc / > <nl> public override TagHelperContent AppendFormat ( <nl> - [ NotNull ] IFormatProvider provider , [ NotNull ] string format , params object [ ] args ) <nl> + [ NotNull ] IFormatProvider provider , <nl> + [ NotNull ] string format , <nl> + params object [ ] args ) <nl> { <nl> _buffer . Add ( string . Format ( provider , format , args ) ) ; <nl> return this ; <nl>\n", "msg": "Adding NotNulls for format and format provider in DefaultTagHelperContent . AppendFormat .\n"}
{"diff_id": 18370, "repo": "duplicati/duplicati\n", "sha": "39ddebcdf5824cd711943544af7a04dd41bc3213\n", "time": "2018-06-30T17:11:42Z\n", "diff": "mmm a / Duplicati / Library / Snapshots / WindowsSnapshot . cs <nl> ppp b / Duplicati / Library / Snapshots / WindowsSnapshot . cs <nl> public WindowsSnapshot ( IEnumerable < string > sources , IDictionary < string , string > <nl> if ( vss = = null ) <nl> throw new InvalidOperationException ( ) ; <nl> <nl> - var excludedWriters = new Guid [ 0 ] ; <nl> + / / Default to exclude the System State writer <nl> + var excludedWriters = new Guid [ ] { new Guid ( \" { e8132975 - 6f93 - 4464 - a53e - 1050253ae220 } \" ) } ; <nl> if ( options . ContainsKey ( \" vss - exclude - writers \" ) ) <nl> { <nl> - excludedWriters = options [ \" vss - exclude - writers \" ] . Split ( ' ; ' ) . Where ( x = > ! string . IsNullOrWhiteSpace ( x ) & & x . Trim ( ) . Length > 0 ) . Select ( x = > new Guid ( x ) ) . ToArray ( ) ; <nl> + excludedWriters = options [ \" vss - exclude - writers \" ] <nl> + . Split ( ' ; ' ) <nl> + . Where ( x = > ! string . IsNullOrWhiteSpace ( x ) & & x . Trim ( ) . Length > 0 ) <nl> + . Select ( x = > new Guid ( x ) ) <nl> + . ToArray ( ) ; <nl> } <nl> <nl> / / Check if we should map any drives <nl>\n", "msg": "Added a default to exclude the System State VSS writer .\n"}
{"diff_id": 18378, "repo": "duplicati/duplicati\n", "sha": "dbea6a268078375a3266e9fc66e8ac3a922fac66\n", "time": "2013-03-08T22:44:03Z\n", "diff": "mmm a / Duplicati / Library / Backend / S3 / S3Backend . cs <nl> ppp b / Duplicati / Library / Backend / S3 / S3Backend . cs <nl> public class S3 : IBackend_v2 , IStreamingBackend , IBackendGUI <nl> new KeyValuePair < string , string > ( \" Asia Pacific ( Tokyo ) \" , \" ap - northeast - 1 \" ) , <nl> new KeyValuePair < string , string > ( \" South America ( Sao Paulo ) \" , \" sa - east - 1 \" ) , <nl> } ; <nl> + <nl> + public static readonly KeyValuePair < string , string > [ ] DEFAULT_S3_LOCATION_BASED_HOSTS = new KeyValuePair < string , string > [ ] { <nl> + new KeyValuePair < string , string > ( \" EU \" , \" s3 - eu - west - 1 . amazonaws . com \" ) , <nl> + new KeyValuePair < string , string > ( \" eu - west - 1 \" , \" s3 - eu - west - 1 . amazonaws . com \" ) , <nl> + new KeyValuePair < string , string > ( \" us - east - 1 \" , \" s3 . amazonaws . com \" ) , <nl> + new KeyValuePair < string , string > ( \" us - west - 1 \" , \" s3 - us - west - 1 . amazonaws . com \" ) , <nl> + new KeyValuePair < string , string > ( \" us - west - 2 \" , \" s3 - us - west - 2 . amazonaws . com \" ) , <nl> + new KeyValuePair < string , string > ( \" ap - southeast - 1 \" , \" s3 - ap - southeast - 1 . amazonaws . com \" ) , <nl> + new KeyValuePair < string , string > ( \" ap - southeast - 2 \" , \" s3 - ap - southeast - 2 . amazonaws . com \" ) , <nl> + new KeyValuePair < string , string > ( \" ap - northeast - 1 \" , \" s3 - ap - northeast - 1 . amazonaws . com \" ) , <nl> + new KeyValuePair < string , string > ( \" sa - east - 1 \" , \" s3 - sa - east - 1 . amazonaws . com \" ) , <nl> + <nl> + } ; <nl> + <nl> private string m_bucket ; <nl> private string m_prefix ; <nl> <nl> public S3 ( string url , Dictionary < string , string > options ) <nl> if ( options . ContainsKey ( \" aws_secret_access_key \" ) ) <nl> awsKey = options [ \" aws_secret_access_key \" ] ; <nl> <nl> - string s3host ; <nl> - options . TryGetValue ( SERVER_NAME , out s3host ) ; <nl> - if ( string . IsNullOrEmpty ( s3host ) ) <nl> - s3host = DEFAULT_S3_HOST ; <nl> - <nl> bool euBuckets = Utility . Utility . ParseBoolOption ( options , EU_BUCKETS_OPTION ) ; <nl> bool useRRS = Utility . Utility . ParseBoolOption ( options , RRS_OPTION ) ; <nl> bool useSSL = Utility . Utility . ParseBoolOption ( options , SSL_OPTION ) ; <nl> public S3 ( string url , Dictionary < string , string > options ) <nl> if ( euBuckets ) <nl> locationConstraint = S3_EU_REGION_NAME ; <nl> <nl> + string s3host ; <nl> + options . TryGetValue ( SERVER_NAME , out s3host ) ; <nl> + if ( string . IsNullOrEmpty ( s3host ) ) <nl> + { <nl> + s3host = DEFAULT_S3_HOST ; <nl> + <nl> + / / Change in S3 , now requires that you use location specific endpoint <nl> + if ( ! string . IsNullOrEmpty ( locationConstraint ) ) <nl> + foreach ( KeyValuePair < string , string > kvp in DEFAULT_S3_LOCATION_BASED_HOSTS ) <nl> + if ( kvp . Key . Equals ( locationConstraint , StringComparison . InvariantCultureIgnoreCase ) ) <nl> + { <nl> + s3host = kvp . Value ; <nl> + break ; <nl> + } <nl> + } <nl> + <nl> / / Fallback to previous formats <nl> if ( host . Contains ( DEFAULT_S3_HOST ) ) <nl> { <nl>\n", "msg": "Updated S3 backend to use location specific endpoints by default\n"}
{"diff_id": 18514, "repo": "PowerShell/PowerShell\n", "sha": "4656f3c07267f5df3c19cecfbed02336a1bd636f\n", "time": "2016-08-10T20:53:37Z\n", "diff": "mmm a / src / System . Management . Automation / DscSupport / CimDSCParser . cs <nl> ppp b / src / System . Management . Automation / DscSupport / CimDSCParser . cs <nl> public static void Initialize ( Collection < Exception > errors , List < string > moduleP <nl> var dscConfigurationDirectory = Environment . GetEnvironmentVariable ( \" DSC_HOME \" ) ? ? <nl> \" / etc / opt / omi / conf / dsc / configuration \" ; <nl> <nl> - Debug . Assert ( Directory . Exists ( dscConfigurationDirectory ) , dscConfigurationDirectory + \" does not exist . \" ) ; <nl> + if ( ! Directory . Exists ( dscConfigurationDirectory ) ) <nl> + { <nl> + throw new DirectoryNotFoundException ( \" Unable to find DSC schema store at \" + dscConfigurationDirectory + \" . Please ensure PS DSC for Linux is installed . \" ) ; <nl> + } <nl> <nl> var resourceBaseFile = Path . Combine ( dscConfigurationDirectory , \" baseregistration / baseresource . schema . mof \" ) ; <nl> ImportClasses ( resourceBaseFile , s_defaultModuleInfoForResource , errors ) ; <nl>\n", "msg": "Adding error message letting the user know they need to install PSDSC for Linux\n"}
{"diff_id": 18609, "repo": "dotnet/runtime\n", "sha": "11dea4f52d40d8db03dcb5923327de40cdf600a4\n", "time": "2017-07-21T14:28:50Z\n", "diff": "mmm a / src / libraries / System . Net . Http / tests / FunctionalTests / ManagedHandlerTest . cs <nl> ppp b / src / libraries / System . Net . Http / tests / FunctionalTests / ManagedHandlerTest . cs <nl> public new void Dispose ( ) <nl> } <nl> } <nl> <nl> - public sealed class ManagedHandler_HttpClientHandler_DefaultProxyCredentials_Test : HttpClientHandler_DefaultProxyCredentials_Test , IDisposable <nl> - { <nl> - public ManagedHandler_HttpClientHandler_DefaultProxyCredentials_Test ( ) = > ManagedHandlerTestHelpers . SetEnvVar ( ) ; <nl> - public new void Dispose ( ) <nl> - { <nl> - ManagedHandlerTestHelpers . RemoveEnvVar ( ) ; <nl> - base . Dispose ( ) ; <nl> - } <nl> - } <nl> + / / TODO # 21452 : Tests started hanging with updated connection pooling . Needs to be investigated . <nl> + / / public sealed class ManagedHandler_HttpClientHandler_DefaultProxyCredentials_Test : HttpClientHandler_DefaultProxyCredentials_Test , IDisposable <nl> + / / { <nl> + / / public ManagedHandler_HttpClientHandler_DefaultProxyCredentials_Test ( ) = > ManagedHandlerTestHelpers . SetEnvVar ( ) ; <nl> + / / public new void Dispose ( ) <nl> + / / { <nl> + / / ManagedHandlerTestHelpers . RemoveEnvVar ( ) ; <nl> + / / base . Dispose ( ) ; <nl> + / / } <nl> + / / } <nl> <nl> public sealed class ManagedHandler_HttpClientHandler_MaxConnectionsPerServer_Test : HttpClientHandler_MaxConnectionsPerServer_Test , IDisposable <nl> { <nl>\n", "msg": "Disable default proxy credentials tests for managed handler ( dotnet / corefx )\n"}
{"diff_id": 19067, "repo": "gitextensions/gitextensions\n", "sha": "89b681e78222067c6f54e4ee2fe2f57cede82796\n", "time": "2013-04-02T13:16:51Z\n", "diff": "mmm a / GitUI / UserControls / RevisionGrid . Designer . cs <nl> ppp b / GitUI / UserControls / RevisionGrid . Designer . cs <nl> private void InitializeComponent ( ) <nl> / / copyToClipboardToolStripMenuItem <nl> / / <nl> this . copyToClipboardToolStripMenuItem . DropDownItems . AddRange ( new System . Windows . Forms . ToolStripItem [ ] { <nl> + this . hashToolStripMenuItem , <nl> this . messageToolStripMenuItem , <nl> this . authorToolStripMenuItem , <nl> this . dateToolStripMenuItem , <nl> - this . hashToolStripMenuItem , <nl> this . toolStripSeparator6 , <nl> this . branchNameToolStripMenuItem , <nl> this . tagToolStripMenuItem } ) ; <nl>\n", "msg": "revision grid context menu : copy to clipboard : move \" Commit hash \" to top\n"}
{"diff_id": 19102, "repo": "nopSolutions/nopCommerce\n", "sha": "be3a286ba005d93aadfc497b45790f82d8e8c21a\n", "time": "2020-09-24T10:19:57Z\n", "diff": "mmm a / src / Libraries / Nop . Services / Catalog / ProductService . cs <nl> ppp b / src / Libraries / Nop . Services / Catalog / ProductService . cs <nl> public virtual IList < TierPrice > GetTierPrices ( Product product , Customer customer <nl> return GetTierPricesByProduct ( product . Id ) <nl> . OrderBy ( price = > price . Quantity ) <nl> . FilterByStore ( storeId ) <nl> - . FilterByCustomerRole ( _catalogSettings . IgnoreAcl ? Array . Empty < int > ( ) : _customerService . GetCustomerRoleIds ( customer ) ) <nl> + . FilterByCustomerRole ( _customerService . GetCustomerRoleIds ( customer ) ) <nl> . FilterByDate ( ) <nl> . RemoveDuplicatedQuantities ( ) <nl> . ToList ( ) ; <nl>\n", "msg": ", Fixed problem on filtering by customer roles in tier prices\n"}
{"diff_id": 19369, "repo": "dotnet/roslyn\n", "sha": "6a48272e234de3792984310833416c51c1b71920\n", "time": "2018-03-09T23:21:36Z\n", "diff": "mmm a / src / VisualStudio / Core / Def / Implementation / CodeModel / ICodeModelInstanceFactory . cs <nl> ppp b / src / VisualStudio / Core / Def / Implementation / CodeModel / ICodeModelInstanceFactory . cs <nl> interface ICodeModelInstanceFactory <nl> / / / < remarks > <nl> / / / This is sometimes necessary because it ' s possible to go from one < see cref = \" EnvDTE . FileCodeModel \" / > to another , <nl> / / / but the language service can ' t create that instance directly , as it doesn ' t know what the < see cref = \" EnvDTE . FileCodeModel . Parent \" / > <nl> - / / / member should be . The expectation is the implementer of this will do what is necessary and call back into the code model implementation <nl> - / / / with a parent object . < / remarks > <nl> + / / / member should be . The expectation is the implementer of this will do what is necessary and call back into < see cref = \" IProjectCodeModel . GetOrCreateFileCodeModel ( string , object ) \" / > <nl> + / / / handing it the appropriate parent . < / remarks > <nl> EnvDTE . FileCodeModel TryCreateFileCodeModelThroughProjectSystem ( string filePath ) ; <nl> } <nl> } <nl>\n", "msg": "Update documentation now that we can point to a concrete method\n"}
{"diff_id": 19565, "repo": "SignalR/SignalR\n", "sha": "e8fbb3577e3920e0bcb614003dd117e1b933af83\n", "time": "2011-07-28T22:49:46Z\n", "diff": "mmm a / SignalR / Hubs / DefaultJavaScriptProxyGenerator . cs <nl> ppp b / SignalR / Hubs / DefaultJavaScriptProxyGenerator . cs <nl> public class DefaultJavaScriptProxyGenerator : IJavaScriptProxyGenerator { <nl> <nl> private void GenerateType ( string serviceUrl , StringBuilder sb , Type type ) { <nl> / / Get public instance methods declared on this type only <nl> - var methods = type . GetMethods ( BindingFlags . Public | BindingFlags . Instance | BindingFlags . DeclaredOnly ) ; <nl> + var methods = GetMethods ( type ) ; <nl> var members = methods . Select ( m = > m . Name ) . ToList ( ) ; <nl> members . Add ( \" namespace \" ) ; <nl> members . Add ( \" serverMembers \" ) ; <nl> members . Add ( \" callbacks \" ) ; <nl> <nl> - sb . AppendFormat ( \" { 0 } : { { \" , Json . CamelCase ( type . Name ) ) . AppendLine ( ) ; <nl> + sb . AppendFormat ( \" { 0 } : { { \" , GetTypeName ( type ) ) . AppendLine ( ) ; <nl> sb . AppendFormat ( \" _ : { { \" ) . AppendLine ( ) ; <nl> sb . AppendFormat ( \" hubName : ' { 0 } ' , \" , type . FullName ? ? \" null \" ) . AppendLine ( ) ; <nl> sb . AppendFormat ( \" serverMembers : [ { 0 } ] , \" , Commas ( members , m = > \" ' \" + Json . CamelCase ( m ) + \" ' \" ) ) . AppendLine ( ) ; <nl> public class DefaultJavaScriptProxyGenerator : IJavaScriptProxyGenerator { <nl> sb . Append ( \" } \" ) ; <nl> } <nl> <nl> + protected virtual string GetTypeName ( Type type ) { <nl> + return Json . CamelCase ( type . Name ) ; <nl> + } <nl> + <nl> + protected virtual MethodInfo [ ] GetMethods ( Type type ) { <nl> + return type . GetMethods ( BindingFlags . Public | BindingFlags . Instance | BindingFlags . DeclaredOnly ) ; <nl> + } <nl> + <nl> private void GenerateMethod ( string serviceUrl , StringBuilder sb , Type type , MethodInfo method ) { <nl> var parameters = method . GetParameters ( ) ; <nl> var parameterNames = parameters . Select ( p = > p . Name ) . ToList ( ) ; <nl>\n", "msg": "Added virtual methods for overriding getting methods and getting the class name\n"}
{"diff_id": 19833, "repo": "ServiceStack/ServiceStack\n", "sha": "9554106c7cb4ae5ac6e235b465be4b810c59e4df\n", "time": "2013-07-15T16:16:30Z\n", "diff": "mmm a / src / ServiceStack / WebHost . Endpoints / Support / Templates / HtmlTemplates . cs <nl> ppp b / src / ServiceStack / WebHost . Endpoints / Support / Templates / HtmlTemplates . cs <nl> public static class HtmlTemplates <nl> <nl> static HtmlTemplates ( ) <nl> { <nl> - var CustomPath = EndpointHost . Config . UseCustomMetadataTemplates ; <nl> + var UseCustomPath = EndpointHost . Config . UseCustomMetadataTemplates ; <nl> <nl> - IndexOperationsTemplate = CustomPath ? LoadExternal ( \" IndexOperations . html \" ) : LoadEmbeddedHtmlTemplate ( \" IndexOperations . html \" ) ; <nl> - OperationControlTemplate = CustomPath ? LoadExternal ( \" OperationControl . html \" ) : LoadEmbeddedHtmlTemplate ( \" OperationControl . html \" ) ; <nl> - OperationsControlTemplate = CustomPath ? LoadExternal ( \" OperationsControl . html \" ) : LoadEmbeddedHtmlTemplate ( \" OperationsControl . html \" ) ; <nl> + if ( UseCustomPath ) <nl> + { <nl> + IndexOperationsTemplate = LoadExternal ( \" IndexOperations . html \" ) ; <nl> + OperationControlTemplate = LoadExternal ( \" OperationControl . html \" ) ; <nl> + OperationsControlTemplate = LoadExternal ( \" OperationsControl . html \" ) ; <nl> + } <nl> + else <nl> + { <nl> + IndexOperationsTemplate = LoadEmbeddedHtmlTemplate ( \" IndexOperations . html \" ) ; <nl> + OperationControlTemplate = LoadEmbeddedHtmlTemplate ( \" OperationControl . html \" ) ; <nl> + OperationsControlTemplate = LoadEmbeddedHtmlTemplate ( \" OperationsControl . html \" ) ; <nl> + } <nl> } <nl> <nl> private static string LoadExternal ( string templateName ) <nl>\n", "msg": "Refractor Metadata custom path handling to avoid too many if conditions\n"}
{"diff_id": 20217, "repo": "IdentityServer/IdentityServer4\n", "sha": "e180ed4ade37bed49ed4d256e46b0071d7ccaeb2\n", "time": "2019-06-30T01:33:02Z\n", "diff": "mmm a / src / IdentityServer4 / src / Endpoints / Results / ConsentPageResult . cs <nl> ppp b / src / IdentityServer4 / src / Endpoints / Results / ConsentPageResult . cs <nl> public Task ExecuteAsync ( HttpContext context ) <nl> { <nl> / / this converts the relative redirect path to an absolute one if we ' re <nl> / / redirecting to a different server <nl> - returnUrl = context . GetIdentityServerBaseUrl ( ) . EnsureTrailingSlash ( ) + returnUrl . RemoveLeadingSlash ( ) ; <nl> + returnUrl = context . GetIdentityServerHost ( ) . EnsureTrailingSlash ( ) + returnUrl . RemoveLeadingSlash ( ) ; <nl> } <nl> <nl> var url = consentUrl . AddQueryString ( _options . UserInteraction . ConsentReturnUrlParameter , returnUrl ) ; <nl>\n", "msg": "ids4 configured to use external ConsentUrl duplicates path in ReturnUrl\n"}
{"diff_id": 20707, "repo": "mono/mono\n", "sha": "74f9629a31810377c05b835d1ed83b985028d86e\n", "time": "2003-12-01T13:51:25Z\n", "diff": "mmm a / mcs / class / System . Data / System . Data / ExpressionElement . cs <nl> ppp b / mcs / class / System . Data / System . Data / ExpressionElement . cs <nl> <nl> <nl> using System . Collections ; <nl> <nl> - namespace System . Data <nl> + namespace System . Data <nl> { <nl> - / / / < summary > <nl> - / / / The main element which includes whole expression <nl> - / / / < / summary > <nl> - internal class ExpressionMainElement : ExpressionElement <nl> + / / / < summary > <nl> + / / / The main element which includes whole expression <nl> + / / / < / summary > <nl> + internal class ExpressionMainElement : ExpressionElement <nl> { <nl> <nl> - # region Fields <nl> - <nl> - enum OP { OPERATOR , OPERAND } ; <nl> - enum OPERATOR_TYPE { SYMBOLIC , LITERAL , UNDEFINED } ; <nl> - enum OPERAND_TYPE { NUMERIC , STRING , UNDEFINED } ; <nl> - <nl> - # endregion / / Fields <nl> + <nl> <nl> - public ExpressionMainElement ( string s ) <nl> + public ExpressionMainElement ( string s ) <nl> { <nl> - s = ValidateExpression ( s ) ; <nl> + s = ExpressionElement . ValidateExpression ( s ) ; <nl> ParseExpression ( s ) ; <nl> } <nl> <nl> - public override bool Test ( DataRow Row ) { <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> <nl> - foreach ( ExpressionElement El in Elements ) { <nl> + foreach ( ExpressionElement El in Elements ) <nl> + { <nl> if ( ! El . Test ( Row ) ) <nl> return false ; <nl> } <nl> public ExpressionMainElement ( string s ) <nl> return true ; <nl> } <nl> <nl> - / / / < summary > <nl> - / / / Checks syntax of expression and throws exception if needed . <nl> - / / / Also removes whitespaces between operator elements for example : age < = 64 - - > age < = 64 <nl> - / / / < / summary > <nl> - private string ValidateExpression ( string s ) <nl> - { <nl> - / / <nl> - / / TODO : find out nice way to do this . This is NOT nice way : - P <nl> - / / <nl> - string temp = \" \" ; <nl> - OP op = OP . OPERAND ; <nl> - OPERATOR_TYPE operatorType = OPERATOR_TYPE . UNDEFINED ; <nl> - <nl> - string strOperator = \" \" ; <nl> - string strOperand = \" \" ; <nl> - int quotes = 0 ; <nl> - int parentheses = 0 ; <nl> - string newExp = \" \" ; <nl> - bool isDigit = false ; <nl> - bool litOperator = false ; <nl> - s = s . Trim ( ) ; <nl> - <nl> - for ( int i = 0 ; i < s . Length ; i + + ) { <nl> - <nl> - char c = s [ i ] ; <nl> - <nl> - if ( c = = ' \\ ' ' ) <nl> - quotes + + ; <nl> - <nl> - if ( ( c = = ' \\ n ' | | c = = ' \\ t ' ) & & quotes = = 0 ) <nl> - c = ' ' ; <nl> - <nl> - if ( op = = OP . OPERAND & & c = = ' ( ' ) <nl> - parentheses + + ; <nl> - else if ( op = = OP . OPERAND & & c = = ' ) ' ) <nl> - parentheses - - ; <nl> - <nl> - if ( c = = ' ' & & op = = OP . OPERAND & & ( quotes % 2 ) = = 0 & & parentheses = = 0 ) { <nl> - <nl> - op = OP . OPERATOR ; <nl> - newExp + = strOperand ; <nl> - strOperand = \" \" ; <nl> - strOperator = \" \" ; <nl> - } <nl> - <nl> - if ( op = = OP . OPERAND ) { <nl> - <nl> - if ( ! Char . IsDigit ( c ) & & isDigit & & ( quotes % 2 ) = = 0 ) { <nl> - <nl> - newExp + = strOperand ; <nl> - strOperand = \" \" ; <nl> - op = OP . OPERATOR ; <nl> - operatorType = OPERATOR_TYPE . UNDEFINED ; <nl> - } <nl> - else <nl> - strOperand + = c ; <nl> - } <nl> - <nl> - if ( op = = OP . OPERATOR ) { <nl> - <nl> - isDigit = false ; <nl> - if ( operatorType = = OPERATOR_TYPE . UNDEFINED ) { <nl> - <nl> - if ( c = = ' < ' | | c = = ' = ' | | c = = ' > ' | | c = = ' * ' | | c = = ' / ' | | c = = ' % ' <nl> - | | c = = ' - ' | | c = = ' + ' ) <nl> - <nl> - operatorType = OPERATOR_TYPE . SYMBOLIC ; <nl> - else if ( c ! = ' ' ) <nl> - operatorType = OPERATOR_TYPE . LITERAL ; <nl> - } <nl> - else if ( operatorType = = OPERATOR_TYPE . SYMBOLIC ) { <nl> - <nl> - if ( c ! = ' < ' & & c ! = ' = ' & & c ! = ' > ' & & c ! = ' ' ) { <nl> - <nl> - / / this is COPY - PASTE <nl> - op = OP . OPERAND ; <nl> - if ( ! newExp . EndsWith ( \" \" ) & & ! strOperator . StartsWith ( \" \" ) ) <nl> - strOperator = \" \" + strOperator ; <nl> - <nl> - newExp + = strOperator ; <nl> - <nl> - if ( Char . IsDigit ( c ) ) <nl> - isDigit = true ; <nl> - <nl> - strOperand = c . ToString ( ) ; <nl> - <nl> - strOperator = \" \" ; <nl> - continue ; <nl> - } <nl> - } <nl> - <nl> - if ( operatorType = = OPERATOR_TYPE . LITERAL & & c = = ' ' ) { <nl> - op = OP . OPERAND ; <nl> - newExp + = strOperator ; <nl> - strOperand + = \" \" ; <nl> - strOperator = \" \" ; <nl> - } <nl> - <nl> - <nl> - if ( Char . IsDigit ( c ) & & operatorType ! = OPERATOR_TYPE . LITERAL ) { <nl> - <nl> - op = OP . OPERAND ; <nl> - <nl> - if ( ! newExp . EndsWith ( \" \" ) & & ! strOperator . StartsWith ( \" \" ) ) <nl> - strOperator = \" \" + strOperator ; <nl> - newExp + = strOperator ; <nl> - strOperand = c . ToString ( ) ; <nl> - isDigit = true ; <nl> - strOperator = \" \" ; <nl> - } <nl> - <nl> - else if ( c ! = ' ' ) <nl> - strOperator + = c ; <nl> - } <nl> - } <nl> - <nl> - if ( op = = OP . OPERATOR ) <nl> - throw new SyntaxErrorException ( <nl> - \" Missing operand after ' \" + strOperator + \" ' operator \" ) ; <nl> - else <nl> - newExp + = strOperand ; <nl> - <nl> - return newExp ; <nl> - } <nl> + <nl> } <nl> <nl> - / / <nl> - / / O_P_E_R_A_T_O_R_S <nl> - / / <nl> + / / <nl> + / / O_P_E_R_A_T_O_R_S <nl> + / / <nl> <nl> - / / / < summary > <nl> - / / / Class for = <nl> - / / / < / summary > <nl> - internal class ExpressionEquals : ExpressionElement <nl> + / / / < summary > <nl> + / / / Class for = <nl> + / / / < / summary > <nl> + internal class ExpressionEquals : ExpressionElement <nl> { <nl> <nl> - public ExpressionEquals ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + public ExpressionEquals ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override bool Test ( DataRow Row ) { <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionElement E2 = ( ExpressionElement ) Elements [ 1 ] ; <nl> <nl> return ExpressionElement . Compare ( E1 , E2 , Row ) = = 0 ; <nl> } <nl> - } <nl> + } <nl> <nl> - / / / < summary > <nl> - / / / Class for < <nl> - / / / < / summary > <nl> - internal class ExpressionLessThan : ExpressionElement <nl> + / / / < summary > <nl> + / / / Class for < <nl> + / / / < / summary > <nl> + internal class ExpressionLessThan : ExpressionElement <nl> { <nl> <nl> - public ExpressionLessThan ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + public ExpressionLessThan ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override bool Test ( DataRow Row ) { <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionElement E2 = ( ExpressionElement ) Elements [ 1 ] ; <nl> <nl> return ExpressionElement . Compare ( E1 , E2 , Row ) < 0 ; <nl> } <nl> - } <nl> + } <nl> <nl> - / / / < summary > <nl> - / / / Class for < = <nl> - / / / < / summary > <nl> - internal class ExpressionLessThanOrEqual : ExpressionElement <nl> + / / / < summary > <nl> + / / / Class for < = <nl> + / / / < / summary > <nl> + internal class ExpressionLessThanOrEqual : ExpressionElement <nl> { <nl> <nl> - public ExpressionLessThanOrEqual ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + public ExpressionLessThanOrEqual ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override bool Test ( DataRow Row ) { <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionElement E2 = ( ExpressionElement ) Elements [ 1 ] ; <nl> <nl> return ExpressionElement . Compare ( E1 , E2 , Row ) < = 0 ; <nl> } <nl> - } <nl> + } <nl> <nl> - / / / < summary > <nl> - / / / Class for > <nl> - / / / < / summary > <nl> - internal class ExpressionGreaterThan : ExpressionElement <nl> + / / / < summary > <nl> + / / / Class for > <nl> + / / / < / summary > <nl> + internal class ExpressionGreaterThan : ExpressionElement <nl> { <nl> <nl> - public ExpressionGreaterThan ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + public ExpressionGreaterThan ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override bool Test ( DataRow Row ) { <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionElement E2 = ( ExpressionElement ) Elements [ 1 ] ; <nl> <nl> return ExpressionElement . Compare ( E1 , E2 , Row ) > 0 ; <nl> } <nl> - } <nl> + } <nl> <nl> - / / / < summary > <nl> - / / / Class for > = <nl> - / / / < / summary > <nl> - internal class ExpressionGreaterThanOrEqual : ExpressionElement <nl> + / / / < summary > <nl> + / / / Class for > = <nl> + / / / < / summary > <nl> + internal class ExpressionGreaterThanOrEqual : ExpressionElement <nl> { <nl> <nl> - public ExpressionGreaterThanOrEqual ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + public ExpressionGreaterThanOrEqual ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override bool Test ( DataRow Row ) { <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionElement E2 = ( ExpressionElement ) Elements [ 1 ] ; <nl> <nl> return ExpressionElement . Compare ( E1 , E2 , Row ) > = 0 ; <nl> } <nl> - } <nl> + } <nl> <nl> - / / / < summary > <nl> - / / / Class for < > <nl> - / / / < / summary > <nl> - internal class ExpressionUnequals : ExpressionElement <nl> - { <nl> + / / / < summary > <nl> + / / / Class for < > <nl> + / / / < / summary > <nl> + internal class ExpressionUnequals : ExpressionElement <nl> + { <nl> <nl> - public ExpressionUnequals ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + public ExpressionUnequals ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override bool Test ( DataRow Row ) { <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionElement E2 = ( ExpressionElement ) Elements [ 1 ] ; <nl> <nl> return ExpressionElement . Compare ( E1 , E2 , Row ) ! = 0 ; <nl> } <nl> - } <nl> + } <nl> <nl> <nl> - / / / < summary > <nl> - / / / Class for LIKE - operator <nl> - / / / < / summary > <nl> - internal class ExpressionLike : ExpressionElement <nl> + / / / < summary > <nl> + / / / Class for LIKE - operator <nl> + / / / < / summary > <nl> + internal class ExpressionLike : ExpressionElement <nl> { <nl> <nl> - public ExpressionLike ( string exp1 , string exp2 ) <nl> - { <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + public ExpressionLike ( string exp1 , string exp2 ) <nl> + { <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override bool Test ( DataRow Row ) { <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionElement E2 = ( ExpressionElement ) Elements [ 1 ] ; <nl> public ExpressionLike ( string exp1 , string exp2 ) <nl> int indexOf = - 1 ; <nl> <nl> indexOf = operand2 . IndexOf ( \" * \" ) ; <nl> - while ( indexOf ! = - 1 ) { <nl> + while ( indexOf ! = - 1 ) <nl> + { <nl> <nl> oldIndex = indexOf + 1 ; <nl> if ( operand2 [ indexOf + 1 ] ! = ' ] ' | | operand2 [ indexOf - 1 ] ! = ' [ ' ) <nl> throw new EvaluateException ( \" Error in Like operator : ther string pattern \" + operand1 + \" is invalid \" ) ; <nl> - else { <nl> + else <nl> + { <nl> operand2 = operand2 . Remove ( indexOf + 1 , 1 ) ; <nl> operand2 = operand2 . Remove ( indexOf - 1 , 1 ) ; <nl> oldIndex - - ; <nl> public ExpressionLike ( string exp1 , string exp2 ) <nl> <nl> oldIndex = 0 ; <nl> indexOf = operand2 . IndexOf ( \" % \" ) ; <nl> - while ( indexOf ! = - 1 ) { <nl> + while ( indexOf ! = - 1 ) <nl> + { <nl> <nl> oldIndex = indexOf + 1 ; <nl> <nl> if ( operand2 [ indexOf + 1 ] ! = ' ] ' | | operand2 [ indexOf - 1 ] ! = ' [ ' ) <nl> throw new EvaluateException ( \" Error in Like operator : ther string pattern \" + operand2 + \" is invalid \" ) ; <nl> - else { <nl> + else <nl> + { <nl> operand2 = operand2 . Remove ( indexOf + 1 , 1 ) ; <nl> operand2 = operand2 . Remove ( indexOf - 1 , 1 ) ; <nl> oldIndex - - ; <nl> public ExpressionLike ( string exp1 , string exp2 ) <nl> <nl> int len2 = operand2 . Length ; <nl> int startIndex = 0 ; <nl> - while ( ( startIndex + len2 ) < = operand1 . Length ) { <nl> + while ( ( startIndex + len2 ) < = operand1 . Length ) <nl> + { <nl> if ( String . Compare ( operand1 . Substring ( startIndex , len2 ) , operand2 , ! Row . Table . CaseSensitive ) = = 0 ) <nl> return true ; <nl> startIndex + + ; <nl> public ExpressionLike ( string exp1 , string exp2 ) <nl> <nl> return false ; <nl> } <nl> - } <nl> + } <nl> <nl> <nl> - / / / < summary > <nl> - / / / Class for OR <nl> - / / / < / summary > <nl> - internal class ExpressionOr : ExpressionElement <nl> - { <nl> - public ExpressionOr ( string exp1 , string exp2 ) <nl> - { <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + / / / < summary > <nl> + / / / Class for OR <nl> + / / / < / summary > <nl> + internal class ExpressionOr : ExpressionElement <nl> + { <nl> + public ExpressionOr ( string exp1 , string exp2 ) <nl> + { <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> public override bool Test ( DataRow Row ) <nl> { <nl> - foreach ( ExpressionElement El in Elements ) { <nl> + foreach ( ExpressionElement El in Elements ) <nl> + { <nl> if ( El . Test ( Row ) ) <nl> return true ; <nl> } <nl> <nl> return false ; <nl> } <nl> - } <nl> + } <nl> <nl> - / / / < summary > <nl> - / / / Class for AND <nl> - / / / < / summary > <nl> - internal class ExpressionAnd : ExpressionElement <nl> - { <nl> - public ExpressionAnd ( string exp1 , string exp2 ) <nl> - { <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + / / / < summary > <nl> + / / / Class for AND <nl> + / / / < / summary > <nl> + internal class ExpressionAnd : ExpressionElement <nl> + { <nl> + public ExpressionAnd ( string exp1 , string exp2 ) <nl> + { <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override object Result ( DataRow Row ) { <nl> + public override object Result ( DataRow Row ) <nl> + { <nl> <nl> return Test ( Row ) ; <nl> } <nl> <nl> public override bool Test ( DataRow Row ) <nl> { <nl> - foreach ( ExpressionElement El in Elements ) { <nl> + foreach ( ExpressionElement El in Elements ) <nl> + { <nl> if ( ! El . Test ( Row ) ) <nl> return false ; <nl> } <nl> <nl> return true ; <nl> } <nl> - } <nl> - <nl> - <nl> - / / <nl> - / / A_R_I_T_H_M_E_T_I_C O_P_E_R_A_T_O_R_S <nl> - / / <nl> - <nl> - / / / < summary > <nl> - / / / Class for + <nl> - / / / < / summary > <nl> - internal class ExpressionAddition : ExpressionElement <nl> - { <nl> - public ExpressionAddition ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + } <nl> + <nl> + <nl> + / / <nl> + / / A_R_I_T_H_M_E_T_I_C O_P_E_R_A_T_O_R_S <nl> + / / <nl> + <nl> + / / / < summary > <nl> + / / / Class for + <nl> + / / / < / summary > <nl> + internal class ExpressionAddition : ExpressionElement <nl> + { <nl> + public ExpressionAddition ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override Type ResultType ( DataRow Row ) <nl> + public override Type ResultType ( DataRow Row ) <nl> { <nl> Type ResultType = typeof ( string ) ; <nl> ExpressionElement exp1Temp = ( ( ExpressionElement ) Elements [ 0 ] ) ; <nl> public override Type ResultType ( DataRow Row ) <nl> return ResultType ; <nl> } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow Row ) <nl> { <nl> return CalculateResult ( Row ) ; <nl> - } <nl> + } <nl> <nl> protected override object Calculate ( object value1 , object value2 , Type TempType ) <nl> { <nl> protected override object Calculate ( object value1 , object value2 , Type TempType <nl> else if ( TempType = = typeof ( short ) ) <nl> Result = ( short ) value1 + ( short ) value2 ; <nl> else if ( TempType = = typeof ( ulong ) ) <nl> - Result = ( ulong ) value1 + ( ulong ) value2 ; <nl> + Result = ( ulong ) value1 + ( ulong ) value2 ; <nl> else if ( TempType = = typeof ( uint ) ) <nl> Result = ( uint ) value1 + ( uint ) value2 ; <nl> else if ( TempType = = typeof ( ushort ) ) <nl> protected override object Calculate ( object value1 , object value2 , Type TempType <nl> Result = ( byte ) value1 + ( byte ) value2 ; <nl> else if ( TempType = = typeof ( sbyte ) ) <nl> Result = ( sbyte ) value1 + ( sbyte ) value2 ; <nl> - / / FIXME : <nl> - / / else if ( TempType = = typeof ( bool ) ) <nl> - / / Result = ( bool ) value1 + ( bool ) value2 ; <nl> + / / FIXME : <nl> + / / else if ( TempType = = typeof ( bool ) ) <nl> + / / Result = ( bool ) value1 + ( bool ) value2 ; <nl> else if ( TempType = = typeof ( float ) ) <nl> Result = ( float ) value1 + ( float ) value2 ; <nl> else if ( TempType = = typeof ( double ) ) <nl> protected override object Calculate ( object value1 , object value2 , Type TempType <nl> } <nl> <nl> <nl> - / / This method is shouldnt never invoked <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Class for - <nl> - / / / < / summary > <nl> - internal class ExpressionSubtraction : ExpressionElement <nl> - { <nl> - public ExpressionSubtraction ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + / / This method is shouldnt never invoked <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Class for - <nl> + / / / < / summary > <nl> + internal class ExpressionSubtraction : ExpressionElement <nl> + { <nl> + public ExpressionSubtraction ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow Row ) <nl> { <nl> return CalculateResult ( Row ) ; <nl> - } <nl> + } <nl> <nl> - / / This method is shouldnt never invoked <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> + / / This method is shouldnt never invoked <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> <nl> protected override object Calculate ( object value1 , object value2 , Type TempType ) <nl> { <nl> protected override object Calculate ( object value1 , object value2 , Type TempType <nl> else if ( TempType = = typeof ( short ) ) <nl> Result = ( short ) value1 - ( short ) value2 ; <nl> else if ( TempType = = typeof ( ulong ) ) <nl> - Result = ( ulong ) value1 + ( ulong ) value2 ; <nl> + Result = ( ulong ) value1 + ( ulong ) value2 ; <nl> else if ( TempType = = typeof ( uint ) ) <nl> Result = ( uint ) value1 - ( uint ) value2 ; <nl> else if ( TempType = = typeof ( ushort ) ) <nl> protected override object Calculate ( object value1 , object value2 , Type TempType <nl> Result = ( byte ) value1 - ( byte ) value2 ; <nl> else if ( TempType = = typeof ( sbyte ) ) <nl> Result = ( sbyte ) value1 - ( sbyte ) value2 ; <nl> - / / FIXME : <nl> - / / else if ( TempType = = typeof ( bool ) ) <nl> - / / Result = ( bool ) value1 - ( bool ) value2 ; <nl> + / / FIXME : <nl> + / / else if ( TempType = = typeof ( bool ) ) <nl> + / / Result = ( bool ) value1 - ( bool ) value2 ; <nl> else if ( TempType = = typeof ( float ) ) <nl> Result = ( float ) value1 - ( float ) value2 ; <nl> else if ( TempType = = typeof ( double ) ) <nl> protected override object Calculate ( object value1 , object value2 , Type TempType <nl> <nl> return Result ; <nl> } <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Class for * <nl> - / / / < / summary > <nl> - internal class ExpressionMultiply : ExpressionElement <nl> - { <nl> - public ExpressionMultiply ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Class for * <nl> + / / / < / summary > <nl> + internal class ExpressionMultiply : ExpressionElement <nl> + { <nl> + public ExpressionMultiply ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override Type ResultType ( DataRow Row ) <nl> + public override Type ResultType ( DataRow Row ) <nl> { <nl> Type ResultType = null ; <nl> ExpressionElement E1 = ( ( ExpressionElement ) Elements [ 0 ] ) ; <nl> public override Type ResultType ( DataRow Row ) <nl> <nl> if ( t1 = = typeof ( string ) | | t2 = = typeof ( string ) ) <nl> throw new EvaluateException ( \" Cannon perform ' * ' operation on \" + t1 . ToString ( ) + <nl> - \" and \" + t2 . ToString ( ) ) ; <nl> + \" and \" + t2 . ToString ( ) ) ; <nl> <nl> else if ( t1 = = typeof ( long ) | | t2 = = typeof ( long ) ) <nl> ResultType = typeof ( long ) ; <nl> public override Type ResultType ( DataRow Row ) <nl> return ResultType ; <nl> } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow Row ) <nl> { <nl> return CalculateResult ( Row ) ; <nl> - } <nl> + } <nl> <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> <nl> protected override object Calculate ( object value1 , object value2 , Type TempType ) <nl> { <nl> protected override object Calculate ( object value1 , object value2 , Type TempType <nl> Result = ( byte ) value1 * ( byte ) value2 ; <nl> else if ( TempType = = typeof ( sbyte ) ) <nl> Result = ( sbyte ) value1 * ( sbyte ) value2 ; <nl> - / / FIXME : <nl> - / / else if ( TempType = = typeof ( bool ) ) <nl> - / / Result = ( bool ) value1 * ( bool ) value2 ; <nl> + / / FIXME : <nl> + / / else if ( TempType = = typeof ( bool ) ) <nl> + / / Result = ( bool ) value1 * ( bool ) value2 ; <nl> else if ( TempType = = typeof ( float ) ) <nl> Result = ( float ) value1 * ( float ) value2 ; <nl> else if ( TempType = = typeof ( double ) ) <nl> protected override object Calculate ( object value1 , object value2 , Type TempType <nl> return Result ; <nl> } <nl> <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Class for * <nl> - / / / < / summary > <nl> - internal class ExpressionDivide : ExpressionElement <nl> - { <nl> - public ExpressionDivide ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Class for * <nl> + / / / < / summary > <nl> + internal class ExpressionDivide : ExpressionElement <nl> + { <nl> + public ExpressionDivide ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow Row ) <nl> { <nl> return CalculateResult ( Row ) ; <nl> - } <nl> + } <nl> <nl> - / / This method is shouldnt never invoked <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> + / / This method is shouldnt never invoked <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> <nl> protected override object Calculate ( object value1 , object value2 , Type TempType ) <nl> { <nl> protected override object Calculate ( object value1 , object value2 , Type TempTyp <nl> <nl> if ( TempType = = typeof ( long ) ) <nl> Result = ( long ) value1 / ( long ) value2 ; <nl> - / / FIXME : <nl> - / / else if ( TempType = = typeof ( int ) ) <nl> - / / Result = ( string ) value1 / ( string ) value2 ; <nl> + / / FIXME : <nl> + / / else if ( TempType = = typeof ( int ) ) <nl> + / / Result = ( string ) value1 / ( string ) value2 ; <nl> else if ( TempType = = typeof ( int ) ) <nl> Result = ( int ) value1 / ( int ) value2 ; <nl> else if ( TempType = = typeof ( short ) ) <nl> protected override object Calculate ( object value1 , object value2 , Type TempTyp <nl> Result = ( byte ) value1 / ( byte ) value2 ; <nl> else if ( TempType = = typeof ( sbyte ) ) <nl> Result = ( sbyte ) value1 / ( sbyte ) value2 ; <nl> - / / FIXME : <nl> - / / else if ( TempType = = typeof ( bool ) ) <nl> - / / Result = ( bool ) value1 / / ( bool ) value2 ; <nl> + / / FIXME : <nl> + / / else if ( TempType = = typeof ( bool ) ) <nl> + / / Result = ( bool ) value1 / / ( bool ) value2 ; <nl> else if ( TempType = = typeof ( float ) ) <nl> Result = ( float ) value1 / ( float ) value2 ; <nl> else if ( TempType = = typeof ( double ) ) <nl> protected override object Calculate ( object value1 , object value2 , Type TempTyp <nl> <nl> return Result ; <nl> } <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Class for * <nl> - / / / < / summary > <nl> - internal class ExpressionModulus : ExpressionElement <nl> - { <nl> - public ExpressionModulus ( string exp1 , string exp2 ) <nl> - { <nl> - this . exp1 = exp1 ; <nl> - this . exp2 = exp2 ; <nl> - ParseExpression ( exp1 ) ; <nl> - ParseExpression ( exp2 ) ; <nl> - } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Class for * <nl> + / / / < / summary > <nl> + internal class ExpressionModulus : ExpressionElement <nl> + { <nl> + public ExpressionModulus ( string exp1 , string exp2 ) <nl> + { <nl> + this . exp1 = exp1 ; <nl> + this . exp2 = exp2 ; <nl> + ParseExpression ( exp1 ) ; <nl> + ParseExpression ( exp2 ) ; <nl> + } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow Row ) <nl> { <nl> return CalculateResult ( Row ) ; <nl> - } <nl> + } <nl> <nl> - / / This method is shouldnt never invoked <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> + / / This method is shouldnt never invoked <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> <nl> protected override object Calculate ( object value1 , object value2 , Type TempType ) <nl> { <nl> protected override object Calculate ( object value1 , object value2 , Type TempTyp <nl> <nl> if ( TempType = = typeof ( long ) ) <nl> Result = ( long ) value1 % ( long ) value2 ; <nl> - / / FIXME : <nl> - / / else if ( TempType = = typeof ( int ) ) <nl> - / / Result = ( string ) value1 % ( string ) value2 ; <nl> + / / FIXME : <nl> + / / else if ( TempType = = typeof ( int ) ) <nl> + / / Result = ( string ) value1 % ( string ) value2 ; <nl> else if ( TempType = = typeof ( int ) ) <nl> Result = ( int ) value1 % ( int ) value2 ; <nl> else if ( TempType = = typeof ( short ) ) <nl> protected override object Calculate ( object value1 , object value2 , Type TempTyp <nl> Result = ( byte ) value1 % ( byte ) value2 ; <nl> else if ( TempType = = typeof ( sbyte ) ) <nl> Result = ( sbyte ) value1 % ( sbyte ) value2 ; <nl> - / / FIXME : <nl> - / / else if ( TempType = = typeof ( bool ) ) <nl> - / / Result = ( bool ) value1 / / ( bool ) value2 ; <nl> + / / FIXME : <nl> + / / else if ( TempType = = typeof ( bool ) ) <nl> + / / Result = ( bool ) value1 / / ( bool ) value2 ; <nl> else if ( TempType = = typeof ( float ) ) <nl> Result = ( float ) value1 % ( float ) value2 ; <nl> else if ( TempType = = typeof ( double ) ) <nl> protected override object Calculate ( object value1 , object value2 , Type TempTyp <nl> <nl> return Result ; <nl> } <nl> - } <nl> + } <nl> <nl> - / / <nl> - / / _____A_G_G_R_E_G_A_T_E_S_____ <nl> - / / <nl> + / / <nl> + / / _____A_G_G_R_E_G_A_T_E_S_____ <nl> + / / <nl> <nl> - internal class ExpressionAggregate : ExpressionElement <nl> + internal class ExpressionAggregate : ExpressionElement <nl> { <nl> - / / public override object Result ( DataRow Row ) <nl> - / / { <nl> - / / return null ; <nl> - / / } <nl> <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> + public ExpressionAggregate ( ) <nl> + { <nl> + } <nl> <nl> - protected virtual void ParseParameters ( string s ) <nl> + public ExpressionAggregate ( string s ) <nl> + { <nl> + s = ExpressionElement . ValidateExpression ( s ) ; <nl> + ParseExpression ( s ) ; <nl> + } <nl> + <nl> + <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> + <nl> + public override object Result ( DataRow Row ) <nl> + { <nl> + DataRow [ ] rows = new DataRow [ Row . Table . Rows . Count ] ; <nl> + Row . Table . Rows . CopyTo ( rows , 0 ) ; <nl> + return ( ( ExpressionAggregate ) Elements [ 0 ] ) . Result ( rows ) ; <nl> + } <nl> + <nl> + public virtual object Result ( DataRow [ ] rows ) <nl> + { <nl> + return ( ( ExpressionAggregate ) Elements [ 0 ] ) . Result ( rows ) ; <nl> + } <nl> + <nl> + <nl> + protected virtual void ParseParameters ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> bool inString = false ; <nl> protected virtual void ParseParameters ( string s ) <nl> s = s . Remove ( 0 , 1 ) ; <nl> <nl> int parentheses = 0 ; <nl> - for ( int i = 0 ; i < s . Length ; i + + ) { <nl> + for ( int i = 0 ; i < s . Length ; i + + ) <nl> + { <nl> <nl> if ( s [ i ] = = ' \\ ' ' ) <nl> inString = ! inString ; <nl> protected virtual void ParseParameters ( string s ) <nl> else if ( s [ i ] = = ' ) ' ) <nl> parentheses - - ; <nl> <nl> - if ( ( s [ i ] = = ' , ' | | s [ i ] = = ' ) ' ) & & ! inString & & parentheses = = - 1 ) { / / Parameter changed <nl> + if ( ( s [ i ] = = ' , ' | | s [ i ] = = ' ) ' ) & & ! inString & & parentheses = = - 1 ) <nl> + { <nl> + / / Parameter changed <nl> <nl> - if ( p1 = = null ) { <nl> + if ( p1 = = null ) <nl> + { <nl> p1 = s . Substring ( 0 , i ) ; <nl> break ; <nl> } <nl> protected virtual void ParseParameters ( string s ) <nl> <nl> } <nl> <nl> - / / / < summary > <nl> - / / / Class for Sum ( column_Name ) <nl> - / / / < / summary <nl> - internal class ExpressionSum : ExpressionAggregate <nl> + / / / < summary > <nl> + / / / Class for Sum ( column_Name ) <nl> + / / / < / summary <nl> + internal class ExpressionSum : ExpressionAggregate <nl> { <nl> - public ExpressionSum ( string exp1 ) <nl> + public ExpressionSum ( string exp1 ) <nl> { <nl> ParseParameters ( exp1 ) ; <nl> } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow [ ] rows ) <nl> { <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> - object value1 = E1 . Result ( Row ) ; <nl> + object value1 = E1 . Result ( rows [ 0 ] ) ; <nl> Type t1 = value1 . GetType ( ) ; <nl> - object result = null ; <nl> + object result = 0 ; <nl> <nl> / / This could be optimized . If E1 is single element ( Not child or parent ) the <nl> / / result of Sum ( ) aggregate is allways same <nl> <nl> - if ( E1 is ExpressionSingleElement ) { <nl> + if ( E1 is ExpressionSingleElement ) <nl> + { <nl> <nl> / / This should be optimized somehow <nl> - foreach ( DataRow tempRow in Row . Table . Rows ) { <nl> + for ( int i = 0 ; i < rows . Length ; i + + ) <nl> + { <nl> <nl> / / TODO : other types and exceptions <nl> - object v = E1 . Result ( tempRow ) ; <nl> + object v = E1 . Result ( rows [ i ] ) ; <nl> t1 = v . GetType ( ) ; <nl> <nl> if ( v = = null | | v = = DBNull . Value ) <nl> continue ; <nl> <nl> - if ( t1 = = typeof ( long ) ) { <nl> - result = 0 ; <nl> + if ( t1 = = typeof ( long ) ) <nl> + { <nl> result = ( long ) result + ( long ) v ; <nl> } <nl> - else if ( t1 = = typeof ( int ) ) { <nl> - result = 0 ; <nl> + else if ( t1 = = typeof ( int ) ) <nl> + { <nl> result = ( int ) result + ( int ) v ; <nl> } <nl> - else if ( t1 = = typeof ( short ) ) { <nl> - result = 0 ; <nl> + else if ( t1 = = typeof ( short ) ) <nl> + { <nl> result = ( short ) result + ( short ) v ; <nl> } <nl> - else if ( t1 = = typeof ( double ) ) { <nl> - result = 0 ; <nl> + else if ( t1 = = typeof ( double ) ) <nl> + { <nl> result = ( double ) result + ( double ) v ; <nl> } <nl> - else if ( t1 = = typeof ( float ) ) { <nl> - result = 0 ; <nl> + else if ( t1 = = typeof ( float ) ) <nl> + { <nl> result = ( float ) result + ( float ) v ; <nl> } <nl> else <nl> public override object Result ( DataRow Row ) <nl> } <nl> <nl> return result ; <nl> - } <nl> + } <nl> + <nl> <nl> / / <nl> - / / FIXME : This method is copy - paste in every Aggregate class . <nl> + / / Copy : This method is copy - paste in every Aggregate class . <nl> / / <nl> } <nl> <nl> - / / / < summary > <nl> - / / / Class for Avg ( column_Name ) <nl> - / / / < / summary <nl> - internal class ExpressionAvg : ExpressionAggregate <nl> + / / / < summary > <nl> + / / / Class for Avg ( column_Name ) <nl> + / / / < / summary <nl> + internal class ExpressionAvg : ExpressionAggregate <nl> { <nl> - public ExpressionAvg ( string exp1 ) <nl> + public ExpressionAvg ( string exp1 ) <nl> { <nl> ParseParameters ( exp1 ) ; <nl> } <nl> <nl> - / / / < summary > <nl> - / / / This is used from ExpressionStdDev for evaluating avg . <nl> - / / / < / summary > <nl> - public ExpressionAvg ( ExpressionElement E ) <nl> - { <nl> - Elements . Add ( E ) ; <nl> - } <nl> - <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow [ ] rows ) <nl> { <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> - object value1 = E1 . Result ( Row ) ; <nl> + object value1 = E1 . Result ( rows [ 0 ] ) ; <nl> Type original = value1 . GetType ( ) ; <nl> object result = null ; <nl> <nl> - if ( E1 is ExpressionSingleElement ) { <nl> + if ( E1 is ExpressionSingleElement ) <nl> + { <nl> <nl> Type t1 = null ; <nl> / / This should be optimized somehow <nl> - foreach ( DataRow tempRow in Row . Table . Rows ) { <nl> + for ( int i = 0 ; i < rows . Length ; i + + ) <nl> + { <nl> <nl> / / TODO : other types and exceptions <nl> - object v = E1 . Result ( tempRow ) ; <nl> + object v = E1 . Result ( rows [ i ] ) ; <nl> <nl> if ( v = = null | | v = = DBNull . Value ) <nl> continue ; <nl> public override object Result ( DataRow Row ) <nl> if ( result = = null ) <nl> result = 0 ; <nl> <nl> - if ( t1 = = typeof ( long ) ) { <nl> + if ( t1 = = typeof ( long ) ) <nl> + { <nl> result = ( long ) result + ( long ) v ; <nl> } <nl> - else if ( t1 = = typeof ( int ) ) { <nl> + else if ( t1 = = typeof ( int ) ) <nl> + { <nl> result = ( int ) result + ( int ) v ; <nl> } <nl> - else if ( t1 = = typeof ( short ) ) { <nl> + else if ( t1 = = typeof ( short ) ) <nl> + { <nl> result = ( short ) result + ( short ) v ; <nl> } <nl> - else if ( t1 = = typeof ( double ) ) { <nl> + else if ( t1 = = typeof ( double ) ) <nl> + { <nl> result = ( double ) result + ( double ) v ; <nl> } <nl> - else if ( t1 = = typeof ( float ) ) { <nl> + else if ( t1 = = typeof ( float ) ) <nl> + { <nl> result = ( float ) result + ( float ) v ; <nl> } <nl> else <nl> public override object Result ( DataRow Row ) <nl> <nl> / / TODO : types <nl> <nl> - if ( t1 = = typeof ( long ) ) <nl> - result = ( long ) result / Row . Table . Rows . Count ; <nl> - else if ( t1 = = typeof ( int ) ) <nl> - result = ( int ) result / Row . Table . Rows . Count ; <nl> - else if ( t1 = = typeof ( short ) ) <nl> - result = ( short ) result / Row . Table . Rows . Count ; <nl> - else if ( t1 = = typeof ( double ) ) <nl> - result = ( double ) result / Row . Table . Rows . Count ; <nl> + if ( t1 = = typeof ( long ) ) <nl> + result = ( long ) result / rows . Length ; <nl> + else if ( t1 = = typeof ( int ) ) <nl> + result = ( int ) result / rows . Length ; <nl> + else if ( t1 = = typeof ( short ) ) <nl> + result = ( short ) result / rows . Length ; <nl> + else if ( t1 = = typeof ( double ) ) <nl> + result = ( double ) result / rows . Length ; <nl> } <nl> <nl> return result ; <nl> - } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / This is used from ExpressionStdDev for evaluating avg . <nl> + / / / < / summary > <nl> + public ExpressionAvg ( ExpressionElement E ) <nl> + { <nl> + Elements . Add ( E ) ; <nl> + } <nl> + <nl> } <nl> <nl> - / / / < summary > <nl> - / / / Class for Min ( column_Name ) <nl> - / / / < / summary <nl> - internal class ExpressionMin : ExpressionAggregate <nl> + / / / < summary > <nl> + / / / Class for Min ( column_Name ) <nl> + / / / < / summary <nl> + internal class ExpressionMin : ExpressionAggregate <nl> { <nl> - public ExpressionMin ( string exp1 ) <nl> + public ExpressionMin ( string exp1 ) <nl> { <nl> ParseParameters ( exp1 ) ; <nl> } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow [ ] rows ) <nl> { <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> - object value1 = E1 . Result ( Row ) ; <nl> + object value1 = E1 . Result ( rows [ 0 ] ) ; <nl> Type original = value1 . GetType ( ) ; <nl> object result = null ; <nl> <nl> - if ( E1 is ExpressionSingleElement ) { <nl> + if ( E1 is ExpressionSingleElement ) <nl> + { <nl> <nl> Type t1 = null ; <nl> / / This should be optimized somehow <nl> - foreach ( DataRow tempRow in Row . Table . Rows ) { <nl> + for ( int i = 0 ; i < rows . Length ; i + + ) <nl> + { <nl> <nl> / / TODO : other types and exceptions <nl> - object v = E1 . Result ( tempRow ) ; <nl> + object v = E1 . Result ( rows [ i ] ) ; <nl> <nl> if ( v = = null | | v = = DBNull . Value ) <nl> continue ; <nl> public override object Result ( DataRow Row ) <nl> result = 0 ; <nl> <nl> object CompResult = t1 . InvokeMember ( \" CompareTo \" , BindingFlags . Default | <nl> - BindingFlags . InvokeMethod , null , <nl> - v , <nl> - new object [ ] { result } ) ; <nl> + BindingFlags . InvokeMethod , null , <nl> + v , <nl> + new object [ ] { result } ) ; <nl> <nl> if ( ( int ) CompResult < 0 ) <nl> result = v ; <nl> public override object Result ( DataRow Row ) <nl> } <nl> <nl> return result ; <nl> - } <nl> + } <nl> + <nl> + <nl> } <nl> <nl> - / / / < summary > <nl> - / / / Class for Max ( column_Name ) <nl> - / / / < / summary <nl> - internal class ExpressionMax : ExpressionAggregate <nl> + / / / < summary > <nl> + / / / Class for Max ( column_Name ) <nl> + / / / < / summary <nl> + internal class ExpressionMax : ExpressionAggregate <nl> { <nl> - public ExpressionMax ( string exp1 ) <nl> + public ExpressionMax ( string exp1 ) <nl> { <nl> ParseParameters ( exp1 ) ; <nl> } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow [ ] rows ) <nl> { <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> - object value1 = E1 . Result ( Row ) ; <nl> + object value1 = E1 . Result ( rows [ 0 ] ) ; <nl> Type original = value1 . GetType ( ) ; <nl> object result = null ; <nl> <nl> - if ( E1 is ExpressionSingleElement ) { <nl> + if ( E1 is ExpressionSingleElement ) <nl> + { <nl> <nl> Type t1 = null ; <nl> / / This should be optimized somehow <nl> - foreach ( DataRow tempRow in Row . Table . Rows ) { <nl> + for ( int i = 0 ; i < rows . Length ; i + + ) <nl> + { <nl> <nl> / / TODO : other types and exceptions <nl> - object v = E1 . Result ( tempRow ) ; <nl> + object v = E1 . Result ( rows [ i ] ) ; <nl> <nl> if ( v = = null | | v = = DBNull . Value ) <nl> continue ; <nl> public override object Result ( DataRow Row ) <nl> result = 0 ; <nl> <nl> object CompResult = t1 . InvokeMember ( \" CompareTo \" , BindingFlags . Default | <nl> - BindingFlags . InvokeMethod , null , <nl> - v , <nl> - new object [ ] { result } ) ; <nl> + BindingFlags . InvokeMethod , null , <nl> + v , <nl> + new object [ ] { result } ) ; <nl> <nl> if ( ( int ) CompResult > 0 ) <nl> result = v ; <nl> public override object Result ( DataRow Row ) <nl> } <nl> <nl> return result ; <nl> - } <nl> + } <nl> + <nl> + <nl> } <nl> <nl> <nl> - / / / < summary > <nl> - / / / Class for count ( column ) <nl> - / / / < / summary > <nl> - internal class ExpressionCount : ExpressionAggregate <nl> + / / / < summary > <nl> + / / / Class for count ( column ) <nl> + / / / < / summary > <nl> + internal class ExpressionCount : ExpressionAggregate <nl> { <nl> - public ExpressionCount ( string exp1 ) <nl> + public ExpressionCount ( string exp1 ) <nl> { <nl> ParseParameters ( exp1 ) ; <nl> } <nl> + <nl> + public override object Result ( DataRow [ ] rows ) <nl> + { <nl> + ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> + int count = 0 ; <nl> <nl> - public override object Result ( DataRow Row ) <nl> + if ( E1 is ExpressionSingleElement ) <nl> + count = rows . Length ; <nl> + <nl> + return count ; <nl> + } <nl> + <nl> + public override object Result ( DataRow Row ) <nl> { <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> int count = 0 ; <nl> <nl> - if ( E1 is ExpressionSingleElement ) { <nl> + if ( E1 is ExpressionSingleElement ) <nl> + { <nl> <nl> - / / This should be optimized somehow <nl> - foreach ( DataRow tempRow in Row . Table . Rows ) { <nl> - <nl> - count + + ; <nl> - } <nl> + count = Row . Table . Rows . Count ; <nl> } <nl> <nl> return count ; <nl> - } <nl> + } <nl> } <nl> <nl> <nl> - / / / < summary > <nl> - / / / Class for StdDev ( column ) <nl> - / / / < / summary > <nl> - internal class ExpressionStdev : ExpressionAggregate <nl> + / / / < summary > <nl> + / / / Class for StdDev ( column ) <nl> + / / / < / summary > <nl> + internal class ExpressionStdev : ExpressionAggregate <nl> { <nl> - public ExpressionStdev ( string exp1 ) <nl> + public ExpressionStdev ( string exp1 ) <nl> { <nl> ParseParameters ( exp1 ) ; <nl> } <nl> - <nl> - public override object Result ( DataRow Row ) <nl> + <nl> + public override object Result ( DataRow [ ] rows ) <nl> { <nl> - ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> + ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionAvg Avg = new ExpressionAvg ( E1 ) ; <nl> <nl> - object tempAvg = Avg . Result ( Row ) ; <nl> + object tempAvg = Avg . Result ( rows [ 0 ] ) ; <nl> double avg = 0 ; <nl> double sum = 0 ; <nl> double result = 0 ; <nl> public override object Result ( DataRow Row ) <nl> if ( tempAvg . GetType ( ) = = typeof ( int ) ) <nl> avg = ( double ) ( int ) tempAvg ; <nl> <nl> - if ( E1 is ExpressionSingleElement ) { <nl> - <nl> - foreach ( DataRow tempRow in Row . Table . Rows ) { <nl> + if ( E1 is ExpressionSingleElement ) <nl> + { <nl> <nl> - <nl> - / / ( value - avg )  <nl> - object v = E1 . Result ( tempRow ) ; <nl> + for ( int i = 0 ; i < rows . Length ; i + + ) <nl> + { <nl> + / / ( value - avg )  <nl> + object v = E1 . Result ( rows [ i ] ) ; <nl> <nl> if ( v = = null | | v = = DBNull . Value ) <nl> continue ; <nl> public override object Result ( DataRow Row ) <nl> result + = Math . Pow ( sum , 2 ) ; <nl> } <nl> <nl> - result = result / ( Row . Table . Rows . Count - 1 ) ; <nl> + result = result / ( rows . Length - 1 ) ; <nl> result = Math . Sqrt ( result ) ; <nl> } <nl> <nl> return result ; <nl> - } <nl> + } <nl> + <nl> + <nl> } <nl> <nl> - / / / < summary > <nl> - / / / Class for Var ( column ) <nl> - / / / < / summary > <nl> - internal class ExpressionVar : ExpressionAggregate <nl> + / / / < summary > <nl> + / / / Class for Var ( column ) <nl> + / / / < / summary > <nl> + internal class ExpressionVar : ExpressionAggregate <nl> { <nl> - public ExpressionVar ( string exp1 ) <nl> + public ExpressionVar ( string exp1 ) <nl> { <nl> ParseParameters ( exp1 ) ; <nl> } <nl> - <nl> - public override object Result ( DataRow Row ) <nl> + <nl> + public override object Result ( DataRow [ ] rows ) <nl> { <nl> - ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> + ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionAvg Avg = new ExpressionAvg ( E1 ) ; <nl> <nl> - object tempAvg = Avg . Result ( Row ) ; <nl> + object tempAvg = Avg . Result ( rows [ 0 ] ) ; <nl> double avg = 0 ; <nl> double sum = 0 ; <nl> double result = 0 ; <nl> public override object Result ( DataRow Row ) <nl> if ( tempAvg . GetType ( ) = = typeof ( int ) ) <nl> avg = ( double ) ( int ) tempAvg ; <nl> <nl> - if ( E1 is ExpressionSingleElement ) { <nl> + if ( E1 is ExpressionSingleElement ) <nl> + { <nl> <nl> - foreach ( DataRow tempRow in Row . Table . Rows ) { <nl> + for ( int i = 0 ; i < rows . Length ; i + + ) <nl> + { <nl> <nl> <nl> - / / ( value - avg )  <nl> - object v = E1 . Result ( tempRow ) ; <nl> + / / ( value - avg )  <nl> + object v = E1 . Result ( rows [ i ] ) ; <nl> <nl> if ( v = = null | | v = = DBNull . Value ) <nl> continue ; <nl> public override object Result ( DataRow Row ) <nl> result + = Math . Pow ( sum , 2 ) ; <nl> } <nl> <nl> - result = result / ( Row . Table . Rows . Count - 1 ) ; <nl> + result = result / ( rows . Length - 1 ) ; <nl> } <nl> <nl> return result ; <nl> - } <nl> + } <nl> + <nl> + <nl> } <nl> <nl> - / / <nl> - / / _____F_U_ N_C_T_I_O_N_S_______ <nl> - / / <nl> - <nl> - / / / < summary > <nl> - / / / Class for len ( string ) function <nl> - / / / < / summary > <nl> - internal class ExpressionLen : ExpressionElement <nl> - { <nl> - public ExpressionLen ( string exp1 ) <nl> - { <nl> + / / <nl> + / / _____F_U_ N_C_T_I_O_N_S_______ <nl> + / / <nl> + <nl> + / / / < summary > <nl> + / / / Class for len ( string ) function <nl> + / / / < / summary > <nl> + internal class ExpressionLen : ExpressionElement <nl> + { <nl> + public ExpressionLen ( string exp1 ) <nl> + { <nl> _ResultType = typeof ( int ) ; <nl> - ParseParameters ( exp1 ) ; <nl> - } <nl> + ParseParameters ( exp1 ) ; <nl> + } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow Row ) <nl> { <nl> ExpressionElement E1 = ( ( ExpressionElement ) Elements [ 0 ] ) ; <nl> object value1 = E1 . Result ( Row ) ; <nl> <nl> return value1 . ToString ( ) . Length ; <nl> - } <nl> + } <nl> <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> <nl> - public void ParseParameters ( string s ) <nl> + public void ParseParameters ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> bool inString = false ; <nl> public void ParseParameters ( string s ) <nl> / / remove ( <nl> s = s . Remove ( 0 , 1 ) ; <nl> int parentheses = 0 ; <nl> - for ( int i = 0 ; i < s . Length ; i + + ) { <nl> + for ( int i = 0 ; i < s . Length ; i + + ) <nl> + { <nl> <nl> if ( s [ i ] = = ' \\ ' ' ) <nl> inString = ! inString ; <nl> public void ParseParameters ( string s ) <nl> else if ( s [ i ] = = ' ) ' ) <nl> parentheses - - ; <nl> <nl> - if ( ( s [ i ] = = ' , ' | | s [ i ] = = ' ) ' ) & & ! inString & & parentheses = = - 1 ) { / / Parameter changed <nl> + if ( ( s [ i ] = = ' , ' | | s [ i ] = = ' ) ' ) & & ! inString & & parentheses = = - 1 ) <nl> + { <nl> + / / Parameter changed <nl> <nl> - if ( p1 = = null ) { <nl> + if ( p1 = = null ) <nl> + { <nl> p1 = s . Substring ( 0 , i ) ; <nl> break ; <nl> } <nl> public void ParseParameters ( string s ) <nl> <nl> ParseExpression ( p1 ) ; <nl> } <nl> - } <nl> + } <nl> <nl> - / / / < summary > <nl> - / / / Class for iif ( exp1 , truepart , falsepart ) function <nl> - / / / < / summary > <nl> - internal class ExpressionIif : ExpressionElement <nl> - { <nl> - public ExpressionIif ( string exp ) <nl> - { <nl> + / / / < summary > <nl> + / / / Class for iif ( exp1 , truepart , falsepart ) function <nl> + / / / < / summary > <nl> + internal class ExpressionIif : ExpressionElement <nl> + { <nl> + public ExpressionIif ( string exp ) <nl> + { <nl> ParseParameters ( exp ) ; <nl> - } <nl> + } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow Row ) <nl> { <nl> ExpressionElement E1 = ( ( ExpressionElement ) Elements [ 0 ] ) ; <nl> ExpressionElement E2 = ( ( ExpressionElement ) Elements [ 1 ] ) ; <nl> public override object Result ( DataRow Row ) <nl> return E2 . Result ( Row ) ; / / truepart <nl> else <nl> return E3 . Result ( Row ) ; / / false part <nl> - } <nl> + } <nl> <nl> - / / This method is shouldnt never invoked <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> + / / This method is shouldnt never invoked <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> <nl> - public override Type ResultType ( DataRow Row ) <nl> + public override Type ResultType ( DataRow Row ) <nl> { <nl> ExpressionElement E1 = ( ( ExpressionElement ) Elements [ 0 ] ) ; <nl> ExpressionElement E2 = ( ( ExpressionElement ) Elements [ 1 ] ) ; <nl> public override Type ResultType ( DataRow Row ) <nl> / / / < summary > <nl> / / / Parses expressions in parameters ( exp , truepart , falsepart ) <nl> / / / < / summary > <nl> - private void ParseParameters ( string s ) <nl> + private void ParseParameters ( string s ) <nl> { <nl> bool inString = false ; <nl> string stemp = s . ToLower ( ) ; <nl> private void ParseParameters ( string s ) <nl> / / remove ( <nl> s = s . Remove ( 0 , 1 ) ; <nl> int parentheses = 0 ; <nl> - for ( int i = 0 ; i < s . Length ; i + + ) { <nl> + for ( int i = 0 ; i < s . Length ; i + + ) <nl> + { <nl> <nl> if ( s [ i ] = = ' \\ ' ' ) <nl> inString = ! inString ; <nl> private void ParseParameters ( string s ) <nl> parentheses - - ; <nl> <nl> if ( ( s [ i ] = = ' , ' & & ! inString & & parentheses = = 0 ) | | <nl> - ( s [ i ] = = ' ) ' & & i = = ( s . Length - 1 ) ) ) { / / Parameter changed <nl> + ( s [ i ] = = ' ) ' & & i = = ( s . Length - 1 ) ) ) <nl> + { <nl> + / / Parameter changed <nl> <nl> - if ( p1 = = null ) { <nl> + if ( p1 = = null ) <nl> + { <nl> p1 = s . Substring ( 0 , i ) ; <nl> s = s . Substring ( i + 1 ) ; <nl> i = 0 ; <nl> } <nl> <nl> - else if ( p2 = = null ) { <nl> + else if ( p2 = = null ) <nl> + { <nl> p2 = s . Substring ( 0 , i ) ; <nl> s = s . Substring ( i + 1 ) ; <nl> i = 0 ; <nl> } <nl> <nl> - else if ( p3 = = null ) { <nl> + else if ( p3 = = null ) <nl> + { <nl> p3 = s . Substring ( 0 , i ) ; <nl> s = s . Substring ( i + 1 ) ; <nl> i = 0 ; <nl> private void ParseParameters ( string s ) <nl> ParseExpression ( p2 ) ; <nl> ParseExpression ( p3 ) ; <nl> } <nl> - } <nl> + } <nl> <nl> - / / / < summary > <nl> - / / / Class for isnull ( expression , returnvalue ) function <nl> - / / / < / summary > <nl> - internal class ExpressionIsNull : ExpressionElement <nl> - { <nl> - public ExpressionIsNull ( string exp ) <nl> - { <nl> + / / / < summary > <nl> + / / / Class for isnull ( expression , returnvalue ) function <nl> + / / / < / summary > <nl> + internal class ExpressionIsNull : ExpressionElement <nl> + { <nl> + public ExpressionIsNull ( string exp ) <nl> + { <nl> ParseParameters ( exp ) ; <nl> - } <nl> + } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow Row ) <nl> { <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionElement E2 = ( ExpressionElement ) Elements [ 1 ] ; <nl> public override object Result ( DataRow Row ) <nl> return E2 . Result ( Row ) ; <nl> else <nl> return R1 ; <nl> - } <nl> + } <nl> <nl> - public override Type ResultType ( DataRow Row ) <nl> + public override Type ResultType ( DataRow Row ) <nl> { <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionElement E2 = ( ExpressionElement ) Elements [ 1 ] ; <nl> public override Type ResultType ( DataRow Row ) <nl> / / / < summary > <nl> / / / IsNull function does not return boolean value , so throw exception <nl> / / / < / summary > <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> <nl> / / / < summary > <nl> / / / Parses parameters of function and invoke ParseExpression methods <nl> / / / < / summary > <nl> - private void ParseParameters ( string s ) <nl> + private void ParseParameters ( string s ) <nl> { <nl> bool inString = false ; <nl> string stemp = s . ToLower ( ) ; <nl> private void ParseParameters ( string s ) <nl> / / remove ( <nl> s = s . Remove ( 0 , 1 ) ; <nl> int parentheses = 0 ; <nl> - for ( int i = 0 ; i < s . Length ; i + + ) { <nl> + for ( int i = 0 ; i < s . Length ; i + + ) <nl> + { <nl> <nl> if ( s [ i ] = = ' \\ ' ' ) <nl> inString = ! inString ; <nl> private void ParseParameters ( string s ) <nl> parentheses - - ; <nl> <nl> if ( ( s [ i ] = = ' , ' & & ! inString & & parentheses = = 0 ) | | <nl> - ( s [ i ] = = ' ) ' & & i = = ( s . Length - 1 ) ) ) { / / Parameter changed <nl> + ( s [ i ] = = ' ) ' & & i = = ( s . Length - 1 ) ) ) <nl> + { <nl> + / / Parameter changed <nl> <nl> - if ( p1 = = null ) { <nl> + if ( p1 = = null ) <nl> + { <nl> p1 = s . Substring ( 0 , i ) ; <nl> s = s . Substring ( i + 1 ) ; <nl> i = 0 ; <nl> } <nl> <nl> - else if ( p2 = = null ) { <nl> + else if ( p2 = = null ) <nl> + { <nl> p2 = s . Substring ( 0 , i ) ; <nl> s = s . Substring ( i + 1 ) ; <nl> i = 0 ; <nl> private void ParseParameters ( string s ) <nl> ParseExpression ( p1 ) ; <nl> ParseExpression ( p2 ) ; <nl> } <nl> - } <nl> + } <nl> <nl> - / / / < summary > <nl> - / / / Class for Substring ( expression , start , length ) function <nl> - / / / < / summary > <nl> - internal class ExpressionSubstring : ExpressionElement <nl> - { <nl> - public ExpressionSubstring ( string exp ) <nl> - { <nl> + / / / < summary > <nl> + / / / Class for Substring ( expression , start , length ) function <nl> + / / / < / summary > <nl> + internal class ExpressionSubstring : ExpressionElement <nl> + { <nl> + public ExpressionSubstring ( string exp ) <nl> + { <nl> ParseParameters ( exp ) ; <nl> _ResultType = typeof ( string ) ; <nl> - } <nl> + } <nl> <nl> - public override object Result ( DataRow Row ) <nl> + public override object Result ( DataRow Row ) <nl> { <nl> ExpressionElement E1 = ( ExpressionElement ) Elements [ 0 ] ; <nl> ExpressionElement E2 = ( ExpressionElement ) Elements [ 1 ] ; <nl> public override object Result ( DataRow Row ) <nl> Type t3 = value3 . GetType ( ) ; <nl> <nl> if ( value1 = = null | | value2 = = null | | value3 = = null <nl> - | | value1 = = DBNull . Value | | value2 = = DBNull . Value | | value3 = = DBNull . Value ) <nl> + | | value1 = = DBNull . Value | | value2 = = DBNull . Value | | value3 = = DBNull . Value ) <nl> return string . Empty ; <nl> <nl> if ( t1 ! = typeof ( string ) ) <nl> public override object Result ( DataRow Row ) <nl> <nl> if ( str . Length < start ) <nl> str = string . Empty ; <nl> - else { <nl> + else <nl> + { <nl> if ( ( start + length - 1 ) > str . Length ) <nl> str = str . Substring ( start - 1 ) ; <nl> else <nl> public override object Result ( DataRow Row ) <nl> } <nl> <nl> return str ; <nl> - } <nl> + } <nl> <nl> / / / < summary > <nl> / / / IsNull function does not return boolean value , so throw exception <nl> / / / < / summary > <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> <nl> / / / < summary > <nl> / / / Parses parameters of function and invoke ParseExpression methods <nl> / / / < / summary > <nl> - private void ParseParameters ( string s ) <nl> + private void ParseParameters ( string s ) <nl> { <nl> bool inString = false ; <nl> string stemp = s . ToLower ( ) ; <nl> private void ParseParameters ( string s ) <nl> / / remove ( <nl> s = s . Remove ( 0 , 1 ) ; <nl> int parentheses = 0 ; <nl> - for ( int i = 0 ; i < s . Length ; i + + ) { <nl> + for ( int i = 0 ; i < s . Length ; i + + ) <nl> + { <nl> <nl> if ( s [ i ] = = ' \\ ' ' ) <nl> inString = ! inString ; <nl> private void ParseParameters ( string s ) <nl> <nl> <nl> if ( ( s [ i ] = = ' , ' & & ! inString & & parentheses = = 0 ) | | <nl> - ( s [ i ] = = ' ) ' & & i = = ( s . Length - 1 ) ) ) { / / Parameter changed <nl> + ( s [ i ] = = ' ) ' & & i = = ( s . Length - 1 ) ) ) <nl> + { <nl> + / / Parameter changed <nl> <nl> - if ( p1 = = null ) { <nl> + if ( p1 = = null ) <nl> + { <nl> p1 = s . Substring ( 0 , i ) ; <nl> s = s . Substring ( i + 1 ) ; <nl> i = 0 ; <nl> } <nl> <nl> - else if ( p2 = = null ) { <nl> + else if ( p2 = = null ) <nl> + { <nl> p2 = s . Substring ( 0 , i ) ; <nl> s = s . Substring ( i + 1 ) ; <nl> i = 0 ; <nl> } <nl> <nl> - else if ( p3 = = null ) { <nl> + else if ( p3 = = null ) <nl> + { <nl> p3 = s . Substring ( 0 , i ) ; <nl> s = s . Substring ( i + 1 ) ; <nl> i = 0 ; <nl> private void ParseParameters ( string s ) <nl> ParseExpression ( p2 ) ; <nl> ParseExpression ( p3 ) ; <nl> } <nl> - } <nl> + } <nl> <nl> / / / < summary > <nl> / / / Class for In ( exp , exp , exp , . . . ) function <nl> / / / < / summary > <nl> - internal class ExpressionIn : ExpressionElement <nl> + internal class ExpressionIn : ExpressionElement <nl> { <nl> - public ExpressionIn ( string exp1 , string exp2 ) <nl> + public ExpressionIn ( string exp1 , string exp2 ) <nl> { <nl> ParseExpression ( exp1 ) ; <nl> ParseParameters ( exp2 ) ; <nl> public override bool Test ( DataRow Row ) <nl> ExpressionElement E ; <nl> ExpressionElement columnElement = ( ExpressionElement ) Elements [ 0 ] ; <nl> <nl> - for ( int i = 1 ; i < Elements . Count ; i + + ) <nl> + for ( int i = 1 ; i < Elements . Count ; i + + ) <nl> { <nl> E = ( ExpressionElement ) Elements [ i ] ; <nl> if ( ExpressionElement . Compare ( columnElement , E , Row ) = = 0 ) <nl> public override bool Test ( DataRow Row ) <nl> / / / < summary > <nl> / / / Parses parameters of function and invoke ParseExpression methods <nl> / / / < / summary > <nl> - private void ParseParameters ( string s ) <nl> + private void ParseParameters ( string s ) <nl> { <nl> bool inString = false ; <nl> ArrayList parameters = new ArrayList ( ) ; <nl> private void ParseParameters ( string s ) <nl> } <nl> } <nl> <nl> - / / / < summary > <nl> - / / / Class for just one element for example string , int , . . . <nl> - / / / < / summary > <nl> - internal class ExpressionSingleElement : ExpressionElement <nl> - { <nl> + / / / < summary > <nl> + / / / Class for just one element for example string , int , . . . <nl> + / / / < / summary > <nl> + internal class ExpressionSingleElement : ExpressionElement <nl> + { <nl> private object Element = null ; <nl> <nl> - public ExpressionSingleElement ( string s ) <nl> - { <nl> + public ExpressionSingleElement ( string s ) <nl> + { <nl> / / TODO : Every type should be checked <nl> - if ( s . StartsWith ( \" ' \" ) & & s . EndsWith ( \" ' \" ) ) { <nl> + if ( s . StartsWith ( \" ' \" ) & & s . EndsWith ( \" ' \" ) ) <nl> + { <nl> Element = s . Substring ( 1 , s . Length - 2 ) ; <nl> _ResultType = typeof ( string ) ; <nl> } <nl> - else if ( ! Char . IsDigit ( s [ 0 ] ) & & s [ 0 ] ! = ' - ' & & s [ 0 ] ! = ' + ' ) { <nl> + else if ( ! Char . IsDigit ( s [ 0 ] ) & & s [ 0 ] ! = ' - ' & & s [ 0 ] ! = ' + ' ) <nl> + { <nl> Element = s ; <nl> _ResultType = typeof ( DataColumn ) ; <nl> } <nl> - else if ( s . StartsWith ( \" # \" ) & & s . EndsWith ( \" # \" ) ) { <nl> + else if ( s . StartsWith ( \" # \" ) & & s . EndsWith ( \" # \" ) ) <nl> + { <nl> Element = DateTime . Parse ( s . Substring ( 1 , s . Length - 2 ) ) ; <nl> _ResultType = typeof ( DateTime ) ; <nl> } <nl> - else { <nl> - try { <nl> + else <nl> + { <nl> + try <nl> + { <nl> Element = int . Parse ( s ) ; <nl> _ResultType = typeof ( int ) ; <nl> - } catch { <nl> + } <nl> + catch <nl> + { <nl> Element = Decimal . Parse ( s ) ; <nl> _ResultType = typeof ( Decimal ) ; <nl> } <nl> } <nl> - } <nl> + } <nl> <nl> - public override object Result ( DataRow Row ) <nl> - { <nl> + public override object Result ( DataRow Row ) <nl> + { <nl> object Result = null ; <nl> - if ( ResultType ( Row ) = = typeof ( DataColumn ) ) { <nl> + if ( ResultType ( Row ) = = typeof ( DataColumn ) ) <nl> + { <nl> <nl> if ( ! Row . Table . Columns . Contains ( Element . ToString ( ) ) ) <nl> throw new EvaluateException ( \" Column name ' \" + Element . ToString ( ) + \" ' not found . \" ) ; <nl> - else <nl> + else <nl> { <nl> DataRowVersion rowVersion = DataRowVersion . Default ; <nl> / / if this row is deleted we get the original version , or else we get an exception . <nl> public override object Result ( DataRow Row ) <nl> else <nl> Result = Element ; <nl> <nl> - return Result ; <nl> - } <nl> + return Result ; <nl> + } <nl> <nl> - public override bool Test ( DataRow Row ) <nl> - { <nl> - throw new EvaluateException ( ) ; <nl> - } <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Parent class of all the elements of expression <nl> - / / / < / summary > <nl> - internal abstract class ExpressionElement <nl> - { <nl> + public override bool Test ( DataRow Row ) <nl> + { <nl> + throw new EvaluateException ( ) ; <nl> + } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Parent class of all the elements of expression <nl> + / / / < / summary > <nl> + internal abstract class ExpressionElement <nl> + { <nl> + enum OP { OPERATOR , OPERAND } ; <nl> + enum OPERATOR_TYPE { SYMBOLIC , LITERAL , UNDEFINED } ; <nl> + enum OPERAND_TYPE { NUMERIC , STRING , UNDEFINED } ; <nl> + <nl> / / <nl> / / TODO / FIXME : This class should be inherited more than once . I mean own subclass for operators , functions , . . . <nl> / / <nl> <nl> protected string exp1 ; <nl> - protected string exp2 ; <nl> + protected string exp2 ; <nl> protected Type _ResultType ; <nl> <nl> - protected ArrayList Elements = new ArrayList ( ) ; <nl> + protected ArrayList Elements = new ArrayList ( ) ; <nl> <nl> enum AGGREGATE { SUM , AVG , MIN , MAX , COUNT , STDEV , VAR } <nl> - / / protected ArrayList Singles = new ArrayList ( ) ; <nl> + / / protected ArrayList Singles = new ArrayList ( ) ; <nl> <nl> / / / < summary > <nl> / / / Tells does the current expressions match to current DataRow <nl> / / / < / summary > <nl> - abstract public bool Test ( DataRow Row ) ; <nl> + abstract public bool Test ( DataRow Row ) ; <nl> <nl> public virtual object Result ( DataRow Row ) { return null ; } <nl> <nl> - public virtual Type ResultType ( DataRow Row ) <nl> + public virtual Type ResultType ( DataRow Row ) <nl> { <nl> return _ResultType ; <nl> } <nl> <nl> - protected object CalculateResult ( DataRow Row ) <nl> + protected object CalculateResult ( DataRow Row ) <nl> { <nl> ExpressionElement E1 = ( ( ExpressionElement ) Elements [ 0 ] ) ; <nl> ExpressionElement E2 = ( ( ExpressionElement ) Elements [ 1 ] ) ; <nl> protected object CalculateResult ( DataRow Row ) <nl> Type t1 = value1 . GetType ( ) ; <nl> Type t2 = value2 . GetType ( ) ; <nl> <nl> - / / Check nulls <nl> + / / Check nulls <nl> if ( value1 = = DBNull . Value & & value2 = = DBNull . Value ) <nl> return null ; <nl> <nl> / / TODO : More types <nl> <nl> - if ( t1 = = typeof ( string ) | | t2 = = typeof ( string ) ) { <nl> + if ( t1 = = typeof ( string ) | | t2 = = typeof ( string ) ) <nl> + { <nl> <nl> if ( t1 ! = typeof ( string ) ) <nl> value1 = Convert . ChangeType ( value1 , Type . GetTypeCode ( t2 ) ) ; <nl> protected object CalculateResult ( DataRow Row ) <nl> <nl> Result = Calculate ( value1 , value2 , t1 ) ; <nl> <nl> - return Result ; <nl> + return Result ; <nl> } <nl> - protected virtual object Calculate ( object value1 , object value2 , Type TempType ) <nl> + protected virtual object Calculate ( object value1 , object value2 , Type TempType ) <nl> { <nl> return null ; <nl> } <nl> protected virtual object Calculate ( object value1 , object value2 , Type TempType ) <nl> / / / static method for comparing two ExpressionElement . This is used in = , < , > , < > , < = , > = elements . <nl> / / / If elements are equal returns 0 , if E1 is less that E2 , return - 1 else if E1 is greater 1 <nl> / / / < / summary > <nl> - protected static int Compare ( ExpressionElement E1 , ExpressionElement E2 , DataRow Row ) <nl> + protected static int Compare ( ExpressionElement E1 , ExpressionElement E2 , DataRow Row ) <nl> { <nl> int ReturnValue = 0 ; <nl> <nl> protected static int Compare ( ExpressionElement E1 , ExpressionElement E2 , DataRo <nl> Type RT1 = E1 . ResultType ( Row ) ; <nl> Type RT2 = E2 . ResultType ( Row ) ; <nl> <nl> - if ( t1 = = typeof ( string ) | | t2 = = typeof ( string ) ) { <nl> + if ( t1 = = typeof ( string ) | | t2 = = typeof ( string ) ) <nl> + { <nl> / / FIXME : If one of elements are string they both should be ? ? ? <nl> / / TempType = typeof ( string ) ; <nl> if ( t1 ! = typeof ( string ) ) <nl> protected static int Compare ( ExpressionElement E1 , ExpressionElement E2 , DataRo <nl> value2 = Convert . ChangeType ( value2 , Type . GetTypeCode ( t1 ) ) ; <nl> <nl> <nl> - if ( ! Row . Table . CaseSensitive ) { <nl> + if ( ! Row . Table . CaseSensitive ) <nl> + { <nl> value1 = ( ( string ) value1 ) . ToLower ( ) ; <nl> value2 = ( ( string ) value2 ) . ToLower ( ) ; <nl> } <nl> - } else if ( t1 ! = t2 ) { <nl> + } <nl> + else if ( t1 ! = t2 ) <nl> + { <nl> <nl> value2 = Convert . ChangeType ( value2 , Type . GetTypeCode ( t1 ) ) ; <nl> } <nl> <nl> object Result = t1 . InvokeMember ( \" CompareTo \" , BindingFlags . Default | <nl> - BindingFlags . InvokeMethod , null , <nl> - value1 , <nl> - new object [ ] { value2 } ) ; <nl> + BindingFlags . InvokeMethod , null , <nl> + value1 , <nl> + new object [ ] { value2 } ) ; <nl> ReturnValue = ( int ) Result ; <nl> <nl> return ReturnValue ; <nl> } <nl> <nl> + / / / < summary > <nl> + / / / Checks syntax of expression and throws exception if needed . <nl> + / / / Also removes whitespaces between operator elements for example : age < = 64 - - > age < = 64 <nl> + / / / < / summary > <nl> + internal static string ValidateExpression ( string s ) <nl> + { <nl> + / / <nl> + / / TODO : find out nice way to do this . This is NOT nice way : - P <nl> + / / <nl> + string temp = \" \" ; <nl> + OP op = OP . OPERAND ; <nl> + OPERATOR_TYPE operatorType = OPERATOR_TYPE . UNDEFINED ; <nl> + <nl> + string strOperator = \" \" ; <nl> + string strOperand = \" \" ; <nl> + int quotes = 0 ; <nl> + int parentheses = 0 ; <nl> + string newExp = \" \" ; <nl> + bool isDigit = false ; <nl> + bool litOperator = false ; <nl> + s = s . Trim ( ) ; <nl> + <nl> + for ( int i = 0 ; i < s . Length ; i + + ) <nl> + { <nl> + <nl> + char c = s [ i ] ; <nl> + <nl> + if ( c = = ' \\ ' ' ) <nl> + quotes + + ; <nl> + <nl> + if ( ( c = = ' \\ n ' | | c = = ' \\ t ' ) & & quotes = = 0 ) <nl> + c = ' ' ; <nl> + <nl> + if ( op = = OP . OPERAND & & c = = ' ( ' ) <nl> + parentheses + + ; <nl> + else if ( op = = OP . OPERAND & & c = = ' ) ' ) <nl> + parentheses - - ; <nl> + <nl> + if ( c = = ' ' & & op = = OP . OPERAND & & ( quotes % 2 ) = = 0 & & parentheses = = 0 ) <nl> + { <nl> + <nl> + op = OP . OPERATOR ; <nl> + newExp + = strOperand ; <nl> + strOperand = \" \" ; <nl> + strOperator = \" \" ; <nl> + } <nl> + <nl> + if ( op = = OP . OPERAND ) <nl> + { <nl> + <nl> + if ( ! Char . IsDigit ( c ) & & isDigit & & ( quotes % 2 ) = = 0 ) <nl> + { <nl> + <nl> + newExp + = strOperand ; <nl> + strOperand = \" \" ; <nl> + op = OP . OPERATOR ; <nl> + operatorType = OPERATOR_TYPE . UNDEFINED ; <nl> + } <nl> + else <nl> + strOperand + = c ; <nl> + } <nl> + <nl> + if ( op = = OP . OPERATOR ) <nl> + { <nl> + <nl> + isDigit = false ; <nl> + if ( operatorType = = OPERATOR_TYPE . UNDEFINED ) <nl> + { <nl> + <nl> + if ( c = = ' < ' | | c = = ' = ' | | c = = ' > ' | | c = = ' * ' | | c = = ' / ' | | c = = ' % ' <nl> + | | c = = ' - ' | | c = = ' + ' ) <nl> + <nl> + operatorType = OPERATOR_TYPE . SYMBOLIC ; <nl> + else if ( c ! = ' ' ) <nl> + operatorType = OPERATOR_TYPE . LITERAL ; <nl> + } <nl> + else if ( operatorType = = OPERATOR_TYPE . SYMBOLIC ) <nl> + { <nl> + <nl> + if ( c ! = ' < ' & & c ! = ' = ' & & c ! = ' > ' & & c ! = ' ' ) <nl> + { <nl> + <nl> + / / this is COPY - PASTE <nl> + op = OP . OPERAND ; <nl> + if ( ! newExp . EndsWith ( \" \" ) & & ! strOperator . StartsWith ( \" \" ) ) <nl> + strOperator = \" \" + strOperator ; <nl> + <nl> + newExp + = strOperator ; <nl> + <nl> + if ( Char . IsDigit ( c ) ) <nl> + isDigit = true ; <nl> + <nl> + strOperand = c . ToString ( ) ; <nl> + <nl> + strOperator = \" \" ; <nl> + continue ; <nl> + } <nl> + } <nl> + <nl> + if ( operatorType = = OPERATOR_TYPE . LITERAL & & c = = ' ' ) <nl> + { <nl> + op = OP . OPERAND ; <nl> + newExp + = strOperator ; <nl> + strOperand + = \" \" ; <nl> + strOperator = \" \" ; <nl> + } <nl> + <nl> + <nl> + if ( Char . IsDigit ( c ) & & operatorType ! = OPERATOR_TYPE . LITERAL ) <nl> + { <nl> + <nl> + op = OP . OPERAND ; <nl> + <nl> + if ( ! newExp . EndsWith ( \" \" ) & & ! strOperator . StartsWith ( \" \" ) ) <nl> + strOperator = \" \" + strOperator ; <nl> + newExp + = strOperator ; <nl> + strOperand = c . ToString ( ) ; <nl> + isDigit = true ; <nl> + strOperator = \" \" ; <nl> + } <nl> + <nl> + else if ( c ! = ' ' ) <nl> + strOperator + = c ; <nl> + } <nl> + } <nl> + <nl> + if ( op = = OP . OPERATOR ) <nl> + throw new SyntaxErrorException ( <nl> + \" Missing operand after ' \" + strOperator + \" ' operator \" ) ; <nl> + else <nl> + newExp + = strOperand ; <nl> + <nl> + return newExp ; <nl> + } <nl> + <nl> / / / < summary > <nl> / / / Finds and creates Expression elements . <nl> / / / This presumes that expression is valid . <nl> / / / < / summary > <nl> - protected void ParseExpression ( string s ) <nl> + protected void ParseExpression ( string s ) <nl> { <nl> / / <nl> / / TODO / FIXME : IMHO , this should be done with different kind of parsing : <nl> protected void ParseExpression ( string s ) <nl> int temp = - 1 ; <nl> <nl> / / Find parenthesis <nl> - if ( ( temp = s . IndexOf ( \" ( \" ) ) ! = - 1 ) { <nl> + if ( ( temp = s . IndexOf ( \" ( \" ) ) ! = - 1 ) <nl> + { <nl> <nl> string functionName = \" \" ; <nl> while ( temp ! = 0 & & s [ temp - 1 ] ! = ' = ' ) <nl> temp - - ; <nl> <nl> / / Get the previous element of expression <nl> - while ( s [ temp ] ! = ' ( ' ) { <nl> + while ( s [ temp ] ! = ' ( ' ) <nl> + { <nl> char c = s [ temp ] ; <nl> functionName = functionName + c ; <nl> temp + + ; <nl> protected void ParseExpression ( string s ) <nl> <nl> / / check if previous element is a function <nl> if ( ! functionName . EndsWith ( \" convert \" ) & & ! functionName . EndsWith ( \" len \" ) & & <nl> - ! functionName . EndsWith ( \" isnull \" ) & & ! functionName . EndsWith ( \" iif \" ) & & <nl> - ! functionName . EndsWith ( \" trim \" ) & & ! functionName . EndsWith ( \" substring \" ) & & <nl> - ! functionName . EndsWith ( \" sum \" ) & & ! functionName . EndsWith ( \" avg \" ) & & <nl> - ! functionName . EndsWith ( \" min \" ) & & ! functionName . EndsWith ( \" max \" ) & & <nl> - ! functionName . EndsWith ( \" count \" ) & & ! functionName . EndsWith ( \" stdev \" ) & & <nl> - ! functionName . EndsWith ( \" var \" ) & & ! functionName . EndsWith ( \" in \" ) ) { <nl> + ! functionName . EndsWith ( \" isnull \" ) & & ! functionName . EndsWith ( \" iif \" ) & & <nl> + ! functionName . EndsWith ( \" trim \" ) & & ! functionName . EndsWith ( \" substring \" ) & & <nl> + ! functionName . EndsWith ( \" sum \" ) & & ! functionName . EndsWith ( \" avg \" ) & & <nl> + ! functionName . EndsWith ( \" min \" ) & & ! functionName . EndsWith ( \" max \" ) & & <nl> + ! functionName . EndsWith ( \" count \" ) & & ! functionName . EndsWith ( \" stdev \" ) & & <nl> + ! functionName . EndsWith ( \" var \" ) & & ! functionName . EndsWith ( \" in \" ) ) <nl> + { <nl> <nl> int startIndex = s . IndexOf ( \" ( \" ) ; <nl> int i = startIndex + 1 ; <nl> int par = 1 ; <nl> char c ; <nl> - while ( par > 0 ) { <nl> + while ( par > 0 ) <nl> + { <nl> <nl> c = s [ i ] ; <nl> if ( c = = ' ( ' ) <nl> protected void ParseExpression ( string s ) <nl> else if ( FindAndElement ( s , ref string1 , ref string2 ) ) <nl> CreateAndElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find LIKE <nl> + / / find LIKE <nl> else if ( FindLikeElement ( s , ref string1 , ref string2 ) ) <nl> CreateLikeElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find IN <nl> + / / find IN <nl> else if ( FindInElement ( s , ref string1 , ref string2 ) ) <nl> CreateInElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find = <nl> + / / find = <nl> else if ( FindEqualElement ( s , ref string1 , ref string2 ) ) <nl> CreateEqualsElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find < > <nl> + / / find < > <nl> else if ( FindUnequalElement ( s , ref string1 , ref string2 ) ) <nl> CreateUnequalsElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find < = <nl> + / / find < = <nl> else if ( FindLessThanOrEqualElement ( s , ref string1 , ref string2 ) ) <nl> CreateLessThanOrEqualElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find < <nl> + / / find < <nl> else if ( FindLessThanElement ( s , ref string1 , ref string2 ) ) <nl> CreateLessThanElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find > = <nl> + / / find > = <nl> else if ( FindGreaterThanOrEqualElement ( s , ref string1 , ref string2 ) ) <nl> CreateGreaterThanOrEqualElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find > <nl> + / / find > <nl> else if ( FindGreaterThanElement ( s , ref string1 , ref string2 ) ) <nl> CreateGreaterThanElement ( string1 , string2 , inside ) ; <nl> <nl> - / / if there wasn ' t any operators like ' and ' or ' not ' there still could be <nl> - / / arithmetic operators like ' + ' or ' - ' or functions like ' iif ' or ' substring ' <nl> + / / if there wasn ' t any operators like ' and ' or ' not ' there still could be <nl> + / / arithmetic operators like ' + ' or ' - ' or functions like ' iif ' or ' substring ' <nl> <nl> - / / find * <nl> + / / find * <nl> else if ( FindMultiplyElement ( s , ref string1 , ref string2 ) ) <nl> CreateMultiplyElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find / <nl> + / / find / <nl> else if ( FindDivideElement ( s , ref string1 , ref string2 ) ) <nl> CreateDivideElement ( string1 , string2 , inside ) ; <nl> <nl> <nl> - / / find + <nl> + / / find + <nl> else if ( FindAdditionElement ( s , ref string1 , ref string2 ) ) <nl> - CreateAdditionElement ( string1 , string2 , inside ) ; <nl> + CreateAdditionElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find - <nl> + / / find - <nl> else if ( FindSubtractElement ( s , ref string1 , ref string2 ) ) <nl> CreateSubtractionElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find % <nl> + / / find % <nl> else if ( FindModulusElement ( s , ref string1 , ref string2 ) ) <nl> CreateModulusElement ( string1 , string2 , inside ) ; <nl> <nl> - / / find sum ( ) <nl> + / / find sum ( ) <nl> else if ( FindAggregateElement ( s , AGGREGATE . SUM ) ) <nl> Elements . Add ( new ExpressionSum ( s . Trim ( ) ) ) ; <nl> <nl> - / / find avg ( ) <nl> + / / find avg ( ) <nl> else if ( FindAggregateElement ( s , AGGREGATE . AVG ) ) <nl> Elements . Add ( new ExpressionAvg ( s . Trim ( ) ) ) ; <nl> <nl> - / / find min ( ) <nl> + / / find min ( ) <nl> else if ( FindAggregateElement ( s , AGGREGATE . MIN ) ) <nl> Elements . Add ( new ExpressionMin ( s . Trim ( ) ) ) ; <nl> <nl> - / / find max ( ) <nl> + / / find max ( ) <nl> else if ( FindAggregateElement ( s , AGGREGATE . MAX ) ) <nl> Elements . Add ( new ExpressionMax ( s . Trim ( ) ) ) ; <nl> <nl> - / / find count ( ) <nl> + / / find count ( ) <nl> else if ( FindAggregateElement ( s , AGGREGATE . COUNT ) ) <nl> Elements . Add ( new ExpressionCount ( s . Trim ( ) ) ) ; <nl> <nl> - / / find stdev ( ) <nl> + / / find stdev ( ) <nl> else if ( FindAggregateElement ( s , AGGREGATE . STDEV ) ) <nl> Elements . Add ( new ExpressionStdev ( s . Trim ( ) ) ) ; <nl> <nl> - / / find var ( ) <nl> + / / find var ( ) <nl> else if ( FindAggregateElement ( s , AGGREGATE . VAR ) ) <nl> Elements . Add ( new ExpressionVar ( s . Trim ( ) ) ) ; <nl> <nl> - / / find len <nl> + / / find len <nl> else if ( FindLenElement ( s ) ) <nl> Elements . Add ( new ExpressionLen ( s . Trim ( ) ) ) ; <nl> <nl> - / / find iif <nl> + / / find iif <nl> else if ( FindIifElement ( s ) ) <nl> Elements . Add ( new ExpressionIif ( s . Trim ( ) ) ) ; <nl> <nl> - / / find isnull <nl> + / / find isnull <nl> else if ( FindIsNullElement ( s ) ) <nl> Elements . Add ( new ExpressionIsNull ( s . Trim ( ) ) ) ; <nl> <nl> - / / find substring <nl> + / / find substring <nl> else if ( FindSubstringElement ( s ) ) <nl> Elements . Add ( new ExpressionSubstring ( s . Trim ( ) ) ) ; <nl> <nl> - / / if expression is like ' ( something someoperator something ) ' <nl> + / / if expression is like ' ( something someoperator something ) ' <nl> else if ( inside . Trim ( ) ! = string . Empty ) <nl> ParseExpression ( inside ) ; <nl> <nl> - / / At least , if it wasnt any of the above it is just normat string or int <nl> - / / or . . . . <nl> + / / At least , if it wasnt any of the above it is just normat string or int <nl> + / / or . . . . <nl> else <nl> Elements . Add ( new ExpressionSingleElement ( s . Trim ( ) ) ) ; <nl> } <nl> protected void ParseExpression ( string s ) <nl> / / These methods are temporary for now <nl> / / <nl> <nl> - private bool FindOrElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindOrElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" or \" ) ; <nl> private bool FindOrElement ( string s , ref string s1 , ref string s2 ) <nl> <nl> / / Test if or is between ' ' <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" or \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" or \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> <nl> private bool FindOrElement ( string s , ref string s1 , ref string s2 ) <nl> continue ; <nl> <nl> / / Check is or part of something else for example column name <nl> - if ( indexOf ! = 0 ) { <nl> + if ( indexOf ! = 0 ) <nl> + { <nl> <nl> if ( stemp [ indexOf - 1 ] ! = ' ' & & stemp [ indexOf - 1 ] ! = ' \\ ' ' ) <nl> continue ; <nl> } <nl> <nl> - if ( indexOf < s . Length + 2 ) { <nl> + if ( indexOf < s . Length + 2 ) <nl> + { <nl> <nl> if ( stemp [ indexOf + 2 ] ! = ' ' & & stemp [ indexOf + 2 ] ! = ' \\ ' ' ) <nl> continue ; <nl> private bool FindOrElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindAndElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindAndElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" and \" ) ; <nl> private bool FindAndElement ( string s , ref string s1 , ref string s2 ) <nl> <nl> / / Test if or is between ' ' <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" and \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" and \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> <nl> private bool FindAndElement ( string s , ref string s1 , ref string s2 ) <nl> <nl> <nl> / / Check is or part of something else for example column name <nl> - if ( indexOf ! = 0 ) { <nl> + if ( indexOf ! = 0 ) <nl> + { <nl> <nl> if ( stemp [ indexOf - 1 ] ! = ' ' & & stemp [ indexOf - 1 ] ! = ' \\ ' ' ) <nl> continue ; <nl> } <nl> <nl> - if ( indexOf < stemp . Length + 3 ) { <nl> + if ( indexOf < stemp . Length + 3 ) <nl> + { <nl> <nl> if ( stemp [ indexOf + 3 ] ! = ' ' & & stemp [ indexOf + 3 ] ! = ' \\ ' ' ) <nl> continue ; <nl> private bool FindAndElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindLikeElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindLikeElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" like \" ) ; <nl> private bool FindLikeElement ( string s , ref string s1 , ref string s2 ) <nl> <nl> / / Test if or is between ' ' <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" like \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" like \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> <nl> private bool FindLikeElement ( string s , ref string s1 , ref string s2 ) <nl> <nl> <nl> / / Check is or part of something else for example column name <nl> - if ( indexOf ! = 0 ) { <nl> + if ( indexOf ! = 0 ) <nl> + { <nl> <nl> if ( stemp [ indexOf - 1 ] ! = ' ' & & stemp [ indexOf - 1 ] ! = ' \\ ' ' ) <nl> continue ; <nl> } <nl> <nl> - if ( indexOf < stemp . Length + 4 ) { <nl> + if ( indexOf < stemp . Length + 4 ) <nl> + { <nl> <nl> if ( stemp [ indexOf + 4 ] ! = ' ' & & stemp [ indexOf + 4 ] ! = ' \\ ' ' ) <nl> continue ; <nl> private bool FindLikeElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindEqualElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindEqualElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" = \" ) ; <nl> private bool FindEqualElement ( string s , ref string s1 , ref string s2 ) <nl> <nl> int oldIndex = - 1 ; <nl> <nl> - while ( ( indexOf = stemp . IndexOf ( \" = \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" = \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> <nl> private bool FindEqualElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindUnequalElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindUnequalElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" < > \" ) ; <nl> private bool FindUnequalElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" < > \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" < > \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> <nl> private bool FindUnequalElement ( string s , ref string s1 , ref string s2 ) <nl> } <nl> <nl> <nl> - private bool FindLessThanElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindLessThanElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" < \" ) ; <nl> private bool FindLessThanElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" < \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" < \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> <nl> private bool FindLessThanElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindLessThanOrEqualElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindLessThanOrEqualElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" < = \" ) ; <nl> private bool FindLessThanOrEqualElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" < = \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" < = \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> / / Test is < = element part of string element <nl> private bool FindLessThanOrEqualElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindGreaterThanElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindGreaterThanElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" > \" ) ; <nl> private bool FindGreaterThanElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" > \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" > \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> <nl> private bool FindGreaterThanElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindGreaterThanOrEqualElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindGreaterThanOrEqualElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" > = \" ) ; <nl> private bool FindGreaterThanOrEqualElement ( string s , ref string s1 , ref string <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" > = \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" > = \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindGreaterThanOrEqualElement ( string s , ref string s1 , ref string <nl> return false ; <nl> } <nl> <nl> - private bool FindAdditionElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindAdditionElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" + \" ) ; <nl> private bool FindAdditionElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" + \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" + \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> / / FIXME : if ' + ' represents sign of integer <nl> <nl> private bool FindAdditionElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindSubtractElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindSubtractElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" - \" ) ; <nl> private bool FindSubtractElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" - \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" - \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> <nl> / / check is this lonely element <nl> failed = true ; <nl> - for ( int i = indexOf - 1 ; i > = 0 ; i - - ) { <nl> - if ( stemp [ i ] ! = ' ' ) { <nl> + for ( int i = indexOf - 1 ; i > = 0 ; i - - ) <nl> + { <nl> + if ( stemp [ i ] ! = ' ' ) <nl> + { <nl> failed = false ; <nl> break ; <nl> } <nl> private bool FindSubtractElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindMultiplyElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindMultiplyElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" * \" ) ; <nl> private bool FindMultiplyElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" * \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" * \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> <nl> oldIndex = indexOf ; <nl> private bool FindMultiplyElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindDivideElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindDivideElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" / \" ) ; <nl> private bool FindDivideElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" / \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" / \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> <nl> oldIndex = indexOf ; <nl> private bool FindDivideElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindModulusElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindModulusElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" % \" ) ; <nl> private bool FindModulusElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" % \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" % \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> <nl> oldIndex = indexOf ; <nl> private bool FindModulusElement ( string s , ref string s1 , ref string s2 ) <nl> return false ; <nl> } <nl> <nl> - private bool FindAggregateElement ( string s , AGGREGATE aggregate ) <nl> + private bool FindAggregateElement ( string s , AGGREGATE aggregate ) <nl> { <nl> string agg = null ; <nl> <nl> - switch ( aggregate ) { <nl> + switch ( aggregate ) <nl> + { <nl> <nl> - case AGGREGATE . SUM : <nl> - agg = \" sum \" ; <nl> + case AGGREGATE . SUM : <nl> + agg = \" sum \" ; <nl> + break ; <nl> + case AGGREGATE . AVG : <nl> + agg = \" avg \" ; <nl> break ; <nl> - case AGGREGATE . AVG : <nl> - agg = \" avg \" ; <nl> - break ; <nl> - case AGGREGATE . MIN : <nl> - agg = \" min \" ; <nl> - break ; <nl> - case AGGREGATE . MAX : <nl> - agg = \" max \" ; <nl> - break ; <nl> - case AGGREGATE . COUNT : <nl> - agg = \" count \" ; <nl> - break ; <nl> - case AGGREGATE . STDEV : <nl> - agg = \" stdev \" ; <nl> - break ; <nl> - case AGGREGATE . VAR : <nl> - agg = \" var \" ; <nl> - break ; <nl> - default : <nl> + case AGGREGATE . MIN : <nl> + agg = \" min \" ; <nl> + break ; <nl> + case AGGREGATE . MAX : <nl> + agg = \" max \" ; <nl> + break ; <nl> + case AGGREGATE . COUNT : <nl> + agg = \" count \" ; <nl> + break ; <nl> + case AGGREGATE . STDEV : <nl> + agg = \" stdev \" ; <nl> + break ; <nl> + case AGGREGATE . VAR : <nl> + agg = \" var \" ; <nl> + break ; <nl> + default : <nl> throw new NotImplementedException ( ) ; <nl> } <nl> <nl> private bool FindAggregateElement ( string s , AGGREGATE aggregate ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( agg , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( agg , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindAggregateElement ( string s , AGGREGATE aggregate ) <nl> <nl> } <nl> <nl> - private bool FindSumElement ( string s ) <nl> + private bool FindSumElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" sum \" ) ; <nl> private bool FindSumElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" sum \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" sum \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindSumElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindAvgElement ( string s ) <nl> + private bool FindAvgElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" avg \" ) ; <nl> private bool FindAvgElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" avg \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" avg \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindAvgElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindMinElement ( string s ) <nl> + private bool FindMinElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" min \" ) ; <nl> private bool FindMinElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" min \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" min \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindMinElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindMaxElement ( string s ) <nl> + private bool FindMaxElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" max \" ) ; <nl> private bool FindMaxElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" max \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" max \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindMaxElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindCountElement ( string s ) <nl> + private bool FindCountElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" count \" ) ; <nl> private bool FindCountElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" count \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" count \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindCountElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindStdevElement ( string s ) <nl> + private bool FindStdevElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" stdev \" ) ; <nl> private bool FindStdevElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" stdev \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" stdev \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindStdevElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindVarElement ( string s ) <nl> + private bool FindVarElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" var \" ) ; <nl> private bool FindVarElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" var \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" var \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindVarElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindLenElement ( string s ) <nl> + private bool FindLenElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" len \" ) ; <nl> private bool FindLenElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" len \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" len \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindLenElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindIifElement ( string s ) <nl> + private bool FindIifElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" iif \" ) ; <nl> private bool FindIifElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" iif \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" iif \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindIifElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindIsNullElement ( string s ) <nl> + private bool FindIsNullElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" isnull \" ) ; <nl> private bool FindIsNullElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" isnull \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" isnull \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindIsNullElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindSubstringElement ( string s ) <nl> + private bool FindSubstringElement ( string s ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" substring \" ) ; <nl> private bool FindSubstringElement ( string s ) <nl> return false ; <nl> <nl> int oldIndex = - 1 ; <nl> - while ( ( indexOf = stemp . IndexOf ( \" substring \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) { <nl> + while ( ( indexOf = stemp . IndexOf ( \" substring \" , oldIndex + 1 ) ) ! = - 1 & & indexOf > oldIndex ) <nl> + { <nl> <nl> oldIndex = indexOf ; <nl> bool failed = false ; <nl> private bool FindSubstringElement ( string s ) <nl> return false ; <nl> } <nl> <nl> - private bool FindInElement ( string s , ref string s1 , ref string s2 ) <nl> + private bool FindInElement ( string s , ref string s1 , ref string s2 ) <nl> { <nl> string stemp = s . ToLower ( ) ; <nl> int indexOf = stemp . IndexOf ( \" in \" ) ; <nl> private void CreateOrElement ( string s1 , string s2 , string inside ) <nl> Elements . Add ( new ExpressionOr ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateAndElement ( string s1 , string s2 , string inside ) <nl> + private void CreateAndElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionAnd ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateLikeElement ( string s1 , string s2 , string inside ) <nl> + private void CreateLikeElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionLike ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateInElement ( string s1 , string s2 , string inside ) <nl> + private void CreateInElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionIn ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateEqualsElement ( string s1 , string s2 , string inside ) <nl> + private void CreateEqualsElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionEquals ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateUnequalsElement ( string s1 , string s2 , string inside ) <nl> + private void CreateUnequalsElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionUnequals ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateLessThanElement ( string s1 , string s2 , string inside ) <nl> + private void CreateLessThanElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionLessThan ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateLessThanOrEqualElement ( string s1 , string s2 , string inside ) <nl> + private void CreateLessThanOrEqualElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionLessThanOrEqual ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateGreaterThanElement ( string s1 , string s2 , string inside ) <nl> + private void CreateGreaterThanElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionGreaterThan ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> <nl> - private void CreateGreaterThanOrEqualElement ( string s1 , string s2 , string inside ) <nl> + private void CreateGreaterThanOrEqualElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionGreaterThanOrEqual ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> private void CreateAdditionElement ( string s1 , string s2 , string inside ) <nl> Elements . Add ( new ExpressionAddition ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateSubtractionElement ( string s1 , string s2 , string inside ) <nl> + private void CreateSubtractionElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionSubtraction ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateMultiplyElement ( string s1 , string s2 , string inside ) <nl> + private void CreateMultiplyElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionMultiply ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateDivideElement ( string s1 , string s2 , string inside ) <nl> + private void CreateDivideElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionDivide ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> } <nl> <nl> - private void CreateModulusElement ( string s1 , string s2 , string inside ) <nl> + private void CreateModulusElement ( string s1 , string s2 , string inside ) <nl> { <nl> CheckParenthesis ( inside , ref s1 , ref s2 ) ; <nl> Elements . Add ( new ExpressionModulus ( s1 . Trim ( ) , s2 . Trim ( ) ) ) ; <nl> private void CreateModulusElement ( string s1 , string s2 , string inside ) <nl> <nl> # region Little helppers <nl> <nl> - private void CheckParenthesis ( string inside , ref string s1 , ref string s2 ) <nl> + private void CheckParenthesis ( string inside , ref string s1 , ref string s2 ) <nl> { <nl> if ( s1 = = string . Empty & & inside ! = string . Empty ) <nl> s1 = inside ; <nl> private bool IsPartOfStringElement ( string s , int indexOf ) <nl> { <nl> / / count how many ' - charachters are before or . If count is odd it means or IS between quotes <nl> int quotes = 0 ; <nl> - for ( int i = indexOf - 1 ; i > = 0 ; i - - ) { <nl> + for ( int i = indexOf - 1 ; i > = 0 ; i - - ) <nl> + { <nl> if ( s [ i ] = = ' \\ ' ' ) <nl> quotes + + ; <nl> } <nl> private bool IsPartOfStringElement ( string s , int indexOf ) <nl> / / / < summary > <nl> / / / Checks is the element part of column table <nl> / / / < / summary > <nl> - private bool IsPartOfColumnName ( string s , int indexOf ) <nl> + private bool IsPartOfColumnName ( string s , int indexOf ) <nl> { <nl> - for ( int i = indexOf ; i > = 0 ; i - - ) { <nl> + for ( int i = indexOf ; i > = 0 ; i - - ) <nl> + { <nl> <nl> / / If the element is between [ ] it is part of columnname <nl> - if ( s [ i ] = = ' \\ ' ' | | s [ i ] = = ' ] ' ) { <nl> + if ( s [ i ] = = ' \\ ' ' | | s [ i ] = = ' ] ' ) <nl> + { <nl> break ; <nl> } <nl> - else if ( s [ i ] = = ' [ ' ) { <nl> + else if ( s [ i ] = = ' [ ' ) <nl> + { <nl> return true ; <nl> } <nl> } <nl> private bool IsPartOfColumnName ( string s , int indexOf ) <nl> / / / < summary > <nl> / / / Checks are element part of function <nl> / / / < / summary > <nl> - private bool IsPartOfFunction ( string s , int indexOf ) <nl> + private bool IsPartOfFunction ( string s , int indexOf ) <nl> { <nl> <nl> / / <nl> / / If ' , ' or ' \\ ' ' comes before ' ( ' this element is not part of function ' s parameters <nl> / / <nl> <nl> - for ( int i = indexOf ; i > = 0 ; i - - ) { <nl> + for ( int i = indexOf ; i > = 0 ; i - - ) <nl> + { <nl> <nl> - if ( s [ i ] = = ' ( ' | | s [ i ] = = ' , ' ) { <nl> + if ( s [ i ] = = ' ( ' | | s [ i ] = = ' , ' ) <nl> + { <nl> return true ; <nl> } <nl> - else if ( s [ i ] = = ' ) ' ) { <nl> + else if ( s [ i ] = = ' ) ' ) <nl> + { <nl> break ; <nl> } <nl> } <nl> private bool IsPartOfFunction ( string s , int indexOf ) <nl> } <nl> <nl> # endregion / / Little helppers <nl> - } <nl> + } <nl> } <nl>\n", "msg": "ExpressionElement . cs ( ValidateExpression ) : Turning ValidateExpression to static .\n"}
{"diff_id": 20882, "repo": "gitextensions/gitextensions\n", "sha": "808c292567cc4b716a23abc73f089a9a5896a1ee\n", "time": "2010-11-22T19:51:55Z\n", "diff": "mmm a / GitUI / FormSettings . cs <nl> ppp b / GitUI / FormSettings . cs <nl> private bool CheckGitExtensionsInstall ( ) <nl> <nl> private static IEnumerable < string > GetWindowsCommandLocations ( ) <nl> { <nl> + yield return @ \" C : \\ cygwin \\ bin \\ git . exe \" ; <nl> yield return @ \" C : \\ cygwin \\ bin \\ git \" ; <nl> yield return GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ Microsoft \\ \\ Windows \\ \\ CurrentVersion \\ \\ Uninstall \\ \\ Git_is1 \" , \" InstallLocation \" ) + \" bin \\ \\ git . exe \" ; <nl> yield return @ \" c : \\ Program Files ( x86 ) \\ Git \\ bin \\ git . exe \" ; <nl> private static IEnumerable < string > GetWindowsCommandLocations ( ) <nl> yield return @ \" c : \\ Program Files \\ Git \\ cmd \\ git . cmd \" ; <nl> yield return \" git \" ; <nl> yield return \" git . cmd \" ; <nl> + yield return @ \" C : \\ msysgit \\ bin \\ git . exe \" ; <nl> + yield return @ \" C : \\ msysgit \\ cmd \\ git . cmd \" ; <nl> } <nl> <nl> private static bool SolveGitCommand ( ) <nl>\n", "msg": "Added several common paths to searchpath for git . exe .\n"}
{"diff_id": 21208, "repo": "duplicati/duplicati\n", "sha": "be1f5ef805d6f5a05d8cbbb3682580a291bb771e\n", "time": "2014-08-07T19:02:23Z\n", "diff": "mmm a / Duplicati / Library / AutoUpdater / UpdaterManager . cs <nl> ppp b / Duplicati / Library / AutoUpdater / UpdaterManager . cs <nl> public static bool DownloadAndUnpackUpdate ( UpdateInfo version , Action < double > pr <nl> if ( INSTALLDIR = = null ) <nl> return false ; <nl> <nl> + <nl> + var updates = version . RemoteURLS . ToList ( ) ; <nl> + <nl> + / / If alternate update URLs are specified , <nl> + / / we look for packages there as well <nl> + if ( AutoUpdateSettings . UsesAlternateURLs ) <nl> + { <nl> + var packagepath = new Library . Utility . Uri ( updates [ 0 ] ) . Path ; <nl> + var packagename = packagepath . Split ( ' / ' ) . Last ( ) ; <nl> + <nl> + foreach ( var alt_url in AutoUpdateSettings . URLs . Reverse ( ) ) <nl> + { <nl> + var alt_uri = new Library . Utility . Uri ( alt_url ) ; <nl> + var path_components = alt_uri . Path . Split ( ' / ' ) ; <nl> + var path = string . Join ( \" / \" , path_components . Take ( path_components . Count ( ) - 1 ) . Union ( new string [ ] { packagename } ) ) ; <nl> + <nl> + var new_path = alt_uri . SetPath ( path ) ; <nl> + updates . Insert ( 0 , new_path . ToString ( ) ) ; <nl> + } <nl> + } <nl> + <nl> using ( var tempfile = new Library . Utility . TempFile ( ) ) <nl> { <nl> - foreach ( var url in version . RemoteURLS ) <nl> + foreach ( var url in updates ) <nl> { <nl> try <nl> { <nl>\n", "msg": "Added check to allow storing update packages on a local server for enterprise - like setups .\n"}
{"diff_id": 21342, "repo": "ppy/osu\n", "sha": "898802340787ec59b212d8d0e7aa955ed797da88\n", "time": "2020-12-04T05:35:56Z\n", "diff": "mmm a / osu . Game . Rulesets . Catch / UI / Catcher . cs <nl> ppp b / osu . Game . Rulesets . Catch / UI / Catcher . cs <nl> protected override void LoadComplete ( ) <nl> / / / < summary > <nl> / / / Calculates the scale of the catcher based off the provided beatmap difficulty . <nl> / / / < / summary > <nl> - private static Vector2 calculateScale ( BeatmapDifficulty difficulty ) <nl> - = > new Vector2 ( 1 . 0f - 0 . 7f * ( difficulty . CircleSize - 5 ) / 5 ) ; <nl> + private static Vector2 calculateScale ( BeatmapDifficulty difficulty ) = > new Vector2 ( 1 . 0f - 0 . 7f * ( difficulty . CircleSize - 5 ) / 5 ) ; <nl> <nl> / / / < summary > <nl> / / / Calculates the width of the area used for attempting catches in gameplay . <nl> / / / < / summary > <nl> / / / < param name = \" scale \" > The scale of the catcher . < / param > <nl> - internal static float CalculateCatchWidth ( Vector2 scale ) <nl> - = > CatcherArea . CATCHER_SIZE * Math . Abs ( scale . X ) * ALLOWED_CATCH_RANGE ; <nl> + internal static float CalculateCatchWidth ( Vector2 scale ) = > CatcherArea . CATCHER_SIZE * Math . Abs ( scale . X ) * ALLOWED_CATCH_RANGE ; <nl> <nl> / / / < summary > <nl> / / / Calculates the width of the area used for attempting catches in gameplay . <nl> / / / < / summary > <nl> / / / < param name = \" difficulty \" > The beatmap difficulty . < / param > <nl> - internal static float CalculateCatchWidth ( BeatmapDifficulty difficulty ) <nl> - = > CalculateCatchWidth ( calculateScale ( difficulty ) ) ; <nl> - <nl> - / / / < summary > <nl> - / / / Add a caught fruit to the catcher ' s stack . <nl> - / / / < / summary > <nl> - / / / < param name = \" fruit \" > The fruit that was caught . < / param > <nl> - public void PlaceOnPlate ( DrawablePalpableCatchHitObject fruit ) <nl> - { <nl> - var ourRadius = fruit . DisplayRadius ; <nl> - float theirRadius = 0 ; <nl> - <nl> - const float allowance = 10 ; <nl> - <nl> - while ( caughtFruitContainer . Any ( f = > <nl> - Vector2Extensions . Distance ( f . Position , fruit . Position ) < ( ourRadius + ( theirRadius = CatchHitObject . OBJECT_RADIUS / 2 ) ) / ( allowance / 2 ) ) ) <nl> - { <nl> - var diff = ( ourRadius + theirRadius ) / allowance ; <nl> - fruit . X + = ( RNG . NextSingle ( ) - 0 . 5f ) * diff * 2 ; <nl> - fruit . Y - = RNG . NextSingle ( ) * diff ; <nl> - } <nl> - <nl> - fruit . X = Math . Clamp ( fruit . X , - CatcherArea . CATCHER_SIZE / 2 , CatcherArea . CATCHER_SIZE / 2 ) ; <nl> - <nl> - caughtFruitContainer . Add ( fruit ) ; <nl> - <nl> - if ( hitLighting . Value ) <nl> - { <nl> - HitExplosion hitExplosion = hitExplosionPool . Get ( ) ; <nl> - hitExplosion . X = fruit . X ; <nl> - hitExplosion . Scale = new Vector2 ( fruit . HitObject . Scale ) ; <nl> - hitExplosion . ObjectColour = fruit . AccentColour . Value ; <nl> - hitExplosionContainer . Add ( hitExplosion ) ; <nl> - } <nl> - } <nl> + internal static float CalculateCatchWidth ( BeatmapDifficulty difficulty ) = > CalculateCatchWidth ( calculateScale ( difficulty ) ) ; <nl> <nl> / / / < summary > <nl> / / / Let the catcher attempt to catch a fruit . <nl> public void UpdatePosition ( float position ) <nl> public void Drop ( ) = > clearPlate ( DroppedObjectAnimation . Drop ) ; <nl> <nl> / / / < summary > <nl> - / / / Explode any fruit off the plate . <nl> + / / / Explode all fruit off the plate . <nl> / / / < / summary > <nl> public void Explode ( ) = > clearPlate ( DroppedObjectAnimation . Explode ) ; <nl> <nl> - public void Explode ( DrawablePalpableCatchHitObject caughtObject ) = > removeFromPlate ( caughtObject , DroppedObjectAnimation . Explode ) ; <nl> - <nl> protected override void SkinChanged ( ISkinSource skin , bool allowFallback ) <nl> { <nl> base . SkinChanged ( skin , allowFallback ) ; <nl> private void updateState ( CatcherAnimationState state ) <nl> private void placeCaughtObject ( PalpableCatchHitObject source ) <nl> { <nl> var caughtObject = createCaughtObject ( source ) ; <nl> + <nl> if ( caughtObject = = null ) return ; <nl> <nl> caughtObject . RelativePositionAxes = Axes . None ; <nl> private void placeCaughtObject ( PalpableCatchHitObject source ) <nl> caughtObject . LifetimeStart = source . StartTime ; <nl> caughtObject . LifetimeEnd = double . MaxValue ; <nl> <nl> - PlaceOnPlate ( caughtObject ) ; <nl> + adjustPositionInStack ( caughtObject ) ; <nl> + <nl> + caughtFruitContainer . Add ( caughtObject ) ; <nl> + <nl> + addLighting ( caughtObject ) ; <nl> <nl> if ( ! caughtObject . StaysOnPlate ) <nl> - Explode ( caughtObject ) ; <nl> + removeFromPlate ( caughtObject , DroppedObjectAnimation . Explode ) ; <nl> + } <nl> + <nl> + private void adjustPositionInStack ( DrawablePalpableCatchHitObject caughtObject ) <nl> + { <nl> + const float radius_div_2 = CatchHitObject . OBJECT_RADIUS / 2 ; <nl> + const float allowance = 10 ; <nl> + <nl> + float caughtObjectRadius = caughtObject . DisplayRadius ; <nl> + <nl> + while ( caughtFruitContainer . Any ( f = > Vector2Extensions . Distance ( f . Position , caughtObject . Position ) < ( caughtObjectRadius + radius_div_2 ) / ( allowance / 2 ) ) ) <nl> + { <nl> + float diff = ( caughtObjectRadius + radius_div_2 ) / allowance ; <nl> + <nl> + caughtObject . X + = ( RNG . NextSingle ( ) - 0 . 5f ) * diff * 2 ; <nl> + caughtObject . Y - = RNG . NextSingle ( ) * diff ; <nl> + } <nl> + <nl> + caughtObject . X = Math . Clamp ( caughtObject . X , - CatcherArea . CATCHER_SIZE / 2 , CatcherArea . CATCHER_SIZE / 2 ) ; <nl> + } <nl> + <nl> + private void addLighting ( DrawablePalpableCatchHitObject caughtObject ) <nl> + { <nl> + if ( ! hitLighting . Value ) return ; <nl> + <nl> + HitExplosion hitExplosion = hitExplosionPool . Get ( ) ; <nl> + hitExplosion . X = caughtObject . X ; <nl> + hitExplosion . Scale = new Vector2 ( caughtObject . HitObject . Scale ) ; <nl> + hitExplosion . ObjectColour = caughtObject . AccentColour . Value ; <nl> + hitExplosionContainer . Add ( hitExplosion ) ; <nl> } <nl> <nl> private DrawablePalpableCatchHitObject createCaughtObject ( PalpableCatchHitObject source ) <nl>\n", "msg": "Tidy up code formatting and remove unnecessarily publicly exposed methods\n"}
{"diff_id": 21655, "repo": "unoplatform/uno\n", "sha": "9e603aeb5065a6ef0783abbefe9428a2d64cb3d5\n", "time": "2020-06-03T13:51:17Z\n", "diff": "mmm a / src / SourceGenerators / Uno . UI . SourceGenerators / XamlGenerator / XamlFileGenerator . cs <nl> ppp b / src / SourceGenerators / Uno . UI . SourceGenerators / XamlGenerator / XamlFileGenerator . cs <nl> private void BuildTopLevelResourceDictionary ( IIndentedStringBuilder writer , Xaml <nl> { <nl> TryAnnotateWithGeneratorSource ( writer ) ; <nl> _isTopLevelDictionary = true ; <nl> - var globalResources = new Dictionary < string , XamlObjectDefinition > ( ) ; <nl> <nl> using ( Scope ( Path . GetFileNameWithoutExtension ( _fileDefinition . FilePath ) . Replace ( \" . \" , \" _ \" ) + \" RD \" ) ) <nl> { <nl> private void BuildTopLevelResourceDictionary ( IIndentedStringBuilder writer , Xaml <nl> AnalyzerSuppressionsGenerator . Generate ( writer , _analyzerSuppressions ) ; <nl> using ( writer . BlockInvariant ( \" public sealed partial class GlobalStaticResources \" ) ) <nl> { <nl> - globalResources . Merge ( ImportResourceDictionary ( writer , topLevelControl ) ) ; <nl> - <nl> BuildPartials ( writer , isStatic : true ) ; <nl> BuildResourceDictionaryGlobalProperties ( writer , topLevelControl ) ; <nl> <nl> private void BuildEmptyBackingClass ( IIndentedStringBuilder writer , XamlObjectDef <nl> } <nl> } <nl> <nl> - private Dictionary < string , XamlObjectDefinition > ImportResourceDictionary ( <nl> - IIndentedStringBuilder writer , <nl> - XamlObjectDefinition topLevelControl <nl> - ) <nl> - { <nl> - TryAnnotateWithGeneratorSource ( writer ) ; <nl> - var resources = new Dictionary < string , XamlObjectDefinition > ( ) ; <nl> - <nl> - XamlMemberDefinition contentNode ; <nl> - <nl> - if ( IsApplication ( topLevelControl . Type ) ) <nl> - { <nl> - contentNode = topLevelControl . Members . FirstOrDefault ( m = > m . Member . Name = = \" Resources \" ) ; <nl> - } <nl> - else <nl> - { <nl> - contentNode = FindMember ( topLevelControl , \" _UnknownContent \" ) ; <nl> - } <nl> - <nl> - if ( contentNode ! = null ) <nl> - { <nl> - foreach ( var resource in contentNode . Objects ) <nl> - { <nl> - var key = resource . Members . FirstOrDefault ( m = > m . Member . Name = = \" Key \" | | m . Member . Name = = \" Name \" ) ; <nl> - <nl> - if ( key ! = null ) <nl> - { <nl> - if ( ! resources . ContainsKey ( key . Value . ToString ( ) ) ) <nl> - { <nl> - resources . Add ( key . Value . ToString ( ) , resource ) ; <nl> - } <nl> - else <nl> - { <nl> - throw new InvalidOperationException ( $ \" Duplicate resource { key . Value . ToString ( ) } \" ) ; <nl> - } <nl> - } <nl> - else <nl> - { <nl> - if ( resource . Type . Name = = \" Style \" ) <nl> - { <nl> - var targetType = FindMember ( resource , \" TargetType \" ) ? . Value . ToString ( ) ; <nl> - <nl> - if ( targetType ! = null ) <nl> - { <nl> - var fullTargetType = FindType ( targetType ) . SelectOrDefault ( t = > t . ToDisplayString ( ) , targetType ) ; <nl> - <nl> - var keyName = ( ImplicitStyleMarker + fullTargetType ) . Replace ( \" . \" , \" _ \" ) ; <nl> - <nl> - if ( resources . ContainsKey ( keyName ) ) <nl> - { <nl> - throw new InvalidOperationException ( $ \" Implicit resource for { keyName } already exists \" ) ; <nl> - } <nl> - else <nl> - { <nl> - resources . Add ( keyName , resource ) ; <nl> - } <nl> - } <nl> - else <nl> - { <nl> - throw new InvalidOperationException ( \" The implicit resource must have a TargetType attribute \" ) ; <nl> - } <nl> - } <nl> - else if ( resource . Type . Name = = \" ResourceDictionary \" ) <nl> - { <nl> - / / ResourceDictionaries and MergedDictionaries are handled elsewhere <nl> - } <nl> - else <nl> - { <nl> - GenerateError ( <nl> - writer , <nl> - \" Implicit resource other than Style in inline resources are not supported ( { 0 } , Line { 1 } : { 2 } ) \" , <nl> - contentNode . Member . Type , <nl> - contentNode . LineNumber , <nl> - contentNode . LinePosition <nl> - ) ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - <nl> - return resources ; <nl> - } <nl> - <nl> / / / < summary > <nl> / / / Helper for building a lazily - initialized static property . <nl> / / / < / summary > <nl>\n", "msg": "chore ( styles ) : Remove unused generation code\n"}
{"diff_id": 21874, "repo": "Sonarr/Sonarr\n", "sha": "e00ec8b01be164003f2220f81f87c4abe55adff0\n", "time": "2015-02-10T22:30:47Z\n", "diff": "mmm a / src / NzbDrone . Core / DecisionEngine / DownloadDecisionMaker . cs <nl> ppp b / src / NzbDrone . Core / DecisionEngine / DownloadDecisionMaker . cs <nl> private IEnumerable < DownloadDecision > GetDecisions ( List < ReleaseInfo > reports , Se <nl> <nl> if ( remoteEpisode . Series ! = null ) <nl> { <nl> - remoteEpisode . DownloadAllowed = true ; <nl> + remoteEpisode . DownloadAllowed = remoteEpisode . Episodes . Any ( ) ; <nl> decision = GetDecisionForReport ( remoteEpisode , searchCriteria ) ; <nl> } <nl> else <nl>\n", "msg": "Manual search no longer permits downloading releases for which we can ' t find an episode until we can fix the association logic .\n"}
{"diff_id": 21981, "repo": "ServiceStack/ServiceStack\n", "sha": "c7503e96608882f7ac7c9acff80b8dae377ba8f2\n", "time": "2013-09-21T08:15:23Z\n", "diff": "mmm a / src / ServiceStack / Html / MvcHtmlString . cs <nl> ppp b / src / ServiceStack / Html / MvcHtmlString . cs <nl> <nl>  using System ; <nl> - using System . Linq . Expressions ; <nl> + using System . Diagnostics . CodeAnalysis ; <nl> using System . Web ; <nl> <nl> - namespace ServiceStack . Html <nl> + public sealed class MvcHtmlString : HtmlString <nl> { <nl> - public class MvcHtmlString <nl> - { <nl> - private delegate MvcHtmlString MvcHtmlStringCreator ( string value ) ; <nl> - private static readonly MvcHtmlStringCreator _creator = GetCreator ( ) ; <nl> - <nl> - / / imporant : this declaration must occur after the _creator declaration <nl> - public static readonly MvcHtmlString Empty = Create ( String . Empty ) ; <nl> - <nl> - private readonly string _value ; <nl> - <nl> - protected MvcHtmlString ( string value ) <nl> - { <nl> - _value = value ? ? String . Empty ; <nl> - } <nl> - <nl> - public static MvcHtmlString Create ( string value ) <nl> - { <nl> - return _creator ( value ) ; <nl> - } <nl> - <nl> - / / in . NET 4 , we dynamically create a type that subclasses MvcHtmlString and implements IHtmlString <nl> - private static MvcHtmlStringCreator GetCreator ( ) <nl> - { <nl> - var iHtmlStringType = typeof ( HttpContext ) . Assembly . GetType ( \" System . Web . IHtmlString \" ) ; <nl> - if ( iHtmlStringType ! = null ) <nl> - { <nl> - / / first , create the dynamic type <nl> - var dynamicType = DynamicTypeGenerator . GenerateType ( \" DynamicMvcHtmlString \" , typeof ( MvcHtmlString ) , new [ ] { iHtmlStringType } ) ; <nl> - <nl> - / / then , create the delegate to instantiate the dynamic type <nl> - var valueParamExpr = Expression . Parameter ( typeof ( string ) , \" value \" ) ; <nl> - var newObjExpr = Expression . New ( dynamicType . GetConstructor ( new [ ] { typeof ( string ) } ) , valueParamExpr ) ; <nl> - var lambdaExpr = Expression . Lambda < MvcHtmlStringCreator > ( newObjExpr , valueParamExpr ) ; <nl> - return lambdaExpr . Compile ( ) ; <nl> - } <nl> - else <nl> - { <nl> - / / disabling 0618 allows us to call the MvcHtmlString ( ) constructor <nl> - # pragma warning disable 0618 <nl> - return value = > new MvcHtmlString ( value ) ; <nl> - # pragma warning restore 0618 <nl> - } <nl> - } <nl> - <nl> - public static bool IsNullOrEmpty ( MvcHtmlString value ) <nl> - { <nl> - return ( value = = null | | value . _value . Length = = 0 ) ; <nl> - } <nl> - <nl> - / / IHtmlString . ToHtmlString ( ) <nl> - public string ToHtmlString ( ) <nl> - { <nl> - return _value ; <nl> - } <nl> - <nl> - public override string ToString ( ) <nl> - { <nl> - return _value ; <nl> - } <nl> - } <nl> - } <nl> + private readonly string _value ; <nl> + <nl> + public MvcHtmlString ( string value ) <nl> + : base ( value ? ? String . Empty ) <nl> + { <nl> + _value = value ? ? String . Empty ; <nl> + } <nl> + <nl> + [ SuppressMessage ( \" Microsoft . Security \" , \" CA2104 : DoNotDeclareReadOnlyMutableReferenceTypes \" , Justification = \" MvcHtmlString is immutable \" ) ] <nl> + public static readonly MvcHtmlString Empty = Create ( String . Empty ) ; <nl> + <nl> + public static MvcHtmlString Create ( string value ) <nl> + { <nl> + return new MvcHtmlString ( value ) ; <nl> + } <nl> + <nl> + public static bool IsNullOrEmpty ( MvcHtmlString value ) <nl> + { <nl> + return ( value = = null | | value . _value . Length = = 0 ) ; <nl> + } <nl> + } <nl> \\ No newline at end of file <nl>\n", "msg": "re - sync MvcHtmlString impl after runtime errors dynamically generating a class\n"}
{"diff_id": 22167, "repo": "ppy/osu\n", "sha": "1c7556ea5d67793c6f363a6e661b2d042896baf4\n", "time": "2020-09-20T17:40:30Z\n", "diff": "mmm a / osu . Game . Rulesets . Taiko / UI / TaikoPlayfield . cs <nl> ppp b / osu . Game . Rulesets . Taiko / UI / TaikoPlayfield . cs <nl> internal void OnNewResult ( DrawableHitObject judgedObject , JudgementResult result <nl> private void addDrumRollHit ( DrawableDrumRollTick drawableTick ) = > <nl> drumRollHitContainer . Add ( new DrawableFlyingHit ( drawableTick ) ) ; <nl> <nl> - private void addExplosion ( DrawableHitObject drawableObject , HitType type ) <nl> + / / / < remarks > <nl> + / / / As legacy skins have different explosions for singular and double strong hits , <nl> + / / / explosion addition is scheduled to ensure that both hits are processed if they occur on the same frame . <nl> + / / / < / remarks > <nl> + private void addExplosion ( DrawableHitObject drawableObject , HitType type ) = > Schedule ( ( ) = > <nl> { <nl> hitExplosionContainer . Add ( new HitExplosion ( drawableObject ) ) ; <nl> if ( drawableObject . HitObject . Kiai ) <nl> kiaiExplosionContainer . Add ( new KiaiHitExplosion ( drawableObject , type ) ) ; <nl> - } <nl> + } ) ; <nl> <nl> private class ProxyContainer : LifetimeManagementContainer <nl> { <nl>\n", "msg": "Schedule explosion addition to ensure both hits are processed\n"}
{"diff_id": 22312, "repo": "MonoGame/MonoGame\n", "sha": "ff39cd8e123d86557ef3d56a95096f5e42211988\n", "time": "2014-07-09T09:57:37Z\n", "diff": "mmm a / Tools / Pipeline / Common / PipelineController . cs <nl> ppp b / Tools / Pipeline / Common / PipelineController . cs <nl> internal partial class PipelineController : IController <nl> <nl> private readonly List < ContentItemTemplate > _templateItems ; <nl> <nl> + private static readonly string [ ] _mgcbSearchPaths = new [ ] <nl> + { <nl> + \" \" , <nl> + # if DEBUG <nl> + \" . . / . . / . . / . . / . . / MGCB / bin / Windows / AnyCPU / Debug \" , <nl> + # else <nl> + \" . . / . . / . . / . . / . . / MGCB / bin / Windows / AnyCPU / Release \" , <nl> + # endif <nl> + \" . . / MGCB \" , <nl> + } ; <nl> + <nl> public IEnumerable < ContentItemTemplate > Templates <nl> { <nl> get { return _templateItems ; } <nl> public void Clean ( ) <nl> _buildTask . ContinueWith ( ( e ) = > OnBuildFinished ( ) ) ; <nl> } <nl> <nl> + private string FindMGCB ( ) <nl> + { <nl> + foreach ( var root in _mgcbSearchPaths ) <nl> + { <nl> + var mgcbPath = Path . Combine ( root , \" MGCB . exe \" ) ; <nl> + if ( File . Exists ( mgcbPath ) ) <nl> + return mgcbPath ; <nl> + } <nl> + <nl> + throw new FileNotFoundException ( \" MGCB . exe is not in the search path ! \" ) ; <nl> + } <nl> + <nl> private void DoBuild ( string commands ) <nl> { <nl> - _buildProcess = new Process ( ) ; <nl> - _buildProcess . StartInfo . WorkingDirectory = Path . GetDirectoryName ( _project . OriginalPath ) ; <nl> - _buildProcess . StartInfo . FileName = \" MGCB . exe \" ; <nl> - _buildProcess . StartInfo . Arguments = commands ; <nl> - _buildProcess . StartInfo . CreateNoWindow = true ; <nl> - _buildProcess . StartInfo . WindowStyle = ProcessWindowStyle . Hidden ; <nl> - _buildProcess . StartInfo . UseShellExecute = false ; <nl> - _buildProcess . StartInfo . RedirectStandardOutput = true ; <nl> - _buildProcess . OutputDataReceived + = ( sender , args ) = > _view . OutputAppend ( args . Data ) ; <nl> - <nl> - / / string stdError = null ; <nl> try <nl> { <nl> + / / Prepare the process . <nl> + _buildProcess = new Process ( ) ; <nl> + _buildProcess . StartInfo . WorkingDirectory = Path . GetDirectoryName ( _project . OriginalPath ) ; <nl> + _buildProcess . StartInfo . FileName = FindMGCB ( ) ; <nl> + _buildProcess . StartInfo . Arguments = commands ; <nl> + _buildProcess . StartInfo . CreateNoWindow = true ; <nl> + _buildProcess . StartInfo . WindowStyle = ProcessWindowStyle . Hidden ; <nl> + _buildProcess . StartInfo . UseShellExecute = false ; <nl> + _buildProcess . StartInfo . RedirectStandardOutput = true ; <nl> + _buildProcess . OutputDataReceived + = ( sender , args ) = > _view . OutputAppend ( args . Data ) ; <nl> + <nl> + / / Fire off the process . <nl> _buildProcess . Start ( ) ; <nl> _buildProcess . BeginOutputReadLine ( ) ; <nl> _buildProcess . WaitForExit ( ) ; <nl> } <nl> catch ( Exception ex ) <nl> { <nl> - _view . OutputAppend ( \" Build process failed ! \" + Environment . NewLine ) ; <nl> - _view . OutputAppend ( ex . Message ) ; <nl> - _view . OutputAppend ( ex . StackTrace ) ; <nl> + / / If we got a message assume it has everything the user needs to know . <nl> + if ( ! string . IsNullOrEmpty ( ex . Message ) ) <nl> + _view . OutputAppend ( \" Build failed : \" + ex . Message ) ; <nl> + else <nl> + { <nl> + / / Else we need to get verbose . <nl> + _view . OutputAppend ( \" Build failed : \" + Environment . NewLine ) ; <nl> + _view . OutputAppend ( ex . ToString ( ) ) ; <nl> + } <nl> } <nl> <nl> / / Clear the process pointer , so that cancel <nl>\n", "msg": "We now try a few search paths to find MGCB .\n"}
{"diff_id": 22667, "repo": "AvaloniaUI/Avalonia\n", "sha": "43b94e997c9aa77b004480962e4ee34c8f2742b7\n", "time": "2020-08-18T09:28:13Z\n", "diff": "mmm a / src / Avalonia . Controls / TextBox . cs <nl> ppp b / src / Avalonia . Controls / TextBox . cs <nl> protected override void OnLostFocus ( RoutedEventArgs e ) <nl> SelectionEnd = 0 ; <nl> RevealPassword = false ; <nl> } <nl> - <nl> + <nl> _presenter ? . HideCaret ( ) ; <nl> } <nl> <nl> public string RemoveInvalidCharacters ( string text ) <nl> return text ; <nl> } <nl> <nl> - private async void Copy ( ) <nl> + public async void Cut ( ) <nl> + { <nl> + _undoRedoHelper . Snapshot ( ) ; <nl> + Copy ( ) ; <nl> + DeleteSelection ( ) ; <nl> + _undoRedoHelper . Snapshot ( ) ; <nl> + } <nl> + <nl> + public async void Copy ( ) <nl> { <nl> await ( ( IClipboard ) AvaloniaLocator . Current . GetService ( typeof ( IClipboard ) ) ) <nl> . SetTextAsync ( GetSelection ( ) ) ; <nl> } <nl> <nl> - private async void Paste ( ) <nl> + public async void Paste ( ) <nl> { <nl> var text = await ( ( IClipboard ) AvaloniaLocator . Current . GetService ( typeof ( IClipboard ) ) ) . GetTextAsync ( ) ; <nl> if ( text = = null ) <nl> protected override void OnKeyDown ( KeyEventArgs e ) <nl> { <nl> if ( ! IsPasswordBox ) <nl> { <nl> - _undoRedoHelper . Snapshot ( ) ; <nl> - Copy ( ) ; <nl> - DeleteSelection ( ) ; <nl> - _undoRedoHelper . Snapshot ( ) ; <nl> + Cut ( ) ; <nl> } <nl> <nl> handled = true ; <nl> } <nl> else if ( Match ( keymap . Paste ) ) <nl> { <nl> - <nl> Paste ( ) ; <nl> handled = true ; <nl> } <nl> else if ( Match ( keymap . Undo ) ) <nl> { <nl> - <nl> try <nl> { <nl> _isUndoingRedoing = true ; <nl>\n", "msg": "Expose Cut Copy and Paste methods for binding for context menus\n"}
{"diff_id": 23109, "repo": "ServiceStack/ServiceStack\n", "sha": "8571ecd6f7e244ee152e959e6759f6a1ee82fe4d\n", "time": "2014-12-20T01:19:44Z\n", "diff": "mmm a / src / ServiceStack / Host / Handlers / StaticFileHandler . cs <nl> ppp b / src / ServiceStack / Host / Handlers / StaticFileHandler . cs <nl> public override void ProcessRequest ( HttpContextBase context ) <nl> private DateTime DefaultFileModified { get ; set ; } <nl> private string DefaultFilePath { get ; set ; } <nl> private byte [ ] DefaultFileContents { get ; set ; } <nl> + public IVirtualNode VirtualNode { get ; set ; } <nl> <nl> / / / < summary > <nl> / / / Keep default file contents in - memory <nl> public override void ProcessRequest ( IRequest request , IResponse response , string <nl> <nl> response . EndHttpHandlerRequest ( skipClose : true , afterHeaders : r = > <nl> { <nl> - var node = request . GetVirtualNode ( ) ; <nl> + var node = this . VirtualNode ? ? request . GetVirtualNode ( ) ; <nl> var file = node as IVirtualFile ; <nl> if ( file = = null ) <nl> { <nl>\n", "msg": "Allow StaticFileHandler to be reusable by specifying VirtualNode to upload\n"}
{"diff_id": 23216, "repo": "Sonarr/Sonarr\n", "sha": "023eaca678ec8efbeae29514a5aec6c00dc3d506\n", "time": "2013-02-16T00:52:43Z\n", "diff": "mmm a / NzbDrone . Core / Providers / RootDirProvider . cs <nl> ppp b / NzbDrone . Core / Providers / RootDirProvider . cs <nl> public virtual RootDir Add ( RootDir rootDir ) <nl> var id = _database . Insert ( rootDir ) ; <nl> rootDir . Id = Convert . ToInt32 ( id ) ; <nl> rootDir . FreeSpace = _diskProvider . FreeDiskSpace ( new DirectoryInfo ( rootDir . Path ) ) ; <nl> + rootDir . UnmappedFolders = GetUnmappedFolders ( rootDir . Path ) ; <nl> <nl> return rootDir ; <nl> } <nl>\n", "msg": "add root dir now returns list of unmapped folders .\n"}
{"diff_id": 23362, "repo": "AvaloniaUI/Avalonia\n", "sha": "6ca33a86c57fcf9aaa412b1df454c276662ca3a9\n", "time": "2020-09-17T15:16:16Z\n", "diff": "mmm a / samples / ControlCatalog / Pages / DataGridPage . xaml . cs <nl> ppp b / samples / ControlCatalog / Pages / DataGridPage . xaml . cs <nl> public DataGridPage ( ) <nl> this . InitializeComponent ( ) ; <nl> <nl> var dataGridSortDescription = DataGridSortDescription . FromPath ( nameof ( Country . Region ) , ListSortDirection . Ascending , new ReversedStringComparer ( ) ) ; <nl> - var colelctionView1 = new DataGridCollectionView ( Countries . All ) ; <nl> + var collectionView1 = new DataGridCollectionView ( Countries . All ) ; <nl> colelctionView1 . SortDescriptions . Add ( dataGridSortDescription ) ; <nl> var dg1 = this . FindControl < DataGrid > ( \" dataGrid1 \" ) ; <nl> dg1 . IsReadOnly = true ; <nl>\n", "msg": "Update samples / ControlCatalog / Pages / DataGridPage . xaml . cs\n"}
{"diff_id": 23371, "repo": "dotnet/aspnetcore\n", "sha": "688914bb70063b97dcb2facdbc1ab91980406ece\n", "time": "2018-12-17T17:18:26Z\n", "diff": "mmm a / src / Testing / src / LoggedTest / LoggedTestBase . cs <nl> ppp b / src / Testing / src / LoggedTest / LoggedTestBase . cs <nl> <nl> using System . Linq ; <nl> using System . Reflection ; <nl> using System . Runtime . CompilerServices ; <nl> + using System . Runtime . ExceptionServices ; <nl> using Microsoft . Extensions . DependencyInjection ; <nl> using Xunit . Abstractions ; <nl> <nl> namespace Microsoft . Extensions . Logging . Testing <nl> { <nl> public class LoggedTestBase : ILoggedTest <nl> { <nl> + private ExceptionDispatchInfo _initializationException ; <nl> + <nl> private IDisposable _testLog ; <nl> <nl> / / Obsolete but keeping for back compat <nl> public IDisposable StartLog ( out ILoggerFactory loggerFactory , LogLevel minLogLev <nl> <nl> public virtual void Initialize ( MethodInfo methodInfo , object [ ] testMethodArguments , ITestOutputHelper testOutputHelper ) <nl> { <nl> - TestOutputHelper = testOutputHelper ; <nl> - <nl> - var classType = GetType ( ) ; <nl> - var logLevelAttribute = methodInfo . GetCustomAttribute < LogLevelAttribute > ( ) <nl> - ? ? methodInfo . DeclaringType . GetCustomAttribute < LogLevelAttribute > ( ) <nl> - ? ? methodInfo . DeclaringType . Assembly . GetCustomAttribute < LogLevelAttribute > ( ) ; <nl> - var testName = testMethodArguments . Aggregate ( methodInfo . Name , ( a , b ) = > $ \" { a } - { ( b ? ? \" null \" ) } \" ) ; <nl> - <nl> - var useShortClassName = methodInfo . DeclaringType . GetCustomAttribute < ShortClassNameAttribute > ( ) <nl> - ? ? methodInfo . DeclaringType . Assembly . GetCustomAttribute < ShortClassNameAttribute > ( ) ; <nl> - / / internal for testing <nl> - ResolvedTestClassName = useShortClassName = = null ? classType . FullName : classType . Name ; <nl> - <nl> - _testLog = AssemblyTestLog <nl> - . ForAssembly ( classType . GetTypeInfo ( ) . Assembly ) <nl> - . StartTestLog ( <nl> - TestOutputHelper , <nl> - ResolvedTestClassName , <nl> - out var loggerFactory , <nl> - logLevelAttribute ? . LogLevel ? ? LogLevel . Debug , <nl> - out var resolvedTestName , <nl> - out var logOutputDirectory , <nl> - testName ) ; <nl> - <nl> - ResolvedLogOutputDirectory = logOutputDirectory ; <nl> - ResolvedTestMethodName = resolvedTestName ; <nl> - <nl> - LoggerFactory = loggerFactory ; <nl> - Logger = loggerFactory . CreateLogger ( classType ) ; <nl> + try <nl> + { <nl> + TestOutputHelper = testOutputHelper ; <nl> + <nl> + var classType = GetType ( ) ; <nl> + var logLevelAttribute = methodInfo . GetCustomAttribute < LogLevelAttribute > ( ) <nl> + ? ? methodInfo . DeclaringType . GetCustomAttribute < LogLevelAttribute > ( ) <nl> + ? ? methodInfo . DeclaringType . Assembly . GetCustomAttribute < LogLevelAttribute > ( ) ; <nl> + var testName = testMethodArguments . Aggregate ( methodInfo . Name , ( a , b ) = > $ \" { a } - { ( b ? ? \" null \" ) } \" ) ; <nl> + <nl> + var useShortClassName = methodInfo . DeclaringType . GetCustomAttribute < ShortClassNameAttribute > ( ) <nl> + ? ? methodInfo . DeclaringType . Assembly . GetCustomAttribute < ShortClassNameAttribute > ( ) ; <nl> + / / internal for testing <nl> + ResolvedTestClassName = useShortClassName = = null ? classType . FullName : classType . Name ; <nl> + <nl> + _testLog = AssemblyTestLog <nl> + . ForAssembly ( classType . GetTypeInfo ( ) . Assembly ) <nl> + . StartTestLog ( <nl> + TestOutputHelper , <nl> + ResolvedTestClassName , <nl> + out var loggerFactory , <nl> + logLevelAttribute ? . LogLevel ? ? LogLevel . Debug , <nl> + out var resolvedTestName , <nl> + out var logOutputDirectory , <nl> + testName ) ; <nl> + <nl> + ResolvedLogOutputDirectory = logOutputDirectory ; <nl> + ResolvedTestMethodName = resolvedTestName ; <nl> + <nl> + LoggerFactory = loggerFactory ; <nl> + Logger = loggerFactory . CreateLogger ( classType ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + _initializationException = ExceptionDispatchInfo . Capture ( e ) ; <nl> + } <nl> } <nl> <nl> - public virtual void Dispose ( ) = > _testLog . Dispose ( ) ; <nl> + public virtual void Dispose ( ) <nl> + { <nl> + _initializationException ? . Throw ( ) ; <nl> + _testLog . Dispose ( ) ; <nl> + } <nl> } <nl> } <nl>\n", "msg": "Capture LoggedTest . Initialize exception and re - trow in Dispose ( )\n"}
{"diff_id": 23725, "repo": "ppy/osu\n", "sha": "5cd2841080caf8e41b135d740a246f5d6535abae\n", "time": "2020-08-03T19:17:42Z\n", "diff": "new file mode 100644 <nl> index 00000000000 . . 2581e305ddd <nl> mmm / dev / null <nl> ppp b / osu . Game . Rulesets . Catch . Tests / TestSceneComboCounter . cs <nl> <nl> + / / Copyright ( c ) ppy Pty Ltd < contact @ ppy . sh > . Licensed under the MIT Licence . <nl> + / / See the LICENCE file in the repository root for full licence text . <nl> + <nl> + using System . Linq ; <nl> + using NUnit . Framework ; <nl> + using osu . Framework . Allocation ; <nl> + using osu . Framework . Bindables ; <nl> + using osu . Framework . Graphics ; <nl> + using osu . Game . Rulesets . Catch . Objects ; <nl> + using osu . Game . Rulesets . Catch . Objects . Drawables ; <nl> + using osu . Game . Rulesets . Catch . UI ; <nl> + using osu . Game . Rulesets . Judgements ; <nl> + using osu . Game . Rulesets . Scoring ; <nl> + using osu . Game . Screens . Play ; <nl> + using osuTK ; <nl> + using osuTK . Graphics ; <nl> + <nl> + namespace osu . Game . Rulesets . Catch . Tests <nl> + { <nl> + public class TestSceneComboCounter : CatchSkinnableTestScene <nl> + { <nl> + private ScoreProcessor scoreProcessor ; <nl> + private GameplayBeatmap gameplayBeatmap ; <nl> + private readonly Bindable < bool > isBreakTime = new BindableBool ( ) ; <nl> + <nl> + [ BackgroundDependencyLoader ] <nl> + private void load ( ) <nl> + { <nl> + gameplayBeatmap = new GameplayBeatmap ( CreateBeatmapForSkinProvider ( ) ) ; <nl> + gameplayBeatmap . IsBreakTime . BindTo ( isBreakTime ) ; <nl> + Dependencies . Cache ( gameplayBeatmap ) ; <nl> + Add ( gameplayBeatmap ) ; <nl> + } <nl> + <nl> + [ SetUp ] <nl> + public void SetUp ( ) = > Schedule ( ( ) = > <nl> + { <nl> + scoreProcessor = new ScoreProcessor ( ) ; <nl> + <nl> + SetContents ( ( ) = > new CatchComboDisplay <nl> + { <nl> + Anchor = Anchor . Centre , <nl> + Origin = Anchor . Centre , <nl> + Scale = new Vector2 ( 2 . 5f ) , <nl> + } ) ; <nl> + } ) ; <nl> + <nl> + [ Test ] <nl> + public void TestCatchComboCounter ( ) <nl> + { <nl> + AddRepeatStep ( \" perform hit \" , ( ) = > performJudgement ( HitResult . Perfect ) , 20 ) ; <nl> + AddStep ( \" perform miss \" , ( ) = > performJudgement ( HitResult . Miss ) ) ; <nl> + AddToggleStep ( \" toggle gameplay break \" , v = > isBreakTime . Value = v ) ; <nl> + } <nl> + <nl> + private void performJudgement ( HitResult type , Judgement judgement = null ) <nl> + { <nl> + var judgedObject = new TestDrawableCatchHitObject ( new TestCatchHitObject ( ) ) ; <nl> + var result = new JudgementResult ( judgedObject . HitObject , judgement ? ? new Judgement ( ) ) { Type = type } ; <nl> + scoreProcessor . ApplyResult ( result ) ; <nl> + <nl> + foreach ( var counter in CreatedDrawables . Cast < CatchComboDisplay > ( ) ) <nl> + counter . OnNewResult ( judgedObject , result ) ; <nl> + } <nl> + <nl> + private class TestDrawableCatchHitObject : DrawableCatchHitObject <nl> + { <nl> + public TestDrawableCatchHitObject ( CatchHitObject hitObject ) <nl> + : base ( hitObject ) <nl> + { <nl> + AccentColour . Value = Color4 . White ; <nl> + } <nl> + } <nl> + <nl> + private class TestCatchHitObject : CatchHitObject <nl> + { <nl> + } <nl> + } <nl> + } <nl>\n", "msg": "Add test scene showing off the skinnable catch - specific combo counter\n"}
{"diff_id": 23974, "repo": "ppy/osu\n", "sha": "80d81c30440594e4aa92d62812504086f82a95da\n", "time": "2020-11-16T19:24:04Z\n", "diff": "mmm a / osu . Game . Rulesets . Taiko / Mods / TaikoModEasy . cs <nl> ppp b / osu . Game . Rulesets . Taiko / Mods / TaikoModEasy . cs <nl> namespace osu . Game . Rulesets . Taiko . Mods <nl> { <nl> public class TaikoModEasy : ModEasy <nl> { <nl> - public override string Description = > @ \" Beats move slower , less accuracy required ! \" ; <nl> + public override string Description = > @ \" Beats move slower , and less accuracy required ! \" ; <nl> } <nl> } <nl>\n", "msg": "Reword taiko easy mod description to fit others better\n"}
{"diff_id": 24253, "repo": "cefsharp/CefSharp\n", "sha": "8d1afada2076a054b98c432a4948d3a08588c07f\n", "time": "2020-08-26T04:55:51Z\n", "diff": "mmm a / CefSharp . WinForms / ChromiumWebBrowser . cs <nl> ppp b / CefSharp . WinForms / ChromiumWebBrowser . cs <nl> protected override void OnHandleCreated ( EventArgs e ) <nl> } <nl> <nl> protected override void OnHandleDestroyed ( EventArgs e ) <nl> + { <nl> + if ( ! designMode ) <nl> + { <nl> + / / NOTE : Had to move the code out of this function otherwise the designer would crash <nl> + OnHandleDestroyedInternal ( ) ; <nl> + } <nl> + <nl> + base . OnHandleDestroyed ( e ) ; <nl> + } <nl> + <nl> + [ MethodImpl ( MethodImplOptions . NoInlining ) ] <nl> + private void OnHandleDestroyedInternal ( ) <nl> { <nl> / / When the Control is being Recreated then we ' ll park <nl> / / the browser ( set to a temp parent ) and assign to <nl> protected override void OnHandleDestroyed ( EventArgs e ) <nl> <nl> NativeMethodWrapper . SetWindowParent ( hwnd , parkingControl . Handle ) ; <nl> } <nl> - <nl> - base . OnHandleDestroyed ( e ) ; <nl> } <nl> <nl> / / / < summary > <nl>\n", "msg": "WinForms - OnHandleDestroyed directly references CefSharp . Core crashing Designer\n"}
{"diff_id": 24347, "repo": "duplicati/duplicati\n", "sha": "b237e911bb5ae409d30ce001e6686e4e78a2eefe\n", "time": "2013-09-13T11:26:38Z\n", "diff": "mmm a / Duplicati / Library / Main / Operation / ListChangesHandler . cs <nl> ppp b / Duplicati / Library / Main / Operation / ListChangesHandler . cs <nl> public void Run ( string baseVersion , string compareVersion , IEnumerable < string > f <nl> var filter = Library . Utility . JoinedFilterExpression . Join ( new Library . Utility . FilterExpression ( filterstrings ) , compositefilter ) ; <nl> <nl> var useLocalDb = ! m_options . NoLocalDb & & System . IO . File . Exists ( m_options . Dbpath ) ; <nl> - baseVersion = string . IsNullOrEmpty ( baseVersion ) ? \" 0 \" : baseVersion ; <nl> - compareVersion = string . IsNullOrEmpty ( compareVersion ) ? \" 1 \" : compareVersion ; <nl> + baseVersion = string . IsNullOrEmpty ( baseVersion ) ? \" 1 \" : baseVersion ; <nl> + compareVersion = string . IsNullOrEmpty ( compareVersion ) ? \" 0 \" : compareVersion ; <nl> <nl> long baseVersionIndex = - 1 ; <nl> long compareVersionIndex = - 1 ; <nl>\n", "msg": "Swapped default compare entries so the output looks more like that from a backup operation\n"}
{"diff_id": 24356, "repo": "dotnet/roslyn\n", "sha": "03087e03c7ebc1cc494a130138aa14955e2296c7\n", "time": "2015-08-05T23:44:20Z\n", "diff": "mmm a / src / Tools / Source / RunTests / ProcessRunner . cs <nl> ppp b / src / Tools / Source / RunTests / ProcessRunner . cs <nl> namespace RunTests <nl> public sealed class ProcessOutput <nl> { <nl> private readonly int _exitCode ; <nl> - private readonly IEnumerable < string > _outputLines ; <nl> - private readonly IEnumerable < string > _errorLines ; <nl> + private readonly IList < string > _outputLines ; <nl> + private readonly IList < string > _errorLines ; <nl> <nl> public int ExitCode <nl> { <nl> get { return _exitCode ; } <nl> } <nl> <nl> - public IEnumerable < string > OutputLines <nl> + public IList < string > OutputLines <nl> { <nl> get { return _outputLines ; } <nl> } <nl> <nl> - public IEnumerable < string > ErrorLines <nl> + public IList < string > ErrorLines <nl> { <nl> get { return _errorLines ; } <nl> } <nl> <nl> - public ProcessOutput ( int exitCode , IEnumerable < string > outputLines , IEnumerable < string > errorLines ) <nl> + public ProcessOutput ( int exitCode , IList < string > outputLines , IList < string > errorLines ) <nl> { <nl> _exitCode = exitCode ; <nl> _outputLines = outputLines ; <nl>\n", "msg": "Use a stronger interface to clarify that repeated enumeration is safe\n"}
{"diff_id": 24390, "repo": "gitextensions/gitextensions\n", "sha": "e269f1008fe33213d1b7c9d8a70361cbbd4bad7e\n", "time": "2018-05-29T07:05:27Z\n", "diff": "mmm a / Plugins / BuildServerIntegration / VstsAndTfsIntegration / TfsApiHelper . cs <nl> ppp b / Plugins / BuildServerIntegration / VstsAndTfsIntegration / TfsApiHelper . cs <nl> private async Task < IEnumerable < BuildDefinition > > GetBuildDefinitionsAsync ( string <nl> { <nl> var buildDefs = new List < BuildDefinition > ( ) ; <nl> <nl> - using ( var response = await _httpClient . GetAsync ( $ \" _apis / build / definitions \" ) ) <nl> + using ( var response = await _httpClient . GetAsync ( $ \" _apis / build / definitions ? api - version = 2 . 0 \" ) ) <nl> { <nl> response . EnsureSuccessStatusCode ( ) ; <nl> string json = await response . Content . ReadAsStringAsync ( ) ; <nl>\n", "msg": "VstsAndTfsIntegration : Explicitly request a REST API version .\n"}
{"diff_id": 24750, "repo": "dotnet/BenchmarkDotNet\n", "sha": "52215889370659058ff0ed9a70f018c41c527bb1\n", "time": "2018-07-24T08:32:00Z\n", "diff": "mmm a / src / BenchmarkDotNet / Extensions / ReflectionExtensions . cs <nl> ppp b / src / BenchmarkDotNet / Extensions / ReflectionExtensions . cs <nl> internal static class ReflectionExtensions <nl> / / / < / summary > <nl> internal static string GetCorrectCSharpTypeName ( this Type type , bool includeNamespace = true , bool includeGenericArgumentsNamespace = true ) <nl> { <nl> - while ( ! ( type . IsPublic | | type . IsNestedPublic ) ) <nl> - type = type . BaseType ; <nl> + if ( ! type . Name . EndsWith ( \" & \" ) ) <nl> + while ( ! ( type . IsPublic | | type . IsNestedPublic ) & & type . BaseType ! = null ) <nl> + type = type . BaseType ; <nl> <nl> / / the reflection is missing information about types passed by ref ( ie ref ValuTuple < int > is reported as NON generic type ) <nl> if ( type . IsByRef & & ! type . IsGenericType & & type . Name . Contains ( ' ` ' ) ) <nl>\n", "msg": "Handle private types in GetCorrectCSharpTypeName ( part 2 ) , fixes\n"}
{"diff_id": 24834, "repo": "AvaloniaUI/Avalonia\n", "sha": "6ed1669803d62f7a02f75d89b0e0ad66b8d5d983\n", "time": "2020-09-04T14:49:04Z\n", "diff": "mmm a / src / Skia / Avalonia . Skia / SkiaOptions . cs <nl> ppp b / src / Skia / Avalonia . Skia / SkiaOptions . cs <nl> public class SkiaOptions <nl> / / / < summary > <nl> / / / The maximum number of bytes for video memory to store textures and resources . <nl> / / / < / summary > <nl> - public long ? MaxGpuResourceSizeBytes { get ; set ; } <nl> + public long ? MaxGpuResourceSizeBytes { get ; set ; } = 1024 * 600 * 4 * 12 ; / / ~ 28mb 12x 1024 x 600 textures . <nl> } <nl> } <nl>\n", "msg": "set a sensible cache size for skia . . based on what flutter uses .\n"}
{"diff_id": 25096, "repo": "NancyFx/Nancy\n", "sha": "c6fae38f14a872f569551ed052f769176d3de829\n", "time": "2012-09-23T16:55:33Z\n", "diff": "mmm a / src / Nancy . Hosting . Owin / TaskHelpers . cs <nl> ppp b / src / Nancy . Hosting . Owin / TaskHelpers . cs <nl> <nl> -  / / Copyright ( c ) Microsoft Corporation . All rights reserved . See License . txt in the project root for license information . <nl> - <nl> - <nl> - <nl> - namespace System . Threading . Tasks <nl> +  / / Copyright ( c ) Microsoft Corporation . All rights reserved . Apache License 2 . 0 <nl> + <nl> + namespace System . Threading . Tasks <nl> { <nl> using System . Collections . Generic ; <nl> using System . Diagnostics . CodeAnalysis ; <nl> - using System . Diagnostics . Contracts ; <nl> - <nl> - / / / < summary > <nl> - / / / Helpers for safely using Task libraries . <nl> - / / / < / summary > <nl> - static class TaskHelpers <nl> - { <nl> - private static readonly Task _defaultCompleted = FromResult < AsyncVoid > ( default ( AsyncVoid ) ) ; <nl> - <nl> - private static readonly Task < object > _completedTaskReturningNull = FromResult < object > ( null ) ; <nl> - <nl> - / / / < summary > <nl> - / / / Returns a canceled Task . The task is completed , IsCanceled = True , IsFaulted = False . <nl> - / / / < / summary > <nl> - internal static Task Canceled ( ) <nl> - { <nl> - return CancelCache < AsyncVoid > . Canceled ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Returns a canceled Task of the given type . The task is completed , IsCanceled = True , IsFaulted = False . <nl> - / / / < / summary > <nl> - internal static Task < TResult > Canceled < TResult > ( ) <nl> - { <nl> - return CancelCache < TResult > . Canceled ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Returns a completed task that has no result . <nl> - / / / < / summary > <nl> - internal static Task Completed ( ) <nl> - { <nl> - return _defaultCompleted ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Returns an error task . The task is Completed , IsCanceled = False , IsFaulted = True <nl> - / / / < / summary > <nl> - internal static Task FromError ( Exception exception ) <nl> - { <nl> - return FromError < AsyncVoid > ( exception ) ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Returns an error task of the given type . The task is Completed , IsCanceled = False , IsFaulted = True <nl> - / / / < / summary > <nl> - / / / < typeparam name = \" TResult \" > < / typeparam > <nl> - internal static Task < TResult > FromError < TResult > ( Exception exception ) <nl> - { <nl> - TaskCompletionSource < TResult > tcs = new TaskCompletionSource < TResult > ( ) ; <nl> - tcs . SetException ( exception ) ; <nl> - return tcs . Task ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Returns an error task of the given type . The task is Completed , IsCanceled = False , IsFaulted = True <nl> - / / / < / summary > <nl> - internal static Task FromErrors ( IEnumerable < Exception > exceptions ) <nl> - { <nl> - return FromErrors < AsyncVoid > ( exceptions ) ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Returns an error task of the given type . The task is Completed , IsCanceled = False , IsFaulted = True <nl> - / / / < / summary > <nl> - internal static Task < TResult > FromErrors < TResult > ( IEnumerable < Exception > exceptions ) <nl> - { <nl> - TaskCompletionSource < TResult > tcs = new TaskCompletionSource < TResult > ( ) ; <nl> - tcs . SetException ( exceptions ) ; <nl> - return tcs . Task ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Returns a successful completed task with the given result . <nl> - / / / < / summary > <nl> - internal static Task < TResult > FromResult < TResult > ( TResult result ) <nl> - { <nl> - TaskCompletionSource < TResult > tcs = new TaskCompletionSource < TResult > ( ) ; <nl> - tcs . SetResult ( result ) ; <nl> - return tcs . Task ; <nl> - } <nl> - <nl> - internal static Task < object > NullResult ( ) <nl> - { <nl> - return _completedTaskReturningNull ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Return a task that runs all the tasks inside the iterator sequentially . It stops as soon <nl> - / / / as one of the tasks fails or cancels , or after all the tasks have run succesfully . <nl> - / / / < / summary > <nl> - / / / < param name = \" asyncIterator \" > collection of tasks to wait on < / param > <nl> - / / / < param name = \" cancellationToken \" > cancellation token < / param > <nl> - / / / < param name = \" disposeEnumerator \" > whether or not to dispose the enumerator we get from < paramref name = \" asyncIterator \" / > . <nl> - / / / Only set to < c > false < / c > if you can guarantee that < paramref name = \" asyncIterator \" / > ' s enumerator does not have any resources it needs to dispose . < / param > <nl> - / / / < returns > a task that signals completed when all the incoming tasks are finished . < / returns > <nl> - [ SuppressMessage ( \" Microsoft . Design \" , \" CA1031 : DoNotCatchGeneralExceptionTypes \" , Justification = \" The exception is propagated in a Task . \" ) ] <nl> - internal static Task Iterate ( IEnumerable < Task > asyncIterator , CancellationToken cancellationToken = default ( CancellationToken ) , bool disposeEnumerator = true ) <nl> - { <nl> - Contract . Assert ( asyncIterator ! = null ) ; <nl> - <nl> - IEnumerator < Task > enumerator = null ; <nl> - try <nl> - { <nl> - enumerator = asyncIterator . GetEnumerator ( ) ; <nl> - Task task = IterateImpl ( enumerator , cancellationToken ) ; <nl> - return ( disposeEnumerator & & enumerator ! = null ) ? task . Finally ( enumerator . Dispose , runSynchronously : true ) : task ; <nl> - } <nl> - catch ( Exception ex ) <nl> - { <nl> - return TaskHelpers . FromError ( ex ) ; <nl> - } <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Provides the implementation of the Iterate method . <nl> - / / / Contains special logic to help speed up common cases . <nl> - / / / < / summary > <nl> - [ SuppressMessage ( \" Microsoft . Design \" , \" CA1031 : DoNotCatchGeneralExceptionTypes \" , Justification = \" The exception is propagated in a Task . \" ) ] <nl> - internal static Task IterateImpl ( IEnumerator < Task > enumerator , CancellationToken cancellationToken ) <nl> - { <nl> - try <nl> - { <nl> - while ( true ) <nl> - { <nl> - / / short - circuit : iteration canceled <nl> - if ( cancellationToken . IsCancellationRequested ) <nl> - { <nl> - return TaskHelpers . Canceled ( ) ; <nl> - } <nl> - <nl> - / / short - circuit : iteration complete <nl> - if ( ! enumerator . MoveNext ( ) ) <nl> - { <nl> - return TaskHelpers . Completed ( ) ; <nl> - } <nl> - <nl> - / / fast case : Task completed synchronously & successfully <nl> - Task currentTask = enumerator . Current ; <nl> - if ( currentTask . Status = = TaskStatus . RanToCompletion ) <nl> - { <nl> - continue ; <nl> - } <nl> - <nl> - / / fast case : Task completed synchronously & unsuccessfully <nl> - if ( currentTask . IsCanceled | | currentTask . IsFaulted ) <nl> - { <nl> - return currentTask ; <nl> - } <nl> - <nl> - / / slow case : Task isn ' t yet complete <nl> - return IterateImplIncompleteTask ( enumerator , currentTask , cancellationToken ) ; <nl> - } <nl> - } <nl> - catch ( Exception ex ) <nl> - { <nl> - return TaskHelpers . FromError ( ex ) ; <nl> - } <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Fallback for IterateImpl when the antecedent Task isn ' t yet complete . <nl> - / / / < / summary > <nl> - internal static Task IterateImplIncompleteTask ( IEnumerator < Task > enumerator , Task currentTask , CancellationToken cancellationToken ) <nl> - { <nl> - / / There ' s a race condition here , the antecedent Task could complete between <nl> - / / the check in Iterate and the call to Then below . If this happens , we could <nl> - / / end up growing the stack indefinitely . But the chances of ( a ) even having <nl> - / / enough Tasks in the enumerator in the first place and of ( b ) * every * one <nl> - / / of them hitting this race condition are so extremely remote that it ' s not <nl> - / / worth worrying about . <nl> - return currentTask . Then ( ( ) = > IterateImpl ( enumerator , cancellationToken ) ) ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Replacement for Task . Factory . StartNew when the code can run synchronously . <nl> - / / / We run the code immediately and avoid the thread switch . <nl> - / / / This is used to help synchronous code implement task interfaces . <nl> - / / / < / summary > <nl> - / / / < param name = \" action \" > action to run synchronouslyt < / param > <nl> - / / / < param name = \" token \" > cancellation token . This is only checked before we run the task , and if cancelled , we immediately return a cancelled task . < / param > <nl> - / / / < returns > a task who result is the result from Func ( ) < / returns > <nl> - / / / < remarks > <nl> - / / / Avoid calling Task . Factory . StartNew . <nl> - / / / This avoids gotchas with StartNew : <nl> - / / / - ensures cancellation token is checked ( StartNew doesn ' t check cancellation tokens ) . <nl> - / / / - Keeps on the same thread . <nl> - / / / - Avoids switching synchronization contexts . <nl> - / / / Also take in a lambda so that we can wrap in a try catch and honor task failure semantics . <nl> - / / / < / remarks > <nl> - [ SuppressMessage ( \" Microsoft . Design \" , \" CA1031 : DoNotCatchGeneralExceptionTypes \" , Justification = \" The caught exception type is reflected into a faulted task . \" ) ] <nl> - public static Task RunSynchronously ( Action action , CancellationToken token = default ( CancellationToken ) ) <nl> - { <nl> - if ( token . IsCancellationRequested ) <nl> - { <nl> - return Canceled ( ) ; <nl> - } <nl> - <nl> - try <nl> - { <nl> - action ( ) ; <nl> - return Completed ( ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - return FromError ( e ) ; <nl> - } <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Replacement for Task . Factory . StartNew when the code can run synchronously . <nl> - / / / We run the code immediately and avoid the thread switch . <nl> - / / / This is used to help synchronous code implement task interfaces . <nl> - / / / < / summary > <nl> - / / / < typeparam name = \" TResult \" > type of result that task will return . < / typeparam > <nl> - / / / < param name = \" func \" > function to run synchronously and produce result < / param > <nl> - / / / < param name = \" cancellationToken \" > cancellation token . This is only checked before we run the task , and if cancelled , we immediately return a cancelled task . < / param > <nl> - / / / < returns > a task who result is the result from Func ( ) < / returns > <nl> - / / / < remarks > <nl> - / / / Avoid calling Task . Factory . StartNew . <nl> - / / / This avoids gotchas with StartNew : <nl> - / / / - ensures cancellation token is checked ( StartNew doesn ' t check cancellation tokens ) . <nl> - / / / - Keeps on the same thread . <nl> - / / / - Avoids switching synchronization contexts . <nl> - / / / Also take in a lambda so that we can wrap in a try catch and honor task failure semantics . <nl> - / / / < / remarks > <nl> - [ SuppressMessage ( \" Microsoft . Design \" , \" CA1031 : DoNotCatchGeneralExceptionTypes \" , Justification = \" The caught exception type is reflected into a faulted task . \" ) ] <nl> - internal static Task < TResult > RunSynchronously < TResult > ( Func < TResult > func , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> - { <nl> - if ( cancellationToken . IsCancellationRequested ) <nl> - { <nl> - return Canceled < TResult > ( ) ; <nl> - } <nl> - <nl> - try <nl> - { <nl> - return FromResult ( func ( ) ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - return FromError < TResult > ( e ) ; <nl> - } <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Overload of RunSynchronously that avoids a call to Unwrap ( ) . <nl> - / / / This overload is useful when func ( ) starts doing some synchronous work and then hits IO and <nl> - / / / needs to create a task to finish the work . <nl> - / / / < / summary > <nl> - / / / < typeparam name = \" TResult \" > type of result that Task will return < / typeparam > <nl> - / / / < param name = \" func \" > function that returns a task < / param > <nl> - / / / < param name = \" cancellationToken \" > cancellation token . This is only checked before we run the task , and if cancelled , we immediately return a cancelled task . < / param > <nl> - / / / < returns > a task , created by running func ( ) . < / returns > <nl> - [ SuppressMessage ( \" Microsoft . Design \" , \" CA1031 : DoNotCatchGeneralExceptionTypes \" , Justification = \" The caught exception type is reflected into a faulted task . \" ) ] <nl> - internal static Task < TResult > RunSynchronously < TResult > ( Func < Task < TResult > > func , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> - { <nl> - if ( cancellationToken . IsCancellationRequested ) <nl> - { <nl> - return Canceled < TResult > ( ) ; <nl> - } <nl> - <nl> - try <nl> - { <nl> - return func ( ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - return FromError < TResult > ( e ) ; <nl> - } <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Update the completion source if the task failed ( cancelled or faulted ) . No change to completion source if the task succeeded . <nl> - / / / < / summary > <nl> - / / / < typeparam name = \" TResult \" > result type of completion source < / typeparam > <nl> - / / / < param name = \" tcs \" > completion source to update < / param > <nl> - / / / < param name = \" source \" > task to update from . < / param > <nl> - / / / < returns > true on success < / returns > <nl> - internal static bool SetIfTaskFailed < TResult > ( this TaskCompletionSource < TResult > tcs , Task source ) <nl> - { <nl> - switch ( source . Status ) <nl> - { <nl> - case TaskStatus . Canceled : <nl> - case TaskStatus . Faulted : <nl> - return tcs . TrySetFromTask ( source ) ; <nl> - } <nl> - <nl> - return false ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Set a completion source from the given Task . <nl> - / / / < / summary > <nl> - / / / < typeparam name = \" TResult \" > result type for completion source . < / typeparam > <nl> - / / / < param name = \" tcs \" > completion source to set < / param > <nl> - / / / < param name = \" source \" > Task to get values from . < / param > <nl> - / / / < returns > true if this successfully sets the completion source . < / returns > <nl> - [ SuppressMessage ( \" Microsoft . WebAPI \" , \" CR4001 : DoNotCallProblematicMethodsOnTask \" , Justification = \" This is a known safe usage of Task . Result , since it only occurs when we know the task ' s state to be completed . \" ) ] <nl> - internal static bool TrySetFromTask < TResult > ( this TaskCompletionSource < TResult > tcs , Task source ) <nl> - { <nl> - if ( source . Status = = TaskStatus . Canceled ) <nl> - { <nl> - return tcs . TrySetCanceled ( ) ; <nl> - } <nl> - <nl> - if ( source . Status = = TaskStatus . Faulted ) <nl> - { <nl> - return tcs . TrySetException ( source . Exception . InnerExceptions ) ; <nl> - } <nl> - <nl> - if ( source . Status = = TaskStatus . RanToCompletion ) <nl> - { <nl> - Task < TResult > taskOfResult = source as Task < TResult > ; <nl> - return tcs . TrySetResult ( taskOfResult = = null ? default ( TResult ) : taskOfResult . Result ) ; <nl> - } <nl> - <nl> - return false ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Set a completion source from the given Task . If the task ran to completion and the result type doesn ' t match <nl> - / / / the type of the completion source , then a default value will be used . This is useful for converting Task into <nl> - / / / Task { AsyncVoid } , but it can also accidentally be used to introduce data loss ( by passing the wrong <nl> - / / / task type ) , so please execute this method with care . <nl> - / / / < / summary > <nl> - / / / < typeparam name = \" TResult \" > result type for completion source . < / typeparam > <nl> - / / / < param name = \" tcs \" > completion source to set < / param > <nl> - / / / < param name = \" source \" > Task to get values from . < / param > <nl> - / / / < returns > true if this successfully sets the completion source . < / returns > <nl> - [ SuppressMessage ( \" Microsoft . WebAPI \" , \" CR4001 : DoNotCallProblematicMethodsOnTask \" , Justification = \" This is a known safe usage of Task . Result , since it only occurs when we know the task ' s state to be completed . \" ) ] <nl> - internal static bool TrySetFromTask < TResult > ( this TaskCompletionSource < Task < TResult > > tcs , Task source ) <nl> - { <nl> - if ( source . Status = = TaskStatus . Canceled ) <nl> - { <nl> - return tcs . TrySetCanceled ( ) ; <nl> - } <nl> - <nl> - if ( source . Status = = TaskStatus . Faulted ) <nl> - { <nl> - return tcs . TrySetException ( source . Exception . InnerExceptions ) ; <nl> - } <nl> - <nl> - if ( source . Status = = TaskStatus . RanToCompletion ) <nl> - { <nl> - / / Sometimes the source task is Task < Task < TResult > > , and sometimes it ' s Task < TResult > . <nl> - / / The latter usually happens when we ' re in the middle of a sync - block postback where <nl> - / / the continuation is a function which returns Task < TResult > rather than just TResult , <nl> - / / but the originating task was itself just Task < TResult > . An example of this can be <nl> - / / found in TaskExtensions . CatchImpl ( ) . <nl> - Task < Task < TResult > > taskOfTaskOfResult = source as Task < Task < TResult > > ; <nl> - if ( taskOfTaskOfResult ! = null ) <nl> - { <nl> - return tcs . TrySetResult ( taskOfTaskOfResult . Result ) ; <nl> - } <nl> - <nl> - Task < TResult > taskOfResult = source as Task < TResult > ; <nl> - if ( taskOfResult ! = null ) <nl> - { <nl> - return tcs . TrySetResult ( taskOfResult ) ; <nl> - } <nl> - <nl> - return tcs . TrySetResult ( TaskHelpers . FromResult ( default ( TResult ) ) ) ; <nl> - } <nl> - <nl> - return false ; <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / Used as the T in a \" conversion \" of a Task into a Task { T } <nl> - / / / < / summary > <nl> - private struct AsyncVoid <nl> - { <nl> - } <nl> - <nl> - / / / < summary > <nl> - / / / This class is a convenient cache for per - type cancelled tasks <nl> - / / / < / summary > <nl> - private static class CancelCache < TResult > <nl> - { <nl> - public static readonly Task < TResult > Canceled = GetCancelledTask ( ) ; <nl> - <nl> - private static Task < TResult > GetCancelledTask ( ) <nl> - { <nl> - TaskCompletionSource < TResult > tcs = new TaskCompletionSource < TResult > ( ) ; <nl> - tcs . SetCanceled ( ) ; <nl> - return tcs . Task ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> + using System . Diagnostics . Contracts ; <nl> + <nl> + / / / < summary > <nl> + / / / Helpers for safely using Task libraries . <nl> + / / / < / summary > <nl> + static class TaskHelpers <nl> + { <nl> + private static readonly Task _defaultCompleted = FromResult < AsyncVoid > ( default ( AsyncVoid ) ) ; <nl> + <nl> + private static readonly Task < object > _completedTaskReturningNull = FromResult < object > ( null ) ; <nl> + <nl> + / / / < summary > <nl> + / / / Returns a canceled Task . The task is completed , IsCanceled = True , IsFaulted = False . <nl> + / / / < / summary > <nl> + internal static Task Canceled ( ) <nl> + { <nl> + return CancelCache < AsyncVoid > . Canceled ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Returns a canceled Task of the given type . The task is completed , IsCanceled = True , IsFaulted = False . <nl> + / / / < / summary > <nl> + internal static Task < TResult > Canceled < TResult > ( ) <nl> + { <nl> + return CancelCache < TResult > . Canceled ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Returns a completed task that has no result . <nl> + / / / < / summary > <nl> + internal static Task Completed ( ) <nl> + { <nl> + return _defaultCompleted ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Returns an error task . The task is Completed , IsCanceled = False , IsFaulted = True <nl> + / / / < / summary > <nl> + internal static Task FromError ( Exception exception ) <nl> + { <nl> + return FromError < AsyncVoid > ( exception ) ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Returns an error task of the given type . The task is Completed , IsCanceled = False , IsFaulted = True <nl> + / / / < / summary > <nl> + / / / < typeparam name = \" TResult \" > < / typeparam > <nl> + internal static Task < TResult > FromError < TResult > ( Exception exception ) <nl> + { <nl> + TaskCompletionSource < TResult > tcs = new TaskCompletionSource < TResult > ( ) ; <nl> + tcs . SetException ( exception ) ; <nl> + return tcs . Task ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Returns an error task of the given type . The task is Completed , IsCanceled = False , IsFaulted = True <nl> + / / / < / summary > <nl> + internal static Task FromErrors ( IEnumerable < Exception > exceptions ) <nl> + { <nl> + return FromErrors < AsyncVoid > ( exceptions ) ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Returns an error task of the given type . The task is Completed , IsCanceled = False , IsFaulted = True <nl> + / / / < / summary > <nl> + internal static Task < TResult > FromErrors < TResult > ( IEnumerable < Exception > exceptions ) <nl> + { <nl> + TaskCompletionSource < TResult > tcs = new TaskCompletionSource < TResult > ( ) ; <nl> + tcs . SetException ( exceptions ) ; <nl> + return tcs . Task ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Returns a successful completed task with the given result . <nl> + / / / < / summary > <nl> + internal static Task < TResult > FromResult < TResult > ( TResult result ) <nl> + { <nl> + TaskCompletionSource < TResult > tcs = new TaskCompletionSource < TResult > ( ) ; <nl> + tcs . SetResult ( result ) ; <nl> + return tcs . Task ; <nl> + } <nl> + <nl> + internal static Task < object > NullResult ( ) <nl> + { <nl> + return _completedTaskReturningNull ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Return a task that runs all the tasks inside the iterator sequentially . It stops as soon <nl> + / / / as one of the tasks fails or cancels , or after all the tasks have run succesfully . <nl> + / / / < / summary > <nl> + / / / < param name = \" asyncIterator \" > collection of tasks to wait on < / param > <nl> + / / / < param name = \" cancellationToken \" > cancellation token < / param > <nl> + / / / < param name = \" disposeEnumerator \" > whether or not to dispose the enumerator we get from < paramref name = \" asyncIterator \" / > . <nl> + / / / Only set to < c > false < / c > if you can guarantee that < paramref name = \" asyncIterator \" / > ' s enumerator does not have any resources it needs to dispose . < / param > <nl> + / / / < returns > a task that signals completed when all the incoming tasks are finished . < / returns > <nl> + [ SuppressMessage ( \" Microsoft . Design \" , \" CA1031 : DoNotCatchGeneralExceptionTypes \" , Justification = \" The exception is propagated in a Task . \" ) ] <nl> + internal static Task Iterate ( IEnumerable < Task > asyncIterator , CancellationToken cancellationToken = default ( CancellationToken ) , bool disposeEnumerator = true ) <nl> + { <nl> + Contract . Assert ( asyncIterator ! = null ) ; <nl> + <nl> + IEnumerator < Task > enumerator = null ; <nl> + try <nl> + { <nl> + enumerator = asyncIterator . GetEnumerator ( ) ; <nl> + Task task = IterateImpl ( enumerator , cancellationToken ) ; <nl> + return ( disposeEnumerator & & enumerator ! = null ) ? task . Finally ( enumerator . Dispose , runSynchronously : true ) : task ; <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + return TaskHelpers . FromError ( ex ) ; <nl> + } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Provides the implementation of the Iterate method . <nl> + / / / Contains special logic to help speed up common cases . <nl> + / / / < / summary > <nl> + [ SuppressMessage ( \" Microsoft . Design \" , \" CA1031 : DoNotCatchGeneralExceptionTypes \" , Justification = \" The exception is propagated in a Task . \" ) ] <nl> + internal static Task IterateImpl ( IEnumerator < Task > enumerator , CancellationToken cancellationToken ) <nl> + { <nl> + try <nl> + { <nl> + while ( true ) <nl> + { <nl> + / / short - circuit : iteration canceled <nl> + if ( cancellationToken . IsCancellationRequested ) <nl> + { <nl> + return TaskHelpers . Canceled ( ) ; <nl> + } <nl> + <nl> + / / short - circuit : iteration complete <nl> + if ( ! enumerator . MoveNext ( ) ) <nl> + { <nl> + return TaskHelpers . Completed ( ) ; <nl> + } <nl> + <nl> + / / fast case : Task completed synchronously & successfully <nl> + Task currentTask = enumerator . Current ; <nl> + if ( currentTask . Status = = TaskStatus . RanToCompletion ) <nl> + { <nl> + continue ; <nl> + } <nl> + <nl> + / / fast case : Task completed synchronously & unsuccessfully <nl> + if ( currentTask . IsCanceled | | currentTask . IsFaulted ) <nl> + { <nl> + return currentTask ; <nl> + } <nl> + <nl> + / / slow case : Task isn ' t yet complete <nl> + return IterateImplIncompleteTask ( enumerator , currentTask , cancellationToken ) ; <nl> + } <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + return TaskHelpers . FromError ( ex ) ; <nl> + } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Fallback for IterateImpl when the antecedent Task isn ' t yet complete . <nl> + / / / < / summary > <nl> + internal static Task IterateImplIncompleteTask ( IEnumerator < Task > enumerator , Task currentTask , CancellationToken cancellationToken ) <nl> + { <nl> + / / There ' s a race condition here , the antecedent Task could complete between <nl> + / / the check in Iterate and the call to Then below . If this happens , we could <nl> + / / end up growing the stack indefinitely . But the chances of ( a ) even having <nl> + / / enough Tasks in the enumerator in the first place and of ( b ) * every * one <nl> + / / of them hitting this race condition are so extremely remote that it ' s not <nl> + / / worth worrying about . <nl> + return currentTask . Then ( ( ) = > IterateImpl ( enumerator , cancellationToken ) ) ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Replacement for Task . Factory . StartNew when the code can run synchronously . <nl> + / / / We run the code immediately and avoid the thread switch . <nl> + / / / This is used to help synchronous code implement task interfaces . <nl> + / / / < / summary > <nl> + / / / < param name = \" action \" > action to run synchronouslyt < / param > <nl> + / / / < param name = \" token \" > cancellation token . This is only checked before we run the task , and if cancelled , we immediately return a cancelled task . < / param > <nl> + / / / < returns > a task who result is the result from Func ( ) < / returns > <nl> + / / / < remarks > <nl> + / / / Avoid calling Task . Factory . StartNew . <nl> + / / / This avoids gotchas with StartNew : <nl> + / / / - ensures cancellation token is checked ( StartNew doesn ' t check cancellation tokens ) . <nl> + / / / - Keeps on the same thread . <nl> + / / / - Avoids switching synchronization contexts . <nl> + / / / Also take in a lambda so that we can wrap in a try catch and honor task failure semantics . <nl> + / / / < / remarks > <nl> + [ SuppressMessage ( \" Microsoft . Design \" , \" CA1031 : DoNotCatchGeneralExceptionTypes \" , Justification = \" The caught exception type is reflected into a faulted task . \" ) ] <nl> + public static Task RunSynchronously ( Action action , CancellationToken token = default ( CancellationToken ) ) <nl> + { <nl> + if ( token . IsCancellationRequested ) <nl> + { <nl> + return Canceled ( ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + action ( ) ; <nl> + return Completed ( ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + return FromError ( e ) ; <nl> + } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Replacement for Task . Factory . StartNew when the code can run synchronously . <nl> + / / / We run the code immediately and avoid the thread switch . <nl> + / / / This is used to help synchronous code implement task interfaces . <nl> + / / / < / summary > <nl> + / / / < typeparam name = \" TResult \" > type of result that task will return . < / typeparam > <nl> + / / / < param name = \" func \" > function to run synchronously and produce result < / param > <nl> + / / / < param name = \" cancellationToken \" > cancellation token . This is only checked before we run the task , and if cancelled , we immediately return a cancelled task . < / param > <nl> + / / / < returns > a task who result is the result from Func ( ) < / returns > <nl> + / / / < remarks > <nl> + / / / Avoid calling Task . Factory . StartNew . <nl> + / / / This avoids gotchas with StartNew : <nl> + / / / - ensures cancellation token is checked ( StartNew doesn ' t check cancellation tokens ) . <nl> + / / / - Keeps on the same thread . <nl> + / / / - Avoids switching synchronization contexts . <nl> + / / / Also take in a lambda so that we can wrap in a try catch and honor task failure semantics . <nl> + / / / < / remarks > <nl> + [ SuppressMessage ( \" Microsoft . Design \" , \" CA1031 : DoNotCatchGeneralExceptionTypes \" , Justification = \" The caught exception type is reflected into a faulted task . \" ) ] <nl> + internal static Task < TResult > RunSynchronously < TResult > ( Func < TResult > func , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> + { <nl> + if ( cancellationToken . IsCancellationRequested ) <nl> + { <nl> + return Canceled < TResult > ( ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + return FromResult ( func ( ) ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + return FromError < TResult > ( e ) ; <nl> + } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Overload of RunSynchronously that avoids a call to Unwrap ( ) . <nl> + / / / This overload is useful when func ( ) starts doing some synchronous work and then hits IO and <nl> + / / / needs to create a task to finish the work . <nl> + / / / < / summary > <nl> + / / / < typeparam name = \" TResult \" > type of result that Task will return < / typeparam > <nl> + / / / < param name = \" func \" > function that returns a task < / param > <nl> + / / / < param name = \" cancellationToken \" > cancellation token . This is only checked before we run the task , and if cancelled , we immediately return a cancelled task . < / param > <nl> + / / / < returns > a task , created by running func ( ) . < / returns > <nl> + [ SuppressMessage ( \" Microsoft . Design \" , \" CA1031 : DoNotCatchGeneralExceptionTypes \" , Justification = \" The caught exception type is reflected into a faulted task . \" ) ] <nl> + internal static Task < TResult > RunSynchronously < TResult > ( Func < Task < TResult > > func , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> + { <nl> + if ( cancellationToken . IsCancellationRequested ) <nl> + { <nl> + return Canceled < TResult > ( ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + return func ( ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + return FromError < TResult > ( e ) ; <nl> + } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Update the completion source if the task failed ( cancelled or faulted ) . No change to completion source if the task succeeded . <nl> + / / / < / summary > <nl> + / / / < typeparam name = \" TResult \" > result type of completion source < / typeparam > <nl> + / / / < param name = \" tcs \" > completion source to update < / param > <nl> + / / / < param name = \" source \" > task to update from . < / param > <nl> + / / / < returns > true on success < / returns > <nl> + internal static bool SetIfTaskFailed < TResult > ( this TaskCompletionSource < TResult > tcs , Task source ) <nl> + { <nl> + switch ( source . Status ) <nl> + { <nl> + case TaskStatus . Canceled : <nl> + case TaskStatus . Faulted : <nl> + return tcs . TrySetFromTask ( source ) ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Set a completion source from the given Task . <nl> + / / / < / summary > <nl> + / / / < typeparam name = \" TResult \" > result type for completion source . < / typeparam > <nl> + / / / < param name = \" tcs \" > completion source to set < / param > <nl> + / / / < param name = \" source \" > Task to get values from . < / param > <nl> + / / / < returns > true if this successfully sets the completion source . < / returns > <nl> + [ SuppressMessage ( \" Microsoft . WebAPI \" , \" CR4001 : DoNotCallProblematicMethodsOnTask \" , Justification = \" This is a known safe usage of Task . Result , since it only occurs when we know the task ' s state to be completed . \" ) ] <nl> + internal static bool TrySetFromTask < TResult > ( this TaskCompletionSource < TResult > tcs , Task source ) <nl> + { <nl> + if ( source . Status = = TaskStatus . Canceled ) <nl> + { <nl> + return tcs . TrySetCanceled ( ) ; <nl> + } <nl> + <nl> + if ( source . Status = = TaskStatus . Faulted ) <nl> + { <nl> + return tcs . TrySetException ( source . Exception . InnerExceptions ) ; <nl> + } <nl> + <nl> + if ( source . Status = = TaskStatus . RanToCompletion ) <nl> + { <nl> + Task < TResult > taskOfResult = source as Task < TResult > ; <nl> + return tcs . TrySetResult ( taskOfResult = = null ? default ( TResult ) : taskOfResult . Result ) ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Set a completion source from the given Task . If the task ran to completion and the result type doesn ' t match <nl> + / / / the type of the completion source , then a default value will be used . This is useful for converting Task into <nl> + / / / Task { AsyncVoid } , but it can also accidentally be used to introduce data loss ( by passing the wrong <nl> + / / / task type ) , so please execute this method with care . <nl> + / / / < / summary > <nl> + / / / < typeparam name = \" TResult \" > result type for completion source . < / typeparam > <nl> + / / / < param name = \" tcs \" > completion source to set < / param > <nl> + / / / < param name = \" source \" > Task to get values from . < / param > <nl> + / / / < returns > true if this successfully sets the completion source . < / returns > <nl> + [ SuppressMessage ( \" Microsoft . WebAPI \" , \" CR4001 : DoNotCallProblematicMethodsOnTask \" , Justification = \" This is a known safe usage of Task . Result , since it only occurs when we know the task ' s state to be completed . \" ) ] <nl> + internal static bool TrySetFromTask < TResult > ( this TaskCompletionSource < Task < TResult > > tcs , Task source ) <nl> + { <nl> + if ( source . Status = = TaskStatus . Canceled ) <nl> + { <nl> + return tcs . TrySetCanceled ( ) ; <nl> + } <nl> + <nl> + if ( source . Status = = TaskStatus . Faulted ) <nl> + { <nl> + return tcs . TrySetException ( source . Exception . InnerExceptions ) ; <nl> + } <nl> + <nl> + if ( source . Status = = TaskStatus . RanToCompletion ) <nl> + { <nl> + / / Sometimes the source task is Task < Task < TResult > > , and sometimes it ' s Task < TResult > . <nl> + / / The latter usually happens when we ' re in the middle of a sync - block postback where <nl> + / / the continuation is a function which returns Task < TResult > rather than just TResult , <nl> + / / but the originating task was itself just Task < TResult > . An example of this can be <nl> + / / found in TaskExtensions . CatchImpl ( ) . <nl> + Task < Task < TResult > > taskOfTaskOfResult = source as Task < Task < TResult > > ; <nl> + if ( taskOfTaskOfResult ! = null ) <nl> + { <nl> + return tcs . TrySetResult ( taskOfTaskOfResult . Result ) ; <nl> + } <nl> + <nl> + Task < TResult > taskOfResult = source as Task < TResult > ; <nl> + if ( taskOfResult ! = null ) <nl> + { <nl> + return tcs . TrySetResult ( taskOfResult ) ; <nl> + } <nl> + <nl> + return tcs . TrySetResult ( TaskHelpers . FromResult ( default ( TResult ) ) ) ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Used as the T in a \" conversion \" of a Task into a Task { T } <nl> + / / / < / summary > <nl> + private struct AsyncVoid <nl> + { <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / This class is a convenient cache for per - type cancelled tasks <nl> + / / / < / summary > <nl> + private static class CancelCache < TResult > <nl> + { <nl> + public static readonly Task < TResult > Canceled = GetCancelledTask ( ) ; <nl> + <nl> + private static Task < TResult > GetCancelledTask ( ) <nl> + { <nl> + TaskCompletionSource < TResult > tcs = new TaskCompletionSource < TResult > ( ) ; <nl> + tcs . SetCanceled ( ) ; <nl> + return tcs . Task ; <nl> + } <nl> + } <nl> + } <nl> + } <nl>\n", "msg": "Update src / Nancy . Hosting . Owin / TaskHelpers . cs\n"}
{"diff_id": 25140, "repo": "ppy/osu\n", "sha": "7c9d11756e566fb15bbc4ec1475680b16880a635\n", "time": "2017-12-18T09:59:25Z\n", "diff": "mmm a / osu . Game / Overlays / Notifications / ProgressNotification . cs <nl> ppp b / osu . Game / Overlays / Notifications / ProgressNotification . cs <nl> public string Text <nl> } <nl> } <nl> <nl> + public string CompletionText { get ; set ; } = \" Task has completed ! \" ; <nl> + <nl> public float Progress <nl> { <nl> get { return progressBar . Progress ; } <nl> public virtual ProgressNotificationState State <nl> protected virtual Notification CreateCompletionNotification ( ) = > new ProgressCompletionNotification <nl> { <nl> Activated = CompletionClickAction , <nl> - Text = \" Task has completed ! \" <nl> + Text = CompletionText <nl> } ; <nl> <nl> protected virtual void Completed ( ) <nl>\n", "msg": "Add the ability to change what text is displayed when a ProgressNotification finishes its task .\n"}
{"diff_id": 25376, "repo": "Live-Charts/Live-Charts\n", "sha": "975bcb5f52d7787bad1b742043cbdfaeac3b4f40\n", "time": "2016-05-16T02:36:46Z\n", "diff": "mmm a / Examples / Wpf / MainWindow . xaml . cs <nl> ppp b / Examples / Wpf / MainWindow . xaml . cs <nl> public MainWindow ( ) <nl> <nl> CartesianExamples = new List < UserControl > <nl> { <nl> - / / new Welcome ( ) , <nl> - / / new ResponsiveExample ( ) , <nl> - / / new CustomTypesPlotting ( ) , <nl> - / / new LineExample ( ) , <nl> - / / new BarExample ( ) , <nl> - / / new BubblesExample ( ) , <nl> - / / new StackedAreaExample ( ) , <nl> - / / new FinancialExample ( ) , <nl> - / / new StackedBarExample ( ) , <nl> - / / new SectionsExample ( ) , <nl> - / / new ZoomingAndPanning ( ) , <nl> + new Welcome ( ) , <nl> + new ResponsiveExample ( ) , <nl> + new CustomTypesPlotting ( ) , <nl> + new LineExample ( ) , <nl> + new BarExample ( ) , <nl> + new BubblesExample ( ) , <nl> + new StackedAreaExample ( ) , <nl> + new FinancialExample ( ) , <nl> + new StackedBarExample ( ) , <nl> + new SectionsExample ( ) , <nl> + new ZoomingAndPanning ( ) , <nl> new ConstantChangesChart ( ) , <nl> - / / new MixingTypes ( ) <nl> + new MixingTypes ( ) <nl> } ; <nl> <nl> CartesianView = CartesianExamples ! = null & & CartesianExamples . Count > 0 ? CartesianExamples [ 0 ] : null ; <nl>\n", "msg": "Bye to portable branch , LiveCharts is now toally portable and soon will be in more platfoms !\n"}
{"diff_id": 25609, "repo": "NancyFx/Nancy\n", "sha": "a25014e1b1d49256bbf9ed7cc42641533684fc1b\n", "time": "2011-09-27T13:49:28Z\n", "diff": "mmm a / src / Nancy . Testing / BrowserContext . cs <nl> ppp b / src / Nancy . Testing / BrowserContext . cs <nl> public void Body ( string body ) <nl> / / / < / summary > <nl> / / / < param name = \" body \" > A stream that should be used as the HTTP request body . < / param > <nl> / / / < param name = \" contentType \" > Content type of the HTTP request body . Defaults to ' application / octet - stream ' < / param > <nl> - public void Body ( Stream body , string contentType = \" application / octet - stream \" ) <nl> + public void Body ( Stream body , string contentType = null ) <nl> { <nl> this . Values . Body = body ; <nl> - this . Header ( \" Content - Type \" , contentType ) ; <nl> + this . Header ( \" Content - Type \" , contentType ? ? \" application / octet - stream \" ) ; <nl> } <nl> <nl> / / / < summary > <nl>\n", "msg": "Changing body method to use optional parameter set to null , added back null check\n"}
{"diff_id": 25682, "repo": "duplicati/duplicati\n", "sha": "b86005f373c739da0a29180631b8d5c0483b80ac\n", "time": "2013-07-10T12:51:25Z\n", "diff": "mmm a / Duplicati / Library / Utility / TempFile . cs <nl> ppp b / Duplicati / Library / Utility / TempFile . cs <nl> public static TempFile CreateWritePrefix ( string prefix ) <nl> return new TempFile ( System . IO . Path . Combine ( TempFolder . SystemTempPath , prefix + GenerateUniqueName ( ) ) ) ; <nl> } <nl> <nl> - # region IDisposable Members <nl> - <nl> - public void Dispose ( ) <nl> + protected void Dispose ( bool disposing ) <nl> { <nl> + if ( disposing ) <nl> + GC . SuppressFinalize ( this ) ; <nl> + <nl> try <nl> { <nl> if ( ! m_protect & & m_path ! = null & & System . IO . File . Exists ( m_path ) ) <nl> public void Dispose ( ) <nl> { <nl> } <nl> } <nl> + <nl> + # region IDisposable Members <nl> + <nl> + public void Dispose ( ) <nl> + { <nl> + Dispose ( true ) ; <nl> + } <nl> <nl> # endregion <nl> + <nl> + ~ TempFile ( ) <nl> + { <nl> + Dispose ( false ) ; <nl> + } <nl> <nl> / / / < summary > <nl> / / / Swaps two instances of temporary files , equivalent to renaming the files but requires no IO <nl>\n", "msg": "Added correct usage of temporary files for disposing without having a using directive\n"}
{"diff_id": 25979, "repo": "ServiceStack/ServiceStack\n", "sha": "e4e51952723c74150672037d30bf4491977d7587\n", "time": "2014-05-15T21:28:11Z\n", "diff": "mmm a / src / ServiceStack / Auth / FacebookAuthProvider . cs <nl> ppp b / src / ServiceStack / Auth / FacebookAuthProvider . cs <nl> public override object Authenticate ( IServiceBase authService , IAuthSession sessi <nl> var tokens = Init ( authService , ref session , request ) ; <nl> var httpRequest = authService . Request ; <nl> <nl> - var error = httpRequest . QueryString [ \" error \" ] ; <nl> + var error = httpRequest . QueryString [ \" error_code \" ] ; <nl> var hasError = ! error . IsNullOrEmpty ( ) ; <nl> if ( hasError ) <nl> { <nl> Log . Error ( \" Facebook error callback . { 0 } \" . Fmt ( httpRequest . QueryString ) ) ; <nl> return authService . Redirect ( session . ReferrerUrl ) ; <nl> - } <nl> - <nl> + } <nl> + <nl> var code = httpRequest . QueryString [ \" code \" ] ; <nl> var isPreAuthCallback = ! code . IsNullOrEmpty ( ) ; <nl> if ( ! isPreAuthCallback ) <nl>\n", "msg": "updated query string parameter name for error handler in FacebookAuthProvider\n"}
{"diff_id": 25992, "repo": "dotnet/roslyn\n", "sha": "f21e4bd94cd62e183bac3ac4cc881d9ff089bdf2\n", "time": "2020-05-19T23:28:03Z\n", "diff": "mmm a / src / Workspaces / Core / Portable / Editing / ImportAdderService . cs <nl> ppp b / src / Workspaces / Core / Portable / Editing / ImportAdderService . cs <nl> <nl> # nullable enable <nl> <nl> using System . Collections . Generic ; <nl> - using System . Collections . Immutable ; <nl> - using System . ComponentModel ; <nl> using System . Linq ; <nl> using System . Threading ; <nl> using System . Threading . Tasks ; <nl> public enum Strategy <nl> { <nl> options ? ? = await document . GetOptionsAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> <nl> - var model = await document . GetRequiredSemanticModelAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> var root = await document . GetRequiredSyntaxRootAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> var addImportsService = document . GetRequiredLanguageService < IAddImportsService > ( ) ; <nl> var generator = document . GetRequiredLanguageService < SyntaxGenerator > ( ) ; <nl> public enum Strategy <nl> var nodes = root . DescendantNodesAndSelf ( ) . Where ( <nl> n = > spansTree . HasIntervalThatOverlapsWith ( n . FullSpan . Start , n . FullSpan . Length ) ) ; <nl> <nl> - var ( importDirectivesToAdd , namespaceSymbols , context , newRoot ) = strategy switch <nl> - { <nl> - Strategy . AddImportsFromSymbolAnnotations = > GetImportDirectivesFromAnnotatedNodes ( model , nodes , root , addImportsService , generator , cancellationToken ) , <nl> - Strategy . AddImportsFromSyntaxes = > GetImportDirectivesFromSyntaxes ( model , nodes , root , addImportsService , generator , cancellationToken ) , <nl> - _ = > throw new InvalidEnumArgumentException ( nameof ( strategy ) , ( int ) strategy , typeof ( Strategy ) ) , <nl> - } ; <nl> - <nl> - / / If the previous call provided a new root , use it . <nl> - root = newRoot ? ? root ; <nl> - <nl> - if ( importDirectivesToAdd . Length = = 0 ) <nl> - { <nl> - return document . WithSyntaxRoot ( root ) ; / / keep any added simplifier annotations <nl> - } <nl> + var placeSystemNamespaceFirst = options . GetOption ( GenerationOptions . PlaceSystemNamespaceFirst , document . Project . Language ) ; <nl> <nl> if ( strategy = = Strategy . AddImportsFromSymbolAnnotations ) <nl> - { <nl> - / / Mark the context with an annotation . <nl> - / / This will allow us to find it after we have called MakeSafeToAddNamespaces . <nl> - var annotation = new SyntaxAnnotation ( ) ; <nl> - RoslynDebug . Assert ( context is object ) ; <nl> - document = document . WithSyntaxRoot ( root . ReplaceNode ( context , context . WithAdditionalAnnotations ( annotation ) ) ) ; <nl> - root = ( await document . GetSyntaxRootAsync ( ) . ConfigureAwait ( false ) ) ! ; <nl> - <nl> - model = await document . GetSemanticModelAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> - Contract . ThrowIfNull ( model ) ; <nl> + return await AddImportDirectivesFromSymbolAnnotationsAsync ( document , nodes , addImportsService , generator , placeSystemNamespaceFirst , cancellationToken ) . ConfigureAwait ( false ) ; <nl> <nl> - / / Make Safe to add namespaces <nl> - document = document . WithSyntaxRoot ( <nl> - MakeSafeToAddNamespaces ( root , namespaceSymbols , model , document . Project . Solution . Workspace , cancellationToken ) ) ; <nl> - root = ( await document . GetSyntaxRootAsync ( ) . ConfigureAwait ( false ) ) ! ; <nl> + if ( strategy = = Strategy . AddImportsFromSyntaxes ) <nl> + return await AddImportDirectivesFromSyntaxesAsync ( document , nodes , addImportsService , generator , placeSystemNamespaceFirst , cancellationToken ) . ConfigureAwait ( false ) ; <nl> <nl> - model = await document . GetSemanticModelAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> - Contract . ThrowIfNull ( model ) ; <nl> - <nl> - / / Find the context . It might be null if we have removed the context in the process of complexifying the tree . <nl> - context = root . DescendantNodesAndSelf ( ) . FirstOrDefault ( x = > x . HasAnnotation ( annotation ) ) ? ? root ; <nl> - } <nl> - <nl> - model ? ? = await document . GetRequiredSemanticModelAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> - <nl> - var placeSystemNamespaceFirst = options . GetOption ( GenerationOptions . PlaceSystemNamespaceFirst , document . Project . Language ) ; <nl> - <nl> - root = addImportsService . AddImports ( model . Compilation , root , context , importDirectivesToAdd , generator , placeSystemNamespaceFirst , cancellationToken ) ; <nl> - <nl> - return document . WithSyntaxRoot ( root ) ; <nl> + throw ExceptionUtilities . UnexpectedValue ( strategy ) ; <nl> } <nl> <nl> protected abstract INamespaceSymbol ? GetExplicitNamespaceSymbol ( SyntaxNode node , SemanticModel model ) ; <nl> private SyntaxNode GenerateNamespaceImportDeclaration ( INamespaceSymbol namespace <nl> . WithAdditionalAnnotations ( Simplifier . Annotation , Formatter . Annotation ) ; <nl> } <nl> <nl> - / / / < param name = \" root \" > ref as we add simplifier annotations to nodes with explicit namespaces < / param > <nl> - / / / < returns > < / returns > <nl> - private ( ImmutableArray < SyntaxNode > imports , HashSet < INamespaceSymbol > namespaceSymbols , SyntaxNode ? context , SyntaxNode newRoot ) GetImportDirectivesFromSyntaxes ( <nl> - SemanticModel model , <nl> + private async Task < Document > AddImportDirectivesFromSyntaxesAsync ( <nl> + Document document , <nl> IEnumerable < SyntaxNode > syntaxNodes , <nl> - SyntaxNode root , <nl> IAddImportsService addImportsService , <nl> SyntaxGenerator generator , <nl> + bool placeSystemNamespaceFirst , <nl> CancellationToken cancellationToken ) <nl> { <nl> - var importsToAdd = ArrayBuilder < SyntaxNode > . GetInstance ( ) ; <nl> + using var _1 = ArrayBuilder < SyntaxNode > . GetInstance ( out var importsToAdd ) ; <nl> + using var _2 = ArrayBuilder < SyntaxNode > . GetInstance ( out var nodesToSimplify ) ; <nl> + <nl> + var root = await document . GetRequiredSyntaxRootAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> + var model = await document . GetRequiredSemanticModelAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> <nl> var nodesWithExplicitNamespaces = syntaxNodes <nl> . Select ( n = > ( syntaxnode : n , namespaceSymbol : GetExplicitNamespaceSymbol ( n , model ) ) ) <nl> . Where ( x = > x . namespaceSymbol ! = null ) ; <nl> <nl> - using var _ = ArrayBuilder < SyntaxNode > . GetInstance ( out var nodesToSimplify ) ; <nl> - <nl> var addedSymbols = new HashSet < INamespaceSymbol > ( ) ; <nl> - <nl> foreach ( var ( node , namespaceSymbol ) in nodesWithExplicitNamespaces ) <nl> { <nl> cancellationToken . ThrowIfCancellationRequested ( ) ; <nl> private SyntaxNode GenerateNamespaceImportDeclaration ( INamespaceSymbol namespace <nl> } <nl> <nl> if ( nodesToSimplify . Count = = 0 ) <nl> - return ( importsToAdd . ToImmutableAndFree ( ) , addedSymbols , null , root ) ; <nl> + return document ; <nl> <nl> var annotation = new SyntaxAnnotation ( ) ; <nl> <nl> root = root . ReplaceNodes ( <nl> - nodesToSimplify , <nl> - ( o , r ) = > r . WithAdditionalAnnotations ( Simplifier . Annotation , annotation ) ) ; <nl> + nodesToSimplify , <nl> + ( o , r ) = > r . WithAdditionalAnnotations ( Simplifier . Annotation , annotation ) ) ; <nl> <nl> var first = root . DescendantNodesAndSelf ( ) . First ( x = > x . HasAnnotation ( annotation ) ) ; <nl> var last = root . DescendantNodesAndSelf ( ) . Last ( x = > x . HasAnnotation ( annotation ) ) ; <nl> <nl> - return ( importsToAdd . ToImmutableAndFree ( ) , addedSymbols , first . GetCommonRoot ( last ) , root ) ; <nl> + var context = first . GetCommonRoot ( last ) ; <nl> + <nl> + root = addImportsService . AddImports ( model . Compilation , root , context , importsToAdd , generator , placeSystemNamespaceFirst , cancellationToken ) ; <nl> + <nl> + return document . WithSyntaxRoot ( root ) ; <nl> + <nl> } <nl> <nl> - private ( ImmutableArray < SyntaxNode > imports , HashSet < INamespaceSymbol > namespaceSymbols , SyntaxNode ? context , SyntaxNode newRoot ) GetImportDirectivesFromAnnotatedNodes ( <nl> - SemanticModel model , <nl> + private async Task < Document > AddImportDirectivesFromSymbolAnnotationsAsync ( <nl> + Document document , <nl> IEnumerable < SyntaxNode > syntaxNodes , <nl> - SyntaxNode root , <nl> IAddImportsService addImportsService , <nl> SyntaxGenerator generator , <nl> + bool placeSystemNamespaceFirst , <nl> CancellationToken cancellationToken ) <nl> { <nl> - ( SyntaxNode first , SyntaxNode last ) ? nodes = null ; <nl> - var importsToAdd = ArrayBuilder < SyntaxNode > . GetInstance ( ) ; <nl> + using var _ = ArrayBuilder < SyntaxNode > . GetInstance ( out var importsToAdd ) ; <nl> + <nl> + var root = await document . GetRequiredSyntaxRootAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> + var model = await document . GetRequiredSemanticModelAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> <nl> + SyntaxNode ? first = null , last = null ; <nl> var annotatedNodes = syntaxNodes . Where ( x = > x . HasAnnotations ( SymbolAnnotation . Kind ) ) ; <nl> var addedSymbols = new HashSet < INamespaceSymbol > ( ) ; <nl> + <nl> foreach ( var annotatedNode in annotatedNodes ) <nl> { <nl> cancellationToken . ThrowIfCancellationRequested ( ) ; <nl> private SyntaxNode GenerateNamespaceImportDeclaration ( INamespaceSymbol namespace <nl> if ( namespaceSymbol is null | | namespaceSymbol . IsGlobalNamespace ) <nl> continue ; <nl> <nl> - nodes = ( first : nodes ? . first ? ? annotatedNode , last : annotatedNode ) ; <nl> + first ? ? = annotatedNode ; <nl> + last = annotatedNode ; <nl> + <nl> if ( addedSymbols . Contains ( namespaceSymbol ) ) <nl> continue ; <nl> <nl> private SyntaxNode GenerateNamespaceImportDeclaration ( INamespaceSymbol namespace <nl> } <nl> } <nl> <nl> - / / we don ' t add simplifier annotations here , <nl> - / / since whatever added the symbol annotation probably also added simplifier annotations , <nl> - / / and if not they probably didn ' t for a reason <nl> + if ( importsToAdd . Count = = 0 ) <nl> + return document ; <nl> + <nl> + var context = first = = null | | last = = null ? null : first . GetCommonRoot ( last ) ; <nl> <nl> - return ( importsToAdd . ToImmutableAndFree ( ) , addedSymbols , nodes is var ( first , last ) ? first . GetCommonRoot ( last ) : null , root ) ; <nl> + { <nl> + / / Mark the context with an annotation . <nl> + / / This will allow us to find it after we have called MakeSafeToAddNamespaces . <nl> + var annotation = new SyntaxAnnotation ( ) ; <nl> + RoslynDebug . Assert ( context is object ) ; <nl> + document = document . WithSyntaxRoot ( root . ReplaceNode ( context , context . WithAdditionalAnnotations ( annotation ) ) ) ; <nl> + root = await document . GetRequiredSyntaxRootAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> + model = await document . GetRequiredSemanticModelAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> + <nl> + / / Make Safe to add namespaces <nl> + document = document . WithSyntaxRoot ( <nl> + MakeSafeToAddNamespaces ( root , addedSymbols , model , document . Project . Solution . Workspace , cancellationToken ) ) ; <nl> + root = await document . GetRequiredSyntaxRootAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> + model = await document . GetRequiredSemanticModelAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> + <nl> + / / Find the context . It might be null if we have removed the context in the process of complexifying the tree . <nl> + context = root . DescendantNodesAndSelf ( ) . FirstOrDefault ( x = > x . HasAnnotation ( annotation ) ) ? ? root ; <nl> + } <nl> + <nl> + root = addImportsService . AddImports ( model . Compilation , root , context , importsToAdd , generator , placeSystemNamespaceFirst , cancellationToken ) ; <nl> + return document . WithSyntaxRoot ( root ) ; <nl> } <nl> <nl> / / / < summary > <nl>\n", "msg": "Break out logic for each type of import addition\n"}
{"diff_id": 26021, "repo": "dotnet/runtime\n", "sha": "8f83038a8b24a7b835d8826a17fadc87e711546f\n", "time": "2016-05-20T22:08:37Z\n", "diff": "mmm a / src / libraries / System . Net . Primitives / src / System / Net / CredentialCache . cs <nl> ppp b / src / libraries / System . Net . Primitives / src / System / Net / CredentialCache . cs <nl> public class CredentialCache : ICredentials , ICredentialsByHost , IEnumerable <nl> private readonly Dictionary < CredentialHostKey , NetworkCredential > _cacheForHosts = new Dictionary < CredentialHostKey , NetworkCredential > ( ) ; <nl> internal int _version ; <nl> <nl> - private int _numbDefaultCredInCache = 0 ; <nl> - <nl> - / / [ thread token optimization ] The resulting counter of default credential resided in the cache . <nl> - internal bool IsDefaultInCache <nl> - { <nl> - get <nl> - { <nl> - return _numbDefaultCredInCache ! = 0 ; <nl> - } <nl> - } <nl> - <nl> / / / < devdoc > <nl> / / / < para > <nl> / / / Initializes a new instance of the < see cref = ' System . Net . CredentialCache ' / > class . <nl> public void Add ( Uri uriPrefix , string authenticationType , NetworkCredential cred <nl> } <nl> <nl> _cache . Add ( key , credential ) ; <nl> - if ( credential is SystemNetworkCredential ) <nl> - { <nl> - + + _numbDefaultCredInCache ; <nl> - } <nl> } <nl> <nl> <nl> public void Add ( string host , int port , string authenticationType , NetworkCredent <nl> } <nl> <nl> _cacheForHosts . Add ( key , credential ) ; <nl> - if ( credential is SystemNetworkCredential ) <nl> - { <nl> - + + _numbDefaultCredInCache ; <nl> - } <nl> } <nl> <nl> <nl> public void Remove ( Uri uriPrefix , string authenticationType ) <nl> GlobalLog . Print ( \" CredentialCache : : Remove ( ) Removing key : [ \" + key . ToString ( ) + \" ] \" ) ; <nl> } <nl> <nl> - NetworkCredential value ; <nl> - if ( _cache . TryGetValue ( key , out value ) ) <nl> - { <nl> - if ( value is SystemNetworkCredential ) <nl> - { <nl> - - - _numbDefaultCredInCache ; <nl> - } <nl> - _cache . Remove ( key ) ; <nl> - } <nl> + _cache . Remove ( key ) ; <nl> } <nl> <nl> <nl> public void Remove ( string host , int port , string authenticationType ) <nl> GlobalLog . Print ( \" CredentialCache : : Remove ( ) Removing key : [ \" + key . ToString ( ) + \" ] \" ) ; <nl> } <nl> <nl> - NetworkCredential value ; <nl> - if ( _cacheForHosts . TryGetValue ( key , out value ) ) <nl> - { <nl> - if ( value is SystemNetworkCredential ) <nl> - { <nl> - - - _numbDefaultCredInCache ; <nl> - } <nl> - _cacheForHosts . Remove ( key ) ; <nl> - } <nl> + _cacheForHosts . Remove ( key ) ; <nl> } <nl> <nl> / / / < devdoc > <nl>\n", "msg": "Remove dead code from System . Net . CredentialCache\n"}
{"diff_id": 26269, "repo": "mono/mono\n", "sha": "375c8f755c32b5cdaae80a4eccd9192e587a0578\n", "time": "2014-05-20T07:20:54Z\n", "diff": "mmm a / mcs / class / Microsoft . Build / Microsoft . Build . Internal / ExpressionEvaluator . cs <nl> ppp b / mcs / class / Microsoft . Build / Microsoft . Build . Internal / ExpressionEvaluator . cs <nl> class ExpressionEvaluator <nl> public ExpressionEvaluator ( Project project ) <nl> { <nl> Project = project ; <nl> - / * <nl> - GetItems = ( name ) = > project . GetItems ( name ) . Select ( i = > new KeyValuePair < string , string > ( i . ItemType , i . EvaluatedInclude ) ) ; <nl> - GetProperty = ( name ) = > { <nl> - var prop = project . GetProperty ( name ) ; <nl> - return new KeyValuePair < string , string > ( prop ! = null ? prop . Name : null , prop ! = null ? prop . EvaluatedValue : null ) ; <nl> - } ; <nl> - * / <nl> } <nl> <nl> public ExpressionEvaluator ( ProjectInstance project ) <nl> { <nl> ProjectInstance = project ; <nl> - / * <nl> - GetItems = ( name ) = > project . GetItems ( name ) . Select ( i = > new KeyValuePair < string , string > ( i . ItemType , i . EvaluatedInclude ) ) ; <nl> - GetProperty = ( name ) = > { <nl> - var prop = project . GetProperty ( name ) ; <nl> - return new KeyValuePair < string , string > ( prop ! = null ? prop . Name : null , prop ! = null ? prop . EvaluatedValue : null ) ; <nl> - } ; <nl> - * / <nl> } <nl> <nl> EvaluationContext CreateContext ( string source ) <nl> EvaluationContext CreateContext ( string source ) <nl> <nl> public Project Project { get ; private set ; } <nl> public ProjectInstance ProjectInstance { get ; set ; } <nl> - / / public Func < string , IEnumerable < KeyValuePair < string , string > > > GetItems { get ; private set ; } <nl> - / / public Func < string , KeyValuePair < string , string > > GetProperty { get ; private set ; } <nl> - <nl> + <nl> List < ITaskItem > evaluated_task_items = new List < ITaskItem > ( ) ; <nl> <nl> public IList < ITaskItem > EvaluatedTaskItems { <nl>\n", "msg": "[ ms . build ] remove unused code .\n"}
{"diff_id": 26329, "repo": "ServiceStack/ServiceStack\n", "sha": "36b0407ee6f298daec85efd7a2f5a1f52b4fce6b\n", "time": "2014-04-19T02:22:15Z\n", "diff": "mmm a / tests / ServiceStack . ServiceHost . Tests / Formats_Razor / RazorPageResolutionTests . cs <nl> ppp b / tests / ServiceStack . ServiceHost . Tests / Formats_Razor / RazorPageResolutionTests . cs <nl> public void OnBeforeEachTest ( ) <nl> private void SetupRootContentLayout ( ) { RazorFormat . AddFileAndPage ( \" / content / _Layout . cshtml \" , RootContentLayout ) ; } <nl> private void SetupChildContentLayout ( ) { RazorFormat . AddFileAndPage ( \" / content / child / _Layout . cshtml \" , ChildContentLayout ) ; } <nl> <nl> - private void SetupAllLayoutFiles ( ) <nl> + private void SetupAllDefaultLayoutFiles ( ) <nl> { <nl> SetupSharedLayout ( ) ; <nl> SetupRootViewLayout ( ) ; <nl> public void Default_content_page_resolution_works_in_folder ( ) <nl> Assert . That ( result , Is . EqualTo ( content ) ) ; <nl> } <nl> <nl> + [ Test ] <nl> + public void View_page_can_resolve_sibling_explicit_layout ( ) <nl> + { <nl> + SetupAllDefaultLayoutFiles ( ) ; <nl> + <nl> + const string layout = \" CustomViewLayout : @ RenderBody ( ) \" ; <nl> + RazorFormat . AddFileAndPage ( \" / Views / _CustomLayout . cshtml \" , layout ) ; <nl> + <nl> + const string viewBody = \" @ { Layout = \\ \" _CustomLayout \\ \" ; } ViewPage \" ; <nl> + RazorFormat . AddFileAndPage ( \" / Views / RootView . cshtml \" , viewBody ) ; <nl> + <nl> + var result = ExecuteViewPage < RootView > ( ) ; <nl> + Assert . That ( result , Is . EqualTo ( \" CustomViewLayout : ViewPage \" ) ) ; <nl> + } <nl> + <nl> + [ Test ] <nl> + public void Content_page_can_resolve_shared_explicit_layout ( ) <nl> + { <nl> + SetupAllDefaultLayoutFiles ( ) ; <nl> + <nl> + const string layout = \" CustomContentLayout : @ RenderBody ( ) \" ; <nl> + RazorFormat . AddFileAndPage ( \" / Views / Shared / _CustomLayout . cshtml \" , layout ) ; <nl> + <nl> + const string contentBody = \" @ { Layout = \\ \" _CustomLayout \\ \" ; } ContentPage \" ; <nl> + RazorFormat . AddFileAndPage ( \" / content / page . cshtml \" , contentBody ) ; <nl> + <nl> + var result = ExecuteContentPage ( \" / content / page \" ) ; <nl> + Assert . That ( result , Is . EqualTo ( \" CustomContentLayout : ContentPage \" ) ) ; <nl> + } <nl> + <nl> [ Test ] <nl> public void Root_view_page_can_resolve_sibling_default_layout ( ) <nl> { <nl> - SetupAllLayoutFiles ( ) ; <nl> + SetupAllDefaultLayoutFiles ( ) ; <nl> <nl> const string viewBody = \" RootViewPage \" ; <nl> RazorFormat . AddFileAndPage ( \" / Views / RootView . cshtml \" , viewBody ) ; <nl> <nl> - var result = ExecuteViewPage < RootViewResponse > ( ) ; <nl> + var result = ExecuteViewPage < RootView > ( ) ; <nl> Assert . That ( result , Is . EqualTo ( RootViewLayout . Replace ( \" @ RenderBody ( ) \" , viewBody ) ) ) ; <nl> } <nl> <nl> [ Test ] <nl> public void Child_view_page_can_resolve_sibling_default_layout ( ) <nl> { <nl> - SetupAllLayoutFiles ( ) ; <nl> + SetupAllDefaultLayoutFiles ( ) ; <nl> <nl> const string viewBody = \" ChildViewPage \" ; <nl> RazorFormat . AddFileAndPage ( \" / Views / Child / ChildView . cshtml \" , viewBody ) ; <nl> <nl> - var result = ExecuteViewPage < ChildViewResponse > ( ) ; <nl> + var result = ExecuteViewPage < ChildView > ( ) ; <nl> Assert . That ( result , Is . EqualTo ( ChildViewLayout . Replace ( \" @ RenderBody ( ) \" , viewBody ) ) ) ; <nl> } <nl> <nl> [ Test ] <nl> public void Child_view_page_without_sibling_default_layout_can_resolve_parent_default_layout ( ) <nl> { <nl> - SetupAllLayoutFiles ( ) ; <nl> + SetupAllDefaultLayoutFiles ( ) ; <nl> <nl> const string viewBody = \" ChildViewWithoutSiblingLayoutPage \" ; <nl> RazorFormat . AddFileAndPage ( \" / Views / ChildWithoutLayout / ChildViewWithoutSiblingLayout . cshtml \" , viewBody ) ; <nl> <nl> - var result = ExecuteViewPage < ChildViewWithoutSiblingLayoutResponse > ( ) ; <nl> + var result = ExecuteViewPage < ChildViewWithoutSiblingLayout > ( ) ; <nl> Assert . That ( result , Is . EqualTo ( RootViewLayout . Replace ( \" @ RenderBody ( ) \" , viewBody ) ) ) ; <nl> } <nl> <nl> public void Child_view_page_without_sibling_or_parent_default_layout_can_resolve <nl> const string viewBody = \" ChildViewWithoutSiblingLayoutPage \" ; <nl> RazorFormat . AddFileAndPage ( \" / Views / ChildWithoutLayout / ChildViewWithoutSiblingLayout . cshtml \" , viewBody ) ; <nl> <nl> - var result = ExecuteViewPage < ChildViewWithoutSiblingLayoutResponse > ( ) ; <nl> + var result = ExecuteViewPage < ChildViewWithoutSiblingLayout > ( ) ; <nl> Assert . That ( result , Is . EqualTo ( SharedLayout . Replace ( \" @ RenderBody ( ) \" , viewBody ) ) ) ; <nl> } <nl> <nl> [ Test ] <nl> public void Root_content_page_can_resolve_sibling_default_layout ( ) <nl> { <nl> - SetupAllLayoutFiles ( ) ; <nl> + SetupAllDefaultLayoutFiles ( ) ; <nl> <nl> const string contentBody = \" RootContentPage \" ; <nl> RazorFormat . AddFileAndPage ( \" / content / root - content . cshtml \" , contentBody ) ; <nl> public void Root_content_page_can_resolve_sibling_default_layout ( ) <nl> [ Test ] <nl> public void Child_content_page_can_resolve_sibling_default_layout ( ) <nl> { <nl> - SetupAllLayoutFiles ( ) ; <nl> + SetupAllDefaultLayoutFiles ( ) ; <nl> <nl> const string contentBody = \" ChildContentPage \" ; <nl> RazorFormat . AddFileAndPage ( \" / content / child / child - content . cshtml \" , contentBody ) ; <nl> public void Child_content_page_can_resolve_sibling_default_layout ( ) <nl> [ Test ] <nl> public void Child_content_page_without_sibling_default_layout_can_resolve_parent_default_layout ( ) <nl> { <nl> - SetupAllLayoutFiles ( ) ; <nl> + SetupAllDefaultLayoutFiles ( ) ; <nl> <nl> const string contentBody = \" ChildContentWithoutSiblingLayoutPage \" ; <nl> RazorFormat . AddFileAndPage ( \" / content / child - without - layout / child - content . cshtml \" , contentBody ) ; <nl> public void Child_content_page_without_sibling_or_parent_default_layout_can_reso <nl> [ Test ] <nl> public void Default_content_page_can_resolve_sibling_default_layout ( ) <nl> { <nl> - SetupAllLayoutFiles ( ) ; <nl> + SetupAllDefaultLayoutFiles ( ) ; <nl> <nl> const string contentBody = \" RootDefaultContentPage \" ; <nl> RazorFormat . AddFileAndPage ( \" / content / \" + RazorFormat . DefaultPageName , contentBody ) ; <nl> public void Content_page_does_not_resolve_root_view_folder_default_layout ( ) <nl> Assert . That ( result , Is . EqualTo ( contentBody ) ) ; <nl> } <nl> <nl> - private string ExecuteViewPage < T > ( ) where T : new ( ) <nl> + private string ExecuteViewPage < TRequest > ( ) where TRequest : new ( ) <nl> { <nl> - var mockReq = new MockHttpRequest { OperationName = typeof ( T ) . Name . Replace ( \" Response \" , \" \" ) } ; <nl> - var mockRes = new MockHttpResponse ( ) ; <nl> - var dto = new T ( ) ; <nl> - RazorFormat . ProcessRequest ( mockReq , mockRes , dto ) ; <nl> + var responseDtoType = typeof ( TRequest ) . Assembly . GetType ( typeof ( TRequest ) . FullName + \" Response \" ) ; <nl> + var responseDto = Activator . CreateInstance ( responseDtoType ) ; <nl> + var mockReq = new MockHttpRequest { OperationName = typeof ( TRequest ) . Name , Dto = new TRequest ( ) } ; <nl> + var mockRes = new MockHttpResponse { Dto = responseDto } ; <nl> + RazorFormat . ProcessRequest ( mockReq , mockRes , responseDto ) ; <nl> return mockRes . ReadAsString ( ) ; <nl> } <nl> <nl>\n", "msg": "Added a few tests related to explicitly set layout file resolution .\n"}
{"diff_id": 26473, "repo": "mono/mono\n", "sha": "6d2d8f3bf77c9bd040026de1f78b2928d8ac75f7\n", "time": "2006-08-28T02:26:39Z\n", "diff": "mmm a / mcs / class / System . Drawing / System . Drawing / ColorTranslator . cs <nl> ppp b / mcs / class / System . Drawing / System . Drawing / ColorTranslator . cs <nl> private ColorTranslator ( ) <nl> public static Color FromHtml ( string htmlColor ) <nl> { <nl> if ( ( htmlColor = = null ) | | ( htmlColor . Length = = 0 ) ) <nl> - return Color . FromArgb ( 0 , 0 , 0 , 0 ) ; <nl> + return Color . Empty ; <nl> <nl> switch ( htmlColor . ToLower ( ) ) { <nl> case \" buttonface \" : <nl>\n", "msg": "ColorTranslator . cs : Use ColorEmpty instead of creating a new Color instance .\n"}
{"diff_id": 26624, "repo": "dotnet/runtime\n", "sha": "7816a10eedfbb4585875cd76ebd7304383cd46d0\n", "time": "2016-03-19T14:52:20Z\n", "diff": "mmm a / src / mono / mono / tests / pinvoke3 . cs <nl> ppp b / src / mono / mono / tests / pinvoke3 . cs <nl> class Derived : Base { <nl> var m = typeof ( Marshal ) . GetMethod ( \" PtrToStringAnsi \" , new Type [ ] { typeof ( IntPtr ) } ) ; <nl> <nl> return mono_test_marshal_icall_delegate ( ( IcallDelegate ) Delegate . CreateDelegate ( typeof ( IcallDelegate ) , m ) ) ; <nl> - Console . WriteLine ( m ) ; <nl> - return 0 ; <nl> } <nl> } <nl>\n", "msg": "[ runtime ] Remove some dead test code added by mono / mono @ c736aba5c94c20e6faad6b736f8e3a834e26d95f .\n"}
{"diff_id": 26656, "repo": "mono/mono\n", "sha": "4abc469313c100f5afa5b8166e0943b389f07c5d\n", "time": "2006-07-02T13:07:19Z\n", "diff": "mmm a / mcs / class / System . Web / Test / mainsoft / NunitWeb / NunitWeb / FakeMembershipProvider . cs <nl> ppp b / mcs / class / System . Web / Test / mainsoft / NunitWeb / NunitWeb / FakeMembershipProvider . cs <nl> public override bool ChangePassword ( string username , string oldPwd , string newP <nl> return null ; <nl> } <nl> <nl> - MembershipUser u = new MembershipUser ( \" FakeProvider \" , username , \" \" , email , passwordQuestion , \" \" , isApproved , false , DateTime . FromBinary ( 10000 ) , DateTime . FromBinary ( 10000 ) , DateTime . FromBinary ( 10000 ) , DateTime . FromBinary ( 0 ) , DateTime . FromBinary ( 0 ) ) ; <nl> + MembershipUser u = new MembershipUser ( \" FakeProvider \" , username , \" \" , email , passwordQuestion , \" \" , isApproved , false , DateTime . Now , DateTime . Now , DateTime . Now , DateTime . Now , DateTime . Now ) ; <nl> status = MembershipCreateStatus . Success ; <nl> return u ; <nl> } <nl> public override string GetPassword ( string username , string answer ) <nl> <nl> public override MembershipUser GetUser ( string username , bool userIsOnline ) <nl> { <nl> - MembershipUser u = new MembershipUser ( \" \" , username , \" \" , \" \" , \" \" , \" \" , true , false , DateTime . FromBinary ( 10000 ) , DateTime . FromBinary ( 10000 ) , DateTime . FromBinary ( 10000 ) , DateTime . FromBinary ( 0 ) , DateTime . FromBinary ( 0 ) ) ; <nl> + MembershipUser u = new MembershipUser ( \" \" , username , \" \" , \" \" , \" \" , \" \" , true , false , DateTime . Now , DateTime . Now , DateTime . Now , DateTime . Now , DateTime . Now ) ; <nl> return u ; <nl> } <nl> <nl> public override MembershipUser GetUser ( object providerUserKey , bool userIsOnline ) <nl> { <nl> - MembershipUser u = new MembershipUser ( \" \" , \" \" , providerUserKey , \" \" , \" \" , \" \" , true , false , DateTime . FromBinary ( 10000 ) , DateTime . FromBinary ( 10000 ) , DateTime . FromBinary ( 10000 ) , DateTime . FromBinary ( 0 ) , DateTime . FromBinary ( 0 ) ) ; <nl> + MembershipUser u = new MembershipUser ( \" \" , \" \" , providerUserKey , \" \" , \" \" , \" \" , true , false , DateTime . Now , DateTime . Now , DateTime . Now , DateTime . Now , DateTime . Now ) ; <nl> return u ; <nl> } <nl> <nl>\n", "msg": "* fixed DateTime . FromBinary to DateTime . Now\n"}
{"diff_id": 26739, "repo": "microsoft/VFSForGit\n", "sha": "de873c92599d3bd797b0cd3db33fcc52314d5ef4\n", "time": "2019-09-09T21:37:23Z\n", "diff": "mmm a / GVFS / GVFS / CommandLine / SparseVerb . cs <nl> ppp b / GVFS / GVFS / CommandLine / SparseVerb . cs <nl> public class SparseVerb : GVFSVerb . ForExistingEnlistment <nl> HelpText = \" List of folders in the sparse set for determining what to project . \" ) ] <nl> public bool List { get ; set ; } <nl> <nl> + [ Option ( <nl> + ' p ' , <nl> + \" prune \" , <nl> + Required = false , <nl> + Default = false , <nl> + HelpText = \" Remove any folders that are not in the list of sparse folders . \" ) ] <nl> + public bool Prune { get ; set ; } <nl> + <nl> protected override string VerbName = > SparseVerbName ; <nl> <nl> protected override void Execute ( GVFSEnlistment enlistment ) <nl> protected override void Execute ( GVFSEnlistment enlistment ) <nl> EventLevel . Informational , <nl> Keywords . Any ) ; <nl> <nl> + HashSet < string > directories ; <nl> bool needToChangeProjection = false ; <nl> using ( GVFSDatabase database = new GVFSDatabase ( new PhysicalFileSystem ( ) , enlistment . EnlistmentRoot , new SqliteDatabase ( ) ) ) <nl> { <nl> SparseTable sparseTable = new SparseTable ( database ) ; <nl> - HashSet < string > directories = sparseTable . GetAll ( ) ; <nl> + directories = sparseTable . GetAll ( ) ; <nl> <nl> string [ ] foldersToRemove = this . ParseFolderList ( this . Remove ) ; <nl> string [ ] foldersToAdd = this . ParseFolderList ( this . Add ) ; <nl> <nl> - if ( this . List | | ( foldersToAdd . Length = = 0 & & foldersToRemove . Length = = 0 ) ) <nl> + if ( this . List | | ( foldersToAdd . Length = = 0 & & foldersToRemove . Length = = 0 & & ! this . Prune ) ) <nl> { <nl> if ( directories . Count = = 0 ) <nl> { <nl> protected override void Execute ( GVFSEnlistment enlistment ) <nl> if ( directories . Contains ( folder ) ) <nl> { <nl> needToChangeProjection = true ; <nl> - break ; <nl> + directories . Remove ( folder ) ; <nl> } <nl> } <nl> <nl> - if ( ! needToChangeProjection ) <nl> + foreach ( string folder in foldersToAdd ) <nl> { <nl> - foreach ( string folder in foldersToAdd ) <nl> + if ( ! directories . Contains ( folder ) ) <nl> { <nl> - if ( ! directories . Contains ( folder ) ) <nl> - { <nl> - needToChangeProjection = true ; <nl> - break ; <nl> - } <nl> + needToChangeProjection = true ; <nl> + directories . Add ( folder ) ; <nl> } <nl> } <nl> <nl> - if ( needToChangeProjection ) <nl> + if ( needToChangeProjection | | this . Prune ) <nl> { <nl> / / Make sure there is a clean git status before allowing sparse set to change <nl> this . CheckGitStatus ( tracer , enlistment ) ; <nl> - if ( ! this . ShowStatusWhileRunning ( <nl> - ( ) = > <nl> - { <nl> - foreach ( string directoryPath in foldersToRemove ) <nl> - { <nl> - tracer . RelatedInfo ( $ \" Removing ' { directoryPath } ' from sparse folders . \" ) ; <nl> - sparseTable . Remove ( directoryPath ) ; <nl> - } <nl> - <nl> - foreach ( string directoryPath in foldersToAdd ) <nl> - { <nl> - tracer . RelatedInfo ( $ \" Adding ' { directoryPath } ' to sparse folders . \" ) ; <nl> - sparseTable . Add ( directoryPath ) ; <nl> - } <nl> - <nl> - return true ; <nl> - } , <nl> - \" Updating sparse folder set \" , <nl> - suppressGvfsLogMessage : true ) ) <nl> - { <nl> - this . ReportErrorAndExit ( tracer , \" Failed to update sparse folder set . \" ) ; <nl> - } <nl> + } <nl> + <nl> + if ( needToChangeProjection ) <nl> + { <nl> + this . UpdateSparseFolders ( tracer , sparseTable , foldersToRemove , foldersToAdd ) ; <nl> } <nl> } <nl> <nl> protected override void Execute ( GVFSEnlistment enlistment ) <nl> { <nl> this . WriteMessage ( tracer , \" No folders to update in sparse set . \" ) ; <nl> } <nl> + <nl> + if ( this . Prune ) <nl> + { <nl> + this . PruneFoldersOutsideSparse ( tracer , enlistment , directories ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private void PruneFoldersOutsideSparse ( ITracer tracer , Enlistment enlistment , HashSet < string > sparseFolders ) <nl> + { <nl> + string [ ] directoriesToDehydrate = this . GetDirectoriesOutsideSparse ( enlistment . WorkingDirectoryBackingRoot , sparseFolders ) ; <nl> + if ( directoriesToDehydrate . Length > 0 ) <nl> + { <nl> + if ( ! this . ShowStatusWhileRunning ( <nl> + ( ) = > <nl> + { <nl> + ReturnCode verbReturnCode = this . ExecuteGVFSVerb < DehydrateVerb > ( <nl> + tracer , <nl> + verb = > <nl> + { <nl> + verb . Confirmed = true ; <nl> + verb . Folders = string . Join ( FolderListSeparator , directoriesToDehydrate ) ; <nl> + } ) ; <nl> + <nl> + return verbReturnCode = = ReturnCode . Success ; <nl> + } , <nl> + \" Pruning folders \" ) ) <nl> + { <nl> + this . ReportErrorAndExit ( tracer , \" Failed to prune . \" ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private string [ ] GetDirectoriesOutsideSparse ( string rootPath , HashSet < string > sparseFolders ) <nl> + { <nl> + PhysicalFileSystem fileSystem = new PhysicalFileSystem ( ) ; <nl> + Queue < string > foldersToEnumerate = new Queue < string > ( ) ; <nl> + foldersToEnumerate . Enqueue ( rootPath ) ; <nl> + <nl> + List < string > foldersOutsideSparse = new List < string > ( ) ; <nl> + while ( foldersToEnumerate . Count > 0 ) <nl> + { <nl> + string folderToEnumerate = foldersToEnumerate . Dequeue ( ) ; <nl> + foreach ( string directory in fileSystem . EnumerateDirectories ( folderToEnumerate ) ) <nl> + { <nl> + string enlistmentRootRelativeFolderPath = GVFSDatabase . NormalizePath ( directory . Substring ( rootPath . Length ) ) ; <nl> + if ( sparseFolders . Any ( x = > x . StartsWith ( enlistmentRootRelativeFolderPath + Path . DirectorySeparatorChar , GVFSPlatform . Instance . Constants . PathComparison ) ) ) <nl> + { <nl> + foldersToEnumerate . Enqueue ( directory ) ; <nl> + } <nl> + else if ( ! sparseFolders . Contains ( enlistmentRootRelativeFolderPath ) ) <nl> + { <nl> + foldersOutsideSparse . Add ( enlistmentRootRelativeFolderPath ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + return foldersOutsideSparse . ToArray ( ) ; <nl> + } <nl> + <nl> + private void UpdateSparseFolders ( ITracer tracer , SparseTable sparseTable , string [ ] foldersToRemove , string [ ] foldersToAdd ) <nl> + { <nl> + if ( ! this . ShowStatusWhileRunning ( <nl> + ( ) = > <nl> + { <nl> + foreach ( string directoryPath in foldersToRemove ) <nl> + { <nl> + tracer . RelatedInfo ( $ \" Removing ' { directoryPath } ' from sparse folders . \" ) ; <nl> + sparseTable . Remove ( directoryPath ) ; <nl> + } <nl> + <nl> + foreach ( string directoryPath in foldersToAdd ) <nl> + { <nl> + tracer . RelatedInfo ( $ \" Adding ' { directoryPath } ' to sparse folders . \" ) ; <nl> + sparseTable . Add ( directoryPath ) ; <nl> + } <nl> + <nl> + return true ; <nl> + } , <nl> + \" Updating sparse folder set \" , <nl> + suppressGvfsLogMessage : true ) ) <nl> + { <nl> + this . ReportErrorAndExit ( tracer , \" Failed to update sparse folder set . \" ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Add - - prune option for removing folders outside the sparse list\n"}
{"diff_id": 26768, "repo": "MonoGame/MonoGame\n", "sha": "157f654621039f35c9d1e798bbd27b631da3ed04\n", "time": "2012-06-12T20:01:44Z\n", "diff": "mmm a / MonoGame . Framework / iOS / iOSGameView . cs <nl> ppp b / MonoGame . Framework / iOS / iOSGameView . cs <nl> private void CreateFramebuffer ( ) <nl> / / to go away someday . <nl> gds . GraphicsDevice . glFramebuffer = _framebuffer ; <nl> } <nl> + <nl> + Threading . BackgroundContext = new MonoTouch . OpenGLES . EAGLContext ( ctx . EAGLContext . API , ctx . EAGLContext . ShareGroup ) ; <nl> } <nl> <nl> private void DestroyFramebuffer ( ) <nl>\n", "msg": "Fixed null reference to Threading . BackgroundContext . . . ?\n"}
{"diff_id": 26790, "repo": "jellyfin/jellyfin\n", "sha": "af38e5469f30b1b08e341fa00a7a7eea53388b8a\n", "time": "2020-07-31T19:33:25Z\n", "diff": "mmm a / Jellyfin . Drawing . Skia / SkiaEncoder . cs <nl> ppp b / Jellyfin . Drawing . Skia / SkiaEncoder . cs <nl> internal static SKImage ResizeImage ( SKBitmap source , SKImageInfo targetInfo , boo <nl> <nl> var kernel = new float [ 9 ] <nl> { <nl> - 0 , - . 1f , 0 , <nl> - - . 1f , 1 . 4f , - . 1f , <nl> - 0 , - . 1f , 0 , <nl> + 0 , - . 1f , 0 , <nl> + - . 1f , 1 . 4f , - . 1f , <nl> + 0 , - . 1f , 0 , <nl> } ; <nl> <nl> var kernelSize = new SKSizeI ( 3 , 3 ) ; <nl>\n", "msg": "Update Jellyfin . Drawing . Skia / SkiaEncoder . cs indentation .\n"}
{"diff_id": 26882, "repo": "OpenRA/OpenRA\n", "sha": "d8c752ecb9fa70cb3bb6608753d2af22d01a90cd\n", "time": "2013-03-10T06:35:36Z\n", "diff": "mmm a / OpenRA . Mods . RA / World / DebugOverlay . cs <nl> ppp b / OpenRA . Mods . RA / World / DebugOverlay . cs <nl> public void Render ( WorldRenderer wr ) <nl> <nl> var qr = Game . Renderer . WorldQuadRenderer ; <nl> bool doDim = refreshTick - world . FrameNumber < = 0 ; <nl> - if ( doDim ) refreshTick = world . FrameNumber + 25 ; <nl> + if ( doDim ) refreshTick = world . FrameNumber + 20 ; <nl> + <nl> + var viewBounds = Game . viewport . WorldBounds ( world ) ; <nl> + var mapBounds = world . Map . Bounds ; <nl> <nl> foreach ( var pair in layers ) <nl> { <nl> Color c = ( pair . Key ! = null ) ? pair . Key . ColorRamp . GetColor ( 0f ) : Color . PaleTurquoise ; <nl> var layer = pair . Value ; <nl> <nl> - for ( int j = world . Map . Bounds . Top ; j < = world . Map . Bounds . Bottom ; + + j ) <nl> - for ( int i = world . Map . Bounds . Left ; i < = world . Map . Bounds . Right ; + + i ) <nl> + for ( int j = mapBounds . Top ; j < = mapBounds . Bottom ; + + j ) <nl> + for ( int i = mapBounds . Left ; i < = mapBounds . Right ; + + i ) <nl> { <nl> - var ploc = new CPos ( i , j ) . ToPPos ( ) ; <nl> if ( layer [ i , j ] < = 0 ) continue ; <nl> <nl> var w = Math . Max ( 0 , Math . Min ( layer [ i , j ] , 128 ) ) ; <nl> if ( doDim ) <nl> { <nl> - layer [ i , j ] = layer [ i , j ] * 4 / 5 ; <nl> + layer [ i , j ] = layer [ i , j ] * 5 / 6 ; <nl> } <nl> + <nl> + if ( ! viewBounds . Contains ( i , j ) ) continue ; <nl> + <nl> + / / Only render quads in viewing range : <nl> + var ploc = new CPos ( i , j ) . ToPPos ( ) ; <nl> qr . FillRect ( new RectangleF ( ploc . X , ploc . Y , Game . CellSize , Game . CellSize ) , Color . FromArgb ( w , c ) ) ; <nl> } <nl> } <nl>\n", "msg": "DebugOverlay improvements to only render inside viewing range .\n"}
{"diff_id": 27077, "repo": "ServiceStack/ServiceStack\n", "sha": "d6fb1594c000fc945b69d81d1a34b1d3fcf18d76\n", "time": "2014-08-24T05:47:52Z\n", "diff": "mmm a / src / ServiceStack / ServerEventsFeature . cs <nl> ppp b / src / ServiceStack / ServerEventsFeature . cs <nl> public class ServerEventsHeartbeatHandler : HttpAsyncTaskHandler <nl> <nl> public override Task ProcessRequestAsync ( IRequest req , IResponse res , string operationName ) <nl> { <nl> - req . TryResolve < IServerEvents > ( ) . Pulse ( req . QueryString [ \" id \" ] ) ; <nl> + var subscriptionId = req . QueryString [ \" id \" ] ; <nl> + if ( ! req . TryResolve < IServerEvents > ( ) . Pulse ( subscriptionId ) ) <nl> + { <nl> + res . StatusCode = 404 ; <nl> + res . StatusDescription = \" Subscription { 0 } does not exist \" . Fmt ( subscriptionId ) ; <nl> + } <nl> res . EndHttpHandlerRequest ( skipHeaders : true ) ; <nl> return EmptyTask ; <nl> } <nl> public void NotifySession ( string sspid , string selector , object message , string <nl> } <nl> } <nl> <nl> - public void Pulse ( string id ) <nl> + public bool Pulse ( string id ) <nl> { <nl> var sub = GetSubscription ( id ) ; <nl> - if ( sub = = null ) return ; <nl> + if ( sub = = null ) <nl> + return false ; <nl> sub . Pulse ( ) ; <nl> + return true ; <nl> } <nl> <nl> public IEventSubscription GetSubscription ( string id ) <nl> public interface IServerEvents <nl> <nl> List < Dictionary < string , string > > GetSubscriptions ( string channel = null ) ; <nl> <nl> - void Pulse ( string id ) ; <nl> + bool Pulse ( string id ) ; <nl> <nl> / / Clear all Registrations <nl> void Reset ( ) ; <nl> } <nl> <nl> - static class Selector <nl> + public static class Selector <nl> { <nl> public static string Id ( Type type ) <nl> { <nl> public static void NotifySubscription ( this IServerEvents server , string subscrip <nl> server . NotifySubscription ( subscriptionId , Selector . Id ( message . GetType ( ) ) , message , channel ) ; <nl> } <nl> <nl> - public static void NotifyUserId ( this IServerEvents server , string userId , string selector , object message , string channel = null ) <nl> + public static void NotifyUserId ( this IServerEvents server , string userId , object message , string channel = null ) <nl> { <nl> server . NotifyUserId ( userId , Selector . Id ( message . GetType ( ) ) , message , channel ) ; <nl> } <nl> <nl> - public static void NotifyUserName ( this IServerEvents server , string userName , string selector , object message , string channel = null ) <nl> + public static void NotifyUserName ( this IServerEvents server , string userName , object message , string channel = null ) <nl> { <nl> server . NotifyUserName ( userName , Selector . Id ( message . GetType ( ) ) , message , channel ) ; <nl> } <nl> <nl> - public static void NotifySession ( this IServerEvents server , string sspid , string selector , object message , string channel = null ) <nl> + public static void NotifySession ( this IServerEvents server , string sspid , object message , string channel = null ) <nl> { <nl> server . NotifySession ( sspid , Selector . Id ( message . GetType ( ) ) , message , channel ) ; <nl> } <nl>\n", "msg": "Change Pulse to return a bool to indicate whether Pulse was successful\n"}
{"diff_id": 27101, "repo": "nopSolutions/nopCommerce\n", "sha": "f0a7a25fa1b06017682f2cbc37e3cd887adfdef2\n", "time": "2016-06-25T05:28:53Z\n", "diff": "mmm a / src / Presentation / Nop . Web / Administration / Controllers / ProductController . cs <nl> ppp b / src / Presentation / Nop . Web / Administration / Controllers / ProductController . cs <nl> protected virtual void PrepareStoresMappingModel ( ProductModel model , Product pro <nl> [ NonAction ] <nl> protected virtual void SaveCategoryMappings ( Product product , ProductModel model ) <nl> { <nl> - var existingProductCategories = _categoryService . GetProductCategoriesByProductId ( product . Id , showHidden : true ) ; <nl> + var existingProductCategories = _categoryService . GetProductCategoriesByProductId ( product . Id , true ) ; <nl> <nl> / / delete categories <nl> foreach ( var existingProductCategory in existingProductCategories ) <nl> protected virtual void SaveCategoryMappings ( Product product , ProductModel model ) <nl> / / add categories <nl> foreach ( var categoryId in model . CategoryIds ) <nl> if ( existingProductCategories . FindProductCategory ( product . Id , categoryId ) = = null ) <nl> + { <nl> + / / find next display order <nl> + var displayOrder = 1 ; <nl> + var existingCategoryMapping = _categoryService . GetProductCategoriesByCategoryId ( categoryId , showHidden : true ) ; <nl> + if ( existingCategoryMapping . Any ( ) ) <nl> + displayOrder = existingCategoryMapping . Max ( x = > x . DisplayOrder ) + 1 ; <nl> _categoryService . InsertProductCategory ( new ProductCategory <nl> { <nl> ProductId = product . Id , <nl> CategoryId = categoryId , <nl> - DisplayOrder = model . DisplayOrder <nl> + DisplayOrder = displayOrder <nl> } ) ; <nl> + } <nl> } <nl> <nl> [ NonAction ] <nl> protected virtual void SaveManufacturerMappings ( Product product , ProductModel model ) <nl> { <nl> - var existingProductManufacturers = _manufacturerService . GetProductManufacturersByProductId ( product . Id , showHidden : true ) ; <nl> + var existingProductManufacturers = _manufacturerService . GetProductManufacturersByProductId ( product . Id , true ) ; <nl> <nl> / / delete manufacturers <nl> foreach ( var existingProductManufacturer in existingProductManufacturers ) <nl> protected virtual void SaveManufacturerMappings ( Product product , ProductModel mo <nl> / / add manufacturers <nl> foreach ( var manufacturerId in model . ManufacturerIds ) <nl> if ( existingProductManufacturers . FindProductManufacturer ( product . Id , manufacturerId ) = = null ) <nl> + { <nl> + / / find next display order <nl> + var displayOrder = 1 ; <nl> + var existingManufacturerMapping = _manufacturerService . GetProductManufacturersByManufacturerId ( manufacturerId , showHidden : true ) ; <nl> + if ( existingManufacturerMapping . Any ( ) ) <nl> + displayOrder = existingManufacturerMapping . Max ( x = > x . DisplayOrder ) + 1 ; <nl> _manufacturerService . InsertProductManufacturer ( new ProductManufacturer ( ) <nl> { <nl> ProductId = product . Id , <nl> ManufacturerId = manufacturerId , <nl> - DisplayOrder = model . DisplayOrder <nl> + DisplayOrder = displayOrder <nl> } ) ; <nl> + } <nl> } <nl> <nl> [ NonAction ] <nl>\n", "msg": "Further changes on the previous commit ( set maximum available display order when mapping a new category or manufacturer )\n"}
{"diff_id": 27246, "repo": "mono/mono\n", "sha": "bb5890363f22c4e44ebc929bd7a35f2308b06d44\n", "time": "2012-04-18T22:54:18Z\n", "diff": "mmm a / mcs / class / Mono . Cecil / Mono . Cecil / MetadataSystem . cs <nl> ppp b / mcs / class / Mono . Cecil / Mono . Cecil / MetadataSystem . cs <nl> static void InitializePrimitives ( ) <nl> <nl> public static void TryProcessPrimitiveTypeReference ( TypeReference type ) <nl> { <nl> + if ( type . Namespace ! = \" System \" ) <nl> + return ; <nl> + <nl> var scope = type . scope ; <nl> if ( scope = = null | | scope . MetadataScopeType ! = MetadataScopeType . AssemblyNameReference | | scope . Name ! = \" mscorlib \" ) <nl> return ; <nl> public static bool TryGetPrimitiveElementType ( TypeDefinition type , out ElementT <nl> { <nl> etype = ElementType . None ; <nl> <nl> + if ( type . Namespace ! = \" System \" ) <nl> + return false ; <nl> + <nl> if ( ! type . HasImage | | ! type . Module . IsCorlib ( ) ) <nl> return false ; <nl> <nl> public static bool TryGetPrimitiveElementType ( TypeDefinition type , out ElementT <nl> <nl> static bool TryGetPrimitiveData ( TypeReference type , out Row < ElementType , bool > primitive_data ) <nl> { <nl> - primitive_data = new Row < ElementType , bool > ( ) ; <nl> - <nl> - if ( type . Namespace ! = \" System \" ) <nl> - return false ; <nl> - <nl> if ( primitive_value_types = = null ) <nl> InitializePrimitives ( ) ; <nl> <nl>\n", "msg": "Bring jbevain / cecil ' s commit 19ba9cd4664f135963b52abd633485e2bec8da4a , Fail earlier when trying to process primitive types\n"}
{"diff_id": 27284, "repo": "Jackett/Jackett\n", "sha": "6201712ce9beaf1f62a3ec5b63907a0589592d5f\n", "time": "2016-12-14T07:55:05Z\n", "diff": "mmm a / src / Jackett / Indexers / HDTorrents . cs <nl> ppp b / src / Jackett / Indexers / HDTorrents . cs <nl> public async Task < IEnumerable < ReleaseInfo > > PerformQuery ( TorznabQuery query ) <nl> string category = qRow . Find ( \" td : eq ( 0 ) a \" ) . Attr ( \" href \" ) . Replace ( \" torrents . php ? category = \" , \" \" ) ; <nl> release . Category = MapTrackerCatToNewznab ( category ) ; <nl> <nl> - if ( qRow . Find ( \" img [ alt = \\ \" Silver Torrent \\ \" ] \" ) . Length > = 1 ) <nl> + release . UploadVolumeFactor = 1 ; <nl> + <nl> + if ( qRow . Find ( \" img [ alt = \\ \" Free Torrent \\ \" ] \" ) . Length > = 1 ) <nl> + { <nl> + release . DownloadVolumeFactor = 0 ; <nl> + release . UploadVolumeFactor = 0 ; <nl> + } <nl> + else if ( qRow . Find ( \" img [ alt = \\ \" Silver Torrent \\ \" ] \" ) . Length > = 1 ) <nl> release . DownloadVolumeFactor = 0 . 5 ; <nl> else if ( qRow . Find ( \" img [ alt = \\ \" Bronze Torrent \\ \" ] \" ) . Length > = 1 ) <nl> release . DownloadVolumeFactor = 0 . 75 ; <nl> public async Task < IEnumerable < ReleaseInfo > > PerformQuery ( TorznabQuery query ) <nl> else <nl> release . DownloadVolumeFactor = 1 ; <nl> <nl> - release . UploadVolumeFactor = 1 ; <nl> - <nl> releases . Add ( release ) ; <nl> } <nl> } <nl>\n", "msg": "HD Torrents : add support for NO RATIO label\n"}
{"diff_id": 27306, "repo": "nopSolutions/nopCommerce\n", "sha": "8956316d0b31abf139d2590c39d74065ed1129fc\n", "time": "2015-04-20T11:46:45Z\n", "diff": "mmm a / src / Libraries / Nop . Services / Localization / LocalizationExtensions . cs <nl> ppp b / src / Libraries / Nop . Services / Localization / LocalizationExtensions . cs <nl> public static string GetLocalizedEnum < T > ( this T enumValue , ILocalizationService <nl> / / / < param name = \" plugin \" > Plugin < / param > <nl> / / / < param name = \" resourceName \" > Resource name < / param > <nl> / / / < param name = \" resourceValue \" > Resource value < / param > <nl> + / / / < param name = \" languageCulture \" > Language culture code . If null or empty , then a resource will be added for all languages < / param > <nl> public static void AddOrUpdatePluginLocaleResource ( this BasePlugin plugin , <nl> - string resourceName , string resourceValue ) <nl> + string resourceName , string resourceValue , string languageCulture = null ) <nl> { <nl> var localizationService = EngineContext . Current . Resolve < ILocalizationService > ( ) ; <nl> var languageService = EngineContext . Current . Resolve < ILanguageService > ( ) ; <nl> AddOrUpdatePluginLocaleResource ( plugin , localizationService , <nl> - languageService , resourceName , resourceValue ) ; <nl> + languageService , resourceName , resourceValue , languageCulture ) ; <nl> } <nl> / / / < summary > <nl> / / / Add a locale resource ( if new ) or update an existing one <nl> public static string GetLocalizedEnum < T > ( this T enumValue , ILocalizationService <nl> / / / < param name = \" languageService \" > Language service < / param > <nl> / / / < param name = \" resourceName \" > Resource name < / param > <nl> / / / < param name = \" resourceValue \" > Resource value < / param > <nl> + / / / < param name = \" languageCulture \" > Language culture code . If null or empty , then a resource will be added for all languages < / param > <nl> public static void AddOrUpdatePluginLocaleResource ( this BasePlugin plugin , <nl> ILocalizationService localizationService , ILanguageService languageService , <nl> - string resourceName , string resourceValue ) <nl> + string resourceName , string resourceValue , string languageCulture = null ) <nl> { <nl> / / actually plugin instance is not required <nl> if ( plugin = = null ) <nl> public static string GetLocalizedEnum < T > ( this T enumValue , ILocalizationService <nl> <nl> foreach ( var lang in languageService . GetAllLanguages ( true ) ) <nl> { <nl> + if ( ! String . IsNullOrEmpty ( languageCulture ) & & ! languageCulture . Equals ( lang . LanguageCulture ) ) <nl> + continue ; <nl> + <nl> var lsr = localizationService . GetLocaleStringResourceByName ( resourceName , lang . Id , false ) ; <nl> if ( lsr = = null ) <nl> { <nl>\n", "msg": "Allow plugin developers to insert locales for certain languages ( \" AddOrUpdatePluginLocaleResource \" method ) .\n"}
{"diff_id": 27322, "repo": "mono/mono\n", "sha": "8a6d0028bd5f7fe33f054d8f95ba7d0006ff7910\n", "time": "2019-02-04T13:14:53Z\n", "diff": "mmm a / mcs / tools / xbuild / LoggerInfo . cs <nl> ppp b / mcs / tools / xbuild / LoggerInfo . cs <nl> static string GetLoggerTypeName ( string assemblyName ) <nl> if ( HasAssemblyInfo ( assemblyName ) ) <nl> loggerAssembly = Assembly . Load ( assemblyName ) ; <nl> else if ( File . Exists ( assemblyName ) ) <nl> - loggerAssembly = Assembly . LoadFile ( assemblyName ) ; <nl> + loggerAssembly = Assembly . LoadFrom ( assemblyName ) ; <nl> <nl> if ( loggerAssembly = = null ) <nl> return null ; <nl>\n", "msg": "Use LoadFrom instead LoadFile for load logger type .\n"}
{"diff_id": 27469, "repo": "migueldeicaza/gui.cs\n", "sha": "ebb3c186ce4f6d3d011065e1b5a86a344c62b39e\n", "time": "2019-10-25T20:43:48Z\n", "diff": "mmm a / Terminal . Gui / Core . cs <nl> ppp b / Terminal . Gui / Core . cs <nl> <nl> using System . Threading ; <nl> using System . Linq ; <nl> using NStack ; <nl> + using System . ComponentModel ; <nl> <nl> namespace Terminal . Gui { <nl> <nl> static public RunState Begin ( Toplevel toplevel ) <nl> var rs = new RunState ( toplevel ) ; <nl> <nl> Init ( ) ; <nl> + if ( toplevel is ISupportInitializeNotification initializableNotification & & <nl> + ! initializableNotification . IsInitialized ) { <nl> + initializableNotification . BeginInit ( ) ; <nl> + initializableNotification . EndInit ( ) ; <nl> + } else if ( toplevel is ISupportInitialize initializable ) { <nl> + initializable . BeginInit ( ) ; <nl> + initializable . EndInit ( ) ; <nl> + } <nl> toplevels . Push ( toplevel ) ; <nl> Current = toplevel ; <nl> Driver . PrepareToRun ( MainLoop , ProcessKeyEvent , ProcessMouseEvent ) ; <nl>\n", "msg": "Add support for ISupportInitialize / ISupportInitializeNotification for UIs ( )\n"}
{"diff_id": 27481, "repo": "jellyfin/jellyfin\n", "sha": "adb789a802438f756492326b0c036bc77d70cea1\n", "time": "2020-06-01T08:58:16Z\n", "diff": "mmm a / Emby . Server . Implementations / Networking / NetworkManager . cs <nl> ppp b / Emby . Server . Implementations / Networking / NetworkManager . cs <nl> private static IEnumerable < PhysicalAddress > GetMacAddressesInternal ( ) <nl> = > NetworkInterface . GetAllNetworkInterfaces ( ) <nl> . Where ( i = > i . NetworkInterfaceType ! = NetworkInterfaceType . Loopback ) <nl> . Select ( x = > x . GetPhysicalAddress ( ) ) <nl> - . Where ( x = > x ! = null & & x ! = PhysicalAddress . None ) ; <nl> + . Where ( x = > ! x . Equals ( PhysicalAddress . None ) ) ; <nl> <nl> private void OnNetworkAvailabilityChanged ( object sender , NetworkAvailabilityEventArgs e ) <nl> { <nl>\n", "msg": "Update Emby . Server . Implementations / Networking / NetworkManager . cs\n"}
{"diff_id": 27649, "repo": "ServiceStack/ServiceStack\n", "sha": "85c6c291f6d9249b836a893198ae1f0bc57f8501\n", "time": "2020-04-06T09:51:48Z\n", "diff": "mmm a / src / ServiceStack . Common / Script / Methods / ProtectedScripts . cs <nl> ppp b / src / ServiceStack . Common / Script / Methods / ProtectedScripts . cs <nl> public Type @ typeof ( string typeName ) <nl> <nl> var key = \" type : \" + typeName ; <nl> <nl> - Type cookType ( Type type , List < string > genericArgs , bool isArray ) <nl> + Type cookType ( Type type , List < string > genericArgs , bool isArray , bool isNullable ) <nl> { <nl> if ( type . IsGenericType ) <nl> { <nl> Type cookType ( Type type , List < string > genericArgs , bool isArray ) <nl> type = type . MakeArrayType ( ) ; <nl> } <nl> <nl> - return type ; <nl> + return isNullable <nl> + ? typeof ( Nullable < > ) . MakeGenericType ( type ) <nl> + : type ; <nl> } <nl> <nl> Type onlyTypeOf ( string _typeName ) <nl> Type onlyTypeOf ( string _typeName ) <nl> genericArgs = typeGenericArgs ( _typeName ) ; <nl> _typeName = _typeName . LeftPart ( ' < ' ) + ' ` ' + Math . Max ( genericArgs . Count , 1 ) ; <nl> } <nl> - <nl> + var isNullable = _typeName . EndsWith ( \" ? \" ) ; <nl> + if ( isNullable ) <nl> + _typeName = _typeName . Substring ( 0 , _typeName . Length - 1 ) ; <nl> + <nl> if ( _typeName . IndexOf ( ' . ' ) > = 0 ) <nl> { <nl> if ( Context . ScriptTypeQualifiedNameMap . TryGetValue ( _typeName , out var type ) ) <nl> - return cookType ( type , genericArgs , isArray ) ; <nl> + return cookType ( type , genericArgs , isArray , isNullable ) ; <nl> <nl> if ( Context . AllowScriptingOfAllTypes ) <nl> { <nl> type = AssemblyUtils . FindType ( _typeName ) ; <nl> if ( type ! = null ) <nl> - return cookType ( type , genericArgs , isArray ) ; <nl> + return cookType ( type , genericArgs , isArray , isNullable ) ; <nl> } <nl> } <nl> else <nl> Type onlyTypeOf ( string _typeName ) <nl> _ = > null , <nl> } ; <nl> if ( ret ! = null ) <nl> - return ret ; <nl> + { <nl> + return isNullable <nl> + ? typeof ( Nullable < > ) . MakeGenericType ( ret ) <nl> + : ret ; <nl> + } <nl> <nl> if ( Context . ScriptTypeNameMap . TryGetValue ( _typeName , out var type ) ) <nl> - return cookType ( type , genericArgs , isArray ) ; <nl> + return cookType ( type , genericArgs , isArray , isNullable ) ; <nl> } <nl> <nl> foreach ( var ns in Context . ScriptNamespaces ) <nl> { <nl> var lookupType = ns + \" . \" + _typeName ; <nl> if ( Context . ScriptTypeQualifiedNameMap . TryGetValue ( lookupType , out var type ) ) <nl> - return cookType ( type , genericArgs , isArray ) ; <nl> + return cookType ( type , genericArgs , isArray , isNullable ) ; <nl> <nl> if ( Context . AllowScriptingOfAllTypes ) <nl> { <nl> type = AssemblyUtils . FindType ( lookupType ) ; <nl> if ( type ! = null ) <nl> - return cookType ( type , genericArgs , isArray ) ; <nl> + return cookType ( type , genericArgs , isArray , isNullable ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Add support for Nullable Types in @ typeof ( ) script method\n"}
{"diff_id": 27652, "repo": "dotnet/roslyn\n", "sha": "ef27aa803f31596e2035470c3ccadc4467edb9c2\n", "time": "2020-04-15T21:22:24Z\n", "diff": "mmm a / src / Compilers / CSharp / Portable / Binder / Semantics / OverloadResolution / OverloadResolution . cs <nl> ppp b / src / Compilers / CSharp / Portable / Binder / Semantics / OverloadResolution / OverloadResolution . cs <nl> private static bool OverloadResolutionResultIsValid < TMember > ( ArrayBuilder < Member <nl> ref HashSet < DiagnosticInfo > useSiteDiagnostics ) <nl> { <nl> Debug . Assert ( funcPtrBuilder . Count = = 1 ) ; <nl> + Debug . Assert ( funcPtrBuilder [ 0 ] . Arity = = 0 ) ; <nl> var typeArgumentsBuilder = ArrayBuilder < TypeWithAnnotations > . GetInstance ( ) ; <nl> <nl> - / / PROTOTYPE ( func - ptr ) : Handle dynamic <nl> AddMemberToCandidateSet ( <nl> funcPtrBuilder [ 0 ] , <nl> overloadResolutionResult . ResultsBuilder , <nl>\n", "msg": "Function pointer method symbols can never have type parameters , so no dynamic inference for type arguments needs to happen .\n"}
{"diff_id": 27670, "repo": "mRemoteNG/mRemoteNG\n", "sha": "6066cb708efe50aac2493d0e815af900d393a97b\n", "time": "2019-08-30T14:28:42Z\n", "diff": "mmm a / mRemoteV1 / Config / Serializers / MiscSerializers / ActiveDirectoryDeserializer . cs <nl> ppp b / mRemoteV1 / Config / Serializers / MiscSerializers / ActiveDirectoryDeserializer . cs <nl> <nl> using mRemoteNG . App ; <nl> using mRemoteNG . Config . Import ; <nl> using mRemoteNG . Connection ; <nl> + using mRemoteNG . Connection . Protocol ; <nl> using mRemoteNG . Container ; <nl> using mRemoteNG . Tools ; <nl> using mRemoteNG . Tree ; <nl> private void DeserializeConnection ( DirectoryEntry directoryEntry , ContainerInfo <nl> { <nl> Name = displayName , <nl> Hostname = hostName , <nl> - Description = description <nl> + Description = description , <nl> + Protocol = ProtocolType . RDP <nl> } ; <nl> <nl> parentContainer . AddChild ( newConnectionInfo ) ; <nl>\n", "msg": "set protocol type when importing from ad , possible fix for\n"}
{"diff_id": 27673, "repo": "gitextensions/gitextensions\n", "sha": "af07d98ab8fe961b3ddc91f35f11130ef2a7539c\n", "time": "2011-12-07T17:52:53Z\n", "diff": "mmm a / GitUI / FormStatus . cs <nl> ppp b / GitUI / FormStatus . cs <nl> private void FormStatus_Load ( object sender , EventArgs e ) <nl> { <nl> Abort . Visible = false ; <nl> } <nl> + StartPosition = FormStartPosition . CenterParent ; <nl> RestorePosition ( \" process \" ) ; <nl> Start ( ) ; <nl> } <nl> <nl> + protected override void OnClosing ( System . ComponentModel . CancelEventArgs e ) <nl> + { <nl> + SavePosition ( \" process \" ) ; <nl> + base . OnClosing ( e ) ; <nl> + } <nl> + <nl> private void FormStatus_FormClosed ( object sender , FormClosedEventArgs e ) <nl> { <nl> # if ! __MonoCS__ <nl>\n", "msg": "Fixed save form position on progress / status dialog\n"}
{"diff_id": 27709, "repo": "dotnet/orleans\n", "sha": "5590075460ad93f3810582f3dd9c13c822858b11\n", "time": "2015-04-03T15:27:37Z\n", "diff": "mmm a / src / OrleansRuntime / GrainTypeManager / SiloAssemblyLoader . cs <nl> ppp b / src / OrleansRuntime / GrainTypeManager / SiloAssemblyLoader . cs <nl> private static void LogGrainTypesFound ( TraceLogger logger , Dictionary < string , Gr <nl> if ( ! typeof ( ISystemTarget ) . IsAssignableFrom ( grainType . Type ) ) <nl> { <nl> int grainClassTypeCode = CodeGeneration . GrainInterfaceData . GetGrainClassTypeCode ( grainType . Type ) ; <nl> - sb . AppendFormat ( \" Grain class { 0 } [ { 1 } ( 0x { 2 } ) ] from { 3 } . dll implementing interfaces : \" , <nl> + sb . AppendFormat ( \" Grain class { 0 } . { 1 } [ { 2 } ( 0x { 3 } ) ] from { 4 } . dll implementing interfaces : \" , <nl> + grainType . Type . Namespace , <nl> TypeUtils . GetTemplatedName ( grainType . Type ) , <nl> grainClassTypeCode , <nl> grainClassTypeCode . ToString ( \" X \" ) , <nl>\n", "msg": "Print full grain class name in silo init loading .\n"}
{"diff_id": 27877, "repo": "OpenRA/OpenRA\n", "sha": "3924e2643dab2ada9c49939864cf528148172b46\n", "time": "2015-04-22T19:51:01Z\n", "diff": "mmm a / OpenRA . Mods . D2k / Traits / Carryall . cs <nl> ppp b / OpenRA . Mods . D2k / Traits / Carryall . cs <nl> public void UnreserveCarryable ( ) <nl> Carrying = null ; <nl> } <nl> <nl> - IsBusy = false ; <nl> - Carrying = null ; <nl> + CarryableReleased ( ) ; <nl> } <nl> <nl> / / INotifyKilled <nl>\n", "msg": "Clean up state properly when a Carryall ' s cargo has died\n"}
{"diff_id": 27882, "repo": "Wox-launcher/Wox\n", "sha": "99b5e3565d0750be234459bf558a6ef8ca321026\n", "time": "2019-10-23T09:20:33Z\n", "diff": "mmm a / Wox / ViewModel / MainViewModel . cs <nl> ppp b / Wox / ViewModel / MainViewModel . cs <nl> private void InitializeKeyCommands ( ) <nl> { <nl> EscCommand = new RelayCommand ( _ = > <nl> { <nl> - if ( ! ResultsSelected ( ) ) <nl> + if ( ! SelectedIsFromQueryResults ( ) ) <nl> { <nl> SelectedResults = Results ; <nl> } <nl> private void InitializeKeyCommands ( ) <nl> MainWindowVisibility = Visibility . Collapsed ; <nl> } <nl> <nl> - if ( ResultsSelected ( ) ) <nl> + if ( SelectedIsFromQueryResults ( ) ) <nl> { <nl> _userSelectedRecord . Add ( result ) ; <nl> _history . Add ( result . OriginQuery . RawQuery ) ; <nl> } <nl> + else <nl> + { <nl> + SelectedResults = Results ; <nl> + } <nl> } <nl> } ) ; <nl> <nl> LoadContextMenuCommand = new RelayCommand ( _ = > <nl> { <nl> - if ( ResultsSelected ( ) ) <nl> + if ( SelectedIsFromQueryResults ( ) ) <nl> { <nl> SelectedResults = ContextMenu ; <nl> } <nl> private void InitializeKeyCommands ( ) <nl> <nl> LoadHistoryCommand = new RelayCommand ( _ = > <nl> { <nl> - if ( ResultsSelected ( ) ) <nl> + if ( SelectedIsFromQueryResults ( ) ) <nl> { <nl> SelectedResults = History ; <nl> History . SelectedIndex = _history . Items . Count - 1 ; <nl> private ResultsViewModel SelectedResults <nl> set <nl> { <nl> _selectedResults = value ; <nl> - if ( ResultsSelected ( ) ) <nl> + if ( SelectedIsFromQueryResults ( ) ) <nl> { <nl> ContextMenu . Visbility = Visibility . Collapsed ; <nl> History . Visbility = Visibility . Collapsed ; <nl> private ResultsViewModel SelectedResults <nl> <nl> public void Query ( ) <nl> { <nl> - if ( ResultsSelected ( ) ) <nl> + if ( SelectedIsFromQueryResults ( ) ) <nl> { <nl> QueryResults ( ) ; <nl> } <nl> private Result ContextMenuPluginInfo ( string id ) <nl> return menu ; <nl> } <nl> <nl> - private bool ResultsSelected ( ) <nl> + private bool SelectedIsFromQueryResults ( ) <nl> { <nl> var selected = SelectedResults = = Results ; <nl> return selected ; <nl>\n", "msg": "Add return to main query window from context menu after selection\n"}
{"diff_id": 27893, "repo": "dotnet/roslyn\n", "sha": "1ea152642889f4bde68d6d83225b36ed4ec253ad\n", "time": "2019-08-13T20:09:12Z\n", "diff": "mmm a / src / Workspaces / Remote / ServiceHub / Telemetry / WatsonReporter . cs <nl> ppp b / src / Workspaces / Remote / ServiceHub / Telemetry / WatsonReporter . cs <nl> internal class WatsonReporter <nl> / / / < / summary > <nl> private static Func < IFaultUtility , int > s_defaultCallback = _ = > 0 ; <nl> <nl> + / / / < summary > <nl> + / / / Default telemetry session <nl> + / / / < / summary > <nl> + [ Obsolete ( \" use RoslynServices . SessionOpt instead \" , error : false ) ] <nl> + public static TelemetrySession SessionOpt = > RoslynServices . SessionOpt ; <nl> + <nl> + / / / < summary > <nl> + / / / Check whether current user is microsoft internal or not <nl> + / / / < / summary > <nl> + [ Obsolete ( \" use RoslynServices . IsUserMicrosoftInternal instead \" , error : false ) ] <nl> + public static bool IsUserMicrosoftInternal = > RoslynServices . IsUserMicrosoftInternal ; <nl> + <nl> / / / < summary > <nl> / / / Report Non - Fatal Watson <nl> / / / < / summary > <nl>\n", "msg": "put some API back since it broke partner ' s IVT\n"}
{"diff_id": 27924, "repo": "dotnet/runtime\n", "sha": "eb7837c2775f38a1b862467ea8896ddf8c94295e\n", "time": "2020-11-26T11:07:40Z\n", "diff": "mmm a / src / libraries / Microsoft . Extensions . Logging . Console / src / ConsoleLoggerProvider . cs <nl> ppp b / src / libraries / Microsoft . Extensions . Logging . Console / src / ConsoleLoggerProvider . cs <nl> public ILogger CreateLogger ( string name ) <nl> ConsoleLoggerFormat . Systemd = > _formatters [ ConsoleFormatterNames . Systemd ] , <nl> _ = > _formatters [ ConsoleFormatterNames . Simple ] , <nl> } ; <nl> + # pragma warning restore CS0618 <nl> + <nl> if ( _options . CurrentValue . FormatterName = = null ) <nl> { <nl> UpdateFormatterOptions ( logFormatter , _options . CurrentValue ) ; <nl> } <nl> - # pragma warning restore CS0618 <nl> } <nl> <nl> - return _loggers . GetOrAdd ( name , loggerName = > new ConsoleLogger ( name , _messageQueue ) <nl> - { <nl> - Options = _options . CurrentValue , <nl> - ScopeProvider = _scopeProvider , <nl> - Formatter = logFormatter , <nl> - } ) ; <nl> + return _loggers . TryGetValue ( name , out ConsoleLogger logger ) ? <nl> + logger : <nl> + _loggers . GetOrAdd ( name , new ConsoleLogger ( name , _messageQueue ) <nl> + { <nl> + Options = _options . CurrentValue , <nl> + ScopeProvider = _scopeProvider , <nl> + Formatter = logFormatter , <nl> + } ) ; <nl> } <nl> + <nl> # pragma warning disable CS0618 <nl> private void UpdateFormatterOptions ( ConsoleFormatter formatter , ConsoleLoggerOptions deprecatedFromOptions ) <nl> { <nl>\n", "msg": "Remove closure / delegate allocation from ConsoleLoggerProvider . CreateLogger ( )\n"}
{"diff_id": 27998, "repo": "Sonarr/Sonarr\n", "sha": "68eada4c4d5b48a71527c3aa496f95e6f4524320\n", "time": "2013-04-10T23:50:56Z\n", "diff": "mmm a / NzbDrone . Core / Indexers / IndexerService . cs <nl> ppp b / NzbDrone . Core / Indexers / IndexerService . cs <nl> <nl> -  using System . Collections . Generic ; <nl> +  using System ; <nl> + using System . Collections . Generic ; <nl> using System . Linq ; <nl> using NLog ; <nl> using NzbDrone . Common . Eventing ; <nl> public void Handle ( ApplicationStartedEvent message ) <nl> foreach ( var feedProvider in _indexers ) <nl> { <nl> IIndexerBase indexerLocal = feedProvider ; <nl> - if ( ! currentIndexers . Exists ( c = > c . Name = = indexerLocal . Name ) ) <nl> + if ( ! currentIndexers . Exists ( c = > c . Name . Equals ( indexerLocal . Name , StringComparison . InvariantCultureIgnoreCase ) ) ) <nl> { <nl> var settings = new IndexerDefinition <nl> { <nl>\n", "msg": "fixed indexer name compression to be case in - sensitive .\n"}
{"diff_id": 28141, "repo": "hbons/SparkleShare\n", "sha": "87d8c1ebce0af14ce8c17a208f8eef6827a594f8\n", "time": "2011-02-12T23:55:28Z\n", "diff": "mmm a / SparkleShare / Mac / SparkleShare / SparkleUI . cs <nl> ppp b / SparkleShare / Mac / SparkleShare / SparkleUI . cs <nl> public SparkleUI ( ) <nl> } ) ; <nl> <nl> } ; <nl> + <nl> + SparkleShare . Controller . OnIdle + = delegate { <nl> + <nl> + InvokeOnMainThread ( delegate { <nl> + <nl> + foreach ( SparkleLog log in SparkleUI . OpenLogs ) <nl> + log . UpdateEventLog ( ) ; <nl> + <nl> + } ) ; <nl> + <nl> + } ; <nl> <nl> } <nl> <nl>\n", "msg": "[ ui ] update [ log ] on local commits\n"}
{"diff_id": 28458, "repo": "dotnet/aspnetcore\n", "sha": "b705ac2c0aa44d42459993944da1483941196ecc\n", "time": "2018-02-22T15:03:49Z\n", "diff": "mmm a / src / Microsoft . AspNetCore . Blazor . Browser / Routing / NavLink . cs <nl> ppp b / src / Microsoft . AspNetCore . Blazor . Browser / Routing / NavLink . cs <nl> <nl> using Microsoft . AspNetCore . Blazor . RenderTree ; <nl> using System ; <nl> using System . Collections . Generic ; <nl> + using System . Linq ; <nl> <nl> namespace Microsoft . AspNetCore . Blazor . Browser . Routing <nl> { <nl> namespace Microsoft . AspNetCore . Blazor . Browser . Routing <nl> / / That ' s because you ' d use NavLink in non - browser scenarios too ( e . g . , prerendering ) . <nl> / / Can ' t do this until DI is implemented . <nl> <nl> + / / NOTE : This could be implemented in a more performant way by iterating through <nl> + / / the ParameterCollection only once ( instead of multiple TryGetValue calls ) , and <nl> + / / avoiding allocating a dictionary in the case where there are no additional params . <nl> + / / However the intention here is to get a sense of what more high - level coding patterns <nl> + / / will exist and what APIs are needed to support them . Later in the project when we <nl> + / / have more examples of components implemented in pure C # ( not Razor ) we could change <nl> + / / this one to the more low - level perf - sensitive implementation . <nl> + <nl> public class NavLink : IComponent , IDisposable <nl> { <nl> - const string CssClassAttributeName = \" class \" ; <nl> - const string HrefAttributeName = \" href \" ; <nl> - <nl> private RenderHandle _renderHandle ; <nl> private bool _isActive ; <nl> <nl> private RenderFragment _childContent ; <nl> private string _cssClass ; <nl> - private string _href ; <nl> private string _hrefAbsolute ; <nl> - private IDictionary < string , string > _otherAttributes ; <nl> + private IReadOnlyDictionary < string , object > _allAttributes ; <nl> <nl> public void Init ( RenderHandle renderHandle ) <nl> { <nl> _renderHandle = renderHandle ; <nl> + <nl> + / / We ' ll consider re - rendering on each location change <nl> UriHelper . OnLocationChanged + = OnLocationChanged ; <nl> } <nl> <nl> public void SetParameters ( ParameterCollection parameters ) <nl> { <nl> - _childContent = null ; <nl> - _href = null ; <nl> - _hrefAbsolute = null ; <nl> - _cssClass = null ; <nl> - _otherAttributes ? . Clear ( ) ; <nl> - foreach ( var kvp in parameters ) <nl> - { <nl> - switch ( kvp . Name ) <nl> - { <nl> - case RenderTreeBuilder . ChildContent : <nl> - _childContent = kvp . Value as RenderFragment ; <nl> - break ; <nl> - case CssClassAttributeName : <nl> - _cssClass = kvp . Value as string ; <nl> - break ; <nl> - case HrefAttributeName : <nl> - _href = kvp . Value as string ; <nl> - _hrefAbsolute = UriHelper . ToAbsoluteUri ( _href ) . AbsoluteUri ; <nl> - break ; <nl> - default : <nl> - if ( kvp . Value ! = null ) <nl> - { <nl> - if ( _otherAttributes = = null ) <nl> - { <nl> - _otherAttributes = new Dictionary < string , string > ( ) ; <nl> - } <nl> - _otherAttributes . Add ( kvp . Name , kvp . Value . ToString ( ) ) ; <nl> - } <nl> - break ; <nl> - } <nl> - } <nl> - <nl> + / / Capture the parameters we want to do special things with , plus all as a dictionary <nl> + parameters . TryGetValue ( RenderTreeBuilder . ChildContent , out _childContent ) ; <nl> + parameters . TryGetValue ( \" class \" , out _cssClass ) ; <nl> + parameters . TryGetValue ( \" href \" , out string href ) ; <nl> + _allAttributes = parameters . ToDictionary ( ) ; <nl> + <nl> + / / Update computed state and render <nl> + _hrefAbsolute = href = = null ? null : UriHelper . ToAbsoluteUri ( href ) . AbsoluteUri ; <nl> _isActive = UriHelper . GetAbsoluteUri ( ) . Equals ( _hrefAbsolute , StringComparison . Ordinal ) ; <nl> _renderHandle . Render ( Render ) ; <nl> } <nl> <nl> public void Dispose ( ) <nl> { <nl> + / / To avoid leaking memory , it ' s important to detach any event handlers <nl> + / / in Dispose ( ) . <nl> UriHelper . OnLocationChanged - = OnLocationChanged ; <nl> } <nl> <nl> private void OnLocationChanged ( object sender , string e ) <nl> { <nl> + / / We could just re - render always , but for this component we know the <nl> + / / only relevant state change is to the _isActive property . <nl> var shouldBeActiveNow = UriHelper . GetAbsoluteUri ( ) . Equals ( <nl> _hrefAbsolute , <nl> StringComparison . Ordinal ) ; <nl> private void OnLocationChanged ( object sender , string e ) <nl> if ( shouldBeActiveNow ! = _isActive ) <nl> { <nl> _isActive = shouldBeActiveNow ; <nl> - <nl> - if ( _renderHandle . IsInitialized ) <nl> - { <nl> - _renderHandle . Render ( Render ) ; <nl> - } <nl> + _renderHandle . Render ( Render ) ; <nl> } <nl> } <nl> <nl> private void Render ( RenderTreeBuilder builder ) <nl> { <nl> builder . OpenElement ( 0 , \" a \" ) ; <nl> <nl> - if ( ! string . IsNullOrEmpty ( _href ) ) <nl> - { <nl> - builder . AddAttribute ( 0 , HrefAttributeName , _href ) ; <nl> - } <nl> + / / Set \" active \" class dynamically <nl> + builder . AddAttribute ( 0 , \" class \" , CombineWithSpace ( _cssClass , _isActive ? \" active \" : null ) ) ; <nl> <nl> - var combinedClassValue = CombineWithSpace ( _cssClass , _isActive ? \" active \" : null ) ; <nl> - if ( combinedClassValue ! = null ) <nl> + / / Pass through all other attributes unchanged <nl> + foreach ( var kvp in _allAttributes . Where ( kvp = > kvp . Key ! = \" class \" ) ) <nl> { <nl> - builder . AddAttribute ( 0 , CssClassAttributeName , combinedClassValue ) ; <nl> + builder . AddAttribute ( 0 , kvp . Key , kvp . Value ) ; <nl> } <nl> <nl> - if ( _otherAttributes ! = null ) <nl> - { <nl> - foreach ( var kvp in _otherAttributes ) <nl> - { <nl> - builder . AddAttribute ( 0 , kvp . Key , kvp . Value ) ; <nl> - } <nl> - } <nl> - <nl> - if ( _childContent ! = null ) <nl> - { <nl> - builder . AddContent ( 1 , _childContent ) ; <nl> - } <nl> + / / Pass through any child content unchanged <nl> + builder . AddContent ( 1 , _childContent ) ; <nl> <nl> builder . CloseElement ( ) ; <nl> } <nl>\n", "msg": "Switch to slightly higher - level implementation of NavLink ( sacrificing some perf for better representation of current idioms )\n"}
{"diff_id": 28473, "repo": "dotnet/runtime\n", "sha": "843c8d739812a348f35e2c4d687c00c089b2336b\n", "time": "2017-05-05T08:44:24Z\n", "diff": "mmm a / src / libraries / System . Configuration . ConfigurationManager / tests / System / Configuration / TypeUtilTests . cs <nl> ppp b / src / libraries / System . Configuration . ConfigurationManager / tests / System / Configuration / TypeUtilTests . cs <nl> public void GetType_NoThrowOnError ( ) <nl> } <nl> <nl> [ Fact ] <nl> + [ SkipOnTargetFramework ( TargetFrameworkMonikers . NetFramework , \" dotnet / corefx # 19339 \" ) ] <nl> public void GetTypeConfigHost ( ) <nl> { <nl> TestHost host = new TestHost ( ( s , b ) = > { return typeof ( string ) ; } ) ; <nl> public void GetTypeConfigHost ( ) <nl> } <nl> <nl> [ Fact ] <nl> + [ SkipOnTargetFramework ( TargetFrameworkMonikers . NetFramework , \" dotnet / corefx # 19339 \" ) ] <nl> public void GetTypeConfigHost_ThrowOnError ( ) <nl> { <nl> TestHost host = new TestHost ( ( s , b ) = > { if ( b ) throw new ArgumentException ( ) ; return null ; } ) ; <nl> public void GetTypeConfigHost_ThrowOnError ( ) <nl> } <nl> <nl> [ Fact ] <nl> + [ SkipOnTargetFramework ( TargetFrameworkMonikers . NetFramework , \" dotnet / corefx # 19339 \" ) ] <nl> public void GetTypeConfigHost_NoThrowOnError ( ) <nl> { <nl> TestHost host = new TestHost ( ( s , b ) = > { if ( b ) throw new ArgumentException ( ) ; return null ; } ) ; <nl>\n", "msg": "Disable failed tests for issue 19339 . ( dotnet / corefx )\n"}
{"diff_id": 28505, "repo": "dotnet/roslyn\n", "sha": "6361275337efa88c12f7ad2532ea63dc65f1f846\n", "time": "2020-01-28T04:40:21Z\n", "diff": "mmm a / src / Workspaces / Core / Portable / Workspace / Solution / ProjectDependencyGraph_RemoveProject . cs <nl> ppp b / src / Workspaces / Core / Portable / Workspace / Solution / ProjectDependencyGraph_RemoveProject . cs <nl> internal ProjectDependencyGraph WithProjectRemoved ( ProjectId projectId ) <nl> / / Project ID set and direct forward references are trivially updated by removing the key corresponding to <nl> / / the project getting removed . <nl> var projectIds = _projectIds . Remove ( projectId ) ; <nl> - var referencesMap = ComputeNewReferencesMapForRemovedProject ( _lazyReverseReferencesMap , _referencesMap , projectId ) ; <nl> + var referencesMap = ComputeNewReferencesMapForRemovedProject ( <nl> + referencesMap : _referencesMap , <nl> + existingReverseReferencesMap : _lazyReverseReferencesMap , <nl> + projectId ) ; <nl> <nl> / / The direct reverse references map is updated by removing the key for the project getting removed , and <nl> / / also updating any direct references to the removed project . <nl> var reverseReferencesMap = _lazyReverseReferencesMap is object <nl> - ? ComputeNewReverseReferencesMapForRemovedProject ( _referencesMap , _lazyReverseReferencesMap , projectId ) <nl> + ? ComputeNewReverseReferencesMapForRemovedProject ( <nl> + existingForwardReferencesMap : _referencesMap , <nl> + existingReverseReferencesMap : _lazyReverseReferencesMap , <nl> + projectId ) <nl> : null ; <nl> var transitiveReferencesMap = ComputeNewTransitiveReferencesMapForRemovedProject ( _transitiveReferencesMap , projectId ) ; <nl> var reverseTransitiveReferencesMap = ComputeNewReverseTransitiveReferencesMapForRemovedProject ( _reverseTransitiveReferencesMap , projectId ) ; <nl> internal ProjectDependencyGraph WithProjectRemoved ( ProjectId projectId ) <nl> / / / < summary > <nl> / / / Computes a new < see cref = \" _referencesMap \" / > for the removal of a project . <nl> / / / < / summary > <nl> + / / / < param name = \" referencesMap \" > The < see cref = \" _referencesMap \" / > prior to the removal . < / param > <nl> / / / < param name = \" existingReverseReferencesMap \" > The < see cref = \" _lazyReverseReferencesMap \" / > prior to the removal . <nl> / / / This map serves as a hint to the removal process ; i . e . it is assumed correct if it contains data , but may be <nl> / / / omitted without impacting correctness . < / param > <nl> - / / / < param name = \" referencesMap \" > The < see cref = \" _referencesMap \" / > prior to the removal . < / param > <nl> / / / < param name = \" projectId \" > The ID of the project which is being removed . < / param > <nl> / / / < returns > The < see cref = \" _referencesMap \" / > for the project dependency graph once the project is removed . < / returns > <nl> private ImmutableDictionary < ProjectId , ImmutableHashSet < ProjectId > > ComputeNewReferencesMapForRemovedProject ( <nl> - ImmutableDictionary < ProjectId , ImmutableHashSet < ProjectId > > ? existingReverseReferencesMap , <nl> ImmutableDictionary < ProjectId , ImmutableHashSet < ProjectId > > referencesMap , <nl> + ImmutableDictionary < ProjectId , ImmutableHashSet < ProjectId > > ? existingReverseReferencesMap , <nl> ProjectId projectId ) <nl> { <nl> var builder = referencesMap . ToBuilder ( ) ; <nl>\n", "msg": "Use consistent parameter order and named arguments for clarity\n"}
{"diff_id": 28513, "repo": "restsharp/RestSharp\n", "sha": "40f922fe1fb20c00664d8e539315119adaf628af\n", "time": "2014-10-26T06:28:53Z\n", "diff": "mmm a / RestSharp . Tests / XmlDeserializerTests . cs <nl> ppp b / RestSharp . Tests / XmlDeserializerTests . cs <nl> private string PathFor ( string sampleFile ) <nl> return Path . Combine ( SampleDataPath , sampleFile ) ; <nl> } <nl> <nl> + [ Fact ] <nl> + public void Can_Deserialize_Into_Struct ( ) <nl> + { <nl> + const string content = \" < root > < one > oneOneOne < / one > < two > twoTwoTwo < / two > < three > 3 < / three > < / root > \" ; <nl> + var xml = new XmlDeserializer ( ) ; <nl> + var output = xml . Deserialize < SimpleStruct > ( new RestResponse { Content = content } ) ; <nl> + <nl> + Assert . NotNull ( output ) ; <nl> + Assert . Equal ( \" oneOneOne \" , output . One ) ; <nl> + Assert . Equal ( \" twoTwoTwo \" , output . Two ) ; <nl> + Assert . Equal ( 3 , output . Three ) ; <nl> + } <nl> [ Fact ] <nl> public void Can_Deserialize_Lists_of_Simple_Types ( ) <nl> { <nl> public void Can_Deserialize_Lists_of_Simple_Types ( ) <nl> var doc = XDocument . Load ( xmlpath ) ; <nl> <nl> var xml = new XmlDeserializer ( ) ; <nl> - var output = xml . Deserialize < SimpleTypesListSample > ( new RestResponse ( ) { Content = doc . ToString ( ) } ) ; <nl> + var output = xml . Deserialize < SimpleTypesListSample > ( new RestResponse { Content = doc . ToString ( ) } ) ; <nl> <nl> Assert . NotEmpty ( output . Names ) ; <nl> Assert . NotEmpty ( output . Numbers ) ; <nl> public void Can_Deserialize_Elements_to_Nullable_Values ( ) <nl> { <nl> var culture = CultureInfo . InvariantCulture ; <nl> var doc = CreateXmlWithoutEmptyValues ( culture ) ; <nl> - var xml = new XmlDeserializer ( ) { Culture = culture } ; <nl> + var xml = new XmlDeserializer { Culture = culture } ; <nl> var output = xml . Deserialize < NullableValues > ( new RestResponse { Content = doc } ) ; <nl> <nl> Assert . NotNull ( output . Id ) ; <nl>\n", "msg": "Added a test to deserialize xml into a struct\n"}
{"diff_id": 28520, "repo": "mRemoteNG/mRemoteNG\n", "sha": "0e0e3b28de1e9d9303d2a0b2b89c828f87117e7b\n", "time": "2016-05-16T15:11:15Z\n", "diff": "mmm a / mRemoteV1 / App / Import . cs <nl> ppp b / mRemoteV1 / App / Import . cs <nl> <nl> using mRemoteNG . Container ; <nl> using mRemoteNG . Tools ; <nl> using mRemoteNG . Tree ; <nl> - using Microsoft . VisualBasic ; <nl> using PSTaskDialog ; <nl> <nl> namespace mRemoteNG . App <nl> public static void ImportFromPortScan ( IEnumerable hosts , ProtocolType protocol ) <nl> { <nl> cTaskDialog . ShowCommandBox ( Application . ProductName , Language . strImportLocationMainInstruction , <nl> Language . strImportLocationContent , \" \" , \" \" , \" \" , <nl> - string . Format ( Language . strImportLocationCommandButtons , Constants . vbLf , rootTreeNode . Text , <nl> + string . Format ( Language . strImportLocationCommandButtons , Environment . NewLine , rootTreeNode . Text , <nl> selectedTreeNode . Text ) , true , eSysIcons . Question , 0 ) ; <nl> switch ( cTaskDialog . CommandButtonResult ) <nl> { <nl>\n", "msg": "Removed dependency to Microsoft . VisualBasic in Import . cs\n"}
{"diff_id": 28544, "repo": "cefsharp/CefSharp\n", "sha": "8e5ae7b5daff6a1af09820ecdb70e577997f0cab\n", "time": "2018-01-18T00:25:53Z\n", "diff": "mmm a / CefSharp . OffScreen . Example / Program . cs <nl> ppp b / CefSharp . OffScreen . Example / Program . cs <nl> <nl> using System . IO ; <nl> using System . Linq ; <nl> using System . Threading . Tasks ; <nl> + using CefSharp ; <nl> using CefSharp . Example ; <nl> using CefSharp . Example . Handlers ; <nl> using CefSharp . Internals ; <nl> private static async void MainAsync ( string cachePath , double zoomLevel ) <nl> / / For Google . com pre - pupulate the search text box <nl> await browser . EvaluateScriptAsync ( \" document . getElementById ( ' lst - ib ' ) . value = ' CefSharp Was Here ! ' \" ) ; <nl> <nl> + / / Example using SendKeyEvent for input instead of javascript <nl> + / / var browserHost = browser . GetBrowserHost ( ) ; <nl> + / / var inputString = \" CefSharp Was Here ! \" ; <nl> + / / foreach ( var c in inputString ) <nl> + / / { <nl> + / / browserHost . SendKeyEvent ( new KeyEvent { WindowsKeyCode = c , Type = KeyEventType . Char } ) ; <nl> + / / } <nl> + <nl> + / / / / Give the browser a little time to finish drawing our SendKeyEvent input <nl> + / / await Task . Delay ( 100 ) ; <nl> + <nl> / / Wait for the screenshot to be taken , <nl> / / if one exists ignore it , wait for a new one to make sure we have the most up to date <nl> await browser . ScreenshotAsync ( true ) . ContinueWith ( DisplayBitmap ) ; <nl>\n", "msg": "Add sendkeyevent example to CefSharp . OffScreen . Example / Program . cs\n"}
{"diff_id": 28552, "repo": "dotnet/roslyn\n", "sha": "ec03d317e85fa75ab31cbebdd995f0d43b231e0f\n", "time": "2015-02-12T15:11:27Z\n", "diff": "mmm a / src / Features / Core / Diagnostics / EngineV2 / DiagnosticIncrementalAnalyzer . cs <nl> ppp b / src / Features / Core / Diagnostics / EngineV2 / DiagnosticIncrementalAnalyzer . cs <nl> <nl> <nl> using System . Collections . Generic ; <nl> using System . Collections . Immutable ; <nl> + using System . Linq ; <nl> using System . Threading ; <nl> using System . Threading . Tasks ; <nl> using Microsoft . CodeAnalysis . Text ; <nl> public override Task AnalyzeDocumentAsync ( Document document , SyntaxNode bodyOpt , <nl> return SpecializedTasks . EmptyTask ; <nl> } <nl> <nl> - public override Task AnalyzeProjectAsync ( Project project , bool semanticsChanged , CancellationToken cancellationToken ) <nl> + public override async Task AnalyzeProjectAsync ( Project project , bool semanticsChanged , CancellationToken cancellationToken ) <nl> { <nl> - return SpecializedTasks . EmptyTask ; <nl> + var diagnostics = await GetDiagnosticsAsync ( project . Solution , project . Id , null , cancellationToken ) . ConfigureAwait ( false ) ; <nl> + <nl> + RaiseEvetns ( project , diagnostics ) ; <nl> } <nl> <nl> public override Task AnalyzeSyntaxAsync ( Document document , CancellationToken cancellationToken ) <nl> public override Task NewSolutionSnapshotAsync ( Solution solution , CancellationTok <nl> <nl> public override void RemoveDocument ( DocumentId documentId ) <nl> { <nl> + _owner . RaiseDiagnosticsUpdated ( <nl> + this , new DiagnosticsUpdatedArgs ( ValueTuple . Create ( this , documentId ) , null , null , null , null , ImmutableArray < DiagnosticData > . Empty ) ) ; <nl> } <nl> <nl> public override void RemoveProject ( ProjectId projectId ) <nl> { <nl> + _owner . RaiseDiagnosticsUpdated ( <nl> + this , new DiagnosticsUpdatedArgs ( ValueTuple . Create ( this , projectId ) , null , null , null , null , ImmutableArray < DiagnosticData > . Empty ) ) ; <nl> } <nl> # endregion <nl> <nl> public override Task < ImmutableArray < DiagnosticData > > GetCachedDiagnosticsAsync ( Solution solution , ProjectId projectId = null , DocumentId documentId = null , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> { <nl> - return SpecializedTasks . EmptyImmutableArray < DiagnosticData > ( ) ; <nl> + return GetDiagnosticsAsync ( solution , projectId , documentId , cancellationToken ) ; <nl> } <nl> <nl> public override Task < ImmutableArray < DiagnosticData > > GetSpecificCachedDiagnosticsAsync ( Solution solution , object id , CancellationToken cancellationToken ) <nl> { <nl> - return SpecializedTasks . EmptyImmutableArray < DiagnosticData > ( ) ; <nl> + return GetSpecificDiagnosticsAsync ( solution , id , cancellationToken ) ; <nl> } <nl> <nl> - public override Task < ImmutableArray < DiagnosticData > > GetDiagnosticsAsync ( Solution solution , ProjectId projectId = null , DocumentId documentId = null , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> + public override async Task < ImmutableArray < DiagnosticData > > GetDiagnosticsAsync ( Solution solution , ProjectId projectId = null , DocumentId documentId = null , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> { <nl> - return SpecializedTasks . EmptyImmutableArray < DiagnosticData > ( ) ; <nl> + if ( documentId ! = null ) <nl> + { <nl> + var diagnostics = await GetProjectDiagnosticsAsync ( solution . GetProject ( projectId ) , cancellationToken ) . ConfigureAwait ( false ) ; <nl> + return diagnostics . Where ( d = > d . DocumentId = = documentId ) . ToImmutableArrayOrEmpty ( ) ; <nl> + } <nl> + <nl> + if ( projectId ! = null ) <nl> + { <nl> + return await GetProjectDiagnosticsAsync ( solution . GetProject ( projectId ) , cancellationToken ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + var builder = ImmutableArray . CreateBuilder < DiagnosticData > ( ) ; <nl> + foreach ( var project in solution . Projects ) <nl> + { <nl> + builder . AddRange ( await GetProjectDiagnosticsAsync ( project , cancellationToken ) . ConfigureAwait ( false ) ) ; <nl> + } <nl> + <nl> + return builder . ToImmutable ( ) ; <nl> } <nl> <nl> - public override Task < ImmutableArray < DiagnosticData > > GetSpecificDiagnosticsAsync ( Solution solution , object id , CancellationToken cancellationToken ) <nl> + public override async Task < ImmutableArray < DiagnosticData > > GetSpecificDiagnosticsAsync ( Solution solution , object id , CancellationToken cancellationToken ) <nl> { <nl> - return SpecializedTasks . EmptyImmutableArray < DiagnosticData > ( ) ; <nl> + if ( id is ValueTuple < DiagnosticIncrementalAnalyzer , DocumentId > ) <nl> + { <nl> + var key = ( ValueTuple < DiagnosticIncrementalAnalyzer , DocumentId > ) id ; <nl> + return await GetDiagnosticsAsync ( solution , key . Item2 . ProjectId , key . Item2 , cancellationToken ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + if ( id is ValueTuple < DiagnosticIncrementalAnalyzer , ProjectId > ) <nl> + { <nl> + var key = ( ValueTuple < DiagnosticIncrementalAnalyzer , ProjectId > ) id ; <nl> + var diagnostics = await GetDiagnosticsAsync ( solution , key . Item2 , null , cancellationToken ) . ConfigureAwait ( false ) ; <nl> + return diagnostics . Where ( d = > d . DocumentId = = null ) . ToImmutableArray ( ) ; <nl> + } <nl> + <nl> + return ImmutableArray < DiagnosticData > . Empty ; <nl> } <nl> <nl> - public override Task < ImmutableArray < DiagnosticData > > GetDiagnosticsForIdsAsync ( Solution solution , ProjectId projectId = null , DocumentId documentId = null , ImmutableHashSet < string > diagnosticIds = null , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> + public override async Task < ImmutableArray < DiagnosticData > > GetDiagnosticsForIdsAsync ( Solution solution , ProjectId projectId = null , DocumentId documentId = null , ImmutableHashSet < string > diagnosticIds = null , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> { <nl> - return SpecializedTasks . EmptyImmutableArray < DiagnosticData > ( ) ; <nl> + var diagnostics = await GetDiagnosticsAsync ( solution , projectId , documentId , cancellationToken ) . ConfigureAwait ( false ) ; <nl> + return diagnostics . Where ( d = > diagnosticIds . Contains ( d . Id ) ) . ToImmutableArrayOrEmpty ( ) ; <nl> } <nl> <nl> - public override Task < ImmutableArray < DiagnosticData > > GetProjectDiagnosticsForIdsAsync ( Solution solution , ProjectId projectId = null , ImmutableHashSet < string > diagnosticIds = null , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> + public override async Task < ImmutableArray < DiagnosticData > > GetProjectDiagnosticsForIdsAsync ( Solution solution , ProjectId projectId = null , ImmutableHashSet < string > diagnosticIds = null , CancellationToken cancellationToken = default ( CancellationToken ) ) <nl> { <nl> - return SpecializedTasks . EmptyImmutableArray < DiagnosticData > ( ) ; <nl> + var diagnostics = await GetDiagnosticsForIdsAsync ( solution , projectId , null , diagnosticIds , cancellationToken ) . ConfigureAwait ( false ) ; <nl> + return diagnostics . Where ( d = > d . DocumentId = = null ) . ToImmutableArray ( ) ; <nl> } <nl> <nl> - public override Task < bool > TryAppendDiagnosticsForSpanAsync ( Document document , TextSpan range , List < DiagnosticData > diagnostics , CancellationToken cancellationToken ) <nl> + public override async Task < bool > TryAppendDiagnosticsForSpanAsync ( Document document , TextSpan range , List < DiagnosticData > result , CancellationToken cancellationToken ) <nl> { <nl> - return SpecializedTasks . False ; <nl> + result . AddRange ( await GetDiagnosticsForSpanAsync ( document , range , cancellationToken ) . ConfigureAwait ( false ) ) ; <nl> + return true ; <nl> } <nl> <nl> - public override Task < IEnumerable < DiagnosticData > > GetDiagnosticsForSpanAsync ( Document document , TextSpan range , CancellationToken cancellationToken ) <nl> + public override async Task < IEnumerable < DiagnosticData > > GetDiagnosticsForSpanAsync ( Document document , TextSpan range , CancellationToken cancellationToken ) <nl> { <nl> - return SpecializedTasks . EmptyEnumerable < DiagnosticData > ( ) ; <nl> + var diagnostics = await GetDiagnosticsAsync ( document . Project . Solution , document . Project . Id , document . Id , cancellationToken ) . ConfigureAwait ( false ) ; <nl> + return diagnostics . Where ( d = > range . IntersectsWith ( d . TextSpan ) ) ; <nl> + } <nl> + <nl> + private async Task < ImmutableArray < DiagnosticData > > GetProjectDiagnosticsAsync ( Project project , CancellationToken cancellationToken ) <nl> + { <nl> + if ( project = = null ) <nl> + { <nl> + return ImmutableArray < DiagnosticData > . Empty ; <nl> + } <nl> + <nl> + var compilation = await project . GetCompilationAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> + <nl> + / / TODO : this should move to _analyzerManager <nl> + var analyzers = _analyzerManager . GetHostDiagnosticAnalyzersPerReference ( project . Language ) <nl> + . SelectMany ( kv = > kv . Value ) <nl> + . Concat ( project . AnalyzerReferences . SelectMany ( r = > r . GetAnalyzers ( project . Language ) ) ) ; <nl> + <nl> + var compilationWithAnalyzer = compilation . WithAnalyzers ( analyzers . ToImmutableArray ( ) , project . AnalyzerOptions , cancellationToken ) ; <nl> + <nl> + / / REVIEW : this API is a bit strange . <nl> + / / if getting diagnostic is cancelled , it has to create new compilation and do everything from scretch again ? <nl> + return GetDiagnosticData ( project , await compilationWithAnalyzer . GetAnalyzerDiagnosticsAsync ( ) . ConfigureAwait ( false ) ) . ToImmutableArrayOrEmpty ( ) ; <nl> + } <nl> + <nl> + private IEnumerable < DiagnosticData > GetDiagnosticData ( Project project , ImmutableArray < Diagnostic > diagnostics ) <nl> + { <nl> + foreach ( var diagnostic in diagnostics ) <nl> + { <nl> + if ( diagnostic . Location = = Location . None ) <nl> + { <nl> + yield return DiagnosticData . Create ( project , diagnostic ) ; <nl> + continue ; <nl> + } <nl> + <nl> + var document = project . GetDocument ( diagnostic . Location . SourceTree ) ; <nl> + if ( document = = null ) <nl> + { <nl> + continue ; <nl> + } <nl> + <nl> + yield return DiagnosticData . Create ( document , diagnostic ) ; <nl> + } <nl> + } <nl> + <nl> + private void RaiseEvetns ( Project project , ImmutableArray < DiagnosticData > diagnostics ) <nl> + { <nl> + var groups = diagnostics . GroupBy ( d = > d . DocumentId ) ; <nl> + <nl> + var solution = project . Solution ; <nl> + var workspace = solution . Workspace ; <nl> + <nl> + foreach ( var kv in groups ) <nl> + { <nl> + if ( kv . Key = = null ) <nl> + { <nl> + _owner . RaiseDiagnosticsUpdated ( <nl> + this , new DiagnosticsUpdatedArgs ( <nl> + ValueTuple . Create ( this , project . Id ) , workspace , solution , project . Id , null , kv . ToImmutableArrayOrEmpty ( ) ) ) ; <nl> + continue ; <nl> + } <nl> + <nl> + _owner . RaiseDiagnosticsUpdated ( <nl> + this , new DiagnosticsUpdatedArgs ( <nl> + ValueTuple . Create ( this , kv . Key ) , workspace , solution , project . Id , kv . Key , kv . ToImmutableArrayOrEmpty ( ) ) ) ; <nl> + } <nl> } <nl> } <nl> } <nl>\n", "msg": "bare minimum implementation of diagnostic analyzer that uses compiler analyzer driver\n"}
{"diff_id": 28601, "repo": "unoplatform/uno\n", "sha": "18ffee13af587f711043fc97044a5b3e47fe6a6c\n", "time": "2018-11-07T17:53:07Z\n", "diff": "mmm a / src / Uno . Foundation / Metadata / ApiInformation . cs <nl> ppp b / src / Uno . Foundation / Metadata / ApiInformation . cs <nl> public static bool IsWriteablePropertyPresent ( string typeName , string propertyNa <nl> public static bool IsEnumNamedValuePresent ( string enumTypeName , string valueName ) <nl> = > GetValidType ( enumTypeName ) ? . GetField ( valueName ) ! = null ; <nl> <nl> - public static bool IsApiContractPresent ( string contractName , ushort majorVersion ) = > false ; <nl> + public static bool IsApiContractPresent ( string contractName , ushort majorVersion ) <nl> + = > IsApiContractPresent ( contractName , majorVersion , 0 ) ; <nl> <nl> - public static bool IsApiContractPresent ( string contractName , ushort majorVersion , ushort minorVersion ) = > false ; <nl> + public static bool IsApiContractPresent ( string contractName , ushort majorVersion , ushort minorVersion ) <nl> + { <nl> + switch ( contractName ) <nl> + { <nl> + case \" Windows . Foundation . UniversalApiContract \" : <nl> + return majorVersion < = 6 ; <nl> + <nl> + default : <nl> + return false ; <nl> + } <nl> + } <nl> <nl> / / / < summary > <nl> / / / Determines if runtime use of not implemented members raises an exception , or logs an error message . <nl>\n", "msg": "Add support for Windows . Foundation . UniversalApiContract in IsApiContractPresent\n"}
{"diff_id": 28738, "repo": "dotnet/aspnetcore\n", "sha": "e72d3cb249199160e8bbaf92c4e684b932519cec\n", "time": "2015-12-16T23:38:25Z\n", "diff": "similarity index 100 % <nl> rename from samples / LocalizationSample / My / Resources / LocalizationSample . Startup . es - ES . resx <nl> rename to samples / LocalizationSample / My / Resources / Startup . es - ES . resx <nl> similarity index 100 % <nl> rename from samples / LocalizationSample / My / Resources / LocalizationSample . Startup . fr - FR . resx <nl> rename to samples / LocalizationSample / My / Resources / Startup . fr - FR . resx <nl> similarity index 100 % <nl> rename from samples / LocalizationSample / My / Resources / LocalizationSample . Startup . ja - JP . resx <nl> rename to samples / LocalizationSample / My / Resources / Startup . ja - JP . resx <nl> similarity index 100 % <nl> rename from samples / LocalizationSample / My / Resources / LocalizationSample . Startup . zh - CN . resx <nl> rename to samples / LocalizationSample / My / Resources / Startup . zh - CN . resx <nl> similarity index 100 % <nl> rename from samples / LocalizationSample / My / Resources / LocalizationSample . Startup . zh . resx <nl> rename to samples / LocalizationSample / My / Resources / Startup . zh . resx <nl> mmm a / src / Microsoft . Extensions . Localization / ResourceManagerStringLocalizerFactory . cs <nl> ppp b / src / Microsoft . Extensions . Localization / ResourceManagerStringLocalizerFactory . cs <nl> public class ResourceManagerStringLocalizerFactory : IStringLocalizerFactory <nl> private readonly ConcurrentDictionary < string , ResourceManagerStringLocalizer > _localizerCache = <nl> new ConcurrentDictionary < string , ResourceManagerStringLocalizer > ( ) ; <nl> private readonly IApplicationEnvironment _applicationEnvironment ; <nl> - <nl> private readonly string _resourcesRelativePath ; <nl> <nl> / / / < summary > <nl> public IStringLocalizer Create ( Type resourceSource ) <nl> <nl> var baseName = string . IsNullOrEmpty ( _resourcesRelativePath ) <nl> ? typeInfo . FullName <nl> - : _applicationEnvironment . ApplicationName + \" . \" + _resourcesRelativePath + typeInfo . FullName ; <nl> + : _applicationEnvironment . ApplicationName + \" . \" + _resourcesRelativePath <nl> + + TrimPrefix ( typeInfo . FullName , _applicationEnvironment . ApplicationName + \" . \" ) ; <nl> <nl> return _localizerCache . GetOrAdd ( baseName , _ = > <nl> new ResourceManagerStringLocalizer ( <nl> public IStringLocalizer Create ( string baseName , string location ) <nl> <nl> var rootPath = location ? ? _applicationEnvironment . ApplicationName ; <nl> var assembly = Assembly . Load ( new AssemblyName ( rootPath ) ) ; <nl> - baseName = rootPath + \" . \" + _resourcesRelativePath + baseName ; <nl> + baseName = rootPath + \" . \" + _resourcesRelativePath + TrimPrefix ( baseName , rootPath + \" . \" ) ; <nl> <nl> return _localizerCache . GetOrAdd ( baseName , _ = > <nl> new ResourceManagerStringLocalizer ( <nl> public IStringLocalizer Create ( string baseName , string location ) <nl> _resourceNamesCache ) <nl> ) ; <nl> } <nl> + <nl> + private static string TrimPrefix ( string name , string prefix ) <nl> + { <nl> + if ( name . StartsWith ( prefix , StringComparison . Ordinal ) ) <nl> + { <nl> + return name . Substring ( prefix . Length ) ; <nl> + } <nl> + <nl> + return name ; <nl> + } <nl> } <nl> } <nl> \\ No newline at end of file <nl> similarity index 100 % <nl> rename from test / LocalizationWebsite / Resources / LocalizationWebsite . Models . Customer . fr - FR . resx <nl> rename to test / LocalizationWebsite / Resources / Models . Customer . fr - FR . resx <nl> similarity index 100 % <nl> rename from test / LocalizationWebsite / Resources / LocalizationWebsite . StartupResourcesInFolder . fr - FR . resx <nl> rename to test / LocalizationWebsite / Resources / StartupResourcesInFolder . fr - FR . resx <nl>\n", "msg": "ResourceManagerStringLocalizerFactory trims app name from resource base name :\n"}
{"diff_id": 28797, "repo": "dotnet/roslyn\n", "sha": "3741ef494a3ac0911d9affa3a1d91f2aabb4333a\n", "time": "2018-04-09T22:40:43Z\n", "diff": "mmm a / src / Workspaces / CoreTestUtilities / UseExportProviderAttribute . cs <nl> ppp b / src / Workspaces / CoreTestUtilities / UseExportProviderAttribute . cs <nl> <nl> using System ; <nl> using System . Collections . Generic ; <nl> using System . Composition . Hosting ; <nl> - using System . Diagnostics ; <nl> using System . Linq ; <nl> using System . Reflection ; <nl> using System . Text ; <nl> using System . Threading ; <nl> - using System . Threading . Tasks ; <nl> - using System . Windows . Threading ; <nl> using Microsoft . CodeAnalysis . Editor ; <nl> using Microsoft . CodeAnalysis . Editor . Implementation . ForegroundNotification ; <nl> + using Microsoft . CodeAnalysis . Editor . Shared . Utilities ; <nl> using Microsoft . CodeAnalysis . Host ; <nl> using Microsoft . CodeAnalysis . Host . Mef ; <nl> using Microsoft . CodeAnalysis . Remote ; <nl> using Microsoft . CodeAnalysis . Shared . TestHooks ; <nl> + using Microsoft . CodeAnalysis . Utilities ; <nl> using Microsoft . VisualStudio . Composition ; <nl> using Roslyn . Test . Utilities ; <nl> using Xunit . Sdk ; <nl> public override void After ( MethodInfo methodUnderTest ) <nl> var listenerProvider = exportProvider ? . GetExportedValues < IAsynchronousOperationListenerProvider > ( ) . SingleOrDefault ( ) ; <nl> if ( listenerProvider ! = null ) <nl> { <nl> - / / Immediately clear items from the foreground notification service for which cancellation is <nl> - / / requested . This service maintains a queue separately from Tasks , and work items scheduled for <nl> - / / execution after a delay are not immediately purged when cancellation is requested . This code <nl> - / / instructs the service to walk the list of queued work items and immediately cancel and purge any <nl> - / / which are already cancelled . <nl> - var foregroundNotificationService = exportProvider ? . GetExportedValues < IForegroundNotificationService > ( ) . SingleOrDefault ( ) as ForegroundNotificationService ; <nl> - foregroundNotificationService ? . ReleaseCancelledItems ( ) ; <nl> + if ( ForegroundThreadAffinitizedObject . CurrentForegroundThreadData . Kind ! = ForegroundThreadDataKind . Unknown ) <nl> + { <nl> + / / Immediately clear items from the foreground notification service for which cancellation is <nl> + / / requested . This service maintains a queue separately from Tasks , and work items scheduled for <nl> + / / execution after a delay are not immediately purged when cancellation is requested . This code <nl> + / / instructs the service to walk the list of queued work items and immediately cancel and purge any <nl> + / / which are already cancelled . <nl> + var foregroundNotificationService = exportProvider ? . GetExportedValues < IForegroundNotificationService > ( ) . SingleOrDefault ( ) as ForegroundNotificationService ; <nl> + foregroundNotificationService ? . ReleaseCancelledItems ( ) ; <nl> + } <nl> <nl> / / Join remaining operations with a timeout <nl> using ( var timeoutTokenSource = new CancellationTokenSource ( CleanupTimeout ) ) <nl>\n", "msg": "Avoid IForegroundNotificationService interaction from tests that can ' t use it\n"}
{"diff_id": 28817, "repo": "duplicati/duplicati\n", "sha": "780f53b89a08ff10f940c4266741e7eb2c890543\n", "time": "2020-12-01T03:56:08Z\n", "diff": "mmm a / Duplicati / UnitTest / PurgeTesting . cs <nl> ppp b / Duplicati / UnitTest / PurgeTesting . cs <nl> <nl> using System . Linq ; <nl> using Duplicati . Library . Common . IO ; <nl> using Duplicati . Library . Interface ; <nl> + using Duplicati . Library . Main ; <nl> using Duplicati . Library . Utility ; <nl> using NUnit . Framework ; <nl> <nl> public void PurgeBrokenFilesTest ( ) <nl> Assert . AreEqual ( affectedfiles [ i ] , files ) ; <nl> } <nl> <nl> + / / A dry - run should run without exceptions ( see issue # 4379 ) . <nl> + Dictionary < string , string > dryRunOptions = new Dictionary < string , string > ( testopts ) { [ \" dry - run \" ] = \" true \" } ; <nl> + using ( Controller c = new Controller ( \" file : / / \" + this . TARGETFOLDER , dryRunOptions , null ) ) <nl> + { <nl> + IPurgeBrokenFilesResults purgeResults = c . PurgeBrokenFiles ( null ) ; <nl> + Assert . AreEqual ( 0 , purgeResults . Errors . Count ( ) ) ; <nl> + Assert . AreEqual ( 0 , purgeResults . Warnings . Count ( ) ) ; <nl> + } <nl> + <nl> using ( var c = new Library . Main . Controller ( \" file : / / \" + TARGETFOLDER , testopts , null ) ) <nl> { <nl> var brk = c . PurgeBrokenFiles ( null ) ; <nl> public void PurgeBrokenFilesTest ( ) <nl> <nl> Assert . AreEqual ( 3 , modFilesets ) ; <nl> } <nl> - } <nl> <nl> + / / A subsequent backup should be successful . <nl> + using ( Controller c = new Controller ( \" file : / / \" + this . TARGETFOLDER , testopts , null ) ) <nl> + { <nl> + IBackupResults backupResults = c . Backup ( new [ ] { this . DATAFOLDER } ) ; <nl> + Assert . AreEqual ( 0 , backupResults . Errors . Count ( ) ) ; <nl> + Assert . AreEqual ( 0 , backupResults . Warnings . Count ( ) ) ; <nl> + } <nl> + } <nl> } <nl> } <nl>\n", "msg": "Add test for purging broken files with dry - run .\n"}
{"diff_id": 28883, "repo": "dotnet/machinelearning\n", "sha": "1679be3b5b684ad4c86004f7734ba40812dd841d\n", "time": "2018-07-09T01:07:45Z\n", "diff": "mmm a / src / Microsoft . ML / Models / OnnxConverter . cs <nl> ppp b / src / Microsoft . ML / Models / OnnxConverter . cs <nl> public sealed partial class OnnxConverter <nl> / / / < see href = \" https : / / onnx . ai / \" > ONNX < / see > is an intermediate representation format <nl> / / / for machine learning models . It is used to make models portable such that you can <nl> / / / train a model using a toolkit and run it in another tookit ' s runtime , for example , <nl> - / / / you can create a model using ML . NET ( or any ONNX compatible toolkit ) , convert it to ONNX and <nl> - / / / then the ONNX model can be converted into say , CoreML , TensorFlow or WinML model <nl> - / / / to run on the respective runtime . <nl> + / / / you can create and train a model using ML . NET , export it to an ONNX - ML model file , <nl> + / / / then load and run that ONNX - ML model in Windows ML , on an UWP Windows 10 app . <nl> / / / <nl> - / / / This API converts an ML . NET model to ONNX format by inspecting the transform pipeline <nl> - / / / from the end , checking for components that know how to save themselves as ONNX . <nl> + / / / This API converts an ML . NET model to ONNX - ML format by inspecting the transform pipeline <nl> + / / / from the end , checking for components that know how to save themselves as ONNX - ML . <nl> / / / The first item in the transform pipeline that does not know how to save itself <nl> - / / / as ONNX , is considered the \" input \" to the ONNX pipeline . ( Ideally this would be the <nl> + / / / as ONNX - ML , is considered the \" input \" to the ONNX pipeline . ( Ideally this would be the <nl> / / / original loader itself , but this may not be possible if the user used unsavable <nl> / / / transforms in defining the pipe . ) All the columns in the source that are a type the <nl> / / / ONNX knows how to deal with will be tracked . Intermediate transformations of the <nl>\n", "msg": "Update Onnx Convert documentation , limited to ONNX - ML target platforms\n"}
{"diff_id": 28924, "repo": "AvaloniaUI/Avalonia\n", "sha": "0d8a82c07aedaaab329e83cd14b92858cc5e1e52\n", "time": "2016-10-15T11:08:31Z\n", "diff": "mmm a / src / Gtk / Avalonia . Cairo / Media / DrawingContext . cs <nl> ppp b / src / Gtk / Avalonia . Cairo / Media / DrawingContext . cs <nl> public void PushOpacityMask ( IBrush mask , Rect bounds ) <nl> public void PopOpacityMask ( ) <nl> { <nl> _context . PopGroupToSource ( ) ; <nl> - _context . Mask ( _maskStack . Pop ( ) . PlatformBrush ) ; <nl> + var brushImpl = _maskStack . Pop ( ) ; <nl> + <nl> + _context . Mask ( brushImpl . PlatformBrush ) ; <nl> + brushImpl . Dispose ( ) ; <nl> } <nl> } <nl> } <nl>\n", "msg": "fixes Cairo . Pattern leaks . Courtest of nc4rrillo\n"}
{"diff_id": 29189, "repo": "dotnet/runtime\n", "sha": "ca8c9dea8e30a9701160e4cd61b5b26f209499ff\n", "time": "2020-05-08T21:30:35Z\n", "diff": "mmm a / src / libraries / System . Diagnostics . EventLog / src / System / Diagnostics / Reader / ProviderMetadataCachedInformation . cs <nl> ppp b / src / libraries / System . Diagnostics . EventLog / src / System / Diagnostics / Reader / ProviderMetadataCachedInformation . cs <nl> private ProviderMetadata GetProviderMetadata ( ProviderMetadataId key ) <nl> <nl> try <nl> { <nl> + pm . CheckReleased ( ) ; <nl> UpdateCacheValueInfoForHit ( cacheItem ) ; <nl> } <nl> catch ( EventLogException ) <nl>\n", "msg": "Revert \" Remove superflous CheckReleased call which will slow down Event Log Reading up to 20x times . ( ) \" ( )\n"}
{"diff_id": 29236, "repo": "mono/mono\n", "sha": "b06106a311f53de734f4247ef8594323ce89c583\n", "time": "2013-04-01T20:31:23Z\n", "diff": "mmm a / mcs / class / Mono . Debugger . Soft / Mono . Debugger . Soft / MethodMirror . cs <nl> ppp b / mcs / class / Mono . Debugger . Soft / Mono . Debugger . Soft / MethodMirror . cs <nl> public class MethodMirror : Mirror <nl> <nl> public LocalVariable [ ] GetLocals ( ) { <nl> if ( locals = = null ) { <nl> - <nl> LocalsInfo li = new LocalsInfo ( ) ; <nl> try { <nl> li = vm . conn . Method_GetLocalsInfo ( id ) ; <nl> } catch ( CommandException ) { <nl> - throw new ArgumentException ( \" Method doesn ' t have a body . \" ) ; <nl> + throw new AbsentInformationException ( \" Method doesn ' t have a body . \" ) ; <nl> } <nl> + <nl> / / Add the arguments as well <nl> var pi = vm . conn . Method_GetParamInfo ( id ) ; <nl> <nl>\n", "msg": "[ Mono . Debugger . Soft ] Throw AbsentInformationException , not ArgumentException which makes no sense\n"}
{"diff_id": 29537, "repo": "PowerShell/PowerShell\n", "sha": "259c4dd3f2b40635b5a47f02e195fc76731caa28\n", "time": "2019-05-31T03:15:40Z\n", "diff": "mmm a / src / System . Management . Automation / engine / lang / scriptblock . cs <nl> ppp b / src / System . Management . Automation / engine / lang / scriptblock . cs <nl> internal static ScriptBlock Create ( ExecutionContext context , string script ) <nl> / / / context is provided . <nl> / / / < / summary > <nl> / / / < param name = \" script \" > The string to compile . < / param > <nl> - public static ScriptBlock Create ( string script ) <nl> - { <nl> - return Create ( new Language . Parser ( ) , null , script ) ; <nl> - } <nl> + public static ScriptBlock Create ( string script ) = > Create ( <nl> + parser : new Language . Parser ( ) , <nl> + fileName : null , <nl> + fileContents : script ) ; <nl> <nl> internal static ScriptBlock CreateDelayParsedScriptBlock ( string script , bool isProductCode ) <nl> - { <nl> - return new ScriptBlock ( new CompiledScriptBlockData ( script , isProductCode ) ) ; <nl> - } <nl> + = > new ScriptBlock ( new CompiledScriptBlockData ( script , isProductCode ) ) ; <nl> <nl> / / / < summary > <nl> / / / Returns a new scriptblock bound to a module . Any local variables in the <nl> public ScriptBlock GetNewClosure ( ) <nl> / / / < exception cref = \" InvalidOperationException \" > <nl> / / / Thrown when there is no ExecutionContext associated with this ScriptBlock object . <nl> / / / < / exception > <nl> - public PowerShell GetPowerShell ( params object [ ] args ) <nl> - { <nl> - ExecutionContext context = LocalPipeline . GetExecutionContextFromTLS ( ) ; <nl> - return GetPowerShellImpl ( context , null , false , false , null , args ) ; <nl> - } <nl> + public PowerShell GetPowerShell ( params object [ ] args ) = > GetPowerShellImpl ( <nl> + context : LocalPipeline . GetExecutionContextFromTLS ( ) , <nl> + variables : null , <nl> + isTrustedInput : false , <nl> + filterNonUsingVariables : false , <nl> + createLocalScope : null , <nl> + args ) ; <nl> <nl> / / / < summary > <nl> / / / Returns PowerShell object representing the pipeline contained in this ScriptBlock , <nl> public PowerShell GetPowerShell ( params object [ ] args ) <nl> / / / can be null <nl> / / / < / param > <nl> public PowerShell GetPowerShell ( bool isTrustedInput , params object [ ] args ) <nl> - { <nl> - ExecutionContext context = LocalPipeline . GetExecutionContextFromTLS ( ) ; <nl> - return GetPowerShellImpl ( context , null , isTrustedInput , false , null , args ) ; <nl> - } <nl> + = > GetPowerShellImpl ( <nl> + context : LocalPipeline . GetExecutionContextFromTLS ( ) , <nl> + variables : null , <nl> + isTrustedInput , <nl> + filterNonUsingVariables : false , <nl> + createLocalScope : null , <nl> + args ) ; <nl> <nl> / / / < summary > <nl> / / / Returns PowerShell object representing the pipeline contained in this ScriptBlock , using variables <nl> public PowerShell GetPowerShell ( Dictionary < string , object > variables , params obj <nl> / / / Thrown when there is no ExecutionContext associated with this ScriptBlock object and no <nl> / / / variables are supplied . <nl> / / / < / exception > <nl> - public PowerShell GetPowerShell ( Dictionary < string , object > variables , out Dictionary < string , object > usingVariables , params object [ ] args ) <nl> - { <nl> - return GetPowerShell ( variables , out usingVariables , false , args ) ; <nl> - } <nl> + public PowerShell GetPowerShell ( <nl> + Dictionary < string , object > variables , <nl> + out Dictionary < string , object > usingVariables , <nl> + params object [ ] args ) <nl> + = > GetPowerShell ( variables , out usingVariables , isTrustedInput : false , args ) ; <nl> <nl> / / / < summary > <nl> / / / Returns PowerShell object representing the pipeline contained in this ScriptBlock , using variables <nl> public PowerShell GetPowerShell ( Dictionary < string , object > variables , out Dictio <nl> / / / Thrown when there is no ExecutionContext associated with this ScriptBlock object and no <nl> / / / variables are supplied . <nl> / / / < / exception > <nl> - public PowerShell GetPowerShell ( Dictionary < string , object > variables , out Dictionary < string , object > usingVariables , bool isTrustedInput , params object [ ] args ) <nl> + public PowerShell GetPowerShell ( <nl> + Dictionary < string , object > variables , <nl> + out Dictionary < string , object > usingVariables , <nl> + bool isTrustedInput , <nl> + params object [ ] args ) <nl> { <nl> ExecutionContext context = LocalPipeline . GetExecutionContextFromTLS ( ) ; <nl> Dictionary < string , object > suppliedVariables = null ; <nl> public PowerShell GetPowerShell ( Dictionary < string , object > variables , out Dictio <nl> return powershell ; <nl> } <nl> <nl> - internal PowerShell GetPowerShell ( ExecutionContext context , bool isTrustedInput , bool ? useLocalScope , object [ ] args ) <nl> - { <nl> - return GetPowerShellImpl ( context , null , isTrustedInput , false , useLocalScope , args ) ; <nl> - } <nl> + internal PowerShell GetPowerShell ( <nl> + ExecutionContext context , <nl> + bool isTrustedInput , <nl> + bool ? useLocalScope , <nl> + object [ ] args ) <nl> + = > GetPowerShellImpl ( <nl> + context , <nl> + variables : null , <nl> + isTrustedInput , <nl> + filterNonUsingVariables : false , <nl> + useLocalScope , <nl> + args ) ; <nl> <nl> / / / < summary > <nl> / / / Get a steppable pipeline object . <nl> / / / < / summary > <nl> / / / < returns > A steppable pipeline object . < / returns > <nl> - [ SuppressMessage ( \" Microsoft . Naming \" , \" CA1704 : IdentifiersShouldBeSpelledCorrectly \" , MessageId = \" Steppable \" , Justification = \" Review this during API naming \" ) ] <nl> + [ SuppressMessage ( <nl> + \" Microsoft . Naming \" , <nl> + \" CA1704 : IdentifiersShouldBeSpelledCorrectly \" , <nl> + MessageId = \" Steppable \" , <nl> + Justification = \" Review this during API naming \" ) ] <nl> public SteppablePipeline GetSteppablePipeline ( ) <nl> - { <nl> - return GetSteppablePipelineImpl ( CommandOrigin . Internal , null ) ; <nl> - } <nl> + = > GetSteppablePipelineImpl ( commandOrigin : CommandOrigin . Internal , args : null ) ; <nl> + <nl> <nl> / / / < summary > <nl> / / / Get a steppable pipeline object . <nl> / / / < / summary > <nl> / / / < returns > A steppable pipeline object . < / returns > <nl> - [ SuppressMessage ( \" Microsoft . Naming \" , \" CA1704 : IdentifiersShouldBeSpelledCorrectly \" , MessageId = \" Steppable \" , Justification = \" Review this during API naming \" ) ] <nl> + [ SuppressMessage ( <nl> + \" Microsoft . Naming \" , <nl> + \" CA1704 : IdentifiersShouldBeSpelledCorrectly \" , <nl> + MessageId = \" Steppable \" , <nl> + Justification = \" Review this during API naming \" ) ] <nl> public SteppablePipeline GetSteppablePipeline ( CommandOrigin commandOrigin ) <nl> - { <nl> - return GetSteppablePipelineImpl ( commandOrigin , null ) ; <nl> - } <nl> + = > GetSteppablePipelineImpl ( commandOrigin , args : null ) ; <nl> <nl> / / / < summary > <nl> / / / Get a steppable pipeline object . <nl> / / / < / summary > <nl> / / / < returns > A steppable pipeline object . < / returns > <nl> - [ SuppressMessage ( \" Microsoft . Naming \" , \" CA1704 : IdentifiersShouldBeSpelledCorrectly \" , MessageId = \" Steppable \" , Justification = \" Review this during API naming \" ) ] <nl> + [ SuppressMessage ( <nl> + \" Microsoft . Naming \" , <nl> + \" CA1704 : IdentifiersShouldBeSpelledCorrectly \" , <nl> + MessageId = \" Steppable \" , <nl> + Justification = \" Review this during API naming \" ) ] <nl> public SteppablePipeline GetSteppablePipeline ( CommandOrigin commandOrigin , object [ ] args ) <nl> - { <nl> - return GetSteppablePipelineImpl ( commandOrigin , args ) ; <nl> - } <nl> + = > GetSteppablePipelineImpl ( commandOrigin , args ) ; <nl> <nl> / / / < summary > <nl> / / / Execute this node with the specified arguments . The arguments show <nl> public SteppablePipeline GetSteppablePipeline ( CommandOrigin commandOrigin , objec <nl> / / / the script block returned as a collection of PSObjects . < / returns > <nl> / / / < exception cref = \" RuntimeException \" > Thrown if a script runtime exceptionexception occurred . < / exception > <nl> / / / < exception cref = \" FlowControlException \" > An internal ( non - public ) exception from a flow control statement . < / exception > <nl> - public Collection < PSObject > Invoke ( params object [ ] args ) <nl> - { <nl> - return DoInvoke ( AutomationNull . Value , AutomationNull . Value , args ) ; <nl> - } <nl> + public Collection < PSObject > Invoke ( params object [ ] args ) = > <nl> + DoInvoke ( dollarUnder : AutomationNull . Value , input : AutomationNull . Value , args ) ; <nl> <nl> / / / < summary > <nl> / / / A method that allows a scriptblock to be invoked with additional context in the form of a <nl> public Collection < PSObject > Invoke ( params object [ ] args ) <nl> <nl> if ( variablesToDefine ! = null ) <nl> { <nl> - / / <nl> / / Extract the special variables \" this \" , \" input \" and \" _ \" <nl> - / / <nl> - PSVariable located = variablesToDefine . FirstOrDefault ( v = > string . Equals ( v . Name , \" this \" , StringComparison . OrdinalIgnoreCase ) ) ; <nl> + PSVariable located = variablesToDefine . FirstOrDefault ( <nl> + v = > string . Equals ( v . Name , \" this \" , StringComparison . OrdinalIgnoreCase ) ) ; <nl> if ( located ! = null ) <nl> { <nl> scriptThis = located . Value ; <nl> variablesToDefine . Remove ( located ) ; <nl> } <nl> <nl> - located = variablesToDefine . FirstOrDefault ( v = > string . Equals ( v . Name , \" _ \" , StringComparison . OrdinalIgnoreCase ) ) ; <nl> + located = variablesToDefine . FirstOrDefault ( <nl> + v = > string . Equals ( v . Name , \" _ \" , StringComparison . Ordinal ) ) ; <nl> if ( located ! = null ) <nl> { <nl> dollarUnder = located . Value ; <nl> variablesToDefine . Remove ( located ) ; <nl> } <nl> <nl> - located = variablesToDefine . FirstOrDefault ( v = > string . Equals ( v . Name , \" input \" , StringComparison . OrdinalIgnoreCase ) ) ; <nl> + located = variablesToDefine . FirstOrDefault ( <nl> + v = > string . Equals ( v . Name , \" input \" , StringComparison . OrdinalIgnoreCase ) ) ; <nl> if ( located ! = null ) <nl> { <nl> input = located . Value ; <nl> public Collection < PSObject > Invoke ( params object [ ] args ) <nl> List < object > result = new List < object > ( ) ; <nl> Pipe outputPipe = new Pipe ( result ) ; <nl> <nl> - InvokeWithPipe ( useLocalScope : true , <nl> - functionsToDefine : functionsToDefine , <nl> - variablesToDefine : variablesToDefine , <nl> - errorHandlingBehavior : ErrorHandlingBehavior . WriteToCurrentErrorPipe , <nl> - dollarUnder : dollarUnder , <nl> - input : input , <nl> - scriptThis : scriptThis , <nl> - outputPipe : outputPipe , <nl> - invocationInfo : null , <nl> - args : args ) ; <nl> + InvokeWithPipe ( <nl> + useLocalScope : true , <nl> + functionsToDefine : functionsToDefine , <nl> + variablesToDefine : variablesToDefine , <nl> + errorHandlingBehavior : ErrorHandlingBehavior . WriteToCurrentErrorPipe , <nl> + dollarUnder : dollarUnder , <nl> + input : input , <nl> + scriptThis : scriptThis , <nl> + outputPipe : outputPipe , <nl> + invocationInfo : null , <nl> + args : args ) ; <nl> return GetWrappedResult ( result ) ; <nl> } <nl> <nl> public Collection < PSObject > Invoke ( params object [ ] args ) <nl> / / / < exception cref = \" RuntimeException \" > Thrown if a script runtime exceptionexception occurred . < / exception > <nl> / / / < exception cref = \" FlowControlException \" > An internal ( non - public ) exception from a flow control statement . < / exception > <nl> public object InvokeReturnAsIs ( params object [ ] args ) <nl> - { <nl> - return DoInvokeReturnAsIs ( <nl> - useLocalScope : true , <nl> - errorHandlingBehavior : ErrorHandlingBehavior . WriteToExternalErrorPipe , <nl> - dollarUnder : AutomationNull . Value , <nl> - input : AutomationNull . Value , <nl> - scriptThis : AutomationNull . Value , <nl> - args : args ) ; <nl> - } <nl> + = > DoInvokeReturnAsIs ( <nl> + useLocalScope : true , <nl> + errorHandlingBehavior : ErrorHandlingBehavior . WriteToExternalErrorPipe , <nl> + dollarUnder : AutomationNull . Value , <nl> + input : AutomationNull . Value , <nl> + scriptThis : AutomationNull . Value , <nl> + args : args ) ; <nl> <nl> internal T InvokeAsMemberFunctionT < T > ( object instance , object [ ] args ) <nl> { <nl> List < object > result = new List < object > ( ) ; <nl> Pipe pipe = new Pipe ( result ) ; <nl> <nl> - InvokeWithPipe ( useLocalScope : true , <nl> - errorHandlingBehavior : ErrorHandlingBehavior . WriteToExternalErrorPipe , <nl> - dollarUnder : AutomationNull . Value , <nl> - input : AutomationNull . Value , <nl> - scriptThis : instance ? ? AutomationNull . Value , <nl> - outputPipe : pipe , <nl> - invocationInfo : null , <nl> - propagateAllExceptionsToTop : true , <nl> - args : args ) ; <nl> + InvokeWithPipe ( <nl> + useLocalScope : true , <nl> + errorHandlingBehavior : ErrorHandlingBehavior . WriteToExternalErrorPipe , <nl> + dollarUnder : AutomationNull . Value , <nl> + input : AutomationNull . Value , <nl> + scriptThis : instance ? ? AutomationNull . Value , <nl> + outputPipe : pipe , <nl> + invocationInfo : null , <nl> + propagateAllExceptionsToTop : true , <nl> + args : args ) ; <nl> <nl> / / This is needed only for the case where the <nl> / / method returns [ object ] . If the argument to ' return ' <nl> internal void InvokeAsMemberFunction ( object instance , object [ ] args ) <nl> List < object > result = new List < object > ( ) ; <nl> Pipe pipe = new Pipe ( result ) ; <nl> <nl> - InvokeWithPipe ( useLocalScope : true , <nl> - errorHandlingBehavior : ErrorHandlingBehavior . WriteToCurrentErrorPipe , <nl> - dollarUnder : AutomationNull . Value , <nl> - input : AutomationNull . Value , <nl> - scriptThis : instance ? ? AutomationNull . Value , <nl> - outputPipe : pipe , <nl> - invocationInfo : null , <nl> - propagateAllExceptionsToTop : true , <nl> - args : args ) ; <nl> + InvokeWithPipe ( <nl> + useLocalScope : true , <nl> + errorHandlingBehavior : ErrorHandlingBehavior . WriteToCurrentErrorPipe , <nl> + dollarUnder : AutomationNull . Value , <nl> + input : AutomationNull . Value , <nl> + scriptThis : instance ? ? AutomationNull . Value , <nl> + outputPipe : pipe , <nl> + invocationInfo : null , <nl> + propagateAllExceptionsToTop : true , <nl> + args : args ) ; <nl> Diagnostics . Assert ( result . Count = = 0 , \" Code generation ensures we return the correct type \" ) ; <nl> } <nl> <nl> / / / < summary > <nl> / / / Return all attributes on a script block . <nl> / / / < / summary > <nl> - public List < Attribute > Attributes <nl> - { <nl> - get { return GetAttributes ( ) ; } <nl> - } <nl> + public List < Attribute > Attributes { get = > GetAttributes ( ) ; } <nl> <nl> / / / < summary > <nl> - / / / The script file that defined this script block . . . <nl> + / / / The script file that defined this script block . <nl> / / / < / summary > <nl> - public string File <nl> - { <nl> - get { return GetFileName ( ) ; } <nl> - } <nl> + public string File { get = > GetFileName ( ) ; } <nl> <nl> / / / < summary > <nl> / / / Get / set whether this scriptblock is a filter . <nl> / / / < / summary > <nl> - public bool IsFilter <nl> - { <nl> - get { return _scriptBlockData . IsFilter ; } <nl> - <nl> - set { throw new PSInvalidOperationException ( ) ; } <nl> - } <nl> + public bool IsFilter { get = > _scriptBlockData . IsFilter ; } <nl> <nl> / / / < summary > <nl> / / / Get / set whether this scriptblock is a Configuration . <nl> / / / < / summary > <nl> - public bool IsConfiguration <nl> - { <nl> - get { return _scriptBlockData . GetIsConfiguration ( ) ; } <nl> - <nl> - set { throw new PSInvalidOperationException ( ) ; } <nl> - } <nl> + public bool IsConfiguration { get = > _scriptBlockData . GetIsConfiguration ( ) ; } <nl> <nl> / / / < summary > <nl> / / / Get the PSModuleInfo object for the module that defined this <nl> / / / scriptblock . <nl> / / / < / summary > <nl> - public PSModuleInfo Module <nl> - { <nl> - get { return SessionStateInternal ! = null ? SessionStateInternal . Module : null ; } <nl> - } <nl> + public PSModuleInfo Module { get = > SessionStateInternal ! = null ? SessionStateInternal . Module : null ; } <nl> <nl> / / / < summary > <nl> / / / Return the PSToken object for this function definition . . . <nl> / / / < / summary > <nl> - public PSToken StartPosition <nl> - { <nl> - get { return GetStartPosition ( ) ; } <nl> - } <nl> + public PSToken StartPosition { get = > GetStartPosition ( ) ; } <nl> <nl> / / LanguageMode is a nullable PSLanguageMode enumeration because script blocks <nl> / / need to inherit the language mode from the context in which they are executing . <nl> internal ReadOnlyCollection < PSTypeName > OutputType <nl> / / / < / remarks > <nl> internal static object GetRawResult ( List < object > result ) <nl> { <nl> - if ( result . Count = = 0 ) <nl> - return AutomationNull . Value ; <nl> - <nl> - if ( result . Count = = 1 ) <nl> - return LanguagePrimitives . AsPSObjectOrNull ( result [ 0 ] ) ; <nl> - <nl> - return LanguagePrimitives . AsPSObjectOrNull ( result . ToArray ( ) ) ; <nl> + switch ( result . Count ) <nl> + { <nl> + case 0 : <nl> + return AutomationNull . Value ; <nl> + case 1 : <nl> + return LanguagePrimitives . AsPSObjectOrNull ( result [ 0 ] ) ; <nl> + default : <nl> + return LanguagePrimitives . AsPSObjectOrNull ( result . ToArray ( ) ) ; <nl> + } <nl> } <nl> <nl> - internal void InvokeUsingCmdlet ( Cmdlet contextCmdlet , <nl> - bool useLocalScope , <nl> - ErrorHandlingBehavior errorHandlingBehavior , <nl> - object dollarUnder , <nl> - object input , <nl> - object scriptThis , <nl> - object [ ] args ) <nl> + internal void InvokeUsingCmdlet ( <nl> + Cmdlet contextCmdlet , <nl> + bool useLocalScope , <nl> + ErrorHandlingBehavior errorHandlingBehavior , <nl> + object dollarUnder , <nl> + object input , <nl> + object scriptThis , <nl> + object [ ] args ) <nl> { <nl> Diagnostics . Assert ( contextCmdlet ! = null , \" caller to verify contextCmdlet parameter \" ) ; <nl> <nl> internal static object GetRawResult ( List < object > result ) <nl> ExecutionContext context = GetContextFromTLS ( ) ; <nl> var myInv = context . EngineSessionState . CurrentScope . GetAutomaticVariableValue ( AutomaticVariable . MyInvocation ) ; <nl> InvocationInfo inInfo = myInv = = AutomationNull . Value ? null : ( InvocationInfo ) myInv ; <nl> - InvokeWithPipe ( useLocalScope , errorHandlingBehavior , dollarUnder , input , scriptThis , outputPipe , inInfo , propagateAllExceptionsToTop : false , args : args ) ; <nl> + InvokeWithPipe ( <nl> + useLocalScope , <nl> + errorHandlingBehavior , <nl> + dollarUnder , <nl> + input , <nl> + scriptThis , <nl> + outputPipe , <nl> + inInfo , <nl> + propagateAllExceptionsToTop : false , <nl> + args : args ) ; <nl> } <nl> <nl> / / / < summary > <nl> - / / / The internal session state object associated with this scriptblock . . . <nl> + / / / The internal session state object associated with this scriptblock . <nl> / / / < / summary > <nl> internal SessionStateInternal SessionStateInternal { get ; set ; } <nl> <nl> internal SessionState SessionState <nl> set <nl> { <nl> if ( value = = null ) <nl> - throw PSTraceSource . NewArgumentNullException ( \" value \" ) ; <nl> + { <nl> + throw PSTraceSource . NewArgumentNullException ( nameof ( value ) ) ; <nl> + } <nl> + <nl> SessionStateInternal = value . Internal ; <nl> } <nl> } <nl> internal SessionState SessionState <nl> new ConditionalWeakTable < ScriptBlock , ConcurrentDictionary < Type , Delegate > > ( ) ; <nl> <nl> internal Delegate GetDelegate ( Type delegateType ) <nl> - { <nl> - var instanceDelegateTable = s_delegateTable . GetOrCreateValue ( this ) ; <nl> - return instanceDelegateTable . GetOrAdd ( delegateType , CreateDelegate ) ; <nl> - } <nl> + = > s_delegateTable . GetOrCreateValue ( this ) . GetOrAdd ( delegateType , CreateDelegate ) ; <nl> <nl> / / / < summary > <nl> / / / Get the delegate method as a call back . <nl> internal Delegate CreateDelegate ( Type delegateType ) <nl> Expression . NewArrayInit ( typeof ( object ) , parameterExprs . Select ( p = > p . Cast ( typeof ( object ) ) ) ) ) ; <nl> if ( returnsSomething ) <nl> { <nl> - call = DynamicExpression . Dynamic ( PSConvertBinder . Get ( invokeMethod . ReturnType ) , invokeMethod . ReturnType , call ) ; <nl> + call = DynamicExpression . Dynamic ( <nl> + PSConvertBinder . Get ( invokeMethod . ReturnType ) , <nl> + invokeMethod . ReturnType , <nl> + call ) ; <nl> } <nl> <nl> return Expression . Lambda ( delegateType , call , parameterExprs ) . Compile ( ) ; <nl> internal object InvokeAsDelegateHelper ( object dollarUnder , object dollarThis , ob <nl> / / / < summary > <nl> / / / Returns the current execution context from TLS , or raises an exception if it is null . <nl> / / / < / summary > <nl> - / / / < exception cref = \" InvalidOperationException \" > An attempt was made to use the scriptblock outside the engine . < / exception > <nl> + / / / < exception cref = \" InvalidOperationException \" > <nl> + / / / An attempt was made to use the scriptblock outside the engine . <nl> + / / / < / exception > <nl> internal ExecutionContext GetContextFromTLS ( ) <nl> { <nl> ExecutionContext context = LocalPipeline . GetExecutionContextFromTLS ( ) ; <nl> internal Collection < PSObject > DoInvoke ( object dollarUnder , object input , object [ <nl> { <nl> List < object > result = new List < object > ( ) ; <nl> Pipe outputPipe = new Pipe ( result ) ; <nl> - InvokeWithPipe ( useLocalScope : true , <nl> - errorHandlingBehavior : ErrorHandlingBehavior . WriteToExternalErrorPipe , <nl> - dollarUnder : dollarUnder , <nl> - input : input , <nl> - scriptThis : AutomationNull . Value , <nl> - outputPipe : outputPipe , <nl> - invocationInfo : null , <nl> - args : args ) ; <nl> + InvokeWithPipe ( <nl> + useLocalScope : true , <nl> + errorHandlingBehavior : ErrorHandlingBehavior . WriteToExternalErrorPipe , <nl> + dollarUnder : dollarUnder , <nl> + input : input , <nl> + scriptThis : AutomationNull . Value , <nl> + outputPipe : outputPipe , <nl> + invocationInfo : null , <nl> + args : args ) ; <nl> return GetWrappedResult ( result ) ; <nl> } <nl> <nl> private static Collection < PSObject > GetWrappedResult ( List < object > result ) <nl> / / / the script block returned as a collection of PSObjects . < / returns > <nl> / / / < exception cref = \" RuntimeException \" > A script exception occurred . < / exception > <nl> / / / < exception cref = \" FlowControlException \" > Internal exception from a flow control statement . < / exception > <nl> - internal object DoInvokeReturnAsIs ( bool useLocalScope , <nl> - ErrorHandlingBehavior errorHandlingBehavior , <nl> - object dollarUnder , <nl> - object input , <nl> - object scriptThis , <nl> - object [ ] args ) <nl> + internal object DoInvokeReturnAsIs ( <nl> + bool useLocalScope , <nl> + ErrorHandlingBehavior errorHandlingBehavior , <nl> + object dollarUnder , <nl> + object input , <nl> + object scriptThis , <nl> + object [ ] args ) <nl> { <nl> List < object > result = new List < object > ( ) ; <nl> Pipe outputPipe = new Pipe ( result ) ; <nl> - InvokeWithPipe ( useLocalScope : useLocalScope , <nl> - errorHandlingBehavior : errorHandlingBehavior , <nl> - dollarUnder : dollarUnder , <nl> - input : input , <nl> - scriptThis : scriptThis , <nl> - outputPipe : outputPipe , <nl> - invocationInfo : null , <nl> - args : args ) ; <nl> + InvokeWithPipe ( <nl> + useLocalScope : useLocalScope , <nl> + errorHandlingBehavior : errorHandlingBehavior , <nl> + dollarUnder : dollarUnder , <nl> + input : input , <nl> + scriptThis : scriptThis , <nl> + outputPipe : outputPipe , <nl> + invocationInfo : null , <nl> + args : args ) ; <nl> return GetRawResult ( result ) ; <nl> } <nl> <nl> internal void InvokeWithPipe ( <nl> - bool useLocalScope , <nl> - ErrorHandlingBehavior errorHandlingBehavior , <nl> - object dollarUnder , <nl> - object input , <nl> - object scriptThis , <nl> - Pipe outputPipe , <nl> - InvocationInfo invocationInfo , <nl> - bool propagateAllExceptionsToTop = false , <nl> - List < PSVariable > variablesToDefine = null , <nl> - Dictionary < string , ScriptBlock > functionsToDefine = null , <nl> - object [ ] args = null ) <nl> + bool useLocalScope , <nl> + ErrorHandlingBehavior errorHandlingBehavior , <nl> + object dollarUnder , <nl> + object input , <nl> + object scriptThis , <nl> + Pipe outputPipe , <nl> + InvocationInfo invocationInfo , <nl> + bool propagateAllExceptionsToTop = false , <nl> + List < PSVariable > variablesToDefine = null , <nl> + Dictionary < string , ScriptBlock > functionsToDefine = null , <nl> + object [ ] args = null ) <nl> { <nl> bool shouldGenerateEvent = false ; <nl> bool oldPropagateExceptions = false ; <nl> private static Collection < PSObject > GetWrappedResult ( List < object > result ) <nl> { <nl> var runspace = ( RunspaceBase ) context . CurrentRunspace ; <nl> shouldGenerateEvent = ! runspace . RunActionIfNoRunningPipelinesWithThreadCheck ( ( ) = > <nl> - InvokeWithPipeImpl ( useLocalScope , functionsToDefine , variablesToDefine , errorHandlingBehavior , <nl> - dollarUnder , input , scriptThis , outputPipe , invocationInfo , args ) ) ; <nl> + InvokeWithPipeImpl ( <nl> + useLocalScope , <nl> + functionsToDefine , <nl> + variablesToDefine , <nl> + errorHandlingBehavior , <nl> + dollarUnder , <nl> + input , <nl> + scriptThis , <nl> + outputPipe , <nl> + invocationInfo , <nl> + args ) ) ; <nl> } <nl> finally <nl> { <nl> private static Collection < PSObject > GetWrappedResult ( List < object > result ) <nl> if ( shouldGenerateEvent ) <nl> { <nl> context . Events . SubscribeEvent ( <nl> - source : null , <nl> - eventName : PSEngineEvent . OnScriptBlockInvoke , <nl> - sourceIdentifier : PSEngineEvent . OnScriptBlockInvoke , <nl> - data : null , <nl> - handlerDelegate : new PSEventReceivedEventHandler ( OnScriptBlockInvokeEventHandler ) , <nl> - supportEvent : true , <nl> - forwardEvent : false , <nl> - shouldQueueAndProcessInExecutionThread : true , <nl> - maxTriggerCount : 1 ) ; <nl> + source : null , <nl> + eventName : PSEngineEvent . OnScriptBlockInvoke , <nl> + sourceIdentifier : PSEngineEvent . OnScriptBlockInvoke , <nl> + data : null , <nl> + handlerDelegate : new PSEventReceivedEventHandler ( OnScriptBlockInvokeEventHandler ) , <nl> + supportEvent : true , <nl> + forwardEvent : false , <nl> + shouldQueueAndProcessInExecutionThread : true , <nl> + maxTriggerCount : 1 ) ; <nl> <nl> var scriptBlockInvocationEventArgs = new ScriptBlockInvocationEventArgs ( <nl> - this , useLocalScope , errorHandlingBehavior , dollarUnder , input , scriptThis , outputPipe , <nl> - invocationInfo , args ) ; <nl> + scriptBlock : this , <nl> + useLocalScope , <nl> + errorHandlingBehavior , <nl> + dollarUnder , <nl> + input , <nl> + scriptThis , <nl> + outputPipe , <nl> + invocationInfo , <nl> + args ) ; <nl> <nl> context . Events . GenerateEvent ( <nl> sourceIdentifier : PSEngineEvent . OnScriptBlockInvoke , <nl> private static Collection < PSObject > GetWrappedResult ( List < object > result ) <nl> private static void OnScriptBlockInvokeEventHandler ( object sender , PSEventArgs args ) <nl> { <nl> var eventArgs = ( object ) args . SourceEventArgs as ScriptBlockInvocationEventArgs ; <nl> - Diagnostics . Assert ( eventArgs ! = null , \" Event Arguments to OnScriptBlockInvokeEventHandler should not be null \" ) ; <nl> + Diagnostics . Assert ( eventArgs ! = null , <nl> + \" Event Arguments to OnScriptBlockInvokeEventHandler should not be null \" ) ; <nl> <nl> try <nl> { <nl> ScriptBlock sb = eventArgs . ScriptBlock ; <nl> - sb . InvokeWithPipeImpl ( eventArgs . UseLocalScope , null , null , eventArgs . ErrorHandlingBehavior , eventArgs . DollarUnder , eventArgs . Input , eventArgs . ScriptThis , eventArgs . OutputPipe , eventArgs . InvocationInfo , eventArgs . Args ) ; <nl> + sb . InvokeWithPipeImpl ( <nl> + eventArgs . UseLocalScope , <nl> + functionsToDefine : null , <nl> + variablesToDefine : null , <nl> + eventArgs . ErrorHandlingBehavior , <nl> + eventArgs . DollarUnder , <nl> + eventArgs . Input , <nl> + eventArgs . ScriptThis , <nl> + eventArgs . OutputPipe , <nl> + eventArgs . InvocationInfo , <nl> + eventArgs . Args ) ; <nl> } <nl> catch ( Exception e ) <nl> { <nl> internal void SetPSScriptRootAndPSCommandPath ( MutableTuple locals , ExecutionCont <nl> / / / < summary > <nl> / / / A steppable pipeline wrapper object . . . <nl> / / / < / summary > <nl> - [ SuppressMessage ( \" Microsoft . Naming \" , \" CA1704 : IdentifiersShouldBeSpelledCorrectly \" , MessageId = \" Steppable \" , Justification = \" Consider Name change during API review \" ) ] <nl> + [ SuppressMessage ( <nl> + \" Microsoft . Naming \" , <nl> + \" CA1704 : IdentifiersShouldBeSpelledCorrectly \" , <nl> + MessageId = \" Steppable \" , <nl> + Justification = \" Consider Name change during API review \" ) ] <nl> public sealed class SteppablePipeline : IDisposable <nl> { <nl> internal SteppablePipeline ( ExecutionContext context , PipelineProcessor pipeline ) <nl> { <nl> - if ( pipeline = = null ) throw new ArgumentNullException ( \" pipeline \" ) ; <nl> - if ( context = = null ) throw new ArgumentNullException ( \" context \" ) ; <nl> + if ( pipeline = = null ) <nl> + { <nl> + throw new ArgumentNullException ( nameof ( pipeline ) ) ; <nl> + } <nl> + <nl> + if ( context = = null ) <nl> + { <nl> + throw new ArgumentNullException ( nameof ( context ) ) ; <nl> + } <nl> + <nl> _pipeline = pipeline ; <nl> _context = context ; <nl> } <nl> internal SteppablePipeline ( ExecutionContext context , PipelineProcessor pipeline ) <nl> / / / Begin execution of a steppable pipeline . This overload doesn ' t reroute output and error pipes . <nl> / / / < / summary > <nl> / / / < param name = \" expectInput \" > < c > true < / c > if you plan to write input into this pipe ; < c > false < / c > otherwise . < / param > <nl> - public void Begin ( bool expectInput ) <nl> - { <nl> - Begin ( expectInput , ( ICommandRuntime ) null ) ; <nl> - } <nl> + public void Begin ( bool expectInput ) = > Begin ( expectInput , commandRuntime : ( ICommandRuntime ) null ) ; <nl> <nl> / / / < summary > <nl> / / / Begin execution of a steppable pipeline , using the command running currently in the specified context to figure <nl> public void Begin ( bool expectInput , EngineIntrinsics contextToRedirectTo ) <nl> { <nl> if ( contextToRedirectTo = = null ) <nl> { <nl> - throw new ArgumentNullException ( \" contextToRedirectTo \" ) ; <nl> + throw new ArgumentNullException ( nameof ( contextToRedirectTo ) ) ; <nl> } <nl> <nl> ExecutionContext executionContext = contextToRedirectTo . SessionState . Internal . ExecutionContext ; <nl> public void Begin ( bool expectInput , EngineIntrinsics contextToRedirectTo ) <nl> public void Begin ( InternalCommand command ) <nl> { <nl> if ( command = = null | | command . MyInvocation = = null ) <nl> - throw new ArgumentNullException ( \" command \" ) ; <nl> + { <nl> + throw new ArgumentNullException ( nameof ( command ) ) ; <nl> + } <nl> <nl> Begin ( command . MyInvocation . ExpectingInput , command . commandRuntime ) ; <nl> } <nl> public void Dispose ( ) <nl> private void Dispose ( bool disposing ) <nl> { <nl> if ( _disposed ) <nl> + { <nl> return ; <nl> + } <nl> <nl> if ( disposing ) <nl> { <nl> public ScriptBlockToPowerShellNotSupportedException ( string message , Exception in <nl> string message , <nl> params object [ ] arguments ) <nl> : base ( string . Format ( CultureInfo . CurrentCulture , message , arguments ) , innerException ) <nl> - { <nl> - this . SetErrorId ( errorId ) ; <nl> - } <nl> + = > this . SetErrorId ( errorId ) ; <nl> <nl> # region Serialization <nl> / / / < summary > <nl> internal sealed class ScriptBlockInvocationEventArgs : EventArgs <nl> / / / < param name = \" args \" > The arguments to this script . < / param > <nl> / / / < exception cref = \" ArgumentNullException \" > ScriptBlock is null <nl> / / / < / exception > <nl> - internal ScriptBlockInvocationEventArgs ( ScriptBlock scriptBlock , <nl> - bool useLocalScope , <nl> - ScriptBlock . ErrorHandlingBehavior errorHandlingBehavior , <nl> - object dollarUnder , <nl> - object input , <nl> - object scriptThis , <nl> - Pipe outputPipe , <nl> - InvocationInfo invocationInfo , <nl> - object [ ] args ) <nl> + internal ScriptBlockInvocationEventArgs ( <nl> + ScriptBlock scriptBlock , <nl> + bool useLocalScope , <nl> + ScriptBlock . ErrorHandlingBehavior errorHandlingBehavior , <nl> + object dollarUnder , <nl> + object input , <nl> + object scriptThis , <nl> + Pipe outputPipe , <nl> + InvocationInfo invocationInfo , <nl> + object [ ] args ) <nl> { <nl> if ( scriptBlock = = null ) <nl> { <nl> - throw PSTraceSource . NewArgumentNullException ( \" scriptBlock \" ) ; <nl> + throw PSTraceSource . NewArgumentNullException ( nameof ( scriptBlock ) ) ; <nl> } <nl> <nl> ScriptBlock = scriptBlock ; <nl>\n", "msg": "Code Cleanup : Tidy up scriptblock . cs ( )\n"}
{"diff_id": 29730, "repo": "mono/mono\n", "sha": "27537cb6760045066b6cb5dbff5abf2bdbc0c8da\n", "time": "2016-11-29T10:44:37Z\n", "diff": "mmm a / mcs / class / System / Test / System . Net . WebSockets / ClientWebSocketTest . cs <nl> ppp b / mcs / class / System / Test / System . Net . WebSockets / ClientWebSocketTest . cs <nl> namespace MonoTests . System . Net . WebSockets <nl> public class ClientWebSocketTest <nl> { <nl> const string EchoServerUrl = \" ws : / / corefx - net . cloudapp . net / WebSocket / EchoWebSocket . ashx \" ; <nl> - int Port = NetworkHelpers . FindFreePort ( ) ; <nl> + <nl> + ClientWebSocket socket ; <nl> + MethodInfo headerSetMethod ; <nl> + int Port ; <nl> + <nl> + [ SetUp ] <nl> + public void Setup ( ) <nl> + { <nl> + socket = new ClientWebSocket ( ) ; <nl> + Port = NetworkHelpers . FindFreePort ( ) ; <nl> + } <nl> + <nl> HttpListener _listener ; <nl> HttpListener listener { <nl> get { <nl> if ( _listener ! = null ) <nl> return _listener ; <nl> + <nl> var tmp = new HttpListener ( ) ; <nl> tmp . Prefixes . Add ( \" http : / / localhost : \" + Port + \" / \" ) ; <nl> tmp . Start ( ) ; <nl> return _listener = tmp ; <nl> } <nl> } <nl> - ClientWebSocket _socket ; <nl> - ClientWebSocket socket { get { return _socket ? ? ( _socket = new ClientWebSocket ( ) ) ; } } <nl> - MethodInfo headerSetMethod ; <nl> <nl> [ TearDown ] <nl> public void Teardown ( ) <nl> public void Teardown ( ) <nl> _listener . Stop ( ) ; <nl> _listener = null ; <nl> } <nl> - if ( _socket ! = null ) { <nl> - if ( _socket . State = = WebSocketState . Open ) <nl> - _socket . CloseAsync ( WebSocketCloseStatus . NormalClosure , string . Empty , CancellationToken . None ) . Wait ( 2000 ) ; <nl> - _socket . Dispose ( ) ; <nl> - _socket = null ; <nl> + if ( socket ! = null ) { <nl> + if ( socket . State = = WebSocketState . Open ) <nl> + socket . CloseAsync ( WebSocketCloseStatus . NormalClosure , string . Empty , CancellationToken . None ) . Wait ( 2000 ) ; <nl> + socket . Dispose ( ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "[ System ] Update ClientWebSocket test to use Setup\n"}
{"diff_id": 29756, "repo": "AvaloniaUI/Avalonia\n", "sha": "8535ee690e81809eb69c737affebfb6a0e22b060\n", "time": "2020-11-13T16:35:50Z\n", "diff": "mmm a / src / Markup / Avalonia . Markup . Xaml . Loader / CompilerExtensions / XamlIlBindingPathHelper . cs <nl> ppp b / src / Markup / Avalonia . Markup . Xaml . Loader / CompilerExtensions / XamlIlBindingPathHelper . cs <nl> public void Emit ( XamlIlEmitContext context , IXamlILEmitter codeGen ) <nl> { <nl> codeGen . Ldtype ( Type ) <nl> . Ldc_I4 ( _level ) <nl> - . EmitCall ( context . GetAvaloniaTypes ( ) . CompiledBindingPathBuilder . FindMethod ( m = > m . Name = = \" FindAncestor \" ) ) ; <nl> + . EmitCall ( context . GetAvaloniaTypes ( ) . CompiledBindingPathBuilder . FindMethod ( m = > m . Name = = \" Ancestor \" ) ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "second attempt make $ parent work in compiled binding\n"}
{"diff_id": 29766, "repo": "ppy/osu\n", "sha": "8292c746ea82e35412f717fe8d6db6921661e54e\n", "time": "2020-12-12T23:30:41Z\n", "diff": "mmm a / osu . Game . Rulesets . Taiko . Tests / TestSceneHits . cs <nl> ppp b / osu . Game . Rulesets . Taiko . Tests / TestSceneHits . cs <nl> <nl> / / See the LICENCE file in the repository root for full licence text . <nl> <nl> using System ; <nl> + using System . Linq ; <nl> using NUnit . Framework ; <nl> using osu . Framework . Graphics ; <nl> using osu . Framework . Utils ; <nl> <nl> using osu . Game . Beatmaps . ControlPoints ; <nl> using osu . Game . Rulesets . Judgements ; <nl> using osu . Game . Rulesets . Objects ; <nl> - using osu . Game . Rulesets . Objects . Drawables ; <nl> using osu . Game . Rulesets . Scoring ; <nl> using osu . Game . Rulesets . Taiko . Judgements ; <nl> using osu . Game . Rulesets . Taiko . Objects ; <nl> private void addStrongHitJudgement ( bool kiai ) <nl> var cpi = new ControlPointInfo ( ) ; <nl> cpi . Add ( 0 , new EffectControlPoint { KiaiMode = kiai } ) ; <nl> <nl> - Hit hit = new Hit ( ) ; <nl> + Hit hit = new Hit { IsStrong = true } ; <nl> hit . ApplyDefaults ( cpi , new BeatmapDifficulty ( ) ) ; <nl> <nl> var h = new DrawableTestHit ( hit ) { X = RNG . NextSingle ( hitResult = = HitResult . Ok ? - 0 . 1f : - 0 . 05f , hitResult = = HitResult . Ok ? 0 . 1f : 0 . 05f ) } ; <nl> private void addStrongHitJudgement ( bool kiai ) <nl> DrawableRuleset . Playfield . Add ( h ) ; <nl> <nl> ( ( TaikoPlayfield ) DrawableRuleset . Playfield ) . OnNewResult ( h , new JudgementResult ( new HitObject ( ) , new TaikoJudgement ( ) ) { Type = hitResult } ) ; <nl> - ( ( TaikoPlayfield ) DrawableRuleset . Playfield ) . OnNewResult ( new TestStrongNestedHit ( h ) , new JudgementResult ( new HitObject ( ) , new TaikoStrongJudgement ( ) ) { Type = HitResult . Great } ) ; <nl> + ( ( TaikoPlayfield ) DrawableRuleset . Playfield ) . OnNewResult ( h . NestedHitObjects . Single ( ) , new JudgementResult ( new HitObject ( ) , new TaikoStrongJudgement ( ) ) { Type = HitResult . Great } ) ; <nl> } <nl> <nl> private void addMissJudgement ( ) <nl> private void addRimHit ( bool strong ) <nl> <nl> DrawableRuleset . Playfield . Add ( new DrawableHit ( h ) ) ; <nl> } <nl> - <nl> - private class TestStrongNestedHit : DrawableStrongNestedHit <nl> - { <nl> - public TestStrongNestedHit ( DrawableHitObject mainObject ) <nl> - : base ( new StrongHitObject { StartTime = mainObject . HitObject . StartTime } , mainObject ) <nl> - { <nl> - } <nl> - <nl> - public override bool OnPressed ( TaikoAction action ) = > false ; <nl> - } <nl> } <nl> } <nl>\n", "msg": "Leverage hitobject model for strong hit instead of creating own\n"}
{"diff_id": 29890, "repo": "ServiceStack/ServiceStack\n", "sha": "a7ba8a41a2808ff807647632cf53e3d7b0eecd66\n", "time": "2015-01-21T17:21:44Z\n", "diff": "mmm a / src / ServiceStack / Auth / DigestAuthProvider . cs <nl> ppp b / src / ServiceStack / Auth / DigestAuthProvider . cs <nl> public virtual bool TryAuthenticate ( IServiceBase authService , string userName , s <nl> var digestInfo = authService . Request . GetDigestAuth ( ) ; <nl> IUserAuth userAuth ; <nl> if ( authRepo . TryAuthenticate ( digestInfo , PrivateKey , NonceTimeOut , session . Sequence , out userAuth ) ) { <nl> - session . PopulateWith ( userAuth ) ; <nl> + <nl> + var holdSessionId = session . Id ; <nl> + session . PopulateWith ( userAuth ) ; / / overwrites session . Id <nl> + session . Id = holdSessionId ; <nl> session . IsAuthenticated = true ; <nl> session . Sequence = digestInfo [ \" nc \" ] ; <nl> session . UserAuthId = userAuth . Id . ToString ( CultureInfo . InvariantCulture ) ; <nl>\n", "msg": "Change digest provider so Id is not overridden when populating session with userAuth info\n"}
{"diff_id": 29951, "repo": "OpenRA/OpenRA\n", "sha": "eb3f8c945cfcbb42a4bce8db1d7c1f3cd99598d9\n", "time": "2016-10-11T19:42:15Z\n", "diff": "mmm a / OpenRA . Mods . Common / AI / HackyAI . cs <nl> ppp b / OpenRA . Mods . Common / AI / HackyAI . cs <nl> void FindAndDeployBackupMcv ( Actor self ) <nl> if ( ! mcv . IsIdle ) <nl> continue ; <nl> <nl> + / / If we lack a base , we need to make sure we don ' t restrict deployment of the MCV to the base ! <nl> + var restrictToBase = <nl> + Info . RestrictMCVDeploymentFallbackToBase & & <nl> + CountBuildingByCommonName ( Info . BuildingCommonNames . ConstructionYard , Player ) > 0 ; <nl> var factType = mcv . Info . TraitInfo < TransformsInfo > ( ) . IntoActor ; <nl> - var desiredLocation = ChooseBuildLocation ( factType , Info . RestrictMCVDeploymentFallbackToBase , BuildingType . Building ) ; <nl> + var desiredLocation = ChooseBuildLocation ( factType , restrictToBase , BuildingType . Building ) ; <nl> if ( desiredLocation = = null ) <nl> continue ; <nl> <nl>\n", "msg": "Make sure AI can deploy an MCV when it lacks a base .\n"}
{"diff_id": 30017, "repo": "mono/mono\n", "sha": "a4de65fd00f4eb8757fe1c51a4bc0d2fa96d694e\n", "time": "2010-12-20T12:37:39Z\n", "diff": "mmm a / mcs / mcs / method . cs <nl> ppp b / mcs / mcs / method . cs <nl> protected SourceMethod ( DeclSpace parent , MethodBase method , ICompileUnit file ) <nl> <nl> public int Token { <nl> get { <nl> - if ( method is MethodBuilder ) <nl> - return ( ( MethodBuilder ) method ) . GetToken ( ) . Token ; <nl> - else if ( method is ConstructorBuilder ) <nl> - return ( ( ConstructorBuilder ) method ) . GetToken ( ) . Token ; <nl> + MethodToken token ; <nl> + var mb = method as MethodBuilder ; <nl> + if ( mb ! = null ) <nl> + token = mb . GetToken ( ) ; <nl> else <nl> - throw new NotSupportedException ( ) ; <nl> + token = ( ( ConstructorBuilder ) method ) . GetToken ( ) ; <nl> + # if STATIC <nl> + if ( token . IsPseudoToken ) <nl> + return ( ( ModuleBuilder ) method . Module ) . ResolvePseudoToken ( token . Token ) ; <nl> + # endif <nl> + return token . Token ; <nl> } <nl> } <nl> <nl>\n", "msg": "Add a workaround for ikvm unfixed baked method tokens\n"}
{"diff_id": 30271, "repo": "dotnet/runtime\n", "sha": "f8edc5bcb6cc258d72679e2ed0813b65502bf796\n", "time": "2015-08-11T20:33:29Z\n", "diff": "mmm a / src / libraries / System . Runtime / tests / System / TimeZoneInfo . cs <nl> ppp b / src / libraries / System . Runtime / tests / System / TimeZoneInfo . cs <nl> <nl> / / Licensed under the MIT license . See LICENSE file in the project root for full license information . <nl> <nl> using System ; <nl> + using System . Collections . ObjectModel ; <nl> using System . Globalization ; <nl> using System . Runtime . InteropServices ; <nl> using Xunit ; <nl> public static class TimeZoneInfoTests <nl> private static String s_strAmsterdam = s_isWindows ? \" W . Europe Standard Time \" : \" Europe / Berlin \" ; <nl> private static String s_strRussian = s_isWindows ? \" Russian Standard Time \" : \" Europe / Moscow \" ; <nl> private static String s_strLibya = s_isWindows ? \" Libya Standard Time \" : \" Africa / Tripoli \" ; <nl> - private static String s_strCatamarca = s_isWindows ? \" Argentina Standard Time \" : \" America / Catamarca \" ; <nl> + private static String s_strCatamarca = s_isWindows ? \" Argentina Standard Time \" : \" America / Argentina / Catamarca \" ; <nl> private static String s_strLisbon = s_isWindows ? \" GMT Standard Time \" : \" Europe / Lisbon \" ; <nl> private static String s_strNewfoundland = s_isWindows ? \" Newfoundland Standard Time \" : \" America / St_Johns \" ; <nl> <nl> public static void TestLisbonDaylightSavingsWithNoOffsetChange ( string dateTimeSt <nl> <nl> [ Theory ] <nl> / / Newfoundland is UTC - 3 : 30 standard and UTC - 2 : 30 dst <nl> - / / using non - UTC date times in this test to get some converage for non - UTC date times <nl> + / / using non - UTC date times in this test to get some coverage for non - UTC date times <nl> [ InlineData ( \" 2015 - 03 - 08T01 : 59 : 59 \" , false , false , false , \" - 3 : 30 : 00 \" , \" - 8 : 00 : 00 \" ) ] <nl> / / since DST kicks in a 2AM , from 2AM - 3AM is Invalid <nl> - [ InlineData ( \" 2015 - 03 - 08T02 : 00 : 00 \" , false , true , false , \" - 3 : 30 : 00 \" , \" - 8 : 00 : 00 \" ) ] <nl> - [ InlineData ( \" 2015 - 03 - 08T02 : 59 : 59 \" , false , true , false , \" - 3 : 30 : 00 \" , \" - 8 : 00 : 00 \" ) ] <nl> - [ InlineData ( \" 2015 - 03 - 08T03 : 00 : 00 \" , true , false , false , \" - 2 : 30 : 00 \" , \" - 8 : 00 : 00 \" ) ] <nl> - [ InlineData ( \" 2015 - 03 - 08T07 : 29 : 59 \" , true , false , false , \" - 2 : 30 : 00 \" , \" - 8 : 00 : 00 \" ) ] <nl> - [ InlineData ( \" 2015 - 03 - 08T07 : 30 : 00 \" , true , false , false , \" - 2 : 30 : 00 \" , \" - 7 : 00 : 00 \" ) ] <nl> + [ InlineData ( \" 2015 - 03 - 08T02 : 00 : 00 \" , false , true , false , \" - 3 : 30 : 00 \" , \" - 8 : 00 : 00 \" ) ] <nl> + [ InlineData ( \" 2015 - 03 - 08T02 : 59 : 59 \" , false , true , false , \" - 3 : 30 : 00 \" , \" - 8 : 00 : 00 \" ) ] <nl> + [ InlineData ( \" 2015 - 03 - 08T03 : 00 : 00 \" , true , false , false , \" - 2 : 30 : 00 \" , \" - 8 : 00 : 00 \" ) ] <nl> + [ InlineData ( \" 2015 - 03 - 08T07 : 29 : 59 \" , true , false , false , \" - 2 : 30 : 00 \" , \" - 8 : 00 : 00 \" ) ] <nl> + [ InlineData ( \" 2015 - 03 - 08T07 : 30 : 00 \" , true , false , false , \" - 2 : 30 : 00 \" , \" - 7 : 00 : 00 \" ) ] <nl> [ InlineData ( \" 2015 - 11 - 01T00 : 59 : 59 \" , true , false , false , \" - 2 : 30 : 00 \" , \" - 7 : 00 : 00 \" ) ] <nl> [ InlineData ( \" 2015 - 11 - 01T01 : 00 : 00 \" , false , false , true , \" - 3 : 30 : 00 \" , \" - 7 : 00 : 00 \" ) ] <nl> [ InlineData ( \" 2015 - 11 - 01T01 : 59 : 59 \" , false , false , true , \" - 3 : 30 : 00 \" , \" - 7 : 00 : 00 \" ) ] <nl> public static void TestLisbonDaylightSavingsWithNoOffsetChange ( string dateTimeSt <nl> } <nl> } <nl> <nl> + [ Fact ] <nl> + public static void TestGetSystemTimeZones ( ) <nl> + { <nl> + ReadOnlyCollection < TimeZoneInfo > timeZones = TimeZoneInfo . GetSystemTimeZones ( ) ; <nl> + Assert . NotEmpty ( timeZones ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strPacific ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strSydney ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strGMT ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strTonga ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strBrasil ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strPerth ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strBrasilia ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strNairobi ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strAmsterdam ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strRussian ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strLibya ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strCatamarca ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strLisbon ) ; <nl> + Assert . Contains ( timeZones , t = > t . Id = = s_strNewfoundland ) ; <nl> + <nl> + / / ensure the TimeZoneInfos are sorted by BaseUtcOffset and then DisplayName . <nl> + TimeZoneInfo previous = timeZones [ 0 ] ; <nl> + for ( int i = 1 ; i < timeZones . Count ; i + + ) <nl> + { <nl> + TimeZoneInfo current = timeZones [ i ] ; <nl> + int baseOffsetsCompared = current . BaseUtcOffset . CompareTo ( previous . BaseUtcOffset ) ; <nl> + Assert . True ( baseOffsetsCompared > = 0 , <nl> + string . Format ( \" TimeZoneInfos are out of order . { 0 } : { 1 } should be before { 2 } : { 3 } \" , <nl> + previous . Id , previous . BaseUtcOffset , current . Id , current . BaseUtcOffset ) ) ; <nl> + <nl> + if ( baseOffsetsCompared = = 0 ) <nl> + { <nl> + Assert . True ( current . DisplayName . CompareTo ( previous . DisplayName ) > = 0 , <nl> + string . Format ( \" TimeZoneInfos are out of order . { 0 } should be before { 1 } \" , <nl> + previous . DisplayName , current . DisplayName ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> / / <nl> / / Helper Methods <nl> / / <nl>\n", "msg": "Adding a test case for TimeZoneInfo . GetSystemTimeZones .\n"}
{"diff_id": 30275, "repo": "QuantConnect/Lean\n", "sha": "77ebcce0501fdc70d77614764bd36808e81683b6\n", "time": "2019-07-12T16:27:36Z\n", "diff": "mmm a / ToolBox / PsychSignalDataConverter / PsychSignalDataConverter . cs <nl> ppp b / ToolBox / PsychSignalDataConverter / PsychSignalDataConverter . cs <nl> public void Convert ( FileInfo sourceFilePath ) <nl> throw new ObjectDisposedException ( \" PsychSignalDataConverter has already been disposed \" ) ; <nl> } <nl> <nl> - var tempRawFile = Path . Combine ( Path . GetTempPath ( ) , Guid . NewGuid ( ) . ToString ( ) ) ; <nl> - <nl> - Log . Trace ( $ \" PsychSignalDataConverter . Convert ( ) : Copying file : { sourceFilePath . Name } - to : { tempRawFile } \" ) ; <nl> - File . Copy ( sourceFilePath . FullName , tempRawFile ) ; <nl> - <nl> - Log . Trace ( $ \" PsychSignalDataConverter . Convert ( ) : Begin converting { sourceFilePath . Name } \" ) ; <nl> - <nl> - var file = File . ReadLines ( tempRawFile ) ; <nl> - var totalLinesCount = file . Count ( ) ; <nl> var previousTicker = string . Empty ; <nl> var currentLineCount = 0 ; <nl> - var percentIncrement = 0 . 10 ; <nl> - var currentTarget = percentIncrement ; <nl> <nl> - foreach ( var line in file ) <nl> + Log . Trace ( $ \" PsychSignalDataConverter . Convert ( ) : Begin converting { sourceFilePath . Name } \" ) ; <nl> + <nl> + using ( var stream = sourceFilePath . OpenRead ( ) ) <nl> + using ( var reader = new StreamReader ( stream ) ) <nl> { <nl> - currentLineCount + + ; <nl> + string line ; <nl> + while ( ( line = reader . ReadLine ( ) ) ! = null ) <nl> + { <nl> + currentLineCount + + ; <nl> <nl> - var csv = line . Split ( ' , ' ) ; <nl> - var ticker = csv [ 1 ] . ToLower ( ) ; <nl> - DateTime timestamp ; <nl> + var csv = line . Split ( ' , ' ) ; <nl> + var ticker = csv [ 1 ] . ToLower ( ) ; <nl> + DateTime timestamp ; <nl> <nl> - if ( csv [ 0 ] = = \" SOURCE \" ) <nl> - { <nl> - Log . Trace ( $ \" PsychSignalDataConverter . Convert ( ) : Skipping line { currentLineCount } - Line contains header information \" ) ; <nl> - continue ; <nl> - } <nl> - if ( ! DateTime . TryParseExact ( csv [ 2 ] , @ \" yyyy - MM - dd \\ THH : mm : ss \\ Z \" , CultureInfo . InvariantCulture , DateTimeStyles . AdjustToUniversal , out timestamp ) ) <nl> - { <nl> - Log . Trace ( $ \" PsychSignalDataConverter . Convert ( ) : Skipping line { currentLineCount } - Failed to parse date properly \" ) ; <nl> - continue ; <nl> - } <nl> - if ( ! _mapFileResolver . ResolveMapFile ( ticker , timestamp ) . Any ( ) ) <nl> - { <nl> - / / Because all tickers are all clustered together , we can detect <nl> - / / duplicate messages and prevent ourselves from spamming the status log <nl> - if ( ticker ! = previousTicker ) <nl> + if ( csv [ 0 ] = = \" SOURCE \" ) <nl> { <nl> - Log . Trace ( $ \" PsychSignalDataDownloader . Convert ( ) : Skipping line { currentLineCount } - Could not resolve map file for ticker { ticker } \" ) ; <nl> + Log . Trace ( $ \" PsychSignalDataConverter . Convert ( ) : Skipping line { currentLineCount } - Line contains header information \" ) ; <nl> + continue ; <nl> + } <nl> + if ( ! DateTime . TryParseExact ( csv [ 2 ] , @ \" yyyy - MM - dd \\ THH : mm : ss \\ Z \" , CultureInfo . InvariantCulture , DateTimeStyles . AdjustToUniversal , out timestamp ) ) <nl> + { <nl> + Log . Trace ( $ \" PsychSignalDataConverter . Convert ( ) : Skipping line { currentLineCount } - Failed to parse date properly \" ) ; <nl> + continue ; <nl> + } <nl> + if ( ! _mapFileResolver . ResolveMapFile ( ticker , timestamp ) . Any ( ) ) <nl> + { <nl> + / / Because all tickers are all clustered together , we can detect <nl> + / / duplicate messages and prevent ourselves from spamming the status log <nl> + if ( ticker ! = previousTicker ) <nl> + { <nl> + Log . Trace ( $ \" PsychSignalDataDownloader . Convert ( ) : Skipping line { currentLineCount } - Could not resolve map file for ticker { ticker } \" ) ; <nl> + } <nl> + previousTicker = ticker ; <nl> + continue ; <nl> } <nl> - previousTicker = ticker ; <nl> - continue ; <nl> - } <nl> - <nl> - TickerData handle ; <nl> - if ( ! _fileHandles . TryGetValue ( ticker , out handle ) ) <nl> - { <nl> - handle = new TickerData ( ticker , timestamp . Date , _destinationDirectory ) ; <nl> - _fileHandles [ ticker ] = handle ; <nl> - } <nl> <nl> - handle . Append ( timestamp , csv ) ; <nl> + TickerData handle ; <nl> + if ( ! _fileHandles . TryGetValue ( ticker , out handle ) ) <nl> + { <nl> + handle = new TickerData ( ticker , timestamp . Date , _destinationDirectory ) ; <nl> + _fileHandles [ ticker ] = handle ; <nl> + } <nl> <nl> - var progress = ( double ) currentLineCount / totalLinesCount ; <nl> - if ( progress > = currentTarget ) <nl> - { <nl> - Log . Trace ( $ \" PsychSignalDataConverter . Convert ( ) : Conversion { progress * 100 } % complete \" ) ; <nl> - currentTarget + = percentIncrement ; <nl> + handle . Append ( timestamp , csv ) ; <nl> + previousTicker = ticker ; <nl> } <nl> <nl> - previousTicker = ticker ; <nl> + Log . Trace ( $ \" PsychSignalDataConverter . Convert ( ) : Finished converting { sourceFilePath . FullName } \" ) ; <nl> } <nl> - <nl> - Log . Trace ( $ \" PsychSignalDataConverter . Convert ( ) : Finished converting { sourceFilePath . FullName } \" ) ; <nl> - <nl> - File . Delete ( tempRawFile ) ; <nl> - Log . Trace ( \" PsychSignalDataConverter . Convert ( ) : Deleted temp raw data file \" ) ; <nl> } <nl> <nl> / / / < summary > <nl> public void ConvertFrom ( DateTime startDateUtc , DateTime endDateUtc ) <nl> return fileDate > = startDateUtc & & fileDate < endDateUtc ; <nl> } <nl> ) <nl> - . OrderBy ( x = > DateTime . ParseExact ( x . Name . Substring ( 0 , 11 ) , \" yyyyMMdd_HH \" , CultureInfo . InvariantCulture , DateTimeStyles . AdjustToUniversal ) ) ; <nl> + . OrderBy ( x = > DateTime . ParseExact ( x . Name . Substring ( 0 , 11 ) , \" yyyyMMdd_HH \" , CultureInfo . InvariantCulture , DateTimeStyles . AdjustToUniversal ) ) <nl> + . ToList ( ) ; <nl> + <nl> + var fileCount = files . Count ( ) ; <nl> + var i = 0 ; <nl> <nl> foreach ( var rawFile in files ) <nl> { <nl> + i + + ; <nl> + Log . Trace ( $ \" PsychSignalDataConverter . ConvertFrom ( ) : Reading file { rawFile . Name } ( file { i } / { fileCount } ) \" ) ; <nl> Convert ( rawFile ) ; <nl> } <nl> <nl>\n", "msg": "Use Stream and StreamReader to read file instead of copying locally\n"}
{"diff_id": 30289, "repo": "duplicati/duplicati\n", "sha": "5ea0322fd1e2b535e2101ca7e953e8f6d43d7001\n", "time": "2013-04-01T11:05:12Z\n", "diff": "mmm a / Duplicati / CommandLine / Program . cs <nl> ppp b / Duplicati / CommandLine / Program . cs <nl> static int Main ( string [ ] args ) <nl> return 200 ; <nl> } <nl> <nl> + if ( options . ContainsKey ( \" fh - dbpath \" ) ) <nl> + { <nl> + PrintNotSupportedWithFhdb ( \" list - source - folders \" ) ; <nl> + return 200 ; <nl> + } <nl> + <nl> Console . WriteLine ( string . Join ( Environment . NewLine , Duplicati . Library . Main . Interface . ListSourceFolders ( target , options ) ? ? new string [ 0 ] ) ) ; <nl> } <nl> else if ( source . Trim ( ) . ToLower ( ) = = \" list - actual - signature - files \" ) <nl> static int Main ( string [ ] args ) <nl> return 200 ; <nl> } <nl> <nl> + if ( options . ContainsKey ( \" fh - dbpath \" ) ) <nl> + { <nl> + PrintNotSupportedWithFhdb ( \" list - actual - signature - files \" ) ; <nl> + return 200 ; <nl> + } <nl> + <nl> List < KeyValuePair < Duplicati . Library . Main . RSync . RSyncDir . PatchFileType , string > > files = Duplicati . Library . Main . Interface . ListActualSignatureFiles ( cargs [ 0 ] , options ) ; <nl> <nl> Console . WriteLine ( \" * \" + Strings . Program . DeletedFoldersHeader + \" : \" ) ; <nl> static int Main ( string [ ] args ) <nl> PrintWrongNumberOfArguments ( cargs , 1 ) ; <nl> return 200 ; <nl> } <nl> + <nl> + if ( options . ContainsKey ( \" fh - dbpath \" ) ) <nl> + { <nl> + PrintNotSupportedWithFhdb ( \" collection - status \" ) ; <nl> + return 200 ; <nl> + } <nl> <nl> List < Duplicati . Library . Main . ManifestEntry > entries = Duplicati . Library . Main . Interface . ParseFileList ( cargs [ 0 ] , options ) ; <nl> <nl> private static void PrintRequiresFhDb ( string command ) <nl> Console . WriteLine ( string . Format ( \" The command \\ \" { 0 } \\ \" requires that the option - - { 1 } is set \" , command , \" fh - dbpath \" ) ) ; <nl> } <nl> <nl> + private static void PrintNotSupportedWithFhdb ( string command ) <nl> + { <nl> + Console . WriteLine ( string . Format ( \" The command \\ \" { 0 } \\ \" is not supported when the option - - { 1 } is set \" , command , \" fh - dbpath \" ) ) ; <nl> + } <nl> + <nl> public static IList < Library . Interface . ICommandLineArgument > SupportedCommands <nl> { <nl> get <nl>\n", "msg": "Added guards to prevent calling unsupported methods from CLI\n"}
{"diff_id": 30471, "repo": "migueldeicaza/gui.cs\n", "sha": "6f7285cfd4e266851d31b76dbf7c68a5493d971f\n", "time": "2020-06-08T09:05:12Z\n", "diff": "mmm a / Terminal . Gui / Views / ComboBox . cs <nl> ppp b / Terminal . Gui / Views / ComboBox . cs <nl> <nl> / / <nl> <nl> using System ; <nl> - using System . Linq ; <nl> + using System . Collections ; <nl> using System . Collections . Generic ; <nl> + using System . Diagnostics ; <nl> + using System . Linq ; <nl> using NStack ; <nl> - using System . Collections ; <nl> <nl> namespace Terminal . Gui { <nl> / / / < summary > <nl> namespace Terminal . Gui { <nl> / / / < / summary > <nl> public class ComboBox : View { <nl> <nl> + <nl> IListDataSource source ; <nl> / / / < summary > <nl> / / / Gets or sets the < see cref = \" IListDataSource \" / > backing this < see cref = \" ComboBox \" / > , enabling custom rendering . <nl> public void SetSource ( IList source ) <nl> / / / Client code can hook up to this event , it is <nl> / / / raised when the selection has been confirmed . <nl> / / / < / remarks > <nl> - public event EventHandler < ustring > Changed ; <nl> + public event EventHandler < ustring > SelectedItemChanged ; <nl> <nl> - / / IList < string > listsource ; <nl> IList searchset ; <nl> ustring text = \" \" ; <nl> TextField search ; <nl> private void Initialize ( ) <nl> { <nl> search . TextChanged + = Search_Changed ; <nl> <nl> + / / On resize <nl> LayoutComplete + = ( LayoutEventArgs a ) = > { <nl> <nl> - search . Width = Frame . Width ; <nl> - listview . Width = Frame . Width - 1 ; <nl> + search . Width = Bounds . Width ; <nl> + listview . Width = Bounds . Width - 1 ; <nl> } ; <nl> <nl> listview . SelectedItemChanged + = ( ListViewItemEventArgs e ) = > { <nl> private void Initialize ( ) <nl> SetValue ( ( string ) searchset [ listview . SelectedItem ] ) ; <nl> } ; <nl> <nl> - / / TODO : LayoutComplete event breaks cursor up / down . Revert to Application . Loaded <nl> Application . Loaded + = ( Application . ResizedEventArgs a ) = > { <nl> / / Determine if this view is hosted inside a dialog <nl> for ( View view = this . SuperView ; view ! = null ; view = view . SuperView ) { <nl> private void Search_MouseClick ( MouseEventArgs e ) <nl> if ( e . MouseEvent . Flags ! = MouseFlags . Button1Clicked ) <nl> return ; <nl> <nl> - SuperView . SetFocus ( ( View ) search ) ; <nl> + SuperView . SetFocus ( search ) ; <nl> } <nl> <nl> / / / < inheritdoc / > <nl> public override bool OnEnter ( ) <nl> return true ; <nl> } <nl> <nl> + / / / < summary > <nl> + / / / Invokes the SelectedChanged event if it is defined . <nl> + / / / < / summary > <nl> + / / / < returns > < / returns > <nl> + public virtual bool OnSelectedChanged ( ) <nl> + { <nl> + / / Note : Cannot rely on \" listview . SelectedItem ! = lastSelectedItem \" because the list is dynamic . <nl> + / / So we cannot optimize . Ie : Don ' t call if not changed <nl> + SelectedItemChanged ? . Invoke ( this , search . Text ) ; <nl> + <nl> + return true ; <nl> + } <nl> + <nl> / / / < inheritdoc / > <nl> public override bool ProcessKey ( KeyEvent e ) <nl> { <nl> public override bool ProcessKey ( KeyEvent e ) <nl> SetValue ( ( string ) searchset [ listview . SelectedItem ] ) ; <nl> search . CursorPosition = search . Text . Length ; <nl> Search_Changed ( search . Text ) ; <nl> - Changed ? . Invoke ( this , text ) ; <nl> + OnSelectedChanged ( ) ; <nl> <nl> searchset . Clear ( ) ; <nl> listview . Clear ( ) ; <nl> public override bool ProcessKey ( KeyEvent e ) <nl> if ( e . Key = = Key . Esc ) { <nl> this . SetFocus ( search ) ; <nl> search . Text = text = \" \" ; <nl> - Changed ? . Invoke ( this , search . Text ) ; <nl> + OnSelectedChanged ( ) ; <nl> return true ; <nl> } <nl> <nl> private void SetValue ( ustring text ) <nl> private void Reset ( ) <nl> { <nl> search . Text = text = \" \" ; <nl> - Changed ? . Invoke ( this , search . Text ) ; <nl> + OnSelectedChanged ( ) ; <nl> <nl> ResetSearchSet ( ) ; <nl> <nl>\n", "msg": "ComboBox supports Dim . Fill ( ) Dim . Percent ( )\n"}
{"diff_id": 31190, "repo": "cefsharp/CefSharp\n", "sha": "6a437710b6e4f616d1dc0ad8fc09bed1aec40c02\n", "time": "2017-03-05T22:55:07Z\n", "diff": "mmm a / CefSharp . WinForms . Example / BrowserTabUserControl . cs <nl> ppp b / CefSharp . WinForms . Example / BrowserTabUserControl . cs <nl> private void OnBrowserLoadingStateChanged ( object sender , LoadingStateChangedEven <nl> SetCanGoBack ( args . CanGoBack ) ; <nl> SetCanGoForward ( args . CanGoForward ) ; <nl> <nl> - this . InvokeOnUiThreadIfRequired ( ( ) = > SetIsLoading ( ! args . CanReload ) ) ; <nl> + this . InvokeOnUiThreadIfRequired ( ( ) = > SetIsLoading ( args . IsLoading ) ) ; <nl> } <nl> <nl> private void OnBrowserTitleChanged ( object sender , TitleChangedEventArgs args ) <nl>\n", "msg": "WinForms example use args . IsLoading rather than ! args . CanReload\n"}
{"diff_id": 31754, "repo": "OpenRA/OpenRA\n", "sha": "b728deb0e104b7a227ec896f1b380462fdfb7f0a\n", "time": "2014-12-20T23:36:28Z\n", "diff": "mmm a / OpenRA . Game / Map / CellRegion . cs <nl> ppp b / OpenRA . Game / Map / CellRegion . cs <nl> public bool Contains ( CPos cell ) <nl> return uv . X > = mapTopLeft . X & & uv . X < = mapBottomRight . X & & uv . Y > = mapTopLeft . Y & & uv . Y < = mapBottomRight . Y ; <nl> } <nl> <nl> + public MapCoordsRegion MapCoords <nl> + { <nl> + get { return new MapCoordsRegion ( this ) ; } <nl> + } <nl> + <nl> public CellRegionEnumerator GetEnumerator ( ) <nl> { <nl> return new CellRegionEnumerator ( this ) ; <nl> IEnumerator IEnumerable . GetEnumerator ( ) <nl> return GetEnumerator ( ) ; <nl> } <nl> <nl> - public class CellRegionEnumerator : IEnumerator < CPos > <nl> + public sealed class CellRegionEnumerator : IEnumerator < CPos > <nl> { <nl> readonly CellRegion r ; <nl> <nl> public void Reset ( ) <nl> object IEnumerator . Current { get { return Current ; } } <nl> public void Dispose ( ) { } <nl> } <nl> + <nl> + public struct MapCoordsRegion : IEnumerable < CPos > <nl> + { <nl> + public struct MapCoordsEnumerator : IEnumerator < CPos > <nl> + { <nl> + readonly CellRegion r ; <nl> + CPos current ; <nl> + <nl> + public MapCoordsEnumerator ( CellRegion region ) <nl> + : this ( ) <nl> + { <nl> + r = region ; <nl> + Reset ( ) ; <nl> + } <nl> + <nl> + public bool MoveNext ( ) <nl> + { <nl> + var u = current . X + 1 ; <nl> + var v = current . Y ; <nl> + <nl> + / / Check for column overflow <nl> + if ( u > r . mapBottomRight . X ) <nl> + { <nl> + v + = 1 ; <nl> + u = r . mapTopLeft . X ; <nl> + <nl> + / / Check for row overflow <nl> + if ( v > r . mapBottomRight . Y ) <nl> + return false ; <nl> + } <nl> + <nl> + current = new CPos ( u , v ) ; <nl> + return true ; <nl> + } <nl> + <nl> + public void Reset ( ) <nl> + { <nl> + current = new CPos ( r . mapTopLeft . X - 1 , r . mapTopLeft . Y ) ; <nl> + } <nl> + <nl> + public CPos Current { get { return current ; } } <nl> + object IEnumerator . Current { get { return Current ; } } <nl> + public void Dispose ( ) { } <nl> + } <nl> + <nl> + readonly CellRegion r ; <nl> + <nl> + public MapCoordsRegion ( CellRegion region ) <nl> + { <nl> + r = region ; <nl> + } <nl> + <nl> + public MapCoordsEnumerator GetEnumerator ( ) <nl> + { <nl> + return new MapCoordsEnumerator ( r ) ; <nl> + } <nl> + <nl> + IEnumerator < CPos > IEnumerable < CPos > . GetEnumerator ( ) <nl> + { <nl> + return GetEnumerator ( ) ; <nl> + } <nl> + <nl> + IEnumerator IEnumerable . GetEnumerator ( ) <nl> + { <nl> + return GetEnumerator ( ) ; <nl> + } <nl> + } <nl> } <nl> } <nl>\n", "msg": "Added the ability to enumerate the map - coords of a CellRegion for performance .\n"}
{"diff_id": 31757, "repo": "JustArchiNET/ArchiSteamFarm\n", "sha": "178eac5db71f1086f6959713be09ef88b53abf95\n", "time": "2017-02-16T14:39:43Z\n", "diff": "mmm a / ArchiSteamFarm / Trading . cs <nl> ppp b / ArchiSteamFarm / Trading . cs <nl> internal sealed class Trading : IDisposable { <nl> <nl> / / Check if it ' s donation trade <nl> if ( tradeOffer . ItemsToGive . Count = = 0 ) { <nl> - ParseTradeResult . EResult donationResult ; <nl> - <nl> / / If it ' s steam fuckup , temporarily ignore it , otherwise react accordingly , depending on our preference <nl> if ( tradeOffer . ItemsToReceive . Count = = 0 ) { <nl> - donationResult = ParseTradeResult . EResult . RejectedTemporarily ; <nl> - } else if ( Bot . BotConfig . TradingPreferences . HasFlag ( BotConfig . ETradingPreferences . AcceptDonations ) | | ( ! Bot . BotConfig . TradingPreferences . HasFlag ( BotConfig . ETradingPreferences . DontAcceptBotTrades ) & & ( tradeOffer . OtherSteamID64 ! = 0 ) & & Bot . Bots . Values . Any ( bot = > bot . SteamID = = tradeOffer . OtherSteamID64 ) ) ) { <nl> - donationResult = ParseTradeResult . EResult . AcceptedWithoutItemLose ; <nl> - } else { <nl> - donationResult = ParseTradeResult . EResult . RejectedPermanently ; <nl> + return new ParseTradeResult ( tradeOffer . TradeOfferID , ParseTradeResult . EResult . RejectedTemporarily ) ; <nl> + } <nl> + <nl> + bool acceptDonations = Bot . BotConfig . TradingPreferences . HasFlag ( BotConfig . ETradingPreferences . AcceptDonations ) ; <nl> + bool acceptBotTrades = ! Bot . BotConfig . TradingPreferences . HasFlag ( BotConfig . ETradingPreferences . DontAcceptBotTrades ) ; <nl> + <nl> + / / If we accept donations and bot trades , accept it right away <nl> + if ( acceptDonations & & acceptBotTrades ) { <nl> + return new ParseTradeResult ( tradeOffer . TradeOfferID , ParseTradeResult . EResult . AcceptedWithItemLose ) ; <nl> + } <nl> + <nl> + / / If we don ' t accept donations , neither bot trades , deny it right away <nl> + if ( ! acceptDonations & & ! acceptBotTrades ) { <nl> + return new ParseTradeResult ( tradeOffer . TradeOfferID , ParseTradeResult . EResult . RejectedPermanently ) ; <nl> } <nl> <nl> - return new ParseTradeResult ( tradeOffer . TradeOfferID , donationResult ) ; <nl> + / / Otherwise we either accept donations but not bot trades , or we accept bot trades but not donations <nl> + bool isBotTrade = ( tradeOffer . OtherSteamID64 ! = 0 ) & & Bot . Bots . Values . Any ( bot = > bot . SteamID = = tradeOffer . OtherSteamID64 ) ; <nl> + return new ParseTradeResult ( tradeOffer . TradeOfferID , ( acceptDonations & & ! isBotTrade ) | | ( acceptBotTrades & & isBotTrade ) ? ParseTradeResult . EResult . AcceptedWithoutItemLose : ParseTradeResult . EResult . RejectedPermanently ) ; <nl> } <nl> <nl> / / If we don ' t have SteamTradeMatcher enabled , this is the end for us <nl>\n", "msg": "Make it possible to use AcceptDonations together with DontAcceptBotTrades\n"}
{"diff_id": 31812, "repo": "dotnet/runtime\n", "sha": "10a4d23f5fb727f041b29b6c03e8f79da60d7dd1\n", "time": "2018-03-06T07:17:13Z\n", "diff": "mmm a / src / libraries / System . Memory / tests / Performance / Perf . Span . Clear . cs <nl> ppp b / src / libraries / System . Memory / tests / Performance / Perf . Span . Clear . cs <nl> public void Int ( int size ) <nl> } <nl> } <nl> } <nl> + <nl> + [ Benchmark ] <nl> + [ InlineData ( 0 ) ] <nl> + [ InlineData ( 1 ) ] <nl> + [ InlineData ( 2 ) ] <nl> + [ InlineData ( 3 ) ] <nl> + [ InlineData ( 4 ) ] <nl> + [ InlineData ( 5 ) ] <nl> + [ InlineData ( 6 ) ] <nl> + [ InlineData ( 7 ) ] <nl> + [ InlineData ( 8 ) ] <nl> + [ InlineData ( 9 ) ] <nl> + [ InlineData ( 10 ) ] <nl> + [ InlineData ( 11 ) ] <nl> + [ InlineData ( 12 ) ] <nl> + [ InlineData ( 13 ) ] <nl> + [ InlineData ( 14 ) ] <nl> + [ InlineData ( 15 ) ] <nl> + [ InlineData ( 16 ) ] <nl> + [ InlineData ( 32 ) ] <nl> + [ InlineData ( 64 ) ] <nl> + [ InlineData ( 100 ) ] <nl> + [ InlineData ( 1000 ) ] <nl> + [ InlineData ( 10000 ) ] <nl> + [ InlineData ( 100000 ) ] <nl> + public void References ( int size ) <nl> + { <nl> + var a = new object [ size ] ; <nl> + var span = new Span < object > ( a ) ; <nl> + foreach ( BenchmarkIteration iteration in Benchmark . Iterations ) <nl> + { <nl> + using ( iteration . StartMeasurement ( ) ) <nl> + { <nl> + for ( int i = 0 ; i < 10000 ; i + + ) <nl> + { <nl> + span . Clear ( ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> } <nl> } <nl>\n", "msg": "Improve performance of Span . Clear for referential T\n"}
{"diff_id": 31953, "repo": "NLog/NLog\n", "sha": "0efbf0ef9f4dcd1284afcb593d251db20ba6c096\n", "time": "2018-04-07T16:40:26Z\n", "diff": "mmm a / src / NLog / Config / ConfigurationItemFactory . cs <nl> ppp b / src / NLog / Config / ConfigurationItemFactory . cs <nl> private static string [ ] GetNLogExtensionFiles ( string assemblyLocation ) <nl> . Select ( x = > Path . Combine ( assemblyLocation , x ) ) ; <nl> return extensionDlls . ToArray ( ) ; <nl> } <nl> + catch ( System . IO . DirectoryNotFoundException ex ) <nl> + { <nl> + InternalLogger . Warn ( ex , \" Skipping auto loading location because assembly directory does not exist : { 0 } \" , assemblyLocation ) ; <nl> + if ( ex . MustBeRethrown ( ) ) <nl> + { <nl> + throw ; <nl> + } <nl> + return ArrayHelper . Empty < string > ( ) ; <nl> + } <nl> catch ( System . Security . SecurityException ex ) <nl> { <nl> - InternalLogger . Warn ( ex , \" Seems that we do not have permission \" ) ; <nl> + InternalLogger . Warn ( ex , \" Skipping auto loading location because access not allowed to assembly directory : { 0 } \" , assemblyLocation ) ; <nl> if ( ex . MustBeRethrown ( ) ) <nl> { <nl> throw ; <nl> private static string [ ] GetNLogExtensionFiles ( string assemblyLocation ) <nl> } <nl> catch ( UnauthorizedAccessException ex ) <nl> { <nl> - InternalLogger . Warn ( ex , \" Seems that we do not have permission \" ) ; <nl> + InternalLogger . Warn ( ex , \" Skipping auto loading location because access not allowed to assembly directory : { 0 } \" , assemblyLocation ) ; <nl> if ( ex . MustBeRethrown ( ) ) <nl> { <nl> throw ; <nl>\n", "msg": "GetNLogExtensionFiles should handle DirectoryNotFoundException when invalid AppDomain . BaseDirectory\n"}
{"diff_id": 32020, "repo": "duplicati/duplicati\n", "sha": "610fa4ffeae90640c50f6dd801810b433add9fee\n", "time": "2019-12-15T21:28:44Z\n", "diff": "mmm a / Duplicati / Library / Main / Database / LocalDeleteDatabase . cs <nl> ppp b / Duplicati / Library / Main / Database / LocalDeleteDatabase . cs <nl> internal IEnumerable < IListResultFileset > FilesetsWithBackupVersion <nl> List < IListResultFileset > filesets = new List < IListResultFileset > ( ) ; <nl> using ( IDbCommand cmd = this . m_connection . CreateCommand ( ) ) <nl> { <nl> - using ( IDataReader reader = cmd . ExecuteReader ( @ \" SELECT ROW_NUMBER ( ) OVER ( ORDER BY \" \" Timestamp \" \" DESC ) Version , \" \" IsFullBackup \" \" , \" \" Timestamp \" \" FROM \" \" Fileset \" \" \" ) ) <nl> + / / We can also use the ROW_NUMBER ( ) window function to generate the backup versions , <nl> + / / but this requires at least SQLite 3 . 25 , which is not available in some common <nl> + / / distributions ( e . g . , Debian ) currently . <nl> + using ( IDataReader reader = cmd . ExecuteReader ( @ \" SELECT \" \" IsFullBackup \" \" , \" \" Timestamp \" \" FROM \" \" Fileset \" \" ORDER BY \" \" Timestamp \" \" DESC \" ) ) <nl> { <nl> + int version = 0 ; <nl> while ( reader . Read ( ) ) <nl> { <nl> - / / Since ROW_NUMBER ( ) starts from 1 , we subtract 1 to get the backup version number . <nl> - filesets . Add ( new ListResultFileset ( reader . GetInt64 ( 0 ) - 1 , reader . GetInt32 ( 1 ) , ParseFromEpochSeconds ( reader . GetInt64 ( 2 ) ) . ToLocalTime ( ) , - 1L , - 1L ) ) ; <nl> + filesets . Add ( new ListResultFileset ( version + + , reader . GetInt32 ( 0 ) , ParseFromEpochSeconds ( reader . GetInt64 ( 1 ) ) . ToLocalTime ( ) , - 1L , - 1L ) ) ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Generate backup version numbers manually instead of in query .\n"}
{"diff_id": 32090, "repo": "jellyfin/jellyfin\n", "sha": "b451eb0bdc1594c88af11ae807fb7f3b3c4ef124\n", "time": "2020-06-16T22:45:17Z\n", "diff": "mmm a / Emby . Server . Implementations / HttpServer / Security / AuthorizationContext . cs <nl> ppp b / Emby . Server . Implementations / HttpServer / Security / AuthorizationContext . cs <nl> private AuthorizationInfo GetAuthorization ( IRequest httpReq ) <nl> token = queryString [ \" ApiKey \" ] ; <nl> } <nl> <nl> - / / TODO depricate this query parameter . <nl> + / / TODO deprecate this query parameter . <nl> if ( string . IsNullOrEmpty ( token ) ) <nl> { <nl> token = queryString [ \" api_key \" ] ; <nl>\n", "msg": "Update Emby . Server . Implementations / HttpServer / Security / AuthorizationContext . cs\n"}
{"diff_id": 32099, "repo": "mono/mono\n", "sha": "ba2ba889f65939735c474a5afaf5fdcc722e2309\n", "time": "2012-05-25T09:59:38Z\n", "diff": "mmm a / mcs / class / corlib / System . Reflection / Binder . cs <nl> ppp b / mcs / class / corlib / System . Reflection / Binder . cs <nl> public override MethodBase BindToMethod ( BindingFlags bindingAttr , MethodBase [ ] <nl> if ( i < names . Length ) <nl> continue ; <nl> <nl> - selected = SelectMethod ( bindingAttr , new MethodBase [ ] { m } , newTypes , newModifiers , true ) ; <nl> + selected = SelectMethod ( bindingAttr , new MethodBase [ ] { m } , newTypes , newModifiers , true , args ) ; <nl> if ( selected ! = null ) <nl> break ; <nl> } <nl> } else { <nl> - selected = SelectMethod ( bindingAttr , match , types , modifiers , true ) ; <nl> + selected = SelectMethod ( bindingAttr , match , types , modifiers , true , args ) ; <nl> } <nl> <nl> state = null ; <nl> public override void ReorderArgumentArray ( ref object [ ] args , object state ) <nl> public override MethodBase SelectMethod ( BindingFlags bindingAttr , MethodBase [ ] match , Type [ ] types , ParameterModifier [ ] modifiers ) <nl> { <nl> return SelectMethod ( bindingAttr , match , types , modifiers , <nl> - false ) ; <nl> + false , null ) ; <nl> } <nl> <nl> - MethodBase SelectMethod ( BindingFlags bindingAttr , MethodBase [ ] match , Type [ ] types , ParameterModifier [ ] modifiers , bool allowByRefMatch ) <nl> + MethodBase SelectMethod ( BindingFlags bindingAttr , MethodBase [ ] match , Type [ ] types , ParameterModifier [ ] modifiers , bool allowByRefMatch , object [ ] parameters ) <nl> { <nl> MethodBase m ; <nl> int i , j ; <nl> MethodBase SelectMethod ( BindingFlags bindingAttr , MethodBase [ ] match , Type [ ] ty <nl> result = m ; <nl> } <nl> <nl> - return result ; <nl> + if ( result ! = null | | parameters = = null ) <nl> + return result ; <nl> + <nl> + / / Xamarin - 5278 : try with parameters that are COM objects <nl> + for ( i = 0 ; i < match . Length ; + + i ) { <nl> + m = match [ i ] ; <nl> + ParameterInfo [ ] args = m . GetParameters ( ) ; <nl> + if ( args . Length ! = types . Length | | args . Length ! = parameters . Length ) <nl> + continue ; <nl> + for ( j = 0 ; j < types . Length ; + + j ) { <nl> + var requiredType = args [ j ] . ParameterType ; <nl> + if ( types [ j ] = = requiredType ) <nl> + continue ; <nl> + if ( types [ j ] = = typeof ( __ComObject ) & & requiredType . IsInterface ) { <nl> + var iface = Marshal . GetComInterfaceForObject ( parameters [ j ] , requiredType ) ; <nl> + if ( iface ! = IntPtr . Zero ) { <nl> + / / the COM object implements the desired interface <nl> + Marshal . Release ( iface ) ; <nl> + continue ; <nl> + } <nl> + } <nl> + break ; <nl> + } <nl> + <nl> + if ( j = = types . Length ) <nl> + return m ; <nl> + } <nl> + return null ; <nl> } <nl> <nl> MethodBase GetBetterMethod ( MethodBase m1 , MethodBase m2 , Type [ ] types ) <nl>\n", "msg": "Xamarin - 5278 : Fix Binder . SelectMethod when passed argument is COM object\n"}
{"diff_id": 32148, "repo": "Sonarr/Sonarr\n", "sha": "be4d70e3a9362baa14871c3eacb0371492a129f0\n", "time": "2017-02-28T08:12:34Z\n", "diff": "mmm a / src / NzbDrone . Core / HealthCheck / Checks / ImportMechanismCheck . cs <nl> ppp b / src / NzbDrone . Core / HealthCheck / Checks / ImportMechanismCheck . cs <nl> <nl> -  using System . Linq ; <nl> +  using System ; <nl> + using System . Collections . Generic ; <nl> + using System . Linq ; <nl> using NzbDrone . Common . Disk ; <nl> using NzbDrone . Core . Configuration ; <nl> using NzbDrone . Core . Download ; <nl> + using NzbDrone . Core . Download . Clients ; <nl> using NzbDrone . Core . Download . Clients . Nzbget ; <nl> using NzbDrone . Core . Download . Clients . Sabnzbd ; <nl> <nl> public ImportMechanismCheck ( IConfigService configService , IProvideDownloadClient <nl> public override HealthCheck Check ( ) <nl> { <nl> var droneFactoryFolder = new OsPath ( _configService . DownloadedEpisodesFolder ) ; <nl> - var downloadClients = _provideDownloadClient . GetDownloadClients ( ) . Select ( v = > new { downloadClient = v , status = v . GetStatus ( ) } ) . ToList ( ) ; <nl> + List < ImportMechanismCheckStatus > downloadClients ; <nl> <nl> - var downloadClientIsLocalHost = downloadClients . All ( v = > v . status . IsLocalhost ) ; <nl> - var downloadClientOutputInDroneFactory = ! droneFactoryFolder . IsEmpty <nl> - & & downloadClients . Any ( v = > v . status . OutputRootFolders ! = null & & v . status . OutputRootFolders . Any ( droneFactoryFolder . Contains ) ) ; <nl> + try <nl> + { <nl> + downloadClients = _provideDownloadClient . GetDownloadClients ( ) . Select ( v = > new ImportMechanismCheckStatus <nl> + { <nl> + DownloadClient = v , <nl> + Status = v . GetStatus ( ) <nl> + } ) . ToList ( ) ; <nl> + } <nl> + catch ( DownloadClientException ) <nl> + { <nl> + / / One or more download clients failed , assume the health is okay and verify later <nl> + return new HealthCheck ( GetType ( ) ) ; <nl> + } <nl> + <nl> + var downloadClientIsLocalHost = downloadClients . All ( v = > v . Status . IsLocalhost ) ; <nl> + var downloadClientOutputInDroneFactory = ! droneFactoryFolder . IsEmpty & & <nl> + downloadClients . Any ( v = > v . Status . OutputRootFolders ! = null & & <nl> + v . Status . OutputRootFolders . Any ( droneFactoryFolder . Contains ) ) ; <nl> <nl> if ( ! _configService . IsDefined ( \" EnableCompletedDownloadHandling \" ) ) <nl> { <nl> public override HealthCheck Check ( ) <nl> return new HealthCheck ( GetType ( ) , HealthCheckResult . Warning , \" Enable Completed Download Handling if possible ( Multi - Computer unsupported ) \" , \" Migrating - to - Completed - Download - Handling # Unsupported - download - client - on - different - computer \" ) ; <nl> } <nl> <nl> - if ( downloadClients . All ( v = > v . downloadClient is Sabnzbd ) ) <nl> + if ( downloadClients . All ( v = > v . DownloadClient is Sabnzbd ) ) <nl> { <nl> / / With Sabnzbd we can check if the category should be changed . <nl> if ( downloadClientOutputInDroneFactory ) <nl> public override HealthCheck Check ( ) <nl> <nl> return new HealthCheck ( GetType ( ) , HealthCheckResult . Warning , \" Enable Completed Download Handling if possible ( Sabnzbd ) \" , \" Migrating - to - Completed - Download - Handling # sabnzbd - enable - completed - download - handling \" ) ; <nl> } <nl> - if ( downloadClients . All ( v = > v . downloadClient is Nzbget ) ) <nl> + <nl> + if ( downloadClients . All ( v = > v . DownloadClient is Nzbget ) ) <nl> { <nl> / / With Nzbget we can check if the category should be changed . <nl> if ( downloadClientOutputInDroneFactory ) <nl> public override HealthCheck Check ( ) <nl> <nl> return new HealthCheck ( GetType ( ) , HealthCheckResult . Warning , \" Enable Completed Download Handling if possible ( Nzbget ) \" , \" Migrating - to - Completed - Download - Handling # nzbget - enable - completed - download - handling \" ) ; <nl> } <nl> + <nl> return new HealthCheck ( GetType ( ) , HealthCheckResult . Warning , \" Enable Completed Download Handling if possible \" , \" Migrating - to - Completed - Download - Handling \" ) ; <nl> } <nl> <nl> public override HealthCheck Check ( ) <nl> return new HealthCheck ( GetType ( ) , HealthCheckResult . Warning , \" Enable Completed Download Handling or configure Drone factory \" ) ; <nl> } <nl> <nl> - <nl> return new HealthCheck ( GetType ( ) ) ; <nl> } <nl> } <nl> + <nl> + public class ImportMechanismCheckStatus <nl> + { <nl> + public IDownloadClient DownloadClient { get ; set ; } <nl> + public DownloadClientStatus Status { get ; set ; } <nl> + } <nl> } <nl>\n", "msg": "Fixed : Health check failing and preventing others from running\n"}
{"diff_id": 32313, "repo": "icsharpcode/ILSpy\n", "sha": "3806610d0ad0a147c4dc94a7d32bdc8edb6bbdfd\n", "time": "2019-03-27T20:50:54Z\n", "diff": "mmm a / ICSharpCode . Decompiler / DecompilerSettings . cs <nl> ppp b / ICSharpCode . Decompiler / DecompilerSettings . cs <nl> public DecompilerSettings ( CSharp . LanguageVersion languageVersion ) <nl> <nl> public CSharp . LanguageVersion GetMinimumRequiredVersion ( ) <nl> { <nl> + if ( nullableReferenceTypes ) <nl> + return CSharp . LanguageVersion . CSharp8_0 ; <nl> if ( introduceUnmanagedConstraint | | tupleComparisons | | stackAllocInitializers ) <nl> return CSharp . LanguageVersion . CSharp7_3 ; <nl> if ( introduceRefModifiersOnStructs | | introduceReadonlyAndInModifiers | | nonTrailingNamedArguments ) <nl>\n", "msg": "GetMinimumRequiredVersion ( ) : Add case for C # 8 . 0\n"}
{"diff_id": 32451, "repo": "OpenRA/OpenRA\n", "sha": "afd620b092d185be85b59438515f73e50e2872ff\n", "time": "2020-05-09T15:40:50Z\n", "diff": "mmm a / OpenRA . Mods . Cnc / Util . cs <nl> ppp b / OpenRA . Mods . Cnc / Util . cs <nl> namespace OpenRA . Mods . Cnc <nl> { <nl> public static class Util <nl> { <nl> - public static int ClassicQuantizeFacing ( int facing , int numFrames , bool useClassicFacingFudge ) <nl> + / / TD and RA used a nonlinear mapping between artwork frames and unit facings for units with 32 facings . <nl> + / / This table defines the exclusive maximum facing for the i ' th sprite frame . <nl> + / / i . e . sprite frame 1 is used for facings 5 - 13 , sprite frame 2 for 14 - 21 , and so on . <nl> + / / Sprite frame 0 is used for facings smaller than 5 or larger than 249 . <nl> + static readonly int [ ] SpriteFacings = <nl> { <nl> - if ( ! useClassicFacingFudge | | numFrames ! = 32 ) <nl> - return OpenRA . Mods . Common . Util . QuantizeFacing ( facing , numFrames ) ; <nl> + 5 , 14 , 22 , 33 , 39 , 46 , 53 , 60 , <nl> + 67 , 74 , 81 , 88 , 96 , 104 , 113 , 122 , <nl> + 133 , 142 , 151 , 161 , 167 , 174 , 181 , 188 , <nl> + 195 , 202 , 209 , 216 , 224 , 232 , 241 , 250 <nl> + } ; <nl> <nl> - / / TD and RA divided the facing artwork into 3 frames from ( north | south ) to ( north | south ) - ( east | west ) <nl> - / / and then 5 frames from ( north | south ) - ( east | west ) to ( east | west ) <nl> - var quadrant = ( ( facing + 31 ) & 0xFF ) / 64 ; <nl> - if ( quadrant = = 0 | | quadrant = = 2 ) <nl> - { <nl> - var frame = OpenRA . Mods . Common . Util . QuantizeFacing ( facing , 24 ) ; <nl> - if ( frame > 18 ) <nl> - return frame + 6 ; <nl> - if ( frame > 4 ) <nl> - return frame + 3 ; <nl> - return frame ; <nl> - } <nl> - else <nl> + public static int ClassicQuantizeFacing ( int facing , int numFrames , bool useClassicFacingFudge ) <nl> + { <nl> + if ( useClassicFacingFudge & & numFrames = = 32 ) <nl> { <nl> - var frame = OpenRA . Mods . Common . Util . QuantizeFacing ( facing , 40 ) ; <nl> - return frame < 20 ? frame - 3 : frame - 8 ; <nl> + for ( var i = 0 ; i < SpriteFacings . Length ; i + + ) <nl> + if ( facing < SpriteFacings [ i ] ) <nl> + return i ; <nl> + <nl> + return 0 ; <nl> } <nl> + <nl> + return Common . Util . QuantizeFacing ( facing , numFrames ) ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Reimplement ClassicQuantizeFacing using a look - up - table .\n"}
{"diff_id": 32724, "repo": "icsharpcode/ILSpy\n", "sha": "024abb3ba6766a139d0d7aae736766c835fe2ad3\n", "time": "2017-11-03T16:08:06Z\n", "diff": "mmm a / ILSpy / SearchStrategies . cs <nl> ppp b / ILSpy / SearchStrategies . cs <nl> protected AbstractSearchStrategy ( params string [ ] terms ) <nl> protected float CalculateFitness ( MemberReference member , string text ) <nl> { <nl> / / Probably compiler generated types without meaningful names , show them last <nl> - if ( text . StartsWith ( \" < \" ) ) <nl> - { <nl> + if ( text . StartsWith ( \" < \" ) ) { <nl> return 0 ; <nl> } <nl> <nl> + / / Constructors always have the same name in IL : <nl> + / / Use type name instead <nl> + if ( text = = \" . . ctor \" | | text = = \" . ctor \" ) { <nl> + text = member . DeclaringType . Name ; <nl> + } <nl> + <nl> / / Ignore generic arguments , it not possible to search based on them either <nl> int length = 0 ; <nl> int generics = 0 ; <nl> - for ( int i = 0 ; i < text . Length ; i + + ) <nl> - { <nl> + for ( int i = 0 ; i < text . Length ; i + + ) { <nl> if ( text [ i ] = = ' < ' ) <nl> generics + + ; <nl> else if ( text [ i ] = = ' > ' ) <nl>\n", "msg": "CalculateFitness : In case of ctors use type name .\n"}
{"diff_id": 33041, "repo": "HangfireIO/Hangfire\n", "sha": "9120620a65bbae6e25270bfc8c463013d44598de\n", "time": "2015-09-30T08:27:54Z\n", "diff": "mmm a / src / Hangfire . Core / Dashboard / EmbeddedResourceDispatcher . cs <nl> ppp b / src / Hangfire . Core / Dashboard / EmbeddedResourceDispatcher . cs <nl> protected void WriteResource ( IOwinResponse response , Assembly assembly , string r <nl> resourceName , assembly ) ) ; <nl> } <nl> <nl> - var buffer = new byte [ Math . Min ( inputStream . Length , 4096 ) ] ; <nl> - var readLength = inputStream . Read ( buffer , 0 , buffer . Length ) ; <nl> - while ( readLength > 0 ) <nl> - { <nl> - response . Write ( buffer , 0 , readLength ) ; <nl> - readLength = inputStream . Read ( buffer , 0 , buffer . Length ) ; <nl> - } <nl> + inputStream . CopyTo ( response . Body ) ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Simplify writing of embedded resource to response body .\n"}
{"diff_id": 33066, "repo": "duplicati/duplicati\n", "sha": "146f4aaa5bbf692a6562cd9625eaeae2982fd22e\n", "time": "2017-09-29T04:48:38Z\n", "diff": "mmm a / Duplicati / Library / Main / Controller . cs <nl> ppp b / Duplicati / Library / Main / Controller . cs <nl> public Duplicati . Library . Interface . IBackupResults Backup ( string [ ] inputsources , <nl> } <nl> <nl> / / Sanity check for duplicate files / folders <nl> - var pathDuplicates = sources . GroupBy ( x = > x , Library . Utility . Utility . ClientFilenameStringComparer ) <nl> - . Where ( g = > g . Count ( ) > 1 ) . Select ( y = > y . Key ) . ToList ( ) ; <nl> + ISet < string > pathDuplicates ; <nl> + sources = Library . Utility . Utility . GetUniqueItems ( sources , Library . Utility . Utility . ClientFilenameStringComparer , out pathDuplicates ) . OrderBy ( a = > a ) . ToList ( ) ; <nl> <nl> foreach ( var pathDuplicate in pathDuplicates ) <nl> result . AddVerboseMessage ( string . Format ( \" Removing duplicate source : { 0 } \" , pathDuplicate ) ) ; <nl> <nl> - sources = sources . Distinct ( Library . Utility . Utility . ClientFilenameStringComparer ) . OrderBy ( a = > a ) . ToList ( ) ; <nl> - <nl> / / Sanity check for multiple inclusions of the same folder <nl> for ( int i = 0 ; i < sources . Count ; i + + ) <nl> for ( int j = 0 ; j < sources . Count ; j + + ) <nl>\n", "msg": "Use helper method to get unique items and duplicates .\n"}
{"diff_id": 33140, "repo": "SignalR/SignalR\n", "sha": "91e4f61b089351525920d08622fbb757cd71ff15\n", "time": "2012-11-17T07:21:15Z\n", "diff": "mmm a / tests / Microsoft . AspNet . SignalR . FunctionalTests / Infrastructure / IIS / SiteManager . cs <nl> ppp b / tests / Microsoft . AspNet . SignalR . FunctionalTests / Infrastructure / IIS / SiteManager . cs <nl> public class SiteManager <nl> { <nl> private readonly string _path ; <nl> private readonly string _appHostConfigPath ; <nl> - private readonly string _iisHomePath ; <nl> private readonly ServerManager _serverManager ; <nl> <nl> private static Process _iisExpressProcess ; <nl> public SiteManager ( string path ) <nl> { <nl> _path = Path . GetFullPath ( path ) ; <nl> _appHostConfigPath = Path . GetFullPath ( Path . Combine ( _path , \" bin \" , \" config \" , \" applicationHost . config \" ) ) ; <nl> - _iisHomePath = Path . GetFullPath ( Path . Combine ( _appHostConfigPath , \" . . \" , \" . . \" ) ) ; <nl> _serverManager = new ServerManager ( _appHostConfigPath ) ; <nl> } <nl> <nl> private Process CreateIISExpressProcess ( ) <nl> } <nl> <nl> var iisExpressProcess = new Process ( ) ; <nl> - iisExpressProcess . StartInfo = new ProcessStartInfo ( IISExpressPath , \" / config : \\ \" \" + _appHostConfigPath + \" \\ \" / site : \" + TestSiteName + \" / systray : false / userhome : \\ \" \" + _iisHomePath + \" \\ \" \" ) ; <nl> - iisExpressProcess . StartInfo . EnvironmentVariables [ \" IIS_USER_HOME \" ] = _iisHomePath ; <nl> + iisExpressProcess . StartInfo = new ProcessStartInfo ( IISExpressPath , \" / config : \\ \" \" + _appHostConfigPath + \" \\ \" / site : \" + TestSiteName + \" / systray : false \" ) ; <nl> iisExpressProcess . StartInfo . CreateNoWindow = true ; <nl> iisExpressProcess . StartInfo . UseShellExecute = false ; <nl> iisExpressProcess . EnableRaisingEvents = true ; <nl>\n", "msg": "Don ' t set the iis home path as it ' s persistent .\n"}
{"diff_id": 33196, "repo": "dotnet/aspnetcore\n", "sha": "c733aa880478ba45029a4686b62d174bade3ab23\n", "time": "2014-07-25T22:43:38Z\n", "diff": "mmm a / src / Microsoft . AspNet . Security / DataHandler / Serializer / TicketSerializer . cs <nl> ppp b / src / Microsoft . AspNet . Security / DataHandler / Serializer / TicketSerializer . cs <nl> namespace Microsoft . AspNet . Security . DataHandler . Serializer <nl> { <nl> public class TicketSerializer : IDataSerializer < AuthenticationTicket > <nl> { <nl> + private static readonly bool IsMono = Type . GetType ( \" Mono . Runtime \" ) ! = null ; <nl> private const int FormatVersion = 2 ; <nl> <nl> [ System . Diagnostics . CodeAnalysis . SuppressMessage ( \" Microsoft . Usage \" , \" CA2202 : Do not dispose objects multiple times \" , Justification = \" Dispose is idempotent \" ) ] <nl> public virtual byte [ ] Serialize ( AuthenticationTicket model ) <nl> { <nl> using ( var memory = new MemoryStream ( ) ) <nl> { <nl> - using ( var compression = new GZipStream ( memory , CompressionLevel . Optimal ) ) <nl> + GZipStream compression ; <nl> + if ( IsMono ) <nl> + { <nl> + / / The other constructor is not currently supported on Mono . <nl> + compression = new GZipStream ( memory , CompressionMode . Compress ) ; <nl> + } <nl> + else <nl> + { <nl> + compression = new GZipStream ( memory , CompressionLevel . Optimal ) ; <nl> + } <nl> + using ( compression ) <nl> { <nl> using ( var writer = new BinaryWriter ( compression ) ) <nl> { <nl>\n", "msg": "- Use a GZipStream constructor that ' s supported on Mono .\n"}
{"diff_id": 33223, "repo": "dotnet/roslyn\n", "sha": "29c9298622359a66c6fd06718b128118efac2b0a\n", "time": "2015-11-12T00:44:53Z\n", "diff": "mmm a / src / Compilers / Extension / CompilerPackage . cs <nl> ppp b / src / Compilers / Extension / CompilerPackage . cs <nl> public sealed class CompilerPackage : Package <nl> <nl> protected override void Initialize ( ) <nl> { <nl> + base . Initialize ( ) ; <nl> + <nl> var packagePath = Path . GetDirectoryName ( Assembly . GetExecutingAssembly ( ) . Location ) ; <nl> <nl> string localRegistryRoot ; <nl> protected override void Initialize ( ) <nl> Microsoft . Build . Evaluation . ProjectCollection . GlobalProjectCollection . DisableMarkDirty = false ; <nl> } <nl> } <nl> - base . Initialize ( ) ; <nl> } <nl> <nl> private void WriteTargetsFile ( string packagePath , string hiveName ) <nl>\n", "msg": "Move call to base . Initialize to the start for safety\n"}
{"diff_id": 33226, "repo": "ServiceStack/ServiceStack\n", "sha": "534a50b808cf717c264fa1ebb8b81c61e274e610\n", "time": "2018-06-04T23:46:56Z\n", "diff": "mmm a / src / ServiceStack / Auth / AuthProvider . cs <nl> ppp b / src / ServiceStack / Auth / AuthProvider . cs <nl> public abstract class AuthProvider : IAuthProvider <nl> public Func < AuthProvider , string , string > SuccessRedirectUrlFilter = UrlFilter ; <nl> public Func < AuthProvider , string , string > FailedRedirectUrlFilter = UrlFilter ; <nl> public Func < AuthProvider , string , string > LogoutUrlFilter = UrlFilter ; <nl> + <nl> + public Func < IAuthRepository , IUserAuth , IAuthTokens , bool > AccountLockedValidator { get ; set ; } <nl> <nl> public static string UrlFilter ( AuthProvider provider , string url ) <nl> { <nl> protected virtual string GetAuthRedirectUrl ( IServiceBase authService , IAuthSessi <nl> <nl> public virtual bool IsAccountLocked ( IAuthRepository authRepo , IUserAuth userAuth , IAuthTokens tokens = null ) <nl> { <nl> + if ( AccountLockedValidator ! = null ) <nl> + return AccountLockedValidator ( authRepo , userAuth , tokens ) ; <nl> + <nl> return userAuth ? . LockedDate ! = null ; <nl> } <nl> <nl>\n", "msg": "Add AuthProvider . AccountLockedValidator to customize IsAccountLocked behavior w / o inheritance\n"}
{"diff_id": 33272, "repo": "ServiceStack/ServiceStack\n", "sha": "0f762436d1e1c9f3555f095458693c5cf8b610c2\n", "time": "2016-05-20T21:57:56Z\n", "diff": "mmm a / src / ServiceStack . Client / ServiceClientBase . cs <nl> ppp b / src / ServiceStack . Client / ServiceClientBase . cs <nl> public static HttpWebResponse Head ( this IRestClient client , string relativeOrAbs <nl> <nl> hasCookies . CookieContainer . Add ( baseUri , cookie ) ; <nl> } <nl> + <nl> + public static string GetSessionId ( this IServiceClient client ) <nl> + { <nl> + string sessionId ; <nl> + client . GetCookieValues ( ) . TryGetValue ( \" ss - id \" , out sessionId ) ; <nl> + return sessionId ; <nl> + } <nl> + <nl> + public static string GetPermanentSessionId ( this IServiceClient client ) <nl> + { <nl> + string sessionId ; <nl> + client . GetCookieValues ( ) . TryGetValue ( \" ss - pid \" , out sessionId ) ; <nl> + return sessionId ; <nl> + } <nl> + <nl> + public static void SetSessionId ( this IServiceClient client , string sessionId ) <nl> + { <nl> + client . SetCookie ( \" ss - id \" , sessionId ) ; <nl> + } <nl> + <nl> + public static void SetPermanentSessionId ( this IServiceClient client , string sessionId ) <nl> + { <nl> + client . SetCookie ( \" ss - pid \" , sessionId , expiresIn : TimeSpan . FromDays ( 365 * 20 ) ) ; <nl> + } <nl> } <nl> <nl> public interface IHasCookieContainer <nl>\n", "msg": "Add Typed ServiceClient overloads for GetSessionId ( ) / SetSessionId ( ) + Permanent\n"}
{"diff_id": 33366, "repo": "dotnet/runtime\n", "sha": "e8dbf4a2f5d656e95e6becda4e6d0c7f875804c1\n", "time": "2017-04-17T21:45:04Z\n", "diff": "mmm a / src / libraries / System . Configuration . ConfigurationManager / tests / Mono / ConfigurationSaveTest . cs <nl> ppp b / src / libraries / System . Configuration . ConfigurationManager / tests / Mono / ConfigurationSaveTest . cs <nl> public void AddListElement ( ) <nl> } <nl> <nl> [ Fact ] <nl> + [ ActiveIssue ( 18431 ) ] <nl> public void NotModifiedAfterSave ( ) <nl> { <nl> Run < DefaultMachineConfig > ( \" NotModifiedAfterSave \" , ( config , label ) = > <nl> public void ModifyListElement2 ( ) <nl> } <nl> <nl> [ Fact ] <nl> + [ ActiveIssue ( 18431 ) ] <nl> public void TestElementWithCollection ( ) <nl> { <nl> Run < DefaultMachineConfig2 > ( \" TestElementWithCollection \" , ( config , label ) = > <nl>\n", "msg": "Disable MonoTests . System . Configuration . ConfigurationSaveTest . NotModifiedAfterSave ( dotnet / corefx )\n"}
{"diff_id": 33371, "repo": "dotnet/runtime\n", "sha": "26eb39824d399406ed089d933884aa4f6e6c5cce\n", "time": "2011-07-24T18:23:11Z\n", "diff": "mmm a / src / mono / mono / mini / exceptions . cs <nl> ppp b / src / mono / mono / mini / exceptions . cs <nl> unsafe struct Foo <nl> <nl> return 0 ; <nl> } <nl> + <nl> + static int test_0_try_clause_in_finally_clause_regalloc ( ) { <nl> + / / Fill up registers with values <nl> + object a = new object ( ) ; <nl> + object [ ] arr1 = new object [ 1 ] ; <nl> + object [ ] arr2 = new object [ 1 ] ; <nl> + object [ ] arr3 = new object [ 1 ] ; <nl> + object [ ] arr4 = new object [ 1 ] ; <nl> + object [ ] arr5 = new object [ 1 ] ; <nl> + <nl> + for ( int i = 0 ; i < 10 ; + + i ) <nl> + arr1 [ 0 ] = a ; <nl> + for ( int i = 0 ; i < 10 ; + + i ) <nl> + arr2 [ 0 ] = a ; <nl> + for ( int i = 0 ; i < 10 ; + + i ) <nl> + arr3 [ 0 ] = a ; <nl> + for ( int i = 0 ; i < 10 ; + + i ) <nl> + arr4 [ 0 ] = a ; <nl> + for ( int i = 0 ; i < 10 ; + + i ) <nl> + arr5 [ 0 ] = a ; <nl> + <nl> + int res = 1 ; <nl> + try { <nl> + try_clause_in_finally_clause_regalloc_inner ( out res ) ; <nl> + } catch ( Exception ) { <nl> + } <nl> + return res ; <nl> + } <nl> + <nl> + public static object Throw ( ) { <nl> + for ( int i = 0 ; i < 10 ; + + i ) <nl> + ; <nl> + throw new Exception ( ) ; <nl> + } <nl> + <nl> + static void try_clause_in_finally_clause_regalloc_inner ( out int res ) { <nl> + object o = null ; <nl> + <nl> + res = 1 ; <nl> + try { <nl> + o = Throw ( ) ; <nl> + } catch ( Exception ) { <nl> + / * Make sure this doesn ' t branch to the finally * / <nl> + throw new DivideByZeroException ( ) ; <nl> + } finally { <nl> + try { <nl> + / * Make sure o is register allocated * / <nl> + if ( o = = null ) <nl> + res = 0 ; <nl> + else <nl> + res = 1 ; <nl> + if ( o = = null ) <nl> + res = 0 ; <nl> + else <nl> + res = 1 ; <nl> + if ( o = = null ) <nl> + res = 0 ; <nl> + else <nl> + res = 1 ; <nl> + } catch ( DivideByZeroException ) { <nl> + } <nl> + } <nl> + } <nl> } <nl> <nl>\n", "msg": "Add a test for mono / mono @ 7cb704d9a9ec73eb225c27b51e7f47de033e0ac0 .\n"}
{"diff_id": 33559, "repo": "AvaloniaUI/Avalonia\n", "sha": "1417aab362ed98b64bc48cfc450fc53c2aab2feb\n", "time": "2016-06-01T22:19:29Z\n", "diff": "mmm a / tests / Avalonia . Controls . UnitTests / Presenters / ItemsPresenterTests_Virtualization_Simple . cs <nl> ppp b / tests / Avalonia . Controls . UnitTests / Presenters / ItemsPresenterTests_Virtualization_Simple . cs <nl> public void Inserting_Items_Should_Update_Containers ( ) <nl> } <nl> <nl> [ Fact ] <nl> - public void Removing_last_item_when_visible_should_UpdateContainers ( ) <nl> + public void Removing_First_Item_When_Visible_Should_UpdateContainers ( ) <nl> + { <nl> + var target = CreateTarget ( itemCount : 20 ) ; <nl> + <nl> + target . ApplyTemplate ( ) ; <nl> + target . Measure ( new Size ( 100 , 195 ) ) ; <nl> + target . Arrange ( new Rect ( 0 , 0 , 100 , 195 ) ) ; <nl> + <nl> + ( ( ILogicalScrollable ) target ) . Offset = new Vector ( 0 , 5 ) ; <nl> + <nl> + var expected = Enumerable . Range ( 0 , 20 ) . Select ( x = > $ \" Item { x } \" ) . ToList ( ) ; <nl> + var items = ( ObservableCollection < string > ) target . Items ; <nl> + <nl> + Assert . Equal ( <nl> + expected , <nl> + target . Panel . Children . Select ( x = > x . DataContext ) ) ; <nl> + <nl> + items . Remove ( items . First ( ) ) ; <nl> + expected . Remove ( expected . First ( ) ) ; <nl> + <nl> + var actual = target . Panel . Children . Select ( x = > x . DataContext ) . ToList ( ) ; <nl> + Assert . Equal ( expected , actual ) ; <nl> + } <nl> + <nl> + [ Fact ] <nl> + public void Removing_Items_From_Middle_Should_Update_Containers ( ) <nl> + { <nl> + var target = CreateTarget ( itemCount : 20 ) ; <nl> + <nl> + target . ApplyTemplate ( ) ; <nl> + target . Measure ( new Size ( 100 , 195 ) ) ; <nl> + target . Arrange ( new Rect ( 0 , 0 , 100 , 195 ) ) ; <nl> + <nl> + ( ( ILogicalScrollable ) target ) . Offset = new Vector ( 0 , 5 ) ; <nl> + <nl> + var expected = Enumerable . Range ( 0 , 20 ) . Select ( x = > $ \" Item { x } \" ) . ToList ( ) ; <nl> + var items = ( ObservableCollection < string > ) target . Items ; <nl> + <nl> + Assert . Equal ( <nl> + expected , <nl> + target . Panel . Children . Select ( x = > x . DataContext ) ) ; <nl> + <nl> + items . RemoveAt ( 2 ) ; <nl> + expected . RemoveAt ( 2 ) ; <nl> + <nl> + var actual = target . Panel . Children . Select ( x = > x . DataContext ) . ToList ( ) ; <nl> + Assert . Equal ( expected , actual ) ; <nl> + <nl> + items . RemoveAt ( items . Count - 2 ) ; <nl> + expected . RemoveAt ( expected . Count - 2 ) ; <nl> + <nl> + actual = target . Panel . Children . Select ( x = > x . DataContext ) . ToList ( ) ; <nl> + Assert . Equal ( expected , actual ) ; <nl> + } <nl> + <nl> + [ Fact ] <nl> + public void Removing_Last_Item_When_Visible_Should_UpdateContainers ( ) <nl> { <nl> var target = CreateTarget ( itemCount : 20 ) ; <nl> <nl>\n", "msg": "added some more test cases for simple virtualization .\n"}
{"diff_id": 33579, "repo": "ServiceStack/ServiceStack\n", "sha": "f749410a67ce41e8a4b02f0dd4ebec5dd8402cc7\n", "time": "2016-10-13T21:40:23Z\n", "diff": "mmm a / src / ServiceStack / NativeTypes / NativeTypesMetadata . cs <nl> ppp b / src / ServiceStack / NativeTypes / NativeTypesMetadata . cs <nl> public static void RemoveIgnoredTypes ( this MetadataTypes metadata , MetadataTypes <nl> var includeList = GetIncludeList ( metadata , config ) ; <nl> <nl> metadata . Types . RemoveAll ( x = > x . IgnoreType ( config , includeList ) ) ; <nl> + <nl> + var matchingResponseTypes = includeList ! = null <nl> + ? metadata . Operations . Where ( x = > x . Response ! = null & & includeList . Contains ( x . Response . Name ) ) <nl> + . Map ( x = > x . Response ) . ToArray ( ) <nl> + : TypeConstants < MetadataType > . EmptyArray ; <nl> + <nl> metadata . Operations . RemoveAll ( x = > x . Request . IgnoreType ( config , includeList ) ) ; <nl> metadata . Operations . Each ( x = > { <nl> if ( x . Response ! = null & & x . Response . IgnoreType ( config , includeList ) ) <nl> public static void RemoveIgnoredTypes ( this MetadataTypes metadata , MetadataTypes <nl> x . Response = null ; <nl> } <nl> } ) ; <nl> + <nl> + / / When the included Type is a Response Type because defined in another Service that ' s not included <nl> + / / ref : https : / / forums . servicestack . net / t / class - is - missing - from - generated - code / 3030 <nl> + foreach ( var responseType in matchingResponseTypes ) <nl> + { <nl> + if ( ! metadata . Operations . Any ( x = > x . Response ! = null & & x . Response . Name = = responseType . Name ) <nl> + & & metadata . Types . All ( x = > x . Name ! = responseType . Name ) ) <nl> + { <nl> + metadata . Types . Add ( responseType ) ; <nl> + } <nl> + } <nl> } <nl> <nl> public static List < string > GetIncludeList ( MetadataTypes metadata , MetadataTypesConfig config ) <nl>\n", "msg": "Add workaround when returning a generic list of a Type that ' s only defined as a Response DTO\n"}
{"diff_id": 33981, "repo": "dotnet/roslyn\n", "sha": "49d2f96adef12bc7d6a004ef623b9ddf816a101f\n", "time": "2020-01-24T18:49:20Z\n", "diff": "mmm a / src / EditorFeatures / Core / Implementation / IntelliSense / SignatureHelp / Controller . Session_ComputeModel . cs <nl> ppp b / src / EditorFeatures / Core / Implementation / IntelliSense / SignatureHelp / Controller . Session_ComputeModel . cs <nl> private static bool CompareParts ( TaggedText p1 , TaggedText p2 ) <nl> <nl> return ( bestProvider , bestItems ) ; <nl> } <nl> - catch ( Exception e ) when ( FatalError . ReportUnlessCanceled ( e ) ) <nl> + catch ( Exception e ) when ( FatalError . ReportWithoutCrashUnlessCanceled ( e ) ) <nl> { <nl> - throw ExceptionUtilities . Unreachable ; <nl> + return ( null , null ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Don ' t crash VS when Signature Help fails to calculate\n"}
{"diff_id": 34124, "repo": "mono/mono\n", "sha": "8cf4310cc1718cf5ed1c645deec0f7caf6fb9a04\n", "time": "2006-09-14T11:58:48Z\n", "diff": "mmm a / mcs / class / System . Web / Test / System . Web . UI / PageTest . cs <nl> ppp b / mcs / class / System . Web / Test / System . Web . UI / PageTest . cs <nl> public void Request_OverridenContext_Indirect ( ) <nl> <nl> # if NET_2_0 <nl> [ Test ] <nl> + [ Category ( \" NunitWeb \" ) ] <nl> public void PageHeaderOnPreInit ( ) <nl> { <nl> Thread . Sleep ( 200 ) ; <nl> public static void Page_OnPreInit ( Page p ) <nl> } <nl> <nl> [ Test ] <nl> + [ Category ( \" NunitWeb \" ) ] <nl> + [ Category ( \" NotWorking \" ) ] <nl> public void PageHeaderInit ( ) <nl> { <nl> Thread . Sleep ( 200 ) ; <nl> public void PageHeaderInit ( ) <nl> } <nl> <nl> [ Test ] <nl> + [ Category ( \" NunitWeb \" ) ] <nl> + [ Category ( \" NotWorking \" ) ] <nl> public void PageHeaderInitComplete ( ) <nl> { <nl> Thread . Sleep ( 200 ) ; <nl> public void PageHeaderInitComplete ( ) <nl> } <nl> <nl> [ Test ] <nl> + [ Category ( \" NunitWeb \" ) ] <nl> + [ Category ( \" NotWorking \" ) ] <nl> public void PageHeaderPreLoad ( ) <nl> { <nl> Thread . Sleep ( 200 ) ; <nl> public void PageHeaderPreLoad ( ) <nl> } <nl> <nl> [ Test ] <nl> + [ Category ( \" NunitWeb \" ) ] <nl> + [ Category ( \" NotWorking \" ) ] <nl> public void PageHeaderLoad ( ) <nl> { <nl> Thread . Sleep ( 200 ) ; <nl> public void PageHeaderLoad ( ) <nl> } <nl> <nl> [ Test ] <nl> + [ Category ( \" NunitWeb \" ) ] <nl> + [ Category ( \" NotWorking \" ) ] <nl> public void PageHeaderLoadComplete ( ) <nl> { <nl> Thread . Sleep ( 200 ) ; <nl> public void PageHeaderLoadComplete ( ) <nl> } <nl> <nl> [ Test ] <nl> + [ Category ( \" NunitWeb \" ) ] <nl> + [ Category ( \" NotWorking \" ) ] <nl> public void PageHeaderPreRender ( ) <nl> { <nl> Thread . Sleep ( 200 ) ; <nl> public void PageHeaderPreRender ( ) <nl> } <nl> <nl> [ Test ] <nl> + [ Category ( \" NunitWeb \" ) ] <nl> + [ Category ( \" NotWorking \" ) ] <nl> public void PageHeaderPreRenderComplete ( ) <nl> { <nl> Thread . Sleep ( 200 ) ; <nl>\n", "msg": "Adding [ NotWorking ] attribute to tests in PageTest . cs\n"}
{"diff_id": 34356, "repo": "mono/mono\n", "sha": "777de937b654c011b0ad7573cfe7b8c1bc8662d2\n", "time": "2012-11-29T16:35:34Z\n", "diff": "mmm a / mono / tests / finalizer - exception . cs <nl> ppp b / mono / tests / finalizer - exception . cs <nl> public class FinalizerException { <nl> throw new Exception ( ) ; <nl> } <nl> <nl> + / * <nl> + * We allocate the exception object deep down the stack so <nl> + * that it doesn ' t get pinned . <nl> + * / <nl> + public static void MakeException ( int depth ) { <nl> + if ( depth < = 0 ) { <nl> + new FinalizerException ( ) ; <nl> + return ; <nl> + } <nl> + MakeException ( depth - 1 ) ; <nl> + } <nl> + <nl> public static int Main ( ) { <nl> AppDomain . CurrentDomain . UnhandledException + = ( sender , args ) = > { <nl> Console . WriteLine ( \" caught \" ) ; <nl> Environment . Exit ( 0 ) ; <nl> } ; <nl> <nl> - new FinalizerException ( ) ; <nl> + MakeException ( 100 ) ; <nl> <nl> GC . Collect ( ) ; <nl> GC . WaitForPendingFinalizers ( ) ; <nl>\n", "msg": "[ tests ] Fix pinning in finalizer - exception . cs .\n"}
{"diff_id": 34620, "repo": "duplicati/duplicati\n", "sha": "1be8d16e22711a509be69c5eaf5e35c049c3a224\n", "time": "2015-04-08T18:34:31Z\n", "diff": "mmm a / Duplicati / Library / Main / Operation / RepairHandler . cs <nl> ppp b / Duplicati / Library / Main / Operation / RepairHandler . cs <nl> public void RunRepairLocal ( Library . Utility . IFilter filter = null ) <nl> { <nl> if ( f ! = null & & System . IO . File . Exists ( f ) ) <nl> System . IO . File . Delete ( f ) ; <nl> - <nl> + <nl> + var filelistfilter = RestoreHandler . FilterNumberedFilelist ( m_options . Time , m_options . Version ) ; <nl> + <nl> new RecreateDatabaseHandler ( m_backendurl , m_options , ( RecreateDatabaseResults ) m_result . RecreateDatabaseResults ) <nl> - . Run ( m_options . Dryrun ? ( string ) f : m_options . Dbpath ) ; <nl> + . Run ( m_options . Dryrun ? ( string ) f : m_options . Dbpath , filter , filelistfilter ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Added option to allow repairing only a specific fileset for faster restore from scratch\n"}
{"diff_id": 34679, "repo": "MonoGame/MonoGame\n", "sha": "b7bdefce7e4db34ca97b128e8802a6d41802b273\n", "time": "2014-02-16T14:58:42Z\n", "diff": "mmm a / MonoGame . Framework / Audio / SoundEffectInstance . cs <nl> ppp b / MonoGame . Framework / Audio / SoundEffectInstance . cs <nl> public void Stop ( bool immediate ) <nl> { <nl> # if DIRECTX <nl> if ( _voice ! = null ) <nl> + { <nl> _voice . Stop ( immediate ? 0 : ( int ) PlayFlags . Tails ) ; <nl> + if ( immediate ) _voice . FlushSourceBuffers ( ) ; <nl> + } <nl> <nl> _paused = false ; <nl> # else <nl>\n", "msg": "[ WP8 ] Calling SoundEffectInstance . Stop ( true ) unstable state .\n"}
{"diff_id": 34774, "repo": "dotnet/runtime\n", "sha": "caa0f882511f9d023b63c407c4937a5c99e14093\n", "time": "2019-10-25T22:17:04Z\n", "diff": "mmm a / src / coreclr / src / tools / crossgen2 / ILCompiler . ReadyToRun / Compiler / DependencyAnalysis / ReadyToRun / DevirtualizationManager . cs <nl> ppp b / src / coreclr / src / tools / crossgen2 / ILCompiler . ReadyToRun / Compiler / DependencyAnalysis / ReadyToRun / DevirtualizationManager . cs <nl> protected override MethodDesc ResolveVirtualMethod ( MethodDesc declMethod , DefTyp <nl> if ( _compilationModuleGroup . VersionsWithMethodBody ( declMethod ) & & <nl> _compilationModuleGroup . VersionsWithType ( implType ) ) <nl> { <nl> + / * * <nl> + * It is possible for us to hit a scenario where a type implements <nl> + * the same interface more than once due to generic instantiations . <nl> + * <nl> + * In some instances of those cases , the VirtualMethodAlgorithm <nl> + * does not produce identical output as CoreCLR would , leading to <nl> + * behavioral differences in compiled outputs . <nl> + * <nl> + * Instead of fixing the algorithm ( in which the work to fix it is <nl> + * tracked in https : / / github . com / dotnet / corert / issues / 208 ) , the <nl> + * following duplication detection algorithm will detect the case and <nl> + * refuse to devirtualize for those scenarios . <nl> + * / <nl> + if ( declMethod . OwningType . IsInterface ) <nl> + { <nl> + DefType [ ] implTypeRuntimeInterfaces = implType . RuntimeInterfaces ; <nl> + for ( int i = 0 ; i < implTypeRuntimeInterfaces . Length ; i + + ) <nl> + { <nl> + for ( int j = i + 1 ; j < implTypeRuntimeInterfaces . Length ; j + + ) <nl> + { <nl> + if ( implTypeRuntimeInterfaces [ i ] = = implTypeRuntimeInterfaces [ j ] ) <nl> + { <nl> + return null ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> return base . ResolveVirtualMethod ( declMethod , implType ) ; <nl> } <nl> <nl>\n", "msg": "[ crossgen2 ] Avoid ambiguous devirtualization ( dotnet / coreclr )\n"}
{"diff_id": 34987, "repo": "nopSolutions/nopCommerce\n", "sha": "6d0eccce595b2adc346196e31853af3621e6c09c\n", "time": "2018-07-17T08:18:06Z\n", "diff": "Binary files a / src / Build / ClearPluginAssemblies . dll and b / src / Build / ClearPluginAssemblies . dll differ <nl> mmm a / src / Build / src / ClearPluginAssemblies / Program . cs <nl> ppp b / src / Build / src / ClearPluginAssemblies / Program . cs <nl> private static void Main ( string [ ] args ) <nl> return ; <nl> <nl> var di = new DirectoryInfo ( outputPath ) ; <nl> - var fileNames = di . GetFiles ( \" * . dll \" , SearchOption . AllDirectories ) . Select ( fi = > fi . Name . Replace ( fi . Extension , \" \" ) ) . ToList ( ) ; <nl> + var fileNames = di . GetFiles ( \" * . dll \" , SearchOption . AllDirectories ) <nl> + . Where ( fi = > ! fi . FullName . Contains ( @ \" \\ Plugins \\ \" ) ) <nl> + . Select ( fi = > fi . Name . Replace ( fi . Extension , \" \" ) ) . ToList ( ) ; <nl> <nl> if ( string . IsNullOrEmpty ( pluginPaths ) | | ! fileNames . Any ( ) ) <nl> { <nl>\n", "msg": "Excluded \" Plugins \" folder and all its subfolders from the list to preparing libraries to deleting\n"}
{"diff_id": 35057, "repo": "nopSolutions/nopCommerce\n", "sha": "9a244ba14c691a73f78758e6af28e02d79d38573\n", "time": "2013-01-17T09:23:51Z\n", "diff": "mmm a / src / Presentation / Nop . Web / Controllers / CommonController . cs <nl> ppp b / src / Presentation / Nop . Web / Controllers / CommonController . cs <nl> public partial class CommonController : BaseNopController <nl> <nl> # region Utilities <nl> <nl> + / / page not found <nl> + public ActionResult PageNotFound ( ) <nl> + { <nl> + this . Response . StatusCode = 404 ; <nl> + this . Response . TrySkipIisCustomErrors = true ; <nl> + <nl> + return View ( ) ; <nl> + } <nl> + <nl> [ NonAction ] <nl> protected LanguageSelectorModel PrepareLanguageSelectorModel ( ) <nl> { <nl>\n", "msg": "Further changes on more user - friendly \" page not found \" page ( with 404 HTTP status code )\n"}
{"diff_id": 35058, "repo": "OpenRA/OpenRA\n", "sha": "f9f9fbf3e4dfa481a1920038b64ea4bcac0979ce\n", "time": "2010-11-27T02:11:38Z\n", "diff": "mmm a / OpenRA . Game / ModData . cs <nl> ppp b / OpenRA . Game / ModData . cs <nl> public class ModData <nl> { <nl> public readonly Manifest Manifest ; <nl> public readonly ObjectCreator ObjectCreator ; <nl> - public readonly SheetBuilder SheetBuilder ; <nl> - public readonly CursorSheetBuilder CursorSheetBuilder ; <nl> public readonly Dictionary < string , MapStub > AvailableMaps ; <nl> public readonly WidgetLoader WidgetLoader ; <nl> public ILoadScreen LoadScreen = null ; <nl> - <nl> + public SheetBuilder SheetBuilder ; <nl> + public CursorSheetBuilder CursorSheetBuilder ; <nl> + <nl> public ModData ( params string [ ] mods ) <nl> { <nl> Manifest = new Manifest ( mods ) ; <nl> public Map PrepareMap ( string uid ) <nl> if ( map . Tileset ! = cachedTileset <nl> | | previousMapHadSequences | | map . Sequences . Count > 0 ) <nl> { <nl> + SheetBuilder = new SheetBuilder ( TextureChannel . Red ) ; <nl> SpriteSheetBuilder . Initialize ( Rules . TileSets [ map . Tileset ] ) ; <nl> + CursorSheetBuilder = new CursorSheetBuilder ( this ) ; <nl> CursorProvider . Initialize ( Manifest . Cursors ) ; <nl> SequenceProvider . Initialize ( Manifest . Sequences , map . Sequences ) ; <nl> cachedTileset = map . Tileset ; <nl>\n", "msg": "Reinit the sheetbuilder too - appending more sprites to the old sheets isn ' t the best of ideas . Fixes \" Terrain sprites span multiple sheets \" on cnc tundra map .\n"}
{"diff_id": 35217, "repo": "OpenRA/OpenRA\n", "sha": "3d7815d8c1e5005977af1289ea279004e301b007\n", "time": "2014-02-22T18:45:25Z\n", "diff": "mmm a / OpenRA . Mods . RA / Render / RenderLandingCraft . cs <nl> ppp b / OpenRA . Mods . RA / Render / RenderLandingCraft . cs <nl> <nl> <nl> using System . Linq ; <nl> using OpenRA . Traits ; <nl> + using OpenRA . Mods . RA . Move ; <nl> <nl> namespace OpenRA . Mods . RA . Render <nl> { <nl> public RenderLandingCraft ( Actor self , RenderLandingCraftInfo info ) <nl> <nl> public bool ShouldBeOpen ( ) <nl> { <nl> - if ( self . CenterPosition . Z > 0 ) <nl> + var mobile = self . TraitOrDefault < Mobile > ( ) ; <nl> + if ( mobile = = null ) <nl> + return false ; <nl> + <nl> + if ( self . CenterPosition . Z > 0 | | mobile . IsMoving ) <nl> return false ; <nl> <nl> return cargo . CurrentAdjacentCells <nl>\n", "msg": "Added a TraitOrDefault for Mobile and with that a check for mobile . IsMoving to RenderLandingCraft .\n"}
{"diff_id": 35393, "repo": "nopSolutions/nopCommerce\n", "sha": "0caf797c39a94c8b7d79b50cc2c0f6f61a1dfd2c\n", "time": "2015-05-21T13:30:35Z\n", "diff": "mmm a / src / Presentation / Nop . Web . Framework / Kendoui / Filter . cs <nl> ppp b / src / Presentation / Nop . Web . Framework / Kendoui / Filter . cs <nl> public string ToExpression ( IList < Filter > filters ) <nl> / / return String . Format ( \" { 0 } . { 1 } ( @ { 2 } ) \" , Field , comparison , index ) ; <nl> / / } <nl> <nl> - <nl> / / we ignore case <nl> if ( comparison = = \" Contains \" ) <nl> { <nl> return String . Format ( \" { 0 } . IndexOf ( @ { 1 } , System . StringComparison . InvariantCultureIgnoreCase ) > = 0 \" , Field , index ) ; <nl> } <nl> - if ( comparison = = \" = \" ) <nl> + if ( comparison = = \" = \" & & Value . GetType ( ) = = typeof ( String ) ) <nl> { <nl> + / / string only <nl> comparison = \" Equals \" ; <nl> + / / numeric values use standard \" = \" char <nl> } <nl> if ( comparison = = \" StartsWith \" | | comparison = = \" EndsWith \" | | comparison = = \" Equals \" ) <nl> { <nl>\n", "msg": "Admin area grid . Added filtering support for numeric properties .\n"}
{"diff_id": 35769, "repo": "nopSolutions/nopCommerce\n", "sha": "bcc3da0ce88d7eebd3a10481ab1dcd92183ef4dd\n", "time": "2014-04-15T05:21:26Z\n", "diff": "mmm a / src / Libraries / Nop . Services / ExportImport / ImportManager . cs <nl> ppp b / src / Libraries / Nop . Services / ExportImport / ImportManager . cs <nl> protected virtual int GetColumnIndex ( string [ ] properties , string columnName ) <nl> return 0 ; <nl> } <nl> <nl> + protected virtual string ConvertColumnToString ( object columnValue ) <nl> + { <nl> + if ( columnValue = = null ) <nl> + return null ; <nl> + <nl> + return Convert . ToString ( columnValue ) ; <nl> + } <nl> + <nl> # endregion <nl> <nl> # region Methods <nl> public virtual void ImportProductsFromXlsx ( Stream stream ) <nl> int productTypeId = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" ProductTypeId \" ) ] . Value ) ; <nl> int parentGroupedProductId = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" ParentGroupedProductId \" ) ] . Value ) ; <nl> bool visibleIndividually = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" VisibleIndividually \" ) ] . Value ) ; <nl> - string name = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Name \" ) ] . Value as string ; <nl> - string shortDescription = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" ShortDescription \" ) ] . Value as string ; <nl> - string fullDescription = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" FullDescription \" ) ] . Value as string ; <nl> + string name = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Name \" ) ] . Value ) ; <nl> + string shortDescription = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" ShortDescription \" ) ] . Value ) ; <nl> + string fullDescription = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" FullDescription \" ) ] . Value ) ; <nl> int vendorId = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" VendorId \" ) ] . Value ) ; <nl> int productTemplateId = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" ProductTemplateId \" ) ] . Value ) ; <nl> bool showOnHomePage = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" ShowOnHomePage \" ) ] . Value ) ; <nl> - string metaKeywords = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" MetaKeywords \" ) ] . Value as string ; <nl> - string metaDescription = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" MetaDescription \" ) ] . Value as string ; <nl> - string metaTitle = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" MetaTitle \" ) ] . Value as string ; <nl> - string seName = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" SeName \" ) ] . Value as string ; <nl> + string metaKeywords = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" MetaKeywords \" ) ] . Value ) ; <nl> + string metaDescription = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" MetaDescription \" ) ] . Value ) ; <nl> + string metaTitle = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" MetaTitle \" ) ] . Value ) ; <nl> + string seName = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" SeName \" ) ] . Value ) ; <nl> bool allowCustomerReviews = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" AllowCustomerReviews \" ) ] . Value ) ; <nl> bool published = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Published \" ) ] . Value ) ; <nl> - string sku = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" SKU \" ) ] . Value as string ; <nl> - string manufacturerPartNumber = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" ManufacturerPartNumber \" ) ] . Value as string ; <nl> - string gtin = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Gtin \" ) ] . Value as string ; <nl> + string sku = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" SKU \" ) ] . Value ) ; <nl> + string manufacturerPartNumber = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" ManufacturerPartNumber \" ) ] . Value ) ; <nl> + string gtin = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Gtin \" ) ] . Value ) ; <nl> bool isGiftCard = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" IsGiftCard \" ) ] . Value ) ; <nl> int giftCardTypeId = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" GiftCardTypeId \" ) ] . Value ) ; <nl> bool requireOtherProducts = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" RequireOtherProducts \" ) ] . Value ) ; <nl> - string requiredProductIds = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" RequiredProductIds \" ) ] . Value as string ; <nl> + string requiredProductIds = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" RequiredProductIds \" ) ] . Value ) ; <nl> bool automaticallyAddRequiredProducts = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" AutomaticallyAddRequiredProducts \" ) ] . Value ) ; <nl> bool isDownload = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" IsDownload \" ) ] . Value ) ; <nl> int downloadId = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" DownloadId \" ) ] . Value ) ; <nl> public virtual void ImportProductsFromXlsx ( Stream stream ) <nl> bool hasSampleDownload = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" HasSampleDownload \" ) ] . Value ) ; <nl> int sampleDownloadId = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" SampleDownloadId \" ) ] . Value ) ; <nl> bool hasUserAgreement = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" HasUserAgreement \" ) ] . Value ) ; <nl> - string userAgreementText = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" UserAgreementText \" ) ] . Value as string ; <nl> + string userAgreementText = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" UserAgreementText \" ) ] . Value ) ; <nl> bool isRecurring = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" IsRecurring \" ) ] . Value ) ; <nl> int recurringCycleLength = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" RecurringCycleLength \" ) ] . Value ) ; <nl> int recurringCyclePeriodId = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" RecurringCyclePeriodId \" ) ] . Value ) ; <nl> public virtual void ImportProductsFromXlsx ( Stream stream ) <nl> bool allowBackInStockSubscriptions = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" AllowBackInStockSubscriptions \" ) ] . Value ) ; <nl> int orderMinimumQuantity = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" OrderMinimumQuantity \" ) ] . Value ) ; <nl> int orderMaximumQuantity = Convert . ToInt32 ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" OrderMaximumQuantity \" ) ] . Value ) ; <nl> - string allowedQuantities = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" AllowedQuantities \" ) ] . Value as string ; <nl> + string allowedQuantities = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" AllowedQuantities \" ) ] . Value ) ; <nl> bool allowAddingOnlyExistingAttributeCombinations = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" AllowAddingOnlyExistingAttributeCombinations \" ) ] . Value ) ; <nl> bool disableBuyButton = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" DisableBuyButton \" ) ] . Value ) ; <nl> bool disableWishlistButton = Convert . ToBoolean ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" DisableWishlistButton \" ) ] . Value ) ; <nl> public virtual void ImportProductsFromXlsx ( Stream stream ) <nl> decimal width = Convert . ToDecimal ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Width \" ) ] . Value ) ; <nl> decimal height = Convert . ToDecimal ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Height \" ) ] . Value ) ; <nl> DateTime createdOnUtc = DateTime . FromOADate ( Convert . ToDouble ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" CreatedOnUtc \" ) ] . Value ) ) ; <nl> - string categoryIds = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" CategoryIds \" ) ] . Value as string ; <nl> - string manufacturerIds = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" ManufacturerIds \" ) ] . Value as string ; <nl> - string picture1 = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Picture1 \" ) ] . Value as string ; <nl> - string picture2 = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Picture2 \" ) ] . Value as string ; <nl> - string picture3 = worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Picture3 \" ) ] . Value as string ; <nl> + string categoryIds = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" CategoryIds \" ) ] . Value ) ; <nl> + string manufacturerIds = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" ManufacturerIds \" ) ] . Value ) ; <nl> + string picture1 = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Picture1 \" ) ] . Value ) ; <nl> + string picture2 = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Picture2 \" ) ] . Value ) ; <nl> + string picture3 = ConvertColumnToString ( worksheet . Cells [ iRow , GetColumnIndex ( properties , \" Picture3 \" ) ] . Value ) ; <nl> <nl> <nl> <nl>\n", "msg": "Import from Excel issue fixed . We should not require apostrophe before numeric fields in Excel files .\n"}
{"diff_id": 35926, "repo": "OpenRA/OpenRA\n", "sha": "b0a7865cfa27c5a355d36981542cd795be414bbd\n", "time": "2019-08-07T12:02:18Z\n", "diff": "mmm a / OpenRA . Game / Map / Map . cs <nl> ppp b / OpenRA . Game / Map / Map . cs <nl> public bool Contains ( CPos cell ) <nl> if ( Grid . Type = = MapGridType . RectangularIsometric & & cell . X < cell . Y ) <nl> return false ; <nl> <nl> + / / If the mod uses flat & rectangular maps , ToMPos and Contains ( MPos ) create unnecessary cost . <nl> + / / Just check if CPos is within map bounds . <nl> + if ( Grid . MaximumTerrainHeight = = 0 & & Grid . Type = = MapGridType . Rectangular ) <nl> + return Bounds . Contains ( cell . X , cell . Y ) ; <nl> + <nl> return Contains ( cell . ToMPos ( this ) ) ; <nl> } <nl> <nl>\n", "msg": "Reduce Map . Contains ( CPos ) cost in legacy mods\n"}
{"diff_id": 36021, "repo": "dotnet/runtime\n", "sha": "d0d5b5f3d9a2632115faf5c37b23b1a94cdad5c4\n", "time": "2017-05-17T05:41:41Z\n", "diff": "mmm a / src / libraries / System . Net . HttpListener / src / System / Net / Managed / HttpEndPointManager . cs <nl> ppp b / src / libraries / System . Net . HttpListener / src / System / Net / Managed / HttpEndPointManager . cs <nl> private static void AddPrefixInternal ( string p , HttpListener listener ) <nl> throw new HttpListenerException ( ( int ) HttpStatusCode . BadRequest , SR . net_invalid_path ) ; <nl> <nl> / / listens on all the interfaces if host name cannot be parsed by IPAddress . <nl> - HttpEndPointListener epl = GetEPListener ( lp . Host , lp . Port , listener , lp . Secure , out bool alreadyExists ) ; <nl> - if ( alreadyExists ) <nl> - { <nl> - throw new HttpListenerException ( 98 , SR . Format ( SR . net_listener_already , p ) ) ; <nl> - } <nl> + HttpEndPointListener epl = GetEPListener ( lp . Host , lp . Port , listener , lp . Secure ) ; <nl> epl . AddPrefix ( lp , listener ) ; <nl> } <nl> <nl> - private static HttpEndPointListener GetEPListener ( string host , int port , HttpListener listener , bool secure , out bool alreadyExists ) <nl> + private static HttpEndPointListener GetEPListener ( string host , int port , HttpListener listener , bool secure ) <nl> { <nl> - alreadyExists = false ; <nl> - <nl> IPAddress addr ; <nl> if ( host = = \" * \" ) <nl> addr = IPAddress . Any ; <nl> private static HttpEndPointListener GetEPListener ( string host , int port , HttpLis <nl> HttpEndPointListener epl = null ; <nl> if ( p . ContainsKey ( port ) ) <nl> { <nl> - alreadyExists = true ; <nl> epl = p [ port ] ; <nl> } <nl> else <nl> private static void RemovePrefixInternal ( string prefix , HttpListener listener ) <nl> if ( lp . Path . IndexOf ( \" / / \" , StringComparison . Ordinal ) ! = - 1 ) <nl> return ; <nl> <nl> - HttpEndPointListener epl = GetEPListener ( lp . Host , lp . Port , listener , lp . Secure , out bool ignored ) ; <nl> + HttpEndPointListener epl = GetEPListener ( lp . Host , lp . Port , listener , lp . Secure ) ; <nl> epl . RemovePrefix ( lp , listener ) ; <nl> } <nl> } <nl>\n", "msg": "Revert fix no exception thrown listening to an already registered host / port \n"}
{"diff_id": 36074, "repo": "gitextensions/gitextensions\n", "sha": "4bdc64b36f86e5ea5e5190ffaf7afa7e4df56690\n", "time": "2011-01-04T20:33:52Z\n", "diff": "mmm a / Plugins / Statistics / GitStatistics / GitStatisticsPlugin . cs <nl> ppp b / Plugins / Statistics / GitStatistics / GitStatisticsPlugin . cs <nl> public string Description <nl> public void Register ( IGitUICommands gitUiCommands ) <nl> { <nl> Settings . AddSetting ( \" Code files \" , <nl> - \" * . c ; * . cpp ; * . h ; * . hpp ; * . inl ; * . idl ; * . asm ; * . inc ; * . cs ; * . xsd ; * . wsdl ; * . xml ; * . htm ; * . html ; * . css ; * . vbs ; * . vb ; * . sql ; * . aspx ; * . asp ; * . php ; * . nav ; * . pas \" ) ; <nl> + \" * . c ; * . cpp ; * . h ; * . hpp ; * . inl ; * . idl ; * . asm ; * . inc ; * . cs ; * . xsd ; * . wsdl ; * . xml ; * . htm ; * . html ; * . css ; * . vbs ; * . vb ; * . sql ; * . aspx ; * . asp ; * . php ; * . nav ; * . pas ; * . py \" ) ; <nl> Settings . AddSetting ( \" Directories to ignore ( EndsWith ) \" , \" \\ \\ Debug ; \\ \\ Release ; \\ \\ obj ; \\ \\ bin ; \\ \\ lib \" ) ; <nl> Settings . AddSetting ( \" Ignore submodules ( true / false ) \" , \" true \" ) ; <nl> } <nl>\n", "msg": "GitStatistics : Added Python files to default file search pattern\n"}
{"diff_id": 36199, "repo": "icsharpcode/ILSpy\n", "sha": "3ef67fed521b5a6fe1df094f8395797a9e09c266\n", "time": "2017-12-01T22:58:42Z\n", "diff": "mmm a / ICSharpCode . Decompiler / CSharp / CSharpDecompiler . cs <nl> ppp b / ICSharpCode . Decompiler / CSharp / CSharpDecompiler . cs <nl> public string DecompileTypesAsString ( IEnumerable < TypeDefinition > types ) <nl> / / / < / remarks > <nl> public SyntaxTree DecompileType ( FullTypeName fullTypeName ) <nl> { <nl> - var type = typeSystem . Compilation . FindType ( fullTypeName ) . GetDefinition ( ) ; <nl> + var type = typeSystem . Compilation . FindType ( fullTypeName . TopLevelTypeName ) . GetDefinition ( ) ; <nl> if ( type = = null ) <nl> throw new InvalidOperationException ( $ \" Could not find type definition { fullTypeName } in type system . \" ) ; <nl> var decompilationContext = new SimpleTypeResolveContext ( typeSystem . MainAssembly ) ; <nl>\n", "msg": "DecompileType only supports top - level types : always use FullTypeName . TopLevelTypeName .\n"}
{"diff_id": 36229, "repo": "dotnet/runtime\n", "sha": "df685c925903c75ae259df214012aa5a2ea9462f\n", "time": "2016-08-22T02:00:19Z\n", "diff": "mmm a / src / coreclr / src / mscorlib / src / System / String . cs <nl> ppp b / src / coreclr / src / mscorlib / src / System / String . cs <nl> public sealed class String : IComparable , ICloneable , IConvertible , IEnumerable <nl> } <nl> <nl> [ ComVisible ( false ) ] <nl> - public static String Join ( String separator , params Object [ ] values ) { <nl> - if ( values = = null ) <nl> + public static string Join ( string separator , params object [ ] values ) <nl> + { <nl> + if ( values = = null ) <nl> throw new ArgumentNullException ( \" values \" ) ; <nl> Contract . EndContractBlock ( ) ; <nl> <nl> if ( values . Length = = 0 | | values [ 0 ] = = null ) <nl> - return String . Empty ; <nl> + return string . Empty ; <nl> <nl> - StringBuilder result = StringBuilderCache . Acquire ( ) ; <nl> + string firstString = values [ 0 ] . ToString ( ) ; <nl> <nl> - result . Append ( values [ 0 ] . ToString ( ) ) ; <nl> + if ( values . Length = = 1 ) <nl> + { <nl> + return firstString ? ? string . Empty ; <nl> + } <nl> + <nl> + StringBuilder result = StringBuilderCache . Acquire ( ) ; <nl> + result . Append ( firstString ) ; <nl> <nl> - for ( int i = 1 ; i < values . Length ; i + + ) { <nl> + for ( int i = 1 ; i < values . Length ; i + + ) <nl> + { <nl> result . Append ( separator ) ; <nl> - if ( values [ i ] ! = null ) { <nl> - result . Append ( values [ i ] . ToString ( ) ) ; <nl> + object value = values [ i ] ; <nl> + if ( value ! = null ) <nl> + { <nl> + result . Append ( value . ToString ( ) ) ; <nl> } <nl> } <nl> + <nl> return StringBuilderCache . GetStringAndRelease ( result ) ; <nl> } <nl> <nl> public static String Join < T > ( String separator , IEnumerable < T > values ) <nl> } <nl> } <nl> <nl> - <nl> - <nl> [ ComVisible ( false ) ] <nl> public static String Join ( String separator , IEnumerable < String > values ) { <nl> if ( values = = null ) <nl> public static string Concat ( params object [ ] args ) <nl> Contract . Ensures ( Contract . Result < String > ( ) ! = null ) ; <nl> Contract . EndContractBlock ( ) ; <nl> <nl> + if ( args . Length < = 1 ) <nl> + { <nl> + return args . Length = = 0 ? <nl> + string . Empty : <nl> + args [ 0 ] ? . ToString ( ) ? ? string . Empty ; <nl> + } <nl> + <nl> / / We need to get an intermediary string array <nl> / / to fill with each of the args ' ToString ( ) , <nl> / / and then just concat that in one operation . <nl> public static string Concat ( params object [ ] args ) <nl> } <nl> <nl> [ ComVisible ( false ) ] <nl> - public static String Concat < T > ( IEnumerable < T > values ) { <nl> + public static string Concat < T > ( IEnumerable < T > values ) <nl> + { <nl> if ( values = = null ) <nl> throw new ArgumentNullException ( \" values \" ) ; <nl> Contract . Ensures ( Contract . Result < String > ( ) ! = null ) ; <nl> Contract . EndContractBlock ( ) ; <nl> <nl> - StringBuilder result = StringBuilderCache . Acquire ( ) ; <nl> - using ( IEnumerator < T > en = values . GetEnumerator ( ) ) { <nl> - while ( en . MoveNext ( ) ) { <nl> - T currentValue = en . Current ; <nl> + using ( IEnumerator < T > en = values . GetEnumerator ( ) ) <nl> + { <nl> + if ( ! en . MoveNext ( ) ) <nl> + return string . Empty ; <nl> + <nl> + / / We called MoveNext once , so this will be the first item <nl> + T currentValue = en . Current ; <nl> + <nl> + / / Call ToString before calling MoveNext again , since <nl> + / / we want to stay consistent with the below loop <nl> + / / Everything should be called in the order <nl> + / / MoveNext - Current - ToString , unless further optimizations <nl> + / / can be made , to avoid breaking changes <nl> + string firstString = currentValue ? . ToString ( ) ; <nl> + <nl> + / / If there ' s only 1 item , simply call ToString on that <nl> + if ( ! en . MoveNext ( ) ) <nl> + { <nl> + / / We have to handle the case of either currentValue <nl> + / / or its ToString being null <nl> + return firstString ? ? string . Empty ; <nl> + } <nl> + <nl> + StringBuilder result = StringBuilderCache . Acquire ( ) ; <nl> + <nl> + result . Append ( firstString ) ; <nl> <nl> - if ( currentValue ! = null ) { <nl> + do <nl> + { <nl> + currentValue = en . Current ; <nl> + <nl> + if ( currentValue ! = null ) <nl> + { <nl> result . Append ( currentValue . ToString ( ) ) ; <nl> } <nl> - } <nl> + } <nl> + while ( en . MoveNext ( ) ) ; <nl> + <nl> + return StringBuilderCache . GetStringAndRelease ( result ) ; <nl> } <nl> - return StringBuilderCache . GetStringAndRelease ( result ) ; <nl> } <nl> <nl> <nl> [ ComVisible ( false ) ] <nl> - public static String Concat ( IEnumerable < String > values ) { <nl> + public static string Concat ( IEnumerable < string > values ) <nl> + { <nl> if ( values = = null ) <nl> throw new ArgumentNullException ( \" values \" ) ; <nl> Contract . Ensures ( Contract . Result < String > ( ) ! = null ) ; <nl> Contract . EndContractBlock ( ) ; <nl> <nl> - StringBuilder result = StringBuilderCache . Acquire ( ) ; <nl> - using ( IEnumerator < String > en = values . GetEnumerator ( ) ) { <nl> - while ( en . MoveNext ( ) ) { <nl> - result . Append ( en . Current ) ; <nl> - } <nl> + using ( IEnumerator < string > en = values . GetEnumerator ( ) ) <nl> + { <nl> + if ( ! en . MoveNext ( ) ) <nl> + return string . Empty ; <nl> + <nl> + string firstValue = en . Current ; <nl> + <nl> + if ( ! en . MoveNext ( ) ) <nl> + { <nl> + return firstValue ? ? string . Empty ; <nl> + } <nl> + <nl> + StringBuilder result = StringBuilderCache . Acquire ( ) ; <nl> + result . Append ( firstValue ) ; <nl> + <nl> + do <nl> + { <nl> + result . Append ( en . Current ) ; <nl> + } <nl> + while ( en . MoveNext ( ) ) ; <nl> + <nl> + return StringBuilderCache . GetStringAndRelease ( result ) ; <nl> } <nl> - return StringBuilderCache . GetStringAndRelease ( result ) ; <nl> } <nl> <nl> <nl> public static string Concat ( params object [ ] args ) <nl> Contract . Ensures ( Contract . Result < String > ( ) ! = null ) ; <nl> Contract . EndContractBlock ( ) ; <nl> <nl> + if ( values . Length < = 1 ) <nl> + { <nl> + return values . Length = = 0 ? <nl> + string . Empty : <nl> + values [ 0 ] ? ? string . Empty ; <nl> + } <nl> + <nl> / / It ' s possible that the input values array could be changed concurrently on another <nl> / / thread , such that we can ' t trust that each read of values [ i ] will be equivalent . <nl> / / Worst case , we can make a defensive copy of the array and use that , but we first <nl>\n", "msg": "Further optimizations for String . Join , String . Concat ( dotnet / coreclr )\n"}
{"diff_id": 36283, "repo": "cefsharp/CefSharp\n", "sha": "68cf269af067a2959685e93111f594fbc29b4377\n", "time": "2014-08-27T04:25:18Z\n", "diff": "mmm a / CefSharp . BrowserSubprocess / CefRenderProcess . cs <nl> ppp b / CefSharp . BrowserSubprocess / CefRenderProcess . cs <nl> public override void OnBrowserCreated ( CefBrowserBase cefBrowserWrapper ) <nl> return ; <nl> } <nl> <nl> + var serviceName = RenderprocessClientFactory . GetServiceName ( ParentProcessId . Value , cefBrowserWrapper . BrowserId ) ; <nl> + <nl> channelFactory = new DuplexChannelFactory < IBrowserProcess > ( <nl> this , <nl> new NetNamedPipeBinding ( ) , <nl> - new EndpointAddress ( RenderprocessClientFactory . GetServiceName ( ParentProcessId . Value , cefBrowserWrapper . BrowserId ) ) <nl> + new EndpointAddress ( serviceName ) <nl> ) ; <nl> <nl> channelFactory . Open ( ) ; <nl>\n", "msg": "Move serviceName to variable - makes for easier debugging\n"}
{"diff_id": 36324, "repo": "duplicati/duplicati\n", "sha": "124a5c4cf5ad7c3af726057562e8ffde039c8d6a\n", "time": "2017-10-12T09:17:45Z\n", "diff": "mmm a / Duplicati / Library / AutoUpdater / UpdaterManager . cs <nl> ppp b / Duplicati / Library / AutoUpdater / UpdaterManager . cs <nl> private static int RunMethod ( System . Reflection . MethodInfo method , string [ ] args ) <nl> <nl> public static int RunFromMostRecent ( System . Reflection . MethodInfo method , string [ ] cmdargs , AutoUpdateStrategy defaultstrategy = AutoUpdateStrategy . CheckDuring ) <nl> { <nl> - return RunFromMostRecentSpawn ( method , cmdargs , defaultstrategy ) ; <nl> + if ( Library . Utility . Utility . ParseBool ( Environment . GetEnvironmentVariable ( \" AUTOUPDATER_USE_APPDOMAIN \" ) , false ) ) <nl> + return RunFromMostRecentAppDomain ( method , cmdargs , defaultstrategy ) ; <nl> + else <nl> + return RunFromMostRecentSpawn ( method , cmdargs , defaultstrategy ) ; <nl> } <nl> <nl> public static int RunFromMostRecentSpawn ( System . Reflection . MethodInfo method , string [ ] cmdargs , AutoUpdateStrategy defaultstrategy = AutoUpdateStrategy . CheckDuring ) <nl>\n", "msg": "Added temporary option to allow switching between the auto update invoke methods , in case we need to test something on installed machines\n"}
{"diff_id": 36325, "repo": "dotnet/maui\n", "sha": "2c49c739c5f8e04f99b80481fc1b7ba982b887ea\n", "time": "2020-04-20T18:53:03Z\n", "diff": "mmm a / Xamarin . Essentials / WebAuthenticator / WebAuthenticator . ios . tvos . cs <nl> ppp b / Xamarin . Essentials / WebAuthenticator / WebAuthenticator . ios . tvos . cs <nl> void AuthSessionCallback ( NSUrl cbUrl , NSError error ) <nl> sf . Start ( ) ; <nl> var result = await tcsResponse . Task ; <nl> sf ? . Dispose ( ) ; <nl> - was = null ; <nl> + sf = null ; <nl> return result ; <nl> } <nl> <nl>\n", "msg": "Update Xamarin . Essentials / WebAuthenticator / WebAuthenticator . ios . tvos . cs\n"}
{"diff_id": 36339, "repo": "JustArchiNET/ArchiSteamFarm\n", "sha": "f3da5d6afc44a3ad65c3014abaa089ba8f4cdca3\n", "time": "2016-04-23T14:21:12Z\n", "diff": "mmm a / ArchiSteamFarm / Bot . cs <nl> ppp b / ArchiSteamFarm / Bot . cs <nl> internal sealed class Bot { <nl> Task . Run ( ( ) = > HandleCallbacks ( ) ) . Forget ( ) ; <nl> } <nl> <nl> - / / 2FA tokens are expiring soon , use limiter only when we don ' t have any pending <nl> - if ( TwoFactorCode = = null ) { <nl> + / / 2FA tokens are expiring soon , use limiter only when user is providing one <nl> + if ( TwoFactorCode = = null | | BotDatabase . SteamGuardAccount ! = null ) { <nl> await Program . LimitSteamRequestsAsync ( ) . ConfigureAwait ( false ) ; <nl> } <nl> <nl> internal sealed class Bot { <nl> <nl> Logging . LogGenericInfo ( \" Reconnecting . . . \" , BotName ) ; <nl> <nl> - / / 2FA tokens are expiring soon , use limiter only when we don ' t have any pending <nl> - if ( TwoFactorCode = = null ) { <nl> + / / 2FA tokens are expiring soon , use limiter only when user is providing one <nl> + if ( TwoFactorCode = = null | | BotDatabase . SteamGuardAccount ! = null ) { <nl> await Program . LimitSteamRequestsAsync ( ) . ConfigureAwait ( false ) ; <nl> } <nl> <nl>\n", "msg": "Fix small regression caused by https : / / github . com / JustArchi / ArchiSteamFarm / commit / d0cc10f3c68457be2a42dc1b9ff57f0f055b348a\n"}
{"diff_id": 36403, "repo": "OpenRA/OpenRA\n", "sha": "05b6b59dadbf52cf52955712353c0118ab990313\n", "time": "2013-02-28T20:59:18Z\n", "diff": "mmm a / OpenRA . Mods . RA / Air / HeliAttack . cs <nl> ppp b / OpenRA . Mods . RA / Air / HeliAttack . cs <nl> public override Activity Tick ( Actor self ) <nl> } <nl> <nl> var attack = self . Trait < AttackHeli > ( ) ; <nl> - var range = attack . GetMaximumRange ( ) * 0 . 625f ; <nl> var dist = target . CenterLocation - self . CenterLocation ; <nl> <nl> var desiredFacing = Util . GetFacing ( dist , aircraft . Facing ) ; <nl> aircraft . Facing = Util . TickFacing ( aircraft . Facing , desiredFacing , aircraft . ROT ) ; <nl> <nl> - if ( ! float2 . WithinEpsilon ( float2 . Zero , dist . ToFloat2 ( ) , range * Game . CellSize ) ) <nl> + if ( ! Combat . IsInRange ( self . CenterLocation , attack . GetMaximumRange ( ) , target ) ) <nl> aircraft . TickMove ( PSubPos . PerPx * aircraft . MovementSpeed , desiredFacing ) ; <nl> <nl> attack . DoAttack ( self , target ) ; <nl>\n", "msg": "use Combat . IsInRange instead of float2 . WithinEpsilon for heli\n"}
{"diff_id": 36487, "repo": "nopSolutions/nopCommerce\n", "sha": "d154732838599f73ae0c9a64cc99a0008121274d\n", "time": "2015-10-15T09:25:33Z\n", "diff": "mmm a / src / Libraries / Nop . Services / Catalog / PriceCalculationService . cs <nl> ppp b / src / Libraries / Nop . Services / Catalog / PriceCalculationService . cs <nl> <nl> using Nop . Services . Catalog . Cache ; <nl> using Nop . Services . Customers ; <nl> using Nop . Services . Discounts ; <nl> + using OfficeOpenXml . ConditionalFormatting ; <nl> <nl> namespace Nop . Services . Catalog <nl> { <nl> protected class ProductPriceForCaching <nl> # region Utilities <nl> <nl> / / / < summary > <nl> - / / / Gets allowed discounts <nl> + / / / Gets allowed discounts applied to product <nl> / / / < / summary > <nl> / / / < param name = \" product \" > Product < / param > <nl> / / / < param name = \" customer \" > Customer < / param > <nl> / / / < returns > Discounts < / returns > <nl> - protected virtual IList < Discount > GetAllowedDiscounts ( Product product , <nl> - Customer customer ) <nl> + protected virtual IList < Discount > GetAllowedDiscountsAppliedToProduct ( Product product , Customer customer ) <nl> { <nl> var allowedDiscounts = new List < Discount > ( ) ; <nl> if ( _catalogSettings . IgnoreDiscounts ) <nl> return allowedDiscounts ; <nl> <nl> - / / discounts applied to products <nl> if ( product . HasDiscountsApplied ) <nl> { <nl> / / we use this property ( \" HasDiscountsApplied \" ) for performance optimziation to avoid unnecessary database calls <nl> protected class ProductPriceForCaching <nl> } <nl> } <nl> <nl> - / / discounts applied to categories <nl> + return allowedDiscounts ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Gets allowed discounts applied to categories <nl> + / / / < / summary > <nl> + / / / < param name = \" product \" > Product < / param > <nl> + / / / < param name = \" customer \" > Customer < / param > <nl> + / / / < returns > Discounts < / returns > <nl> + protected virtual IList < Discount > GetAllowedDiscountsAppliedToCategories ( Product product , Customer customer ) <nl> + { <nl> + var allowedDiscounts = new List < Discount > ( ) ; <nl> + if ( _catalogSettings . IgnoreDiscounts ) <nl> + return allowedDiscounts ; <nl> + <nl> foreach ( var discount in _discountService . GetAllDiscounts ( DiscountType . AssignedToCategories ) ) <nl> { <nl> / / load identifier of categories with this discount applied to <nl> protected class ProductPriceForCaching <nl> } <nl> return categoryIds ; <nl> } ) ; <nl> - <nl> + <nl> / / compare with categories of this product <nl> if ( appliedToCategoryIds . Any ( ) ) <nl> { <nl> protected class ProductPriceForCaching <nl> } <nl> } <nl> <nl> - / / discounts applied to manufacturers <nl> + return allowedDiscounts ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Gets allowed discounts applied to manufacturers <nl> + / / / < / summary > <nl> + / / / < param name = \" product \" > Product < / param > <nl> + / / / < param name = \" customer \" > Customer < / param > <nl> + / / / < returns > Discounts < / returns > <nl> + protected virtual IList < Discount > GetAllowedDiscountsAppliedToManufacturers ( Product product , Customer customer ) <nl> + { <nl> + var allowedDiscounts = new List < Discount > ( ) ; <nl> + if ( _catalogSettings . IgnoreDiscounts ) <nl> + return allowedDiscounts ; <nl> + <nl> foreach ( var discount in _discountService . GetAllDiscounts ( DiscountType . AssignedToManufacturers ) ) <nl> { <nl> / / load identifier of categories with this discount applied to <nl> protected class ProductPriceForCaching <nl> <nl> return allowedDiscounts ; <nl> } <nl> + <nl> + / / / < summary > <nl> + / / / Gets allowed discounts <nl> + / / / < / summary > <nl> + / / / < param name = \" product \" > Product < / param > <nl> + / / / < param name = \" customer \" > Customer < / param > <nl> + / / / < returns > Discounts < / returns > <nl> + protected virtual IList < Discount > GetAllowedDiscounts ( Product product , Customer customer ) <nl> + { <nl> + var allowedDiscounts = new List < Discount > ( ) ; <nl> + if ( _catalogSettings . IgnoreDiscounts ) <nl> + return allowedDiscounts ; <nl> + <nl> + / / discounts applied to products <nl> + foreach ( var discount in GetAllowedDiscountsAppliedToProduct ( product , customer ) ) <nl> + if ( ! allowedDiscounts . ContainsDiscount ( discount ) ) <nl> + allowedDiscounts . Add ( discount ) ; <nl> + <nl> + / / discounts applied to categories <nl> + foreach ( var discount in GetAllowedDiscountsAppliedToCategories ( product , customer ) ) <nl> + if ( ! allowedDiscounts . ContainsDiscount ( discount ) ) <nl> + allowedDiscounts . Add ( discount ) ; <nl> + <nl> + / / discounts applied to manufacturers <nl> + foreach ( var discount in GetAllowedDiscountsAppliedToManufacturers ( product , customer ) ) <nl> + if ( ! allowedDiscounts . ContainsDiscount ( discount ) ) <nl> + allowedDiscounts . Add ( discount ) ; <nl> + <nl> + return allowedDiscounts ; <nl> + } <nl> <nl> / / / < summary > <nl> / / / Gets a tier price <nl>\n", "msg": "Refactoring of source code ( previous commit ) .\n"}
{"diff_id": 36569, "repo": "dotnet/runtime\n", "sha": "de83f4b8de1d824843a4598fabdc8f7764773959\n", "time": "2016-03-05T16:29:38Z\n", "diff": "mmm a / src / libraries / System . Runtime / tests / System / Guid . cs <nl> ppp b / src / libraries / System . Runtime / tests / System / Guid . cs <nl> public static void TestParse_Invalid ( string input , Type exceptionType ) <nl> Guid result ; <nl> <nl> Assert . False ( Guid . TryParse ( input , out result ) ) ; <nl> + Assert . Equal ( Guid . Empty , result ) ; <nl> <nl> Assert . False ( Guid . TryParseExact ( input , \" N \" , out result ) ) ; <nl> + Assert . Equal ( Guid . Empty , result ) ; <nl> + <nl> Assert . False ( Guid . TryParseExact ( input , \" D \" , out result ) ) ; <nl> + Assert . Equal ( Guid . Empty , result ) ; <nl> + <nl> Assert . False ( Guid . TryParseExact ( input , \" B \" , out result ) ) ; <nl> - Assert . False ( Guid . TryParseExact ( input , \" P \" , out result ) ) ; <nl> - Assert . False ( Guid . TryParseExact ( input , \" X \" , out result ) ) ; <nl> - } <nl> + Assert . Equal ( Guid . Empty , result ) ; <nl> <nl> - [ ActiveIssue ( 6316 ) ] <nl> - [ Theory ] <nl> - [ MemberData ( nameof ( GuidStrings_Format_Invalid_TryParseThrows_TestData ) ) ] <nl> - public static void TestTryParse_Invalid_ReturnsFals ( string input , string format , Type exceptionType ) <nl> - { <nl> - Guid result ; <nl> - Assert . False ( Guid . TryParse ( input , out result ) ) ; <nl> + Assert . False ( Guid . TryParseExact ( input , \" P \" , out result ) ) ; <nl> Assert . Equal ( Guid . Empty , result ) ; <nl> <nl> Assert . False ( Guid . TryParseExact ( input , \" X \" , out result ) ) ; <nl> public static IEnumerable < object [ ] > GuidStrings_Invalid_TestData ( ) <nl> <nl> yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 <nl> yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } - missing group <nl> - <nl> + yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } - extra group <nl> + <nl> yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } with leading brace only <nl> yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } with leading brace only <nl> <nl> public static IEnumerable < object [ ] > GuidStrings_Invalid_TestData ( ) <nl> yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xddd , 0xddd , 0xdd , 0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 3 - 2 - 2 } <nl> yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xddd , 0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 3 - 2 } <nl> yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xddd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 3 } <nl> + <nl> + yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> + yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> + yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> + yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd0xdd , 0xdd , 0xdd , 0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> + yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd0xdd , 0xdd , 0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> + yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd0xdd , 0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd0xdd } } \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> } <nl> <nl> public static IEnumerable < object [ ] > GuidStrings_Format_Invalid_TestData ( ) <nl> yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , \" B \" , typeof ( FormatException ) } ; / / Hex values <nl> yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , \" P \" , typeof ( FormatException ) } ; / / Hex values <nl> } <nl> - <nl> - public static IEnumerable < object [ ] > GuidStrings_Format_Invalid_TryParseThrows_TestData ( ) <nl> - { <nl> - yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , \" X \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } - extra group <nl> - <nl> - yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , \" X \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> - yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , \" X \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> - yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd0xdd , 0xdd , 0xdd , 0xdd , 0xdd } } \" , \" X \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> - yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd0xdd , 0xdd , 0xdd , 0xdd } } \" , \" X \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> - yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd0xdd , 0xdd , 0xdd } } \" , \" X \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> - yield return new object [ ] { \" { 0xdddddddd , 0xdddd , 0xdddd , { 0xdd , 0xdd , 0xdd , 0xdd , 0xdd , 0xdd0xdd , 0xdd } } \" , \" X \" , typeof ( FormatException ) } ; / / 8 - 4 - 4 - { 2 - 2 - 2 - 2 - 2 - 2 - 2 - 2 } without comma <nl> - } <nl> } <nl>\n", "msg": "Enable some Guid tests now that dotnet / corefx has been fixed\n"}
{"diff_id": 36795, "repo": "mono/mono\n", "sha": "11661568def2bffa361a6aba8496e0d7fa92a351\n", "time": "2013-04-23T11:41:19Z\n", "diff": "mmm a / mcs / class / Mono . Debugger . Soft / Test / dtest . cs <nl> ppp b / mcs / class / Mono . Debugger . Soft / Test / dtest . cs <nl> public class DebuggerTests <nl> TypeMirror t = child . Type ; <nl> } ) ; <nl> * / <nl> - <nl> + / * <nl> AssertThrows < ObjectCollectedException > ( delegate ( ) { <nl> long addr = child . Address ; <nl> } ) ; <nl> + * / <nl> } <nl> <nl> [ Test ] <nl>\n", "msg": "Disable an sdb test which is not deterministic .\n"}
{"diff_id": 36921, "repo": "mRemoteNG/mRemoteNG\n", "sha": "b65fdbdd78985021657d7278f5a7a999d821f514\n", "time": "2016-09-09T15:50:06Z\n", "diff": "mmm a / mRemoteV1 / Connection / ConnectionInfo . cs <nl> ppp b / mRemoteV1 / Connection / ConnectionInfo . cs <nl> public virtual void Dispose ( ) <nl> { <nl> RemoveParent ( ) ; <nl> } <nl> - # endregion <nl> + <nl> + public override bool Equals ( object otherObject ) <nl> + { <nl> + var otherObjectAsConnectionInfo = otherObject as ConnectionInfo ; <nl> + if ( otherObjectAsConnectionInfo = = null ) return false ; <nl> + return otherObjectAsConnectionInfo . ConstantID = = ConstantID ; <nl> + } <nl> + <nl> + # endregion <nl> <nl> # region Public Enumerations <nl> [ Flags ( ) ] <nl>\n", "msg": "Overrode the Equals method for ConnectionInfo . Equality based on ConstantID\n"}
{"diff_id": 36959, "repo": "Radarr/Radarr\n", "sha": "04fec6d4d8a5c0a8db20c0e06f328479ab433197\n", "time": "2017-01-11T00:09:12Z\n", "diff": "mmm a / src / NzbDrone . Core / Indexers / Newznab / NewznabSettings . cs <nl> ppp b / src / NzbDrone . Core / Indexers / Newznab / NewznabSettings . cs <nl> public class NewznabSettings : IProviderConfig <nl> <nl> public NewznabSettings ( ) <nl> { <nl> - Categories = new [ ] { 2030 , 2040 , 2050 } ; <nl> + Categories = new [ ] { 2030 , 2035 , 2040 , 2050 } ; <nl> AnimeCategories = Enumerable . Empty < int > ( ) ; <nl> } <nl> <nl>\n", "msg": "Add category 2035 to Newznab providers for WEB - DL search support .\n"}
{"diff_id": 37006, "repo": "MahApps/MahApps.Metro\n", "sha": "db93d32150cb752a7094085d34f42f5ad7084c76\n", "time": "2013-12-03T12:46:50Z\n", "diff": "mmm a / MahApps . Metro / Behaviours / GlowWindowBehavior . cs <nl> ppp b / MahApps . Metro / Behaviours / GlowWindowBehavior . cs <nl> <nl>  using System . Windows ; <nl> using System . Windows . Interactivity ; <nl> - using System . Windows . Media . Animation ; <nl> using MahApps . Metro . Controls ; <nl> <nl> namespace MahApps . Metro . Behaviours <nl> protected override void OnAttached ( ) <nl> this . bottom = new GlowWindow ( this . AssociatedObject , GlowDirection . Bottom ) ; <nl> <nl> this . Show ( ) ; <nl> - <nl> - this . left . Update ( ) ; <nl> - this . right . Update ( ) ; <nl> - this . top . Update ( ) ; <nl> - this . bottom . Update ( ) ; <nl> + this . Update ( ) ; <nl> <nl> var windowTransitionsEnabled = metroWindow ! = null & & metroWindow . WindowTransitionsEnabled ; <nl> - if ( ! windowTransitionsEnabled ) { <nl> - this . left . Opacity = 1 ; <nl> - this . right . Opacity = 1 ; <nl> - this . top . Opacity = 1 ; <nl> - this . bottom . Opacity = 1 ; <nl> + if ( ! windowTransitionsEnabled ) <nl> + { <nl> + / / no storyboard so set opacity to 1 <nl> + this . SetOpacityTo ( 1 ) ; <nl> } <nl> else <nl> { <nl> - if ( this . left . OpacityStoryboard ! = null <nl> - & & this . right . OpacityStoryboard ! = null <nl> - & & this . top . OpacityStoryboard ! = null <nl> - & & this . bottom . OpacityStoryboard ! = null ) <nl> + / / start the opacity storyboard 0 - > 1 <nl> + this . StartOpacityStoryboard ( ) ; <nl> + / / hide the glows if window get invisible state <nl> + this . AssociatedObject . IsVisibleChanged + = this . AssociatedObject_IsVisibleChanged ; <nl> + / / closing always handled <nl> + this . AssociatedObject . Closing + = ( o , args ) = > <nl> { <nl> - this . left . BeginStoryboard ( this . left . OpacityStoryboard ) ; <nl> - this . right . BeginStoryboard ( this . right . OpacityStoryboard ) ; <nl> - this . top . BeginStoryboard ( this . top . OpacityStoryboard ) ; <nl> - this . bottom . BeginStoryboard ( this . bottom . OpacityStoryboard ) ; <nl> - } <nl> + if ( ! args . Cancel ) <nl> + { <nl> + this . AssociatedObject . IsVisibleChanged - = this . AssociatedObject_IsVisibleChanged ; <nl> + } <nl> + } ; <nl> } <nl> } ; <nl> + } <nl> + <nl> + private void AssociatedObject_IsVisibleChanged ( object sender , DependencyPropertyChangedEventArgs e ) <nl> + { <nl> + this . Update ( ) ; <nl> <nl> - this . AssociatedObject . Closed + = ( sender , args ) = > <nl> + if ( ! this . AssociatedObject . IsVisible ) <nl> { <nl> - if ( left ! = null ) left . Close ( ) ; <nl> - if ( right ! = null ) right . Close ( ) ; <nl> - if ( top ! = null ) top . Close ( ) ; <nl> - if ( bottom ! = null ) bottom . Close ( ) ; <nl> - } ; <nl> + / / the associated owner got invisible so set opacity to 0 to start the storyboard by 0 for the next visible state <nl> + this . SetOpacityTo ( 0 ) ; <nl> + } <nl> + else <nl> + { <nl> + this . StartOpacityStoryboard ( ) ; <nl> + } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Updates all glow windows ( visible , hidden , collapsed ) <nl> + / / / < / summary > <nl> + private void Update ( ) <nl> + { <nl> + if ( this . left ! = null <nl> + & & this . right ! = null <nl> + & & this . top ! = null <nl> + & & this . bottom ! = null ) <nl> + { <nl> + this . left . Update ( ) ; <nl> + this . right . Update ( ) ; <nl> + this . top . Update ( ) ; <nl> + this . bottom . Update ( ) ; <nl> + } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Sets the opacity to all glow windows <nl> + / / / < / summary > <nl> + private void SetOpacityTo ( double newOpacity ) <nl> + { <nl> + if ( this . left ! = null <nl> + & & this . right ! = null <nl> + & & this . top ! = null <nl> + & & this . bottom ! = null ) <nl> + { <nl> + this . left . Opacity = newOpacity ; <nl> + this . right . Opacity = newOpacity ; <nl> + this . top . Opacity = newOpacity ; <nl> + this . bottom . Opacity = newOpacity ; <nl> + } <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Starts the opacity storyboard 0 - > 1 <nl> + / / / < / summary > <nl> + private void StartOpacityStoryboard ( ) <nl> + { <nl> + if ( this . left ! = null & & this . left . OpacityStoryboard ! = null <nl> + & & this . right ! = null & & this . right . OpacityStoryboard ! = null <nl> + & & this . top ! = null & & this . top . OpacityStoryboard ! = null <nl> + & & this . bottom ! = null & & this . bottom . OpacityStoryboard ! = null ) <nl> + { <nl> + this . left . BeginStoryboard ( this . left . OpacityStoryboard ) ; <nl> + this . right . BeginStoryboard ( this . right . OpacityStoryboard ) ; <nl> + this . top . BeginStoryboard ( this . top . OpacityStoryboard ) ; <nl> + this . bottom . BeginStoryboard ( this . bottom . OpacityStoryboard ) ; <nl> + } <nl> } <nl> <nl> - public void Show ( ) <nl> + / / / < summary > <nl> + / / / Shows all glow windows <nl> + / / / < / summary > <nl> + private void Show ( ) <nl> { <nl> left . Show ( ) ; <nl> right . Show ( ) ; <nl>\n", "msg": "handle visibility from associated owner for all glow windows\n"}
{"diff_id": 37019, "repo": "gitextensions/gitextensions\n", "sha": "29b7cfd18d0d216ff59b95ec6e7f38a673eda85c\n", "time": "2018-11-25T09:48:54Z\n", "diff": "mmm a / GitUI / CommandsDialogs / FormBrowse . cs <nl> ppp b / GitUI / CommandsDialogs / FormBrowse . cs <nl> private void LayoutRevisionInfo ( ) <nl> if ( commitInfoPosition = = CommitInfoPosition . RightwardFromList ) <nl> { <nl> RevisionsSplitContainer . FixedPanel = FixedPanel . Panel2 ; <nl> - RevisionsSplitContainer . SplitterDistance = RevisionsSplitContainer . Width - width ; <nl> + RevisionsSplitContainer . SplitterDistance = Math . Max ( 0 , RevisionsSplitContainer . Width - width ) ; <nl> RevisionInfo . Parent = RevisionsSplitContainer . Panel2 ; <nl> RevisionGrid . Parent = RevisionsSplitContainer . Panel1 ; <nl> } <nl>\n", "msg": "Limits RevisionsSplitContainer . SplitterDistance to a min of 0\n"}
{"diff_id": 37055, "repo": "MonoGame/MonoGame\n", "sha": "82880e337848ab3e7141344af91f710a2f9a00a9\n", "time": "2013-05-03T01:56:47Z\n", "diff": "mmm a / MonoGame . Framework / WindowsPhone / WPGameWindow . cs <nl> ppp b / MonoGame . Framework / WindowsPhone / WPGameWindow . cs <nl> public WindowsPhoneGameWindow ( Game game ) <nl> _orientation = ToOrientation ( Page . Orientation ) ; <nl> Page . OrientationChanged + = Page_OrientationChanged ; <nl> <nl> - PhoneApplicationService . Current . Activated + = ( sender , e ) = > Platform . IsActive = true ; <nl> - PhoneApplicationService . Current . Launching + = ( sender , e ) = > Platform . IsActive = true ; <nl> - PhoneApplicationService . Current . Deactivated + = ( sender , e ) = > Platform . IsActive = false ; <nl> - PhoneApplicationService . Current . Closing + = ( sender , e ) = > Platform . IsActive = false ; <nl> + PhoneApplicationService . Current . Activated + = ( sender , e ) = > { if ( Game . Instance ! = null ) Platform . IsActive = true ; } ; <nl> + PhoneApplicationService . Current . Launching + = ( sender , e ) = > { if ( Game . Instance ! = null ) Platform . IsActive = true ; } ; <nl> + PhoneApplicationService . Current . Deactivated + = ( sender , e ) = > { if ( Game . Instance ! = null ) Platform . IsActive = false ; } ; <nl> + PhoneApplicationService . Current . Closing + = ( sender , e ) = > { if ( Game . Instance ! = null ) Platform . IsActive = false ; } ; <nl> <nl> SetClientBounds ( Width , Height ) ; <nl> } <nl>\n", "msg": "Added null checks to fix crash on exit if game has been disposed .\n"}
{"diff_id": 37085, "repo": "HangfireIO/Hangfire\n", "sha": "d5dc0d597481f8deb4abb6cca947fc7da3ab23c0\n", "time": "2016-12-02T12:41:38Z\n", "diff": "mmm a / src / Hangfire . Core / Server / RecurringJobScheduler . cs <nl> ppp b / src / Hangfire . Core / Server / RecurringJobScheduler . cs <nl> public void Execute ( BackgroundProcessContext context ) <nl> ex ) ; <nl> } <nl> } <nl> - <nl> - _throttler . Delay ( context . CancellationToken ) ; <nl> } <nl> + <nl> + / / The code above may be completed in less than a second . Default throttler use <nl> + / / the second resolution , and without an extra delay , CPU and DB bursts may happen . <nl> + _throttler . Delay ( context . CancellationToken ) ; <nl> } <nl> <nl> / / / < inheritdoc / > <nl>\n", "msg": "Move throttler . Delay call outside of connection and lock\n"}
{"diff_id": 37366, "repo": "restsharp/RestSharp\n", "sha": "ef43aae63c04c1dae1646528bfe321ac76340ee5\n", "time": "2013-12-28T12:21:29Z\n", "diff": "mmm a / RestSharp / RestClient . cs <nl> ppp b / RestSharp / RestClient . cs <nl> private IRestResponse < T > Deserialize < T > ( IRestRequest request , IRestResponse raw ) <nl> / / Only attempt to deserialize if the request has not errored due <nl> / / to a transport or framework exception . HTTP errors should attempt to <nl> / / be deserialized <nl> - <nl> if ( response . ErrorException = = null ) <nl> { <nl> IDeserializer handler = GetHandler ( raw . ContentType ) ; <nl> - handler . RootElement = request . RootElement ; <nl> - handler . DateFormat = request . DateFormat ; <nl> - handler . Namespace = request . XmlNamespace ; <nl> - <nl> - response . Data = handler . Deserialize < T > ( raw ) ; <nl> + / / Only continue if there is a handler defined else there is no way to deserialize the data . <nl> + / / This can happen when a request returns for example a 404 page instead of the requested JSON / XML resource <nl> + if ( handler ! = null ) <nl> + { <nl> + handler . RootElement = request . RootElement ; <nl> + handler . DateFormat = request . DateFormat ; <nl> + handler . Namespace = request . XmlNamespace ; <nl> + <nl> + response . Data = handler . Deserialize < T > ( raw ) ; <nl> + } <nl> } <nl> } <nl> catch ( Exception ex ) <nl>\n", "msg": "Prevent object is null or undefined exception when the request returns an unexpected type before deserializing ( type for which no handler is defined )\n"}
{"diff_id": 37476, "repo": "mono/mono\n", "sha": "94baf5685b5cd449596ff6f5ab7face9e3167b58\n", "time": "2013-02-18T23:09:42Z\n", "diff": "mmm a / mcs / class / corlib / System / MarshalByRefObject . cs <nl> ppp b / mcs / class / corlib / System / MarshalByRefObject . cs <nl> namespace System <nl> [ StructLayout ( LayoutKind . Sequential ) ] <nl> public abstract class MarshalByRefObject <nl> { <nl> + # if MOBILE <nl> + private object _dummy ; / / Keep layout equal to avoid runtime issues <nl> + # else <nl> [ NonSerialized ] <nl> private ServerIdentity _identity ; / / Holds marshalling iformation of the object <nl> + # endif <nl> <nl> protected MarshalByRefObject ( ) <nl> { <nl> } <nl> <nl> + # if MOBILE <nl> + internal ServerIdentity ObjectIdentity { <nl> + get { throw new NotSupportedException ( ) ; } <nl> + set { throw new NotSupportedException ( ) ; } <nl> + } <nl> + # else <nl> + <nl> internal Identity GetObjectIdentity ( MarshalByRefObject obj , out bool IsClient ) <nl> { <nl> IsClient = false ; <nl> internal Identity GetObjectIdentity ( MarshalByRefObject obj , out bool IsClient ) <nl> get { return _identity ; } <nl> set { _identity = value ; } <nl> } <nl> + # endif <nl> <nl> [ SecurityPermission ( SecurityAction . LinkDemand , Infrastructure = true ) ] <nl> public virtual ObjRef CreateObjRef ( Type requestedType ) <nl> { <nl> + # if MOBILE <nl> + throw new NotSupportedException ( ) ; <nl> + # else <nl> / / This method can only be called when this object has been marshalled <nl> if ( _identity = = null ) <nl> throw new RemotingException ( Locale . GetText ( \" No remoting information was found for the object . \" ) ) ; <nl> return _identity . CreateObjRef ( requestedType ) ; <nl> + # endif <nl> } <nl> <nl> / / corcompare says it is \" virtual final \" , so there is likely <nl> public virtual ObjRef CreateObjRef ( Type requestedType ) <nl> [ SecurityPermission ( SecurityAction . LinkDemand , Infrastructure = true ) ] <nl> public object GetLifetimeService ( ) <nl> { <nl> + # if MOBILE <nl> + throw new NotSupportedException ( ) ; <nl> + # else <nl> + <nl> if ( _identity = = null ) <nl> return null ; <nl> else return _identity . Lease ; <nl> + # endif <nl> } <nl> <nl> [ SecurityPermission ( SecurityAction . LinkDemand , Infrastructure = true ) ] <nl> public virtual object InitializeLifetimeService ( ) <nl> { <nl> + # if MOBILE <nl> + throw new NotSupportedException ( ) ; <nl> + # else <nl> if ( _identity ! = null & & _identity . Lease ! = null ) <nl> return _identity . Lease ; <nl> else <nl> return new System . Runtime . Remoting . Lifetime . Lease ( ) ; <nl> + # endif <nl> } <nl> <nl> protected MarshalByRefObject MemberwiseClone ( bool cloneIdentity ) <nl> { <nl> + # if MOBILE <nl> + throw new NotSupportedException ( ) ; <nl> + # else <nl> MarshalByRefObject mbr = ( MarshalByRefObject ) MemberwiseClone ( ) ; <nl> if ( ! cloneIdentity ) <nl> mbr . _identity = null ; <nl> return mbr ; <nl> + # endif <nl> } <nl> } <nl> } <nl>\n", "msg": "Stub the implementation of MarshalByRef to help the linker kill some remoting code .\n"}
{"diff_id": 37540, "repo": "NancyFx/Nancy\n", "sha": "ac2336a4dddd95160999acd88d41d867dcf92131\n", "time": "2011-10-25T09:11:18Z\n", "diff": "mmm a / src / Nancy . Authentication . Basic / BasicAuthenticationConfiguration . cs <nl> ppp b / src / Nancy . Authentication . Basic / BasicAuthenticationConfiguration . cs <nl> <nl> <nl> namespace Nancy . Authentication . Basic <nl> { <nl> - / / / < summary > <nl> - / / / Configuration options for forms authentication <nl> - / / / < / summary > <nl> - public class BasicAuthenticationConfiguration <nl> - { <nl> - / / / < summary > <nl> - / / / Initializes a new instance of the < see cref = \" BasicAuthenticationConfiguration \" / > class . <nl> + / / / < summary > <nl> + / / / Configuration options for forms authentication <nl> + / / / < / summary > <nl> + public class BasicAuthenticationConfiguration <nl> + { <nl> + / / / < summary > <nl> + / / / Initializes a new instance of the < see cref = \" BasicAuthenticationConfiguration \" / > class . <nl> / / / < / summary > <nl> - / / / < param name = \" userValidator \" > A valid instance of < see cref = \" IUserValidator \" / > class < / param > <nl> - / / / < param name = \" realm \" > Basic authentication realm < / param > <nl> + / / / < param name = \" userValidator \" > A valid instance of < see cref = \" IUserValidator \" / > class < / param > <nl> + / / / < param name = \" realm \" > Basic authentication realm < / param > <nl> / / / < param name = \" promptUser \" > Tell the browser to prompt the user for credentials < / param > <nl> - public BasicAuthenticationConfiguration ( IUserValidator userValidator , string realm , bool promptUser = true ) <nl> + public BasicAuthenticationConfiguration ( IUserValidator userValidator , string realm , bool promptUser = true ) <nl> { <nl> - if ( userValidator = = null ) <nl> - throw new ArgumentNullException ( \" userValidator \" ) ; <nl> + if ( userValidator = = null ) <nl> + throw new ArgumentNullException ( \" userValidator \" ) ; <nl> <nl> - if ( string . IsNullOrEmpty ( realm ) ) <nl> - throw new ArgumentException ( \" realm \" ) ; <nl> + if ( string . IsNullOrEmpty ( realm ) ) <nl> + throw new ArgumentException ( \" realm \" ) ; <nl> <nl> - this . UserValidator = userValidator ; <nl> - this . Realm = realm ; <nl> + this . UserValidator = userValidator ; <nl> + this . Realm = realm ; <nl> this . PromptUser = promptUser ; <nl> } <nl> <nl> - / / / < summary > <nl> - / / / Gets the user validator <nl> - / / / < / summary > <nl> - public IUserValidator UserValidator <nl> - { <nl> - get ; <nl> - private set ; <nl> - } <nl> + / / / < summary > <nl> + / / / Gets the user validator <nl> + / / / < / summary > <nl> + public IUserValidator UserValidator <nl> + { <nl> + get ; <nl> + private set ; <nl> + } <nl> <nl> - / / / < summary > <nl> - / / / Gets the basic authentication realm <nl> - / / / < / summary > <nl> - public string Realm <nl> - { <nl> - get ; <nl> - private set ; <nl> - } <nl> + / / / < summary > <nl> + / / / Gets the basic authentication realm <nl> + / / / < / summary > <nl> + public string Realm <nl> + { <nl> + get ; <nl> + private set ; <nl> + } <nl> <nl> / / / < summary > <nl> / / / Determines whether the browser should prompt for credentials <nl> public bool PromptUser <nl> get ; <nl> private set ; <nl> } <nl> - } <nl> + } <nl> } <nl>\n", "msg": "Reformatted file to use spaces instead of tabs to match the rest of the project .\n"}
{"diff_id": 37783, "repo": "mono/mono\n", "sha": "55e06987d3c604d4dde885c4ff099c0e349f306e\n", "time": "2015-04-03T07:58:49Z\n", "diff": "mmm a / mcs / class / corlib / System / TimeZoneInfo . cs <nl> ppp b / mcs / class / corlib / System / TimeZoneInfo . cs <nl> private static string TrimSpecial ( string str ) <nl> } <nl> # endif <nl> <nl> + public static bool TryAddTicks ( DateTime date , long ticks , out DateTime result , DateTimeKind kind = DateTimeKind . Unspecified ) <nl> + { <nl> + var resultTicks = date . Ticks + ticks ; <nl> + if ( resultTicks < DateTime . MinValue . Ticks | | resultTicks > DateTime . MaxValue . Ticks ) { <nl> + result = default ( DateTime ) ; <nl> + return false ; <nl> + } <nl> + <nl> + result = new DateTime ( resultTicks , kind ) ; <nl> + return true ; <nl> + } <nl> + <nl> public static void ClearCachedData ( ) <nl> { <nl> local = null ; <nl> private DateTime ConvertTimeFromUtc ( DateTime dateTime ) <nl> <nl> var kind = ( this = = TimeZoneInfo . Local ) ? DateTimeKind . Local : DateTimeKind . Unspecified ; <nl> <nl> - return DateTime . SpecifyKind ( dateTime + utcOffset , kind ) ; <nl> + DateTime result ; <nl> + if ( ! TryAddTicks ( dateTime , utcOffset . Ticks , out result , kind ) ) <nl> + return DateTime . SpecifyKind ( DateTime . MaxValue , kind ) ; <nl> + <nl> + return result ; <nl> } <nl> <nl> public static DateTime ConvertTimeFromUtc ( DateTime dateTime , TimeZoneInfo destinationTimeZone ) <nl> static DateTime ConvertTimeToUtc ( DateTime dateTime , TimeZoneInfo sourceTimeZone <nl> bool isDst ; <nl> var utcOffset = sourceTimeZone . GetUtcOffset ( dateTime , out isDst ) ; <nl> <nl> - return DateTime . SpecifyKind ( dateTime - utcOffset , DateTimeKind . Utc ) ; <nl> + DateTime utcDateTime ; <nl> + if ( ! TryAddTicks ( dateTime , - utcOffset . Ticks , out utcDateTime , DateTimeKind . Utc ) ) <nl> + return DateTime . SpecifyKind ( DateTime . MinValue , DateTimeKind . Utc ) ; <nl> + <nl> + return utcDateTime ; <nl> } <nl> <nl> static internal TimeSpan GetDateTimeNowUtcOffsetFromUtc ( DateTime time , out Boolean isAmbiguousLocalDst ) <nl> private TimeSpan GetUtcOffset ( DateTime dateTime , out bool isDST ) <nl> return tzOffset ; <nl> } <nl> <nl> - var utcTicks = dateTime . Ticks - tzOffset . Ticks ; <nl> - if ( utcTicks < 0 | | utcTicks > DateTime . MaxValue . Ticks ) <nl> + DateTime utcDateTime ; <nl> + if ( ! TryAddTicks ( dateTime , - tzOffset . Ticks , out utcDateTime , DateTimeKind . Utc ) ) <nl> return BaseUtcOffset ; <nl> <nl> - var utcDateTime = new DateTime ( utcTicks , DateTimeKind . Utc ) ; <nl> - <nl> return GetUtcOffsetHelper ( utcDateTime , this , out isDST ) ; <nl> } <nl> <nl> private static TimeSpan GetUtcOffsetHelper ( DateTime dateTime , TimeZoneInfo tz , <nl> return tz . BaseUtcOffset ; <nl> } <nl> <nl> - var stdTicks = dateTime . Ticks - tz . BaseUtcOffset . Ticks ; <nl> - if ( stdTicks < 0 | | stdTicks > DateTime . MaxValue . Ticks ) <nl> + DateTime stdUtcDateTime ; <nl> + if ( ! TryAddTicks ( dateTime , - tz . BaseUtcOffset . Ticks , out stdUtcDateTime , DateTimeKind . Utc ) ) <nl> return tz . BaseUtcOffset ; <nl> <nl> - var stdUtcDateTime = new DateTime ( stdTicks , DateTimeKind . Utc ) ; <nl> var tzRule = tz . GetApplicableRule ( stdUtcDateTime ) ; <nl> <nl> DateTime dstUtcDateTime = DateTime . MinValue ; <nl> if ( tzRule ! = null ) { <nl> - var dstTicks = stdUtcDateTime . Ticks - tzRule . DaylightDelta . Ticks ; <nl> - if ( dstTicks < 0 | | dstTicks > DateTime . MaxValue . Ticks ) <nl> + if ( ! TryAddTicks ( stdUtcDateTime , - tzRule . DaylightDelta . Ticks , out dstUtcDateTime , DateTimeKind . Utc ) ) <nl> return tz . BaseUtcOffset ; <nl> - <nl> - dstUtcDateTime = new DateTime ( dstTicks , DateTimeKind . Utc ) ; <nl> } <nl> <nl> if ( tzRule ! = null & & tz . IsInDST ( tzRule , stdUtcDateTime ) & & tz . IsInDST ( tzRule , dstUtcDateTime ) ) { <nl> private AdjustmentRule GetApplicableRule ( DateTime dateTime ) <nl> / / Applicable rules are in standard time <nl> DateTime date = dateTime ; <nl> <nl> - if ( dateTime . Kind = = DateTimeKind . Local & & this ! = TimeZoneInfo . Local ) <nl> - date = date . ToUniversalTime ( ) + BaseUtcOffset ; <nl> - else if ( dateTime . Kind = = DateTimeKind . Utc & & this ! = TimeZoneInfo . Utc ) <nl> - date = date + BaseUtcOffset ; <nl> + if ( dateTime . Kind = = DateTimeKind . Local & & this ! = TimeZoneInfo . Local ) { <nl> + if ( ! TryAddTicks ( date . ToUniversalTime ( ) , BaseUtcOffset . Ticks , out date ) ) <nl> + return null ; <nl> + } else if ( dateTime . Kind = = DateTimeKind . Utc & & this ! = TimeZoneInfo . Utc ) { <nl> + if ( ! TryAddTicks ( date , BaseUtcOffset . Ticks , out date ) ) <nl> + return null ; <nl> + } <nl> <nl> / / get the date component of the datetime <nl> date = date . Date ; <nl> private bool TryGetTransitionOffset ( DateTime dateTime , out TimeSpan offset , out <nl> DateTime date = dateTime ; <nl> <nl> if ( dateTime . Kind = = DateTimeKind . Local & & this ! = TimeZoneInfo . Local ) { <nl> - var ticks = date . ToUniversalTime ( ) . Ticks + BaseUtcOffset . Ticks ; <nl> - if ( ticks < DateTime . MinValue . Ticks | | ticks > DateTime . MaxValue . Ticks ) <nl> + if ( ! TryAddTicks ( date . ToUniversalTime ( ) , BaseUtcOffset . Ticks , out date , DateTimeKind . Utc ) ) <nl> return false ; <nl> - <nl> - date = new DateTime ( ticks , DateTimeKind . Utc ) ; <nl> } <nl> <nl> if ( dateTime . Kind ! = DateTimeKind . Utc ) { <nl> - var ticks = date . Ticks - BaseUtcOffset . Ticks ; <nl> - if ( ticks < DateTime . MinValue . Ticks | | ticks > DateTime . MaxValue . Ticks ) <nl> + if ( ! TryAddTicks ( date , - BaseUtcOffset . Ticks , out date , DateTimeKind . Utc ) ) <nl> return false ; <nl> - <nl> - date = new DateTime ( ticks , DateTimeKind . Utc ) ; <nl> } <nl> <nl> for ( var i = transitions . Count - 1 ; i > = 0 ; i - - ) { <nl>\n", "msg": "[ corlib ] Refactored TimeZoneInfo DateTime overflow checks .\n"}
{"diff_id": 37908, "repo": "dotnet/runtime\n", "sha": "9f3a5f86531b517baa75082cb0cfb9c6b2fd8f08\n", "time": "2017-12-04T19:20:44Z\n", "diff": "mmm a / src / libraries / Microsoft . CSharp / src / Microsoft / CSharp / RuntimeBinder / Semantics / MemberLookup . cs <nl> ppp b / src / libraries / Microsoft . CSharp / src / Microsoft / CSharp / RuntimeBinder / Semantics / MemberLookup . cs <nl> internal sealed class MemberLookup <nl> private readonly SymWithType _swtBad ; / / If we ' re looking for a constructor or indexer , this matched on name , but isn ' t the right thing . <nl> private readonly SymWithType _swtBogus ; / / A bogus member - such as an indexed property . <nl> private readonly SymWithType _swtBadArity ; / / An symbol with the wrong arity . <nl> - private SymWithType _swtAmbigWarn ; / / An ambiguous symbol , but only warn . <nl> - <nl> - / / We have an override symbol , which we ' ve errored on in SymbolPrepare . If we have nothing better , use this . <nl> - / / This is because if we have : <nl> - / / <nl> - / / class C : D <nl> - / / { <nl> - / / public override int M ( ) { } <nl> - / / static void Main ( ) <nl> - / / { <nl> - / / C c = new C ( ) ; <nl> - / / c . M ( ) ; < - - <nl> - / / <nl> - / / We try to look up M , and find the M on C , but throw it out since its an override , and <nl> - / / we want the virtual that it overrides . However , in this case , we ' ll never find that <nl> - / / virtual , since it doesn ' t exist . We therefore want to use the override anyway , and <nl> - / / continue on to give results with that . <nl> - <nl> - private readonly SymWithType _swtOverride ; <nl> private bool _fMulti ; / / Whether symFirst is of a kind for which we collect multiples ( methods and indexers ) . <nl> <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> private bool SearchSingleType ( AggregateType typeCur , out bool pfHideByName ) <nl> / / Check for user callability . <nl> if ( symCur . IsOverride ( ) & & ! symCur . IsHideByName ( ) ) <nl> { <nl> - if ( ! _swtOverride ) <nl> - { <nl> - _swtOverride . Set ( symCur , typeCur ) ; <nl> - } <nl> continue ; <nl> } <nl> <nl> private bool SearchSingleType ( AggregateType typeCur , out bool pfHideByName ) <nl> / / Give method groups priority . <nl> if ( ! ( symCur is MethodSymbol ) ) <nl> goto LAmbig ; <nl> - _swtAmbigWarn = _swtFirst ; <nl> / / Erase previous results so we ' ll record this method as the first . <nl> _prgtype = new List < AggregateType > ( ) ; <nl> _csym = 0 ; <nl> private bool SearchSingleType ( AggregateType typeCur , out bool pfHideByName ) <nl> / / Give method groups priority . <nl> if ( ! ( _swtFirst . Sym is MethodSymbol ) ) <nl> goto LAmbig ; <nl> - if ( ! _swtAmbigWarn ) <nl> - _swtAmbigWarn . Set ( symCur , typeCur ) ; <nl> } <nl> / / This one is hidden by another . This one also hides any more in base types . <nl> pfHideByName = true ; <nl> public MemberLookup ( ) <nl> _swtBad = new SymWithType ( ) ; <nl> _swtBogus = new SymWithType ( ) ; <nl> _swtBadArity = new SymWithType ( ) ; <nl> - _swtAmbigWarn = new SymWithType ( ) ; <nl> - _swtOverride = new SymWithType ( ) ; <nl> } <nl> <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl>\n", "msg": "Microsoft . CSharp : Remove unused SymWithType fields from MemberLookup ( dotnet / corefx )\n"}
{"diff_id": 37979, "repo": "hbons/SparkleShare\n", "sha": "62bdadf43b91d7834e14a3c0d6e7568d3dd67d34\n", "time": "2011-02-16T19:07:15Z\n", "diff": "mmm a / SparkleShare / SparkleIntro . cs <nl> ppp b / SparkleShare / SparkleIntro . cs <nl> private void ShowSyncingPage ( string name ) <nl> } ; <nl> <nl> Label information = new Label ( _ ( \" This may take a while . \\ n \" ) + <nl> - _ ( \" You sure it  s not coffee o - clock ? \" ) ) { <nl> + _ ( \" Are you sure it  s not coffee o ' clock ? \" ) ) { <nl> UseMarkup = true , <nl> Xalign = 0 <nl> } ; <nl>\n", "msg": "Slight english string change to improve coffee o ' clock .\n"}
{"diff_id": 38090, "repo": "gitextensions/gitextensions\n", "sha": "b5a3544bf6622c9bdb33a6321151f2f6fe63e749\n", "time": "2011-05-08T14:11:38Z\n", "diff": "mmm a / GitUI / FormBrowse . cs <nl> ppp b / GitUI / FormBrowse . cs <nl> private void InternalInitialize ( bool hard ) <nl> ShowRevisions ( ) ; <nl> <nl> _NO_TRANSLATE_Workingdir . Text = Settings . WorkingDir ; <nl> - Text = Settings . WorkingDir + \" - Git Extensions \" ; <nl> + Text = GenerateWindowTitle ( Settings . WorkingDir , validWorkingDir ) ; <nl> <nl> CheckForMergeConflicts ( ) ; <nl> UpdateStashCount ( ) ; <nl> private void CheckForMergeConflicts ( ) <nl> statusStrip . Hide ( ) ; <nl> } <nl> <nl> + / / / < summary > <nl> + / / / Generates main window title according to given repository . <nl> + / / / < / summary > <nl> + / / / < param name = \" workingDir \" > Path to repository . < / param > <nl> + / / / < param name = \" isWorkingDirValid \" > If the given path contains valid repository . < / param > <nl> + private static string GenerateWindowTitle ( string workingDir , bool isWorkingDirValid ) <nl> + { <nl> + const string defaultTitle = \" Git Extensions \" ; <nl> + const string repositoryTitleFormat = \" { 0 } - Git Extensions \" ; <nl> + <nl> + if ( ! isWorkingDirValid ) <nl> + return defaultTitle ; <nl> + string repositoryDescription = ReadRepositoryDescription ( workingDir ) ? ? Directory . GetParent ( workingDir ) . Name ; <nl> + return string . Format ( repositoryTitleFormat , repositoryDescription ) ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Reads repository description ' s first line from \" . git \\ description \" file . <nl> + / / / < / summary > <nl> + / / / < param name = \" workingDir \" > Path to repository . < / param > <nl> + / / / < returns > If the repository has description , returns that description , else returns < c > null < / c > . < / returns > <nl> + private static string ReadRepositoryDescription ( string workingDir ) <nl> + { <nl> + const string repositoryDescriptionFileName = \" description \" ; <nl> + const string repositoryDirectoryName = \" . git \" ; <nl> + const string defaultDescription = \" Unnamed repository ; edit this file ' description ' to name the repository . \" ; <nl> + <nl> + var repositoryPath = Path . Combine ( workingDir , repositoryDirectoryName ) ; <nl> + var repositoryDescriptionFilePath = Path . Combine ( repositoryPath , repositoryDescriptionFileName ) ; <nl> + if ( ! File . Exists ( repositoryDescriptionFilePath ) ) <nl> + return null ; <nl> + try <nl> + { <nl> + var repositoryDescription = File . ReadAllLines ( repositoryDescriptionFilePath ) . FirstOrDefault ( ) ; <nl> + return string . Equals ( repositoryDescription , defaultDescription , StringComparison . CurrentCulture ) <nl> + ? null <nl> + : repositoryDescription ; <nl> + } <nl> + catch ( IOException ) <nl> + { <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> private void InitToolStripBranchFilter ( bool local , bool remote ) <nl> { <nl> toolStripBranches . Items . Clear ( ) ; <nl> private void SettingsToolStripMenuItem2Click ( object sender , EventArgs e ) <nl> this . Hotkeys = HotkeySettingsManager . LoadHotkeys ( HotkeySettingsName ) ; <nl> Initialize ( ) ; <nl> RevisionGrid . ReloadHotkeys ( ) ; <nl> - RevisionGrid . ReloadTranslation ( ) ; <nl> + RevisionGrid . ReloadTranslation ( ) ; <nl> RevisionGrid . ForceRefreshRevisions ( ) ; <nl> } <nl> <nl> private void openWithDifftoolToolStripMenuItem_Click ( object sender , EventArgs e ) <nl> <nl> string output ; <nl> if ( revisions . Count = = 1 ) / / single item selected <nl> - output = GitCommandHelpers . OpenWithDifftool ( selectedItem , revisions [ 0 ] . Guid , <nl> + output = GitCommandHelpers . OpenWithDifftool ( selectedItem , revisions [ 0 ] . Guid , <nl> revisions [ 0 ] . ParentGuids [ 0 ] ) ; <nl> else / / multiple items selected <nl> output = GitCommandHelpers . OpenWithDifftool ( selectedItem , revisions [ 0 ] . Guid , <nl> private void goToToolStripMenuItem_Click ( object sender , EventArgs e ) <nl> else <nl> { <nl> MessageBox . Show ( \" No revision found . \" ) ; <nl> - } <nl> + } <nl> } <nl> <nl> private void toggleSplitViewLayout_Click ( object sender , EventArgs e ) <nl>\n", "msg": "fixed issue from upstream : \" Change main window title to repository name instead of path \"\n"}
{"diff_id": 38096, "repo": "mono/mono\n", "sha": "666987dbcfca64d4c88d57f8d478d596d84a2119\n", "time": "2014-06-29T10:26:33Z\n", "diff": "mmm a / mcs / class / System / System / Uri . cs <nl> ppp b / mcs / class / System / System / Uri . cs <nl> private void Parse ( UriKind kind , string uriString ) <nl> <nl> private bool SupportsQuery ( ) <nl> { <nl> - return ( ( scheme ! = Uri . UriSchemeNntp ) & & ( scheme ! = Uri . UriSchemeFtp ) & & ( scheme ! = Uri . UriSchemeFile ) ) ; <nl> + return UriHelper . SupportsQuery ( scheme ) ; <nl> } <nl> <nl> / / <nl>\n", "msg": "Changed Uri . SupportsQuery to use UriHelper . SupportsQuery .\n"}
{"diff_id": 38239, "repo": "ppy/osu\n", "sha": "db443babb6e9281525c65cda4cf71db065eddbb0\n", "time": "2018-10-07T17:15:42Z\n", "diff": "mmm a / osu . Game / Database / ArchiveModelManager . cs <nl> ppp b / osu . Game / Database / ArchiveModelManager . cs <nl> private List < TFileModel > createFileInfos ( ArchiveReader reader , FileStore files ) <nl> using ( Stream s = reader . GetStream ( file ) ) <nl> fileInfos . Add ( new TFileModel <nl> { <nl> - Filename = FileSafety . PathSanitise ( file ) , <nl> + Filename = FileSafety . PathStandardise ( file ) , <nl> FileInfo = files . Add ( s ) <nl> } ) ; <nl> <nl>\n", "msg": "Fix database entries using platform - specific path separator\n"}
{"diff_id": 38242, "repo": "PowerShell/PowerShell\n", "sha": "f6caf2d5c651e41be4ae1d2f9b9567d157f4406c\n", "time": "2020-11-13T04:36:43Z\n", "diff": "mmm a / src / System . Management . Automation / engine / Attributes . cs <nl> ppp b / src / System . Management . Automation / engine / Attributes . cs <nl> public ValidateSetAttribute ( Type valuesGeneratorType ) <nl> / / / < summary > <nl> / / / Allows dynamically generate set of values for < see cref = \" ValidateSetAttribute \" / > <nl> / / / < / summary > <nl> + # nullable enable <nl> public interface IValidateSetValuesGenerator <nl> { <nl> / / / < summary > <nl> / / / Gets valid values . <nl> / / / < / summary > <nl> + / / / < returns > A non - null array of non - null strings . < / returns > <nl> string [ ] GetValidValues ( ) ; <nl> } <nl> + # nullable restore <nl> <nl> / / / < summary > <nl> / / / Validates that each parameter argument is Trusted data . <nl>\n", "msg": "Enable nullable : System . Management . Automation . Internal . IValidateSetValuesGenerator ( )\n"}
{"diff_id": 38285, "repo": "SignalR/SignalR\n", "sha": "c827237411d300fc684d1c49dafa25bf2715f765\n", "time": "2013-05-06T23:35:17Z\n", "diff": "mmm a / src / Microsoft . AspNet . SignalR . Stress / Stress / StressRuns . cs <nl> ppp b / src / Microsoft . AspNet . SignalR . Stress / Stress / StressRuns . cs <nl> public LoadBalancer ( params SignalR . Client . Http . IHttpClient [ ] servers ) <nl> _servers = servers ; <nl> } <nl> <nl> - public Task < Client . Http . IResponse > Get ( string url , Action < Client . Http . IRequest > prepareRequest ) <nl> + public void Initialize ( SignalR . Client . IConnection connection ) <nl> + { <nl> + foreach ( SignalR . Client . Http . IHttpClient server in _servers ) <nl> + { <nl> + server . Initialize ( connection ) ; <nl> + } <nl> + } <nl> + <nl> + public Task < Client . Http . IResponse > Get ( string url , Action < Client . Http . IRequest > prepareRequest , bool isLongRunning ) <nl> { <nl> int index = _random . Next ( 0 , _servers . Length ) ; <nl> _counter = ( _counter + 1 ) % _servers . Length ; <nl> - return _servers [ index ] . Get ( url , prepareRequest ) ; <nl> + return _servers [ index ] . Get ( url , prepareRequest , isLongRunning ) ; <nl> } <nl> <nl> - public Task < Client . Http . IResponse > Post ( string url , Action < Client . Http . IRequest > prepareRequest , IDictionary < string , string > postData ) <nl> + public Task < Client . Http . IResponse > Post ( string url , Action < Client . Http . IRequest > prepareRequest , IDictionary < string , string > postData , bool isLongRunning ) <nl> { <nl> int index = _random . Next ( 0 , _servers . Length ) ; <nl> _counter = ( _counter + 1 ) % _servers . Length ; <nl> - return _servers [ index ] . Post ( url , prepareRequest , postData ) ; <nl> + return _servers [ index ] . Post ( url , prepareRequest , postData , isLongRunning ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Made changes to StressRun because of changes in IHttpClient\n"}
{"diff_id": 38603, "repo": "OpenRA/OpenRA\n", "sha": "0739fc80a3f7f315080f4357e341b26a57bb361a\n", "time": "2015-08-31T19:45:34Z\n", "diff": "mmm a / OpenRA . Mods . Common / Traits / Mobile . cs <nl> ppp b / OpenRA . Mods . Common / Traits / Mobile . cs <nl> public class Mobile : IIssueOrder , IResolveOrder , IOrderVoice , IPositionable , IM <nl> internal int TicksBeforePathing = 0 ; <nl> <nl> readonly Actor self ; <nl> - readonly Lazy < ISpeedModifier [ ] > speedModifiers ; <nl> + readonly Lazy < IEnumerable < int > > speedModifiers ; <nl> public readonly MobileInfo Info ; <nl> public bool IsMoving { get ; set ; } <nl> <nl> public Mobile ( ActorInitializer init , MobileInfo info ) <nl> self = init . Self ; <nl> Info = info ; <nl> <nl> - speedModifiers = Exts . Lazy ( ( ) = > self . TraitsImplementing < ISpeedModifier > ( ) . ToArray ( ) ) ; <nl> + speedModifiers = Exts . Lazy ( ( ) = > self . TraitsImplementing < ISpeedModifier > ( ) . ToArray ( ) . Select ( x = > x . GetSpeedModifier ( ) ) ) ; <nl> <nl> ToSubCell = FromSubCell = info . SharesCell ? init . World . Map . DefaultSubCell : SubCell . FullCell ; <nl> if ( init . Contains < SubCellInit > ( ) ) <nl> public int MovementSpeedForCell ( Actor self , CPos cell ) <nl> if ( terrainSpeed = = 0 ) <nl> return 0 ; <nl> <nl> - var modifiers = speedModifiers . Value . Select ( x = > x . GetSpeedModifier ( ) ) . Append ( terrainSpeed ) ; <nl> + var modifiers = speedModifiers . Value . Append ( terrainSpeed ) ; <nl> <nl> return Util . ApplyPercentageModifiers ( Info . Speed , modifiers ) ; <nl> } <nl>\n", "msg": "Cache the speed modifiers enumerable , not just the traits , in Mobile .\n"}
{"diff_id": 38892, "repo": "AvaloniaUI/Avalonia\n", "sha": "f0a9de18ac54212379ae23d231d47a32cdac5269\n", "time": "2019-09-10T14:50:57Z\n", "diff": "mmm a / src / Avalonia . Base / Utilities / TypeUtilities . cs <nl> ppp b / src / Avalonia . Base / Utilities / TypeUtilities . cs <nl> namespace Avalonia . Utilities <nl> / / / < / summary > <nl> public static class TypeUtilities <nl> { <nl> - private static int [ ] Conversions = <nl> + private static readonly int [ ] Conversions = <nl> { <nl> 0b101111111111101 , / / Boolean <nl> 0b100001111111110 , / / Char <nl> public static class TypeUtilities <nl> 0b111111111111111 , / / String <nl> } ; <nl> <nl> - private static int [ ] ImplicitConversions = <nl> + private static readonly int [ ] ImplicitConversions = <nl> { <nl> 0b000000000000001 , / / Boolean <nl> 0b001110111100010 , / / Char <nl> public static class TypeUtilities <nl> 0b100000000000000 , / / String <nl> } ; <nl> <nl> - private static Type [ ] InbuiltTypes = <nl> + private static readonly Type [ ] InbuiltTypes = <nl> { <nl> typeof ( Boolean ) , <nl> typeof ( Char ) , <nl> public static class TypeUtilities <nl> typeof ( String ) , <nl> } ; <nl> <nl> - private static readonly Type [ ] NumericTypes = new [ ] <nl> + private static readonly Type [ ] NumericTypes = <nl> { <nl> typeof ( Byte ) , <nl> typeof ( Decimal ) , <nl> public static bool TryConvert ( Type to , object value , CultureInfo culture , out ob <nl> } <nl> } <nl> <nl> - var cast = from . GetRuntimeMethods ( ) <nl> - . FirstOrDefault ( m = > ( m . Name = = \" op_Implicit \" | | m . Name = = \" op_Explicit \" ) & & m . ReturnType = = to ) ; <nl> + var cast = FindTypeConversionOperatorMethod ( from , to , OperatorType . Implicit | OperatorType . Explicit ) ; <nl> <nl> if ( cast ! = null ) <nl> { <nl> public static bool TryConvertImplicit ( Type to , object value , out object result ) <nl> } <nl> } <nl> <nl> - var cast = from . GetRuntimeMethods ( ) <nl> - . FirstOrDefault ( m = > m . Name = = \" op_Implicit \" & & m . ReturnType = = to ) ; <nl> + var cast = FindTypeConversionOperatorMethod ( from , to , OperatorType . Implicit ) ; <nl> <nl> if ( cast ! = null ) <nl> { <nl> public static bool IsNumeric ( Type type ) <nl> return NumericTypes . Contains ( type ) ; <nl> } <nl> } <nl> + <nl> + [ Flags ] <nl> + private enum OperatorType <nl> + { <nl> + Implicit = 1 , <nl> + Explicit = 2 <nl> + } <nl> + <nl> + private static MethodInfo FindTypeConversionOperatorMethod ( Type fromType , Type toType , OperatorType operatorType ) <nl> + { <nl> + const string implicitName = \" op_Implicit \" ; <nl> + const string explicitName = \" op_Explicit \" ; <nl> + <nl> + bool allowImplicit = ( operatorType & OperatorType . Implicit ) ! = 0 ; <nl> + bool allowExplicit = ( operatorType & OperatorType . Explicit ) ! = 0 ; <nl> + <nl> + foreach ( MethodInfo method in fromType . GetMethods ( ) ) <nl> + { <nl> + if ( ! method . IsSpecialName | | method . ReturnType ! = toType ) <nl> + { <nl> + continue ; <nl> + } <nl> + <nl> + if ( allowImplicit & & method . Name = = implicitName ) <nl> + { <nl> + return method ; <nl> + } <nl> + <nl> + if ( allowExplicit & & method . Name = = explicitName ) <nl> + { <nl> + return method ; <nl> + } <nl> + } <nl> + <nl> + return null ; <nl> + } <nl> } <nl> } <nl>\n", "msg": "Remove lambda closure allocations . Optimize search for conversion operator .\n"}
{"diff_id": 39013, "repo": "MonoGame/MonoGame\n", "sha": "4decc7a8019dabdac824b65910a88b10a85f10f7\n", "time": "2014-07-23T05:37:07Z\n", "diff": "mmm a / MonoGame . Framework / Game . cs <nl> ppp b / MonoGame . Framework / Game . cs <nl> public TimeSpan TargetElapsedTime <nl> <nl> if ( value < = TimeSpan . Zero ) <nl> throw new ArgumentOutOfRangeException ( <nl> - \" value must be positive and non - zero . \" ) ; <nl> + \" The time must be positive and non - zero . \" , default ( Exception ) ) ; <nl> <nl> if ( value ! = _targetElapsedTime ) <nl> { <nl>\n", "msg": "Fixed exception message being set as parameter name .\n"}
{"diff_id": 39450, "repo": "mono/mono\n", "sha": "4161e6d1e8e4913386554cb32b8fa30249a93534\n", "time": "2002-07-13T18:46:16Z\n", "diff": "new file mode 100644 <nl> index 000000000000 . . 0cfff223275d <nl> mmm / dev / null <nl> ppp b / mono / tests / delegate6 . cs <nl> <nl> + using System ; <nl> + using System . Reflection ; <nl> + <nl> + public class T <nl> + { <nl> + public void Test ( ) <nl> + { <nl> + Console . WriteLine ( \" CreateDelegate success ! \" ) ; <nl> + } <nl> + <nl> + public delegate void blah ( ) ; <nl> + <nl> + public static void Main ( ) <nl> + { <nl> + T t = new T ( ) ; <nl> + Delegate o = Delegate . CreateDelegate ( typeof ( T . blah ) , t , \" Test \" ) ; <nl> + o . DynamicInvoke ( new Object [ ] { } ) ; <nl> + } <nl> + } <nl> + <nl> + <nl>\n", "msg": "* Added a test case for System . Delegate . CreateDelegate ( )\n"}
{"diff_id": 39451, "repo": "Radarr/Radarr\n", "sha": "3986433884d0e7cf5710646081fef84e032f4f5a\n", "time": "2020-10-11T05:26:53Z\n", "diff": "mmm a / src / NzbDrone . Core / Movies / Movie . cs <nl> ppp b / src / NzbDrone . Core / Movies / Movie . cs <nl> public Movie ( ) <nl> Translations = new List < MovieTranslation > ( ) ; <nl> Recommendations = new List < int > ( ) ; <nl> OriginalLanguage = Language . English ; <nl> + Ratings = new Ratings ( ) ; <nl> } <nl> <nl> public int TmdbId { get ; set ; } <nl>\n", "msg": "Fixed : Default a Movie object with Empty Ratings\n"}
{"diff_id": 39502, "repo": "ServiceStack/ServiceStack\n", "sha": "b95b2a286f51e18f056fc968456bd071009aa876\n", "time": "2015-01-31T09:45:04Z\n", "diff": "Binary files a / lib / ServiceStack . Text . dll and b / lib / ServiceStack . Text . dll differ <nl> mmm a / src / ServiceStack / NativeTypes / Swift / SwiftGenerator . cs <nl> ppp b / src / ServiceStack / NativeTypes / Swift / SwiftGenerator . cs <nl> public SwiftGenerator ( MetadataTypesConfig config ) <nl> { \" Char \" , \" Character \" } , <nl> { \" Byte \" , \" Int8 \" } , <nl> { \" Int16 \" , \" Int16 \" } , <nl> - { \" Int32 \" , \" Int32 \" } , <nl> + { \" Int32 \" , \" Int \" } , <nl> { \" Int64 \" , \" Int64 \" } , <nl> { \" UInt16 \" , \" UInt16 \" } , <nl> { \" UInt32 \" , \" UInt32 \" } , <nl>\n", "msg": "Convert Int32 to Int in Swift as they ' re both default types that use integer literals\n"}
{"diff_id": 39634, "repo": "jellyfin/jellyfin\n", "sha": "2d97423a404228f742976dc6abe4a43746bc23fb\n", "time": "2016-01-28T19:18:30Z\n", "diff": "mmm a / MediaBrowser . Server . Implementations / FileOrganization / EpisodeFileOrganizer . cs <nl> ppp b / MediaBrowser . Server . Implementations / FileOrganization / EpisodeFileOrganizer . cs <nl> public async Task < FileOrganizationResult > OrganizeEpisodeFile ( string path , TvFil <nl> { <nl> var seasonNumber = episodeInfo . SeasonNumber ; <nl> <nl> - result . ExtractedSeasonNumber = seasonNumber ; <nl> - <nl> - / / Passing in true will include a few extra regex ' s <nl> - var episodeNumber = episodeInfo . EpisodeNumber ; <nl> - <nl> - result . ExtractedEpisodeNumber = episodeNumber ; <nl> - <nl> - var premiereDate = episodeInfo . IsByDate ? <nl> - new DateTime ( episodeInfo . Year . Value , episodeInfo . Month . Value , episodeInfo . Day . Value ) : <nl> - ( DateTime ? ) null ; <nl> - <nl> - if ( episodeInfo . IsByDate | | ( seasonNumber . HasValue & & episodeNumber . HasValue ) ) <nl> - { <nl> - if ( episodeInfo . IsByDate ) <nl> - { <nl> - _logger . Debug ( \" Extracted information from { 0 } . Series name { 1 } , Date { 2 } \" , path , seriesName , premiereDate . Value ) ; <nl> - } <nl> - else <nl> - { <nl> - _logger . Debug ( \" Extracted information from { 0 } . Series name { 1 } , Season { 2 } , Episode { 3 } \" , path , seriesName , seasonNumber , episodeNumber ) ; <nl> - } <nl> - <nl> - var endingEpisodeNumber = episodeInfo . EndingEpsiodeNumber ; <nl> - <nl> - result . ExtractedEndingEpisodeNumber = endingEpisodeNumber ; <nl> - <nl> - await OrganizeEpisode ( path , <nl> - seriesName , <nl> - seasonNumber , <nl> - episodeNumber , <nl> - endingEpisodeNumber , <nl> - premiereDate , <nl> - options , <nl> - overwriteExisting , <nl> - result , <nl> - cancellationToken ) . ConfigureAwait ( false ) ; <nl> - } <nl> - else <nl> - { <nl> - var msg = string . Format ( \" Unable to determine episode number from { 0 } \" , path ) ; <nl> - result . Status = FileSortingStatus . Failure ; <nl> - result . StatusMessage = msg ; <nl> - _logger . Warn ( msg ) ; <nl> - } <nl> + result . ExtractedSeasonNumber = seasonNumber ; <nl> + <nl> + / / Passing in true will include a few extra regex ' s <nl> + var episodeNumber = episodeInfo . EpisodeNumber ; <nl> + <nl> + result . ExtractedEpisodeNumber = episodeNumber ; <nl> + <nl> + var premiereDate = episodeInfo . IsByDate ? <nl> + new DateTime ( episodeInfo . Year . Value , episodeInfo . Month . Value , episodeInfo . Day . Value ) : <nl> + ( DateTime ? ) null ; <nl> + <nl> + if ( episodeInfo . IsByDate | | ( seasonNumber . HasValue & & episodeNumber . HasValue ) ) <nl> + { <nl> + if ( episodeInfo . IsByDate ) <nl> + { <nl> + _logger . Debug ( \" Extracted information from { 0 } . Series name { 1 } , Date { 2 } \" , path , seriesName , premiereDate . Value ) ; <nl> + } <nl> + else <nl> + { <nl> + _logger . Debug ( \" Extracted information from { 0 } . Series name { 1 } , Season { 2 } , Episode { 3 } \" , path , seriesName , seasonNumber , episodeNumber ) ; <nl> + } <nl> + <nl> + var endingEpisodeNumber = episodeInfo . EndingEpsiodeNumber ; <nl> + <nl> + result . ExtractedEndingEpisodeNumber = endingEpisodeNumber ; <nl> + <nl> + await OrganizeEpisode ( path , <nl> + seriesName , <nl> + seasonNumber , <nl> + episodeNumber , <nl> + endingEpisodeNumber , <nl> + premiereDate , <nl> + options , <nl> + overwriteExisting , <nl> + result , <nl> + cancellationToken ) . ConfigureAwait ( false ) ; <nl> + } <nl> + else <nl> + { <nl> + var msg = string . Format ( \" Unable to determine episode number from { 0 } \" , path ) ; <nl> + result . Status = FileSortingStatus . Failure ; <nl> + result . StatusMessage = msg ; <nl> + _logger . Warn ( msg ) ; <nl> + } <nl> } <nl> else <nl> { <nl> public async Task < FileOrganizationResult > OrganizeWithCorrection ( EpisodeFileOrga <nl> <nl> var series = ( Series ) _libraryManager . GetItemById ( new Guid ( request . SeriesId ) ) ; <nl> <nl> - await OrganizeEpisode ( result . OriginalPath , <nl> - series , <nl> - request . SeasonNumber , <nl> - request . EpisodeNumber , <nl> - request . EndingEpisodeNumber , <nl> - null , <nl> - options , <nl> - true , <nl> - result , <nl> - cancellationToken ) . ConfigureAwait ( false ) ; <nl> + await OrganizeEpisode ( result . OriginalPath , <nl> + series , <nl> + request . SeasonNumber , <nl> + request . EpisodeNumber , <nl> + request . EndingEpisodeNumber , <nl> + null , <nl> + options , <nl> + true , <nl> + result , <nl> + cancellationToken ) . ConfigureAwait ( false ) ; <nl> <nl> await _organizationService . SaveResult ( result , CancellationToken . None ) . ConfigureAwait ( false ) ; <nl> <nl> return result ; <nl> } <nl> <nl> - private Task OrganizeEpisode ( string sourcePath , <nl> - string seriesName , <nl> - int ? seasonNumber , <nl> - int ? episodeNumber , <nl> - int ? endingEpiosdeNumber , <nl> - DateTime ? premiereDate , <nl> - TvFileOrganizationOptions options , <nl> - bool overwriteExisting , <nl> - FileOrganizationResult result , <nl> - CancellationToken cancellationToken ) <nl> + private Task OrganizeEpisode ( string sourcePath , <nl> + string seriesName , <nl> + int ? seasonNumber , <nl> + int ? episodeNumber , <nl> + int ? endingEpiosdeNumber , <nl> + DateTime ? premiereDate , <nl> + TvFileOrganizationOptions options , <nl> + bool overwriteExisting , <nl> + FileOrganizationResult result , <nl> + CancellationToken cancellationToken ) <nl> { <nl> var series = GetMatchingSeries ( seriesName , result ) ; <nl> <nl> public async Task < FileOrganizationResult > OrganizeWithCorrection ( EpisodeFileOrga <nl> return Task . FromResult ( true ) ; <nl> } <nl> <nl> - return OrganizeEpisode ( sourcePath , <nl> - series , <nl> - seasonNumber , <nl> - episodeNumber , <nl> - endingEpiosdeNumber , <nl> - premiereDate , <nl> - options , <nl> - overwriteExisting , <nl> - result , <nl> - cancellationToken ) ; <nl> + if ( ! series . ProviderIds . Any ( ) ) <nl> + { <nl> + var msg = string . Format ( \" Series has not yet been identified : { 0 } . If you just added the series , please run a library scan or use the identify feature to identify it . \" , seriesName ) ; <nl> + result . Status = FileSortingStatus . Failure ; <nl> + result . StatusMessage = msg ; <nl> + _logger . Warn ( msg ) ; <nl> + return Task . FromResult ( true ) ; <nl> + } <nl> + <nl> + return OrganizeEpisode ( sourcePath , <nl> + series , <nl> + seasonNumber , <nl> + episodeNumber , <nl> + endingEpiosdeNumber , <nl> + premiereDate , <nl> + options , <nl> + overwriteExisting , <nl> + result , <nl> + cancellationToken ) ; <nl> } <nl> <nl> - private async Task OrganizeEpisode ( string sourcePath , <nl> - Series series , <nl> - int ? seasonNumber , <nl> - int ? episodeNumber , <nl> - int ? endingEpiosdeNumber , <nl> - DateTime ? premiereDate , <nl> - TvFileOrganizationOptions options , <nl> - bool overwriteExisting , <nl> - FileOrganizationResult result , <nl> - CancellationToken cancellationToken ) <nl> + private async Task OrganizeEpisode ( string sourcePath , <nl> + Series series , <nl> + int ? seasonNumber , <nl> + int ? episodeNumber , <nl> + int ? endingEpiosdeNumber , <nl> + DateTime ? premiereDate , <nl> + TvFileOrganizationOptions options , <nl> + bool overwriteExisting , <nl> + FileOrganizationResult result , <nl> + CancellationToken cancellationToken ) <nl> { <nl> _logger . Info ( \" Sorting file { 0 } into series { 1 } \" , sourcePath , series . Path ) ; <nl> <nl> / / Proceed to sort the file <nl> - var newPath = await GetNewPath ( sourcePath , series , seasonNumber , episodeNumber , endingEpiosdeNumber , premiereDate , options , cancellationToken ) . ConfigureAwait ( false ) ; <nl> + var newPath = await GetNewPath ( sourcePath , series , seasonNumber , episodeNumber , endingEpiosdeNumber , premiereDate , options , cancellationToken ) . ConfigureAwait ( false ) ; <nl> <nl> if ( string . IsNullOrEmpty ( newPath ) ) <nl> { <nl> private void DeleteLibraryFile ( string path , bool renameRelatedFiles , string targ <nl> } <nl> } <nl> <nl> - private List < string > GetOtherDuplicatePaths ( string targetPath , <nl> - Series series , <nl> - int ? seasonNumber , <nl> - int ? episodeNumber , <nl> - int ? endingEpisodeNumber ) <nl> + private List < string > GetOtherDuplicatePaths ( string targetPath , <nl> + Series series , <nl> + int ? seasonNumber , <nl> + int ? episodeNumber , <nl> + int ? endingEpisodeNumber ) <nl> { <nl> - / / TODO : Support date - naming ? <nl> - if ( ! seasonNumber . HasValue | | episodeNumber . HasValue ) <nl> - { <nl> - return new List < string > ( ) ; <nl> - } <nl> + / / TODO : Support date - naming ? <nl> + if ( ! seasonNumber . HasValue | | episodeNumber . HasValue ) <nl> + { <nl> + return new List < string > ( ) ; <nl> + } <nl> <nl> var episodePaths = series . GetRecursiveChildren ( ) <nl> . OfType < Episode > ( ) <nl> private Series GetMatchingSeries ( string seriesName , FileOrganizationResult resul <nl> / / / < param name = \" endingEpisodeNumber \" > The ending episode number . < / param > <nl> / / / < param name = \" options \" > The options . < / param > <nl> / / / < returns > System . String . < / returns > <nl> - private async Task < string > GetNewPath ( string sourcePath , <nl> - Series series , <nl> - int ? seasonNumber , <nl> - int ? episodeNumber , <nl> - int ? endingEpisodeNumber , <nl> - DateTime ? premiereDate , <nl> - TvFileOrganizationOptions options , <nl> - CancellationToken cancellationToken ) <nl> + private async Task < string > GetNewPath ( string sourcePath , <nl> + Series series , <nl> + int ? seasonNumber , <nl> + int ? episodeNumber , <nl> + int ? endingEpisodeNumber , <nl> + DateTime ? premiereDate , <nl> + TvFileOrganizationOptions options , <nl> + CancellationToken cancellationToken ) <nl> { <nl> var episodeInfo = new EpisodeInfo <nl> { <nl> private Series GetMatchingSeries ( string seriesName , FileOrganizationResult resul <nl> MetadataLanguage = series . GetPreferredMetadataLanguage ( ) , <nl> ParentIndexNumber = seasonNumber , <nl> SeriesProviderIds = series . ProviderIds , <nl> - PremiereDate = premiereDate <nl> + PremiereDate = premiereDate <nl> } ; <nl> <nl> var searchResults = await _providerManager . GetRemoteSearchResults < Episode , EpisodeInfo > ( new RemoteSearchQuery < EpisodeInfo > <nl> private Series GetMatchingSeries ( string seriesName , FileOrganizationResult resul <nl> } , cancellationToken ) . ConfigureAwait ( false ) ; <nl> <nl> var episode = searchResults . FirstOrDefault ( ) ; <nl> - <nl> + <nl> string episodeName = string . Empty ; <nl> <nl> if ( episode = = null ) <nl> private Series GetMatchingSeries ( string seriesName , FileOrganizationResult resul <nl> else <nl> { <nl> episodeName = episode . Name ; <nl> - } <nl> + } <nl> <nl> - seasonNumber = seasonNumber ? ? episode . ParentIndexNumber ; <nl> - episodeNumber = episodeNumber ? ? episode . IndexNumber ; <nl> + seasonNumber = seasonNumber ? ? episode . ParentIndexNumber ; <nl> + episodeNumber = episodeNumber ? ? episode . IndexNumber ; <nl> <nl> var newPath = GetSeasonFolderPath ( series , seasonNumber . Value , options ) ; <nl> <nl>\n", "msg": "don ' t organize episode if series has no provider ids\n"}
{"diff_id": 39648, "repo": "dotnet/runtime\n", "sha": "f455941ad19a677f66d5dea64bf25130a18be19b\n", "time": "2016-02-01T21:46:54Z\n", "diff": "mmm a / src / libraries / System . Net . Sockets . Legacy / tests / FunctionalTests / DualModeSocketTest . cs <nl> ppp b / src / libraries / System . Net . Sockets . Legacy / tests / FunctionalTests / DualModeSocketTest . cs <nl> private void ConnectClient ( object state ) <nl> catch ( SocketException ex ) <nl> { <nl> Task . Delay ( Configuration . FailingTestTimeout ) . Wait ( ) ; / / Give the other end a chance to call Accept ( ) . <nl> - _serverSocket . Shutdown ( SocketShutdown . Both ) ; / / Cancels the test <nl> - _serverSocket . Dispose ( ) ; <nl> + _serverSocket . Dispose ( ) ; / / Cancels the test <nl> Error = ex . SocketErrorCode ; <nl> } <nl> finally <nl>\n", "msg": "Revert \" Shutdown server socket to cancel the pending Accept call . Dispose does not cancel Accept . \"\n"}
{"diff_id": 204, "repo": "ppy/osu\n", "sha": "e80ef341d2663ea07c272154b8ddb1e0bde13467\n", "time": "2020-09-03T04:20:23Z\n", "diff": "mmm a / osu . Game / Database / ArchiveModelManager . cs <nl> ppp b / osu . Game / Database / ArchiveModelManager . cs <nl> public void Export ( TModel item ) <nl> } <nl> } <nl> <nl> + / / / < summary > <nl> + / / / Update an existing file , or create a new entry if not already part of the < paramref name = \" model \" / > ' s files . <nl> + / / / < / summary > <nl> + / / / < param name = \" model \" > The item to operate on . < / param > <nl> + / / / < param name = \" file \" > The file model to be updated or added . < / param > <nl> + / / / < param name = \" contents \" > The new file contents . < / param > <nl> public void UpdateFile ( TModel model , TFileModel file , Stream contents ) <nl> { <nl> using ( var usage = ContextFactory . GetForWrite ( ) ) <nl> { <nl> / / Dereference the existing file info , since the file model will be removed . <nl> - Files . Dereference ( file . FileInfo ) ; <nl> + if ( file . FileInfo ! = null ) <nl> + { <nl> + Files . Dereference ( file . FileInfo ) ; <nl> <nl> - / / Remove the file model . <nl> - usage . Context . Set < TFileModel > ( ) . Remove ( file ) ; <nl> + / / Remove the file model . <nl> + usage . Context . Set < TFileModel > ( ) . Remove ( file ) ; <nl> + } <nl> <nl> / / Add the new file info and containing file model . <nl> model . Files . Remove ( file ) ; <nl>\n", "msg": "Allow UpdateFile to be called when a previous file doesn ' t exist\n", "score": 1}
{"diff_id": 432, "repo": "dotnet/roslyn\n", "sha": "f616cf4cc32a02103ce4ec79d303596ebba8d62c\n", "time": "2020-01-22T19:03:22Z\n", "diff": "mmm a / src / EditorFeatures / Core / GoToDefinition / GoToDefinitionCommandHandler . cs <nl> ppp b / src / EditorFeatures / Core / GoToDefinition / GoToDefinitionCommandHandler . cs <nl> public bool ExecuteCommand ( GoToDefinitionCommandArgs args , CommandExecutionConte <nl> { <nl> var subjectBuffer = args . SubjectBuffer ; <nl> var ( document , service ) = GetDocumentAndService ( subjectBuffer . CurrentSnapshot ) ; <nl> - if ( service ! = null ) <nl> + <nl> + / / Prevent the remote workspace from handling go to definition commands <nl> + if ( service ! = null & & document . Project . Solution . Workspace . Kind ! = WorkspaceKind . AnyCodeRoslynWorkspace ) <nl> { <nl> var caretPos = args . TextView . GetCaretPoint ( subjectBuffer ) ; <nl> if ( caretPos . HasValue & & TryExecuteCommand ( document , caretPos . Value , service , context ) ) <nl>\n", "msg": "Prevent the remote workspace from handling goto def commands .\n", "score": 1}
{"diff_id": 520, "repo": "unoplatform/uno\n", "sha": "b1562d9ed5fede0d105105eb9f44c2d739558116\n", "time": "2019-10-14T18:49:48Z\n", "diff": "mmm a / src / Uno . UWP / System / Launcher . Android . cs <nl> ppp b / src / Uno . UWP / System / Launcher . Android . cs <nl> public partial class Launcher <nl> ( \" defaultapps \" , AndroidSettings . ActionManageDefaultAppsSettings ) , <nl> ( \" appsforwebsites \" , AndroidSettings . ActionManageDefaultAppsSettings ) , <nl> ( \" cortana \" , AndroidSettings . ActionVoiceInputSettings ) , <nl> + ( \" bluetooth \" , AndroidSettings . ActionBluetoothSettings ) , <nl> ( \" printers \" , AndroidSettings . ActionPrintSettings ) , <nl> ( \" typing \" , AndroidSettings . ActionHardKeyboardSettings ) , <nl> ( \" easeofaccess \" , AndroidSettings . ActionAccessibilitySettings ) , <nl> public partial class Launcher <nl> ( \" notifications \" , AndroidSettings . ActionAppNotificationSettings ) , <nl> ( \" storage \" , AndroidSettings . ActionInternalStorageSettings ) , <nl> ( \" sound \" , AndroidSettings . ActionSoundSettings ) , <nl> + ( \" dateandtime \" , AndroidSettings . ActionDateSettings ) , <nl> + ( \" keyboard \" , AndroidSettings . ActionInputMethodSettings ) , <nl> + ( \" regionlanguage \" , AndroidSettings . ActionLocaleSettings ) , <nl> + ( \" developers \" , AndroidSettings . ActionApplicationDevelopmentSettings ) , <nl> } ; <nl> <nl> static Launcher ( ) <nl> private static Task < bool > HandleSpecialUriAsync ( Uri uri ) <nl> <nl> private static Task < bool > HandleSettingsUriAsync ( Uri uri ) <nl> { <nl> - var settingsString = uri . AbsoluteUri . ToLowerInvariant ( ) ; <nl> + var settingsString = uri . AbsolutePath . ToLowerInvariant ( ) ; <nl> / / get exact match first <nl> var bestMatch = _settingsHandlers <nl> . Where ( handler = > handler . uriPrefix = = settingsString ) <nl>\n", "msg": "Added support for several more settings categories\n", "score": 1}
{"diff_id": 928, "repo": "ppy/osu\n", "sha": "268bbcf77dee56a5ca1f0e4a0fb0b931c4d6f9a5\n", "time": "2020-11-15T13:22:46Z\n", "diff": "mmm a / osu . Game . Rulesets . Osu / Edit / OsuSelectionHandler . cs <nl> ppp b / osu . Game . Rulesets . Osu / Edit / OsuSelectionHandler . cs <nl> private bool moveSelection ( Vector2 delta ) <nl> <nl> Quad quad = getSurroundingQuad ( hitObjects ) ; <nl> <nl> - if ( quad . TopLeft . X + delta . X < 0 | | <nl> - quad . TopLeft . Y + delta . Y < 0 | | <nl> - quad . BottomRight . X + delta . X > DrawWidth | | <nl> - quad . BottomRight . Y + delta . Y > DrawHeight ) <nl> - return false ; <nl> + Vector2 newTopLeft = quad . TopLeft + delta ; <nl> + if ( newTopLeft . X < 0 ) <nl> + delta . X - = newTopLeft . X ; <nl> + if ( newTopLeft . Y < 0 ) <nl> + delta . Y - = newTopLeft . Y ; <nl> + <nl> + Vector2 newBottomRight = quad . BottomRight + delta ; <nl> + if ( newBottomRight . X > DrawWidth ) <nl> + delta . X - = newBottomRight . X - DrawWidth ; <nl> + if ( newBottomRight . Y > DrawHeight ) <nl> + delta . Y - = newBottomRight . Y - DrawHeight ; <nl> <nl> foreach ( var h in hitObjects ) <nl> h . Position + = delta ; <nl>\n", "msg": "Clamp selection movement instead of refusing to move on borders\n", "score": 1}
{"diff_id": 1398, "repo": "mRemoteNG/mRemoteNG\n", "sha": "a055d7f4a8c9414bd7a2bc3eab8fb022c8c076ae\n", "time": "2016-05-27T17:56:48Z\n", "diff": "mmm a / mRemoteV1 / Tree / ConnectionTree . cs <nl> ppp b / mRemoteV1 / Tree / ConnectionTree . cs <nl> public static void DeleteSelectedNode ( ) <nl> { <nl> if ( UserConfirmsNonEmptyFolderDeletion ( ) ) <nl> { <nl> + TreeView . BeginUpdate ( ) ; <nl> SelectedNode . Nodes . Clear ( ) ; <nl> SelectedNode . Remove ( ) ; <nl> + TreeView . EndUpdate ( ) ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Slight optimization to prevent window flicker when deleting a folder with many connections .\n", "score": 1}
{"diff_id": 1400, "repo": "OpenRA/OpenRA\n", "sha": "a65358f1910e221744ae18f5a0882e367cdec5d2\n", "time": "2013-12-26T19:14:50Z\n", "diff": "mmm a / OpenRA . Mods . RA / CrateSpawner . cs <nl> ppp b / OpenRA . Mods . RA / CrateSpawner . cs <nl> public class CrateSpawnerInfo : ITraitInfo <nl> public readonly string [ ] ValidWater = { \" Water \" } ; <nl> [ Desc ( \" Chance of generating a water crate instead of a land crate \" ) ] <nl> public readonly float WaterChance = . 2f ; <nl> - [ Desc ( \" Drop crates via DeliveryAircraft : or instantly spawn them on the ground \" ) ] <nl> + [ Desc ( \" Airdrop crates via DeliveryAircraft : or instantly spawn them on the ground \" ) ] <nl> public readonly bool DeliverByAircraft = false ; <nl> [ Desc ( \" If DeliverByAircraft : yes , this actor will deliver crates \" ) , ActorReference ] <nl> public readonly string DeliveryAircraft = \" badr \" ; <nl> - [ Desc ( \" Crate actor to drop \" ) , ActorReference ] <nl> - public readonly string CrateActor = \" crate \" ; <nl> + [ Desc ( \" Crate actors to drop \" ) , ActorReference ] <nl> + public readonly string [ ] CrateActors = { \" crate \" } ; <nl> + [ Desc ( \" Chance of each crate actor spawning \" ) ] <nl> + public readonly int [ ] CrateActorShares = { 10 } ; <nl> <nl> - public object Create ( ActorInitializer init ) { return new CrateSpawner ( this ) ; } <nl> + public object Create ( ActorInitializer init ) { return new CrateSpawner ( this , init . self ) ; } <nl> } <nl> <nl> public class CrateSpawner : ITick <nl> public class CrateSpawner : ITick <nl> List < Actor > crates = new List < Actor > ( ) ; <nl> int ticks = 0 ; <nl> CrateSpawnerInfo Info ; <nl> + Actor self ; <nl> <nl> - public CrateSpawner ( CrateSpawnerInfo info ) { Info = info ; } <nl> + public CrateSpawner ( CrateSpawnerInfo info , Actor self ) <nl> + { <nl> + Info = info ; <nl> + this . self = self ; <nl> + } <nl> <nl> public void Tick ( Actor self ) <nl> { <nl> void SpawnCrate ( Actor self ) <nl> return ; <nl> <nl> var p = pp . Value ; <nl> + var crateActor = ChooseCrateActor ( ) ; <nl> <nl> self . World . AddFrameEndTask ( w = > <nl> { <nl> if ( Info . DeliverByAircraft ) <nl> { <nl> - var crate = w . CreateActor ( false , Info . CrateActor , new TypeDictionary { new OwnerInit ( w . WorldActor . Owner ) } ) ; <nl> + var crate = w . CreateActor ( false , crateActor , new TypeDictionary { new OwnerInit ( w . WorldActor . Owner ) } ) ; <nl> crates . Add ( crate ) ; <nl> <nl> var startPos = w . ChooseRandomEdgeCell ( ) ; <nl> void SpawnCrate ( Actor self ) <nl> } <nl> else <nl> { <nl> - crates . Add ( w . CreateActor ( Info . CrateActor , new TypeDictionary { new OwnerInit ( w . WorldActor . Owner ) , new LocationInit ( p ) } ) ) ; <nl> + crates . Add ( w . CreateActor ( crateActor , new TypeDictionary { new OwnerInit ( w . WorldActor . Owner ) , new LocationInit ( p ) } ) ) ; <nl> } <nl> } ) ; <nl> } <nl> void SpawnCrate ( Actor self ) <nl> <nl> return null ; <nl> } <nl> + <nl> + string ChooseCrateActor ( ) <nl> + { <nl> + var crateShares = Info . CrateActorShares ; <nl> + var n = self . World . SharedRandom . Next ( crateShares . Sum ( ) ) ; <nl> + <nl> + var cumulativeShares = 0 ; <nl> + for ( var i = 0 ; i < crateShares . Length ; i + + ) <nl> + { <nl> + cumulativeShares + = crateShares [ i ] ; <nl> + if ( n < = cumulativeShares ) <nl> + return Info . CrateActors [ i ] ; <nl> + } <nl> + <nl> + return null ; <nl> + } <nl> } <nl> } <nl>\n", "msg": "Add support for multiple crate actors to be spawned from CrateSpawner\n", "score": 1}
{"diff_id": 1450, "repo": "OpenRA/OpenRA\n", "sha": "073a00a2f4eed2585db84d73e28e5235f5dc8292\n", "time": "2017-02-18T22:37:47Z\n", "diff": "mmm a / OpenRA . Mods . Common / Widgets / Logic / SettingsLogic . cs <nl> ppp b / OpenRA . Mods . Common / Widgets / Logic / SettingsLogic . cs <nl> public SettingsLogic ( Widget widget , Action onExit , ModData modData , WorldRendere <nl> OriginalGraphicsWindowedSize ! = current . Graphics . WindowedSize | | <nl> OriginalGraphicsFullscreenSize ! = current . Graphics . FullscreenSize | | <nl> OriginalServerDiscoverNatDevices ! = current . Server . DiscoverNatDevices ) <nl> + { <nl> + Action restart = ( ) = > <nl> + { <nl> + var external = Game . ExternalMods [ ExternalMod . MakeKey ( Game . ModData . Manifest ) ] ; <nl> + Game . SwitchToExternalMod ( external , null , closeAndExit ) ; <nl> + } ; <nl> + <nl> ConfirmationDialogs . ButtonPrompt ( <nl> title : \" Restart Now ? \" , <nl> text : \" Some changes will not be applied until \\ nthe game is restarted . Restart now ? \" , <nl> - onConfirm : Game . Restart , <nl> + onConfirm : restart , <nl> onCancel : closeAndExit , <nl> confirmText : \" Restart Now \" , <nl> cancelText : \" Restart Later \" ) ; <nl> + } <nl> else <nl> closeAndExit ( ) ; <nl> } ; <nl>\n", "msg": "Use mod switching for settings menu restart .\n", "score": 1}
{"diff_id": 1463, "repo": "HangfireIO/Hangfire\n", "sha": "7044974d677b488e2e1b2295559b4e0c719fde61\n", "time": "2015-03-12T14:51:52Z\n", "diff": "mmm a / src / Hangfire . SqlServer / CountersAggregator . cs <nl> ppp b / src / Hangfire . SqlServer / CountersAggregator . cs <nl> public void Execute ( CancellationToken cancellationToken ) <nl> new { now = DateTime . UtcNow , count = NumberOfRecordsInSinglePass } ) ; <nl> } <nl> <nl> - if ( removedCount > 0 ) <nl> + if ( removedCount > = NumberOfRecordsInSinglePass ) <nl> { <nl> cancellationToken . WaitHandle . WaitOne ( DelayBetweenPasses ) ; <nl> cancellationToken . ThrowIfCancellationRequested ( ) ; <nl> } <nl> - } while ( removedCount ! = 0 ) ; <nl> + } while ( removedCount > = NumberOfRecordsInSinglePass ) ; <nl> <nl> cancellationToken . WaitHandle . WaitOne ( _interval ) ; <nl> } <nl> private static string GetAggregationQuery ( ) <nl> SET TRANSACTION ISOLATION LEVEL READ COMMITTED <nl> BEGIN TRAN <nl> <nl> - DELETE TOP ( @ count ) [ Hangfire ] . [ Counter ] <nl> + DELETE TOP ( @ count ) [ Hangfire ] . [ Counter ] with ( readpast ) <nl> OUTPUT DELETED . [ Key ] , DELETED . [ Value ] , DELETED . [ ExpireAt ] INTO @ RecordsToAggregate <nl> <nl> SET NOCOUNT ON <nl>\n", "msg": "Aggregate counters only if there are a lot of them\n", "score": 1}
{"diff_id": 1638, "repo": "dotnet/roslyn\n", "sha": "0a87a0ddf965a324fc6dad728791b8c0282c4daa\n", "time": "2015-03-17T18:14:25Z\n", "diff": "mmm a / src / VisualStudio / Core / Def / Implementation / ProjectSystem / AbstractProject . cs <nl> ppp b / src / VisualStudio / Core / Def / Implementation / ProjectSystem / AbstractProject . cs <nl> <nl> using Microsoft . CodeAnalysis . Diagnostics ; <nl> using Microsoft . CodeAnalysis . ErrorReporting ; <nl> using Microsoft . CodeAnalysis . Host ; <nl> + using Microsoft . CodeAnalysis . Notification ; <nl> using Microsoft . VisualStudio . ComponentModelHost ; <nl> using Microsoft . VisualStudio . LanguageServices . Implementation . EditAndContinue ; <nl> using Microsoft . VisualStudio . LanguageServices . Implementation . TaskList ; <nl> internal void RemoveAdditionalDocument ( IVisualStudioHostDocument document ) <nl> <nl> public virtual void Disconnect ( ) <nl> { <nl> - / / Unsubscribe IVsHierarchyEvents <nl> - DisconnectHierarchyEvents ( ) ; <nl> - <nl> - / / The project is going away , so let ' s remove ourselves from the host . First , we <nl> - / / close and dispose of any remaining documents <nl> - foreach ( var document in this . GetCurrentDocuments ( ) ) <nl> + using ( _visualStudioWorkspaceOpt ? . Services . GetService < IGlobalOperationNotificationService > ( ) ? . Start ( \" Disconnect Project \" ) ) <nl> { <nl> - UninitializeDocument ( document ) ; <nl> - } <nl> + / / Unsubscribe IVsHierarchyEvents <nl> + DisconnectHierarchyEvents ( ) ; <nl> <nl> - / / Dispose metadata references . <nl> - foreach ( var reference in _metadataReferences ) <nl> - { <nl> - reference . Dispose ( ) ; <nl> - } <nl> + / / The project is going away , so let ' s remove ourselves from the host . First , we <nl> + / / close and dispose of any remaining documents <nl> + foreach ( var document in this . GetCurrentDocuments ( ) ) <nl> + { <nl> + UninitializeDocument ( document ) ; <nl> + } <nl> <nl> - foreach ( var analyzer in _analyzers . Values ) <nl> - { <nl> - analyzer . Dispose ( ) ; <nl> - } <nl> + / / Dispose metadata references . <nl> + foreach ( var reference in _metadataReferences ) <nl> + { <nl> + reference . Dispose ( ) ; <nl> + } <nl> <nl> - / / Make sure we clear out any external errors left when closing the project . <nl> - if ( _externalErrorReporter ! = null ) <nl> - { <nl> - _externalErrorReporter . ClearAllErrors ( ) ; <nl> - } <nl> + foreach ( var analyzer in _analyzers . Values ) <nl> + { <nl> + analyzer . Dispose ( ) ; <nl> + } <nl> <nl> - / / Make sure we clear out any host errors left when closing the project . <nl> - if ( _hostDiagnosticUpdateSourceOpt ! = null ) <nl> - { <nl> - _hostDiagnosticUpdateSourceOpt . ClearAllDiagnosticsForProject ( this . Id ) ; <nl> - } <nl> + / / Make sure we clear out any external errors left when closing the project . <nl> + if ( _externalErrorReporter ! = null ) <nl> + { <nl> + _externalErrorReporter . ClearAllErrors ( ) ; <nl> + } <nl> + <nl> + / / Make sure we clear out any host errors left when closing the project . <nl> + if ( _hostDiagnosticUpdateSourceOpt ! = null ) <nl> + { <nl> + _hostDiagnosticUpdateSourceOpt . ClearAllDiagnosticsForProject ( this . Id ) ; <nl> + } <nl> <nl> - ClearAnalyzerRuleSet ( ) ; <nl> + ClearAnalyzerRuleSet ( ) ; <nl> <nl> - this . ProjectTracker . RemoveProject ( this ) ; <nl> + this . ProjectTracker . RemoveProject ( this ) ; <nl> + } <nl> } <nl> <nl> internal void TryProjectConversionForIntroducedOutputPath ( string binPath , AbstractProject projectToReference ) <nl>\n", "msg": "Start a global operation during project disconnect\n", "score": 1}
{"diff_id": 2387, "repo": "dotnet/orleans\n", "sha": "b0afc7ac8c1a35360d1695d20d6eacd8b9368354\n", "time": "2015-07-21T19:33:29Z\n", "diff": "mmm a / src / OrleansAzureUtils / Hosting / AzureSilo . cs <nl> ppp b / src / OrleansAzureUtils / Hosting / AzureSilo . cs <nl> public AzureSilo ( ) <nl> # region Azure RoleEntryPoint methods <nl> <nl> / / / < summary > <nl> - / / / Initialize this Orleans silo for execution with the current Azure deploymentId and role instance <nl> + / / / Initialize this Orleans silo for execution <nl> / / / < / summary > <nl> / / / < returns > < c > true < / c > is the silo startup was successful < / returns > <nl> public bool Start ( ) <nl> public bool Start ( ) <nl> return Start ( null ) ; <nl> } <nl> <nl> - / / / < summary > <nl> - / / / Initialize this Orleans silo for execution <nl> - / / / < / summary > <nl> - / / / < param name = \" config \" > If null , Config data will be read from silo config file as normal , otherwise use the specified config data . < / param > <nl> - / / / < returns > < c > true < / c > is the silo startup was successful < / returns > <nl> - public bool Start ( ClusterConfiguration config ) <nl> - { <nl> - return Start ( null , config ) ; <nl> - } <nl> - <nl> / / / < summary > <nl> / / / Initialize this Orleans silo for execution with the specified Azure deploymentId <nl> / / / < / summary > <nl> - / / / < param name = \" deploymentId \" > Azure DeploymentId this silo is running under < / param > <nl> / / / < param name = \" config \" > If null , Config data will be read from silo config file as normal , otherwise use the specified config data . < / param > <nl> + / / / < param name = \" deploymentId \" > Azure DeploymentId this silo is running under < / param > <nl> / / / < returns > < c > true < / c > is the silo startup was successful < / returns > <nl> - public bool Start ( string deploymentId , ClusterConfiguration config ) <nl> + public bool Start ( ClusterConfiguration config , string deploymentId = null ) <nl> { <nl> / / Program ident <nl> Trace . TraceInformation ( \" Starting { 0 } v { 1 } \" , this . GetType ( ) . FullName , RuntimeVersion . Current ) ; <nl> public bool Start ( string deploymentId , ClusterConfiguration config ) <nl> string instanceName = serviceRuntimeWrapper . InstanceName ; <nl> <nl> / / Configure this Orleans silo instance <nl> - <nl> if ( config = = null ) <nl> { <nl> host = new SiloHost ( instanceName ) ; <nl>\n", "msg": "Swapped order of arguments , removed additional overload & replaced with optional argument\n", "score": 1}
{"diff_id": 2397, "repo": "nopSolutions/nopCommerce\n", "sha": "067d573a8f96f7f2114d1024a052e64cc721f647\n", "time": "2020-08-27T22:26:49Z\n", "diff": "mmm a / src / Libraries / Nop . Services / Installation / CodeFirstInstallationService . cs <nl> ppp b / src / Libraries / Nop . Services / Installation / CodeFirstInstallationService . cs <nl> public partial class CodeFirstInstallationService : IInstallationService <nl> private readonly INopDataProvider _dataProvider ; <nl> private readonly IGenericAttributeService _genericAttributeService ; <nl> private readonly INopFileProvider _fileProvider ; <nl> - private readonly IRepository < ActivityLog > _activityLogRepository ; <nl> private readonly IRepository < ActivityLogType > _activityLogTypeRepository ; <nl> private readonly IRepository < Address > _addressRepository ; <nl> - private readonly IRepository < Affiliate > _affiliateRepository ; <nl> - private readonly IRepository < BlogPost > _blogPostRepository ; <nl> private readonly IRepository < Category > _categoryRepository ; <nl> private readonly IRepository < CategoryTemplate > _categoryTemplateRepository ; <nl> private readonly IRepository < Country > _countryRepository ; <nl> private readonly IRepository < Currency > _currencyRepository ; <nl> private readonly IRepository < Customer > _customerRepository ; <nl> - private readonly IRepository < CustomerPassword > _customerPasswordRepository ; <nl> private readonly IRepository < CustomerRole > _customerRoleRepository ; <nl> private readonly IRepository < DeliveryDate > _deliveryDateRepository ; <nl> - private readonly IRepository < Discount > _discountRepository ; <nl> private readonly IRepository < EmailAccount > _emailAccountRepository ; <nl> - private readonly IRepository < Forum > _forumRepository ; <nl> - private readonly IRepository < ForumGroup > _forumGroupRepository ; <nl> - private readonly IRepository < GiftCard > _giftCardRepository ; <nl> private readonly IRepository < Language > _languageRepository ; <nl> private readonly IRepository < Manufacturer > _manufacturerRepository ; <nl> private readonly IRepository < ManufacturerTemplate > _manufacturerTemplateRepository ; <nl> private readonly IRepository < MeasureDimension > _measureDimensionRepository ; <nl> private readonly IRepository < MeasureWeight > _measureWeightRepository ; <nl> - private readonly IRepository < MessageTemplate > _messageTemplateRepository ; <nl> - private readonly IRepository < NewsItem > _newsItemRepository ; <nl> - private readonly IRepository < Order > _orderRepository ; <nl> - private readonly IRepository < OrderItem > _orderItemRepository ; <nl> - private readonly IRepository < OrderNote > _orderNoteRepository ; <nl> - private readonly IRepository < PollAnswer > _pollAnswerRepository ; <nl> - private readonly IRepository < Poll > _pollRepository ; <nl> private readonly IRepository < Product > _productRepository ; <nl> private readonly IRepository < ProductAttribute > _productAttributeRepository ; <nl> - private readonly IRepository < ProductAttributeMapping > _productAttributeMappingRepository ; <nl> private readonly IRepository < ProductAvailabilityRange > _productAvailabilityRangeRepository ; <nl> - private readonly IRepository < ProductProductTagMapping > _productProductTagMappingRepository ; <nl> private readonly IRepository < ProductTag > _productTagRepository ; <nl> private readonly IRepository < ProductTemplate > _productTemplateRepository ; <nl> - private readonly IRepository < RelatedProduct > _relatedProductRepository ; <nl> - private readonly IRepository < ReturnRequestAction > _returnRequestActionRepository ; <nl> - private readonly IRepository < ReturnRequestReason > _returnRequestReasonRepository ; <nl> - private readonly IRepository < ScheduleTask > _scheduleTaskRepository ; <nl> - private readonly IRepository < SearchTerm > _searchTermRepository ; <nl> - private readonly IRepository < Shipment > _shipmentRepository ; <nl> - private readonly IRepository < ShipmentItem > _shipmentItemRepository ; <nl> - private readonly IRepository < ShippingMethod > _shippingMethodRepository ; <nl> private readonly IRepository < SpecificationAttribute > _specificationAttributeRepository ; <nl> private readonly IRepository < SpecificationAttributeOption > _specificationAttributeOptionRepository ; <nl> private readonly IRepository < StateProvince > _stateProvinceRepository ; <nl> - private readonly IRepository < StockQuantityHistory > _stockQuantityHistoryRepository ; <nl> private readonly IRepository < Store > _storeRepository ; <nl> private readonly IRepository < TaxCategory > _taxCategoryRepository ; <nl> - private readonly IRepository < TierPrice > _tierPriceRepository ; <nl> - private readonly IRepository < Topic > _topicRepository ; <nl> private readonly IRepository < TopicTemplate > _topicTemplateRepository ; <nl> private readonly IRepository < UrlRecord > _urlRecordRepository ; <nl> - private readonly IRepository < Vendor > _vendorRepository ; <nl> - private readonly IRepository < Warehouse > _warehouseRepository ; <nl> private readonly IWebHelper _webHelper ; <nl> <nl> # endregion <nl> public partial class CodeFirstInstallationService : IInstallationService <nl> INopDataProvider dataProvider , <nl> IGenericAttributeService genericAttributeService , <nl> INopFileProvider fileProvider , <nl> - IRepository < ActivityLog > activityLogRepository , <nl> IRepository < ActivityLogType > activityLogTypeRepository , <nl> IRepository < Address > addressRepository , <nl> - IRepository < Affiliate > affiliateRepository , <nl> - IRepository < BlogPost > blogPostRepository , <nl> IRepository < Category > categoryRepository , <nl> IRepository < CategoryTemplate > categoryTemplateRepository , <nl> IRepository < Country > countryRepository , <nl> IRepository < Currency > currencyRepository , <nl> IRepository < Customer > customerRepository , <nl> - IRepository < CustomerPassword > customerPasswordRepository , <nl> IRepository < CustomerRole > customerRoleRepository , <nl> IRepository < DeliveryDate > deliveryDateRepository , <nl> - IRepository < Discount > discountRepository , <nl> IRepository < EmailAccount > emailAccountRepository , <nl> - IRepository < Forum > forumRepository , <nl> - IRepository < ForumGroup > forumGroupRepository , <nl> - IRepository < GiftCard > giftCardRepository , <nl> IRepository < Language > languageRepository , <nl> IRepository < Manufacturer > manufacturerRepository , <nl> IRepository < ManufacturerTemplate > manufacturerTemplateRepository , <nl> IRepository < MeasureDimension > measureDimensionRepository , <nl> IRepository < MeasureWeight > measureWeightRepository , <nl> - IRepository < MessageTemplate > messageTemplateRepository , <nl> - IRepository < NewsItem > newsItemRepository , <nl> - IRepository < Order > orderRepository , <nl> - IRepository < OrderItem > orderItemRepository , <nl> - IRepository < OrderNote > orderNoteRepository , <nl> - IRepository < PollAnswer > pollAnswerRepository , <nl> - IRepository < Poll > pollRepository , <nl> IRepository < Product > productRepository , <nl> IRepository < ProductAttribute > productAttributeRepository , <nl> - IRepository < ProductAttributeMapping > productAttributeMappingRepository , <nl> IRepository < ProductAvailabilityRange > productAvailabilityRangeRepository , <nl> - IRepository < ProductProductTagMapping > productProductTagMappingRepository , <nl> IRepository < ProductTag > productTagRepository , <nl> IRepository < ProductTemplate > productTemplateRepository , <nl> - IRepository < RelatedProduct > relatedProductRepository , <nl> - IRepository < ReturnRequestAction > returnRequestActionRepository , <nl> - IRepository < ReturnRequestReason > returnRequestReasonRepository , <nl> - IRepository < ScheduleTask > scheduleTaskRepository , <nl> - IRepository < SearchTerm > searchTermRepository , <nl> - IRepository < Shipment > shipmentRepository , <nl> - IRepository < ShipmentItem > shipmentItemRepository , <nl> - IRepository < ShippingMethod > shippingMethodRepository , <nl> IRepository < SpecificationAttribute > specificationAttributeRepository , <nl> IRepository < SpecificationAttributeOption > specificationAttributeOptionRepository , <nl> IRepository < StateProvince > stateProvinceRepository , <nl> - IRepository < StockQuantityHistory > stockQuantityHistoryRepository , <nl> IRepository < Store > storeRepository , <nl> IRepository < TaxCategory > taxCategoryRepository , <nl> - IRepository < TierPrice > tierPriceRepository , <nl> - IRepository < Topic > topicRepository , <nl> IRepository < TopicTemplate > topicTemplateRepository , <nl> IRepository < UrlRecord > urlRecordRepository , <nl> - IRepository < Vendor > vendorRepository , <nl> - IRepository < Warehouse > warehouseRepository , <nl> IWebHelper webHelper ) <nl> { <nl> _addressService = addressService ; <nl> _dataProvider = dataProvider ; <nl> _genericAttributeService = genericAttributeService ; <nl> _fileProvider = fileProvider ; <nl> - _activityLogRepository = activityLogRepository ; <nl> _activityLogTypeRepository = activityLogTypeRepository ; <nl> _addressRepository = addressRepository ; <nl> - _affiliateRepository = affiliateRepository ; <nl> - _blogPostRepository = blogPostRepository ; <nl> _categoryRepository = categoryRepository ; <nl> _categoryTemplateRepository = categoryTemplateRepository ; <nl> _countryRepository = countryRepository ; <nl> _currencyRepository = currencyRepository ; <nl> - _customerPasswordRepository = customerPasswordRepository ; <nl> _customerRepository = customerRepository ; <nl> _customerRoleRepository = customerRoleRepository ; <nl> _deliveryDateRepository = deliveryDateRepository ; <nl> - _discountRepository = discountRepository ; <nl> _emailAccountRepository = emailAccountRepository ; <nl> - _forumGroupRepository = forumGroupRepository ; <nl> - _forumRepository = forumRepository ; <nl> - _giftCardRepository = giftCardRepository ; <nl> _languageRepository = languageRepository ; <nl> _manufacturerRepository = manufacturerRepository ; <nl> _manufacturerTemplateRepository = manufacturerTemplateRepository ; <nl> _measureDimensionRepository = measureDimensionRepository ; <nl> _measureWeightRepository = measureWeightRepository ; <nl> - _messageTemplateRepository = messageTemplateRepository ; <nl> - _newsItemRepository = newsItemRepository ; <nl> - _orderItemRepository = orderItemRepository ; <nl> - _orderNoteRepository = orderNoteRepository ; <nl> - _orderRepository = orderRepository ; <nl> - _pollAnswerRepository = pollAnswerRepository ; <nl> - _pollRepository = pollRepository ; <nl> _productAttributeRepository = productAttributeRepository ; <nl> - _productAttributeMappingRepository = productAttributeMappingRepository ; <nl> _productAvailabilityRangeRepository = productAvailabilityRangeRepository ; <nl> - _productProductTagMappingRepository = productProductTagMappingRepository ; <nl> _productRepository = productRepository ; <nl> _productTagRepository = productTagRepository ; <nl> _productTemplateRepository = productTemplateRepository ; <nl> - _relatedProductRepository = relatedProductRepository ; <nl> - _returnRequestActionRepository = returnRequestActionRepository ; <nl> - _returnRequestReasonRepository = returnRequestReasonRepository ; <nl> - _scheduleTaskRepository = scheduleTaskRepository ; <nl> - _searchTermRepository = searchTermRepository ; <nl> - _shipmentItemRepository = shipmentItemRepository ; <nl> - _shipmentRepository = shipmentRepository ; <nl> - _shippingMethodRepository = shippingMethodRepository ; <nl> _specificationAttributeRepository = specificationAttributeRepository ; <nl> _specificationAttributeOptionRepository = specificationAttributeOptionRepository ; <nl> _stateProvinceRepository = stateProvinceRepository ; <nl> - _stockQuantityHistoryRepository = stockQuantityHistoryRepository ; <nl> _storeRepository = storeRepository ; <nl> _taxCategoryRepository = taxCategoryRepository ; <nl> - _tierPriceRepository = tierPriceRepository ; <nl> - _topicRepository = topicRepository ; <nl> _topicTemplateRepository = topicTemplateRepository ; <nl> _urlRecordRepository = urlRecordRepository ; <nl> - _vendorRepository = vendorRepository ; <nl> - _warehouseRepository = warehouseRepository ; <nl> _webHelper = webHelper ; <nl> } <nl> <nl> public partial class CodeFirstInstallationService : IInstallationService <nl> } <nl> } <nl> <nl> + protected virtual void InsertInstallationData < T > ( IList < T > entities ) where T : BaseEntity <nl> + { <nl> + if ( ! entities . Any ( ) ) <nl> + return ; <nl> + <nl> + InsertInstallationData ( entities . ToArray ( ) ) ; <nl> + } <nl> + <nl> + protected virtual void UpdateInstallationData < T > ( T entity ) where T : BaseEntity <nl> + { <nl> + _dataProvider . UpdateEntity ( entity ) ; <nl> + } <nl> + <nl> + protected virtual void UpdateInstallationData < T > ( IList < T > entities ) where T : BaseEntity <nl> + { <nl> + if ( ! entities . Any ( ) ) <nl> + return ; <nl> + <nl> + foreach ( var entity in entities ) <nl> + _dataProvider . UpdateEntity ( entity ) ; <nl> + } <nl> + <nl> protected virtual SpecificationAttributeOption GetSpecificationAttributeOption ( string specAttributeName , string specAttributeOptionName ) <nl> { <nl> var specificationAttribute = _specificationAttributeRepository . Table . Single ( sa = > sa . Name = = specAttributeName ) ; <nl> protected virtual void InstallStores ( ) <nl> } <nl> } ; <nl> <nl> - _storeRepository . Insert ( stores ) ; <nl> + InsertInstallationData ( stores ) ; <nl> } <nl> <nl> protected virtual void InstallMeasures ( ) <nl> protected virtual void InstallMeasures ( ) <nl> } <nl> } ; <nl> <nl> - _measureDimensionRepository . Insert ( measureDimensions ) ; <nl> + InsertInstallationData ( measureDimensions ) ; <nl> <nl> var measureWeights = new List < MeasureWeight > <nl> { <nl> protected virtual void InstallMeasures ( ) <nl> } <nl> } ; <nl> <nl> - _measureWeightRepository . Insert ( measureWeights ) ; <nl> + InsertInstallationData ( measureWeights ) ; <nl> } <nl> <nl> protected virtual void InstallTaxCategories ( ) <nl> protected virtual void InstallTaxCategories ( ) <nl> DisplayOrder = 20 <nl> } <nl> } ; <nl> - _taxCategoryRepository . Insert ( taxCategories ) ; <nl> + InsertInstallationData ( taxCategories ) ; <nl> } <nl> <nl> protected virtual void InstallLanguages ( ) <nl> protected virtual void InstallLanguages ( ) <nl> Published = true , <nl> DisplayOrder = 1 <nl> } ; <nl> - _languageRepository . Insert ( language ) ; <nl> + InsertInstallationData ( language ) ; <nl> } <nl> <nl> protected virtual void InstallLocaleResources ( ) <nl> protected virtual void InstallCurrencies ( ) <nl> RoundingType = RoundingType . Rounding001 <nl> } <nl> } ; <nl> - _currencyRepository . Insert ( currencies ) ; <nl> + InsertInstallationData ( currencies ) ; <nl> } <nl> <nl> protected virtual void InstallCountriesAndStates ( ) <nl> protected virtual void InstallCountriesAndStates ( ) <nl> Published = true <nl> } <nl> } ; <nl> - _countryRepository . Insert ( countries ) ; <nl> + InsertInstallationData ( countries . ToArray ( ) ) ; <nl> <nl> var statesUsa = new List < StateProvince > <nl> { <nl> protected virtual void InstallCountriesAndStates ( ) <nl> } ; <nl> <nl> statesUsa . ForEach ( x = > x . CountryId = cUsa . Id ) ; <nl> - _stateProvinceRepository . Insert ( statesUsa ) ; <nl> + InsertInstallationData ( statesUsa ) ; <nl> <nl> var statesCanada = new List < StateProvince > <nl> { <nl> protected virtual void InstallCountriesAndStates ( ) <nl> } ; <nl> <nl> statesCanada . ForEach ( x = > x . CountryId = cCanada . Id ) ; <nl> - _stateProvinceRepository . Insert ( statesCanada ) ; <nl> + InsertInstallationData ( statesCanada ) ; <nl> } <nl> <nl> protected virtual void InstallShippingMethods ( ) <nl> protected virtual void InstallShippingMethods ( ) <nl> DisplayOrder = 3 <nl> } <nl> } ; <nl> - _shippingMethodRepository . Insert ( shippingMethods ) ; <nl> + InsertInstallationData ( shippingMethods ) ; <nl> } <nl> <nl> protected virtual void InstallDeliveryDates ( ) <nl> protected virtual void InstallDeliveryDates ( ) <nl> DisplayOrder = 10 <nl> } <nl> } ; <nl> - _deliveryDateRepository . Insert ( deliveryDates ) ; <nl> + InsertInstallationData ( deliveryDates ) ; <nl> } <nl> <nl> protected virtual void InstallProductAvailabilityRanges ( ) <nl> protected virtual void InstallProductAvailabilityRanges ( ) <nl> DisplayOrder = 3 <nl> } <nl> } ; <nl> - _productAvailabilityRangeRepository . Insert ( productAvailabilityRanges ) ; <nl> + InsertInstallationData ( productAvailabilityRanges ) ; <nl> } <nl> <nl> protected virtual void InstallSampleCustomers ( ) <nl> protected virtual void InstallSampleCustomers ( ) <nl> secondUser . BillingAddressId = defaultSecondUserAddress . Id ; <nl> secondUser . ShippingAddressId = defaultSecondUserAddress . Id ; <nl> <nl> - _customerRepository . Insert ( secondUser ) ; <nl> + InsertInstallationData ( secondUser ) ; <nl> <nl> InsertInstallationData ( new CustomerAddressMapping { CustomerId = secondUser . Id , AddressId = defaultSecondUserAddress . Id } ) ; <nl> InsertInstallationData ( new CustomerCustomerRoleMapping { CustomerId = secondUser . Id , CustomerRoleId = crRegistered . Id } ) ; <nl> protected virtual void InstallSampleCustomers ( ) <nl> _genericAttributeService . SaveAttribute ( secondUser , NopCustomerDefaults . LastNameAttribute , defaultSecondUserAddress . LastName ) ; <nl> <nl> / / set customer password <nl> - _customerPasswordRepository . Insert ( new CustomerPassword <nl> + InsertInstallationData ( new CustomerPassword <nl> { <nl> CustomerId = secondUser . Id , <nl> Password = \" 123456 \" , <nl> protected virtual void InstallSampleCustomers ( ) <nl> thirdUser . BillingAddressId = defaultThirdUserAddress . Id ; <nl> thirdUser . ShippingAddressId = defaultThirdUserAddress . Id ; <nl> <nl> - _customerRepository . Insert ( thirdUser ) ; <nl> + InsertInstallationData ( thirdUser ) ; <nl> <nl> InsertInstallationData ( new CustomerAddressMapping { CustomerId = thirdUser . Id , AddressId = defaultThirdUserAddress . Id } ) ; <nl> InsertInstallationData ( new CustomerCustomerRoleMapping { CustomerId = thirdUser . Id , CustomerRoleId = crRegistered . Id } ) ; <nl> protected virtual void InstallSampleCustomers ( ) <nl> _genericAttributeService . SaveAttribute ( thirdUser , NopCustomerDefaults . LastNameAttribute , defaultThirdUserAddress . LastName ) ; <nl> <nl> / / set customer password <nl> - _customerPasswordRepository . Insert ( new CustomerPassword <nl> + InsertInstallationData ( new CustomerPassword <nl> { <nl> CustomerId = thirdUser . Id , <nl> Password = \" 123456 \" , <nl> protected virtual void InstallSampleCustomers ( ) <nl> fourthUser . BillingAddressId = defaultFourthUserAddress . Id ; <nl> fourthUser . ShippingAddressId = defaultFourthUserAddress . Id ; <nl> <nl> - _customerRepository . Insert ( fourthUser ) ; <nl> + InsertInstallationData ( fourthUser ) ; <nl> <nl> InsertInstallationData ( new CustomerAddressMapping { CustomerId = fourthUser . Id , AddressId = defaultFourthUserAddress . Id } ) ; <nl> InsertInstallationData ( new CustomerCustomerRoleMapping { CustomerId = fourthUser . Id , CustomerRoleId = crRegistered . Id } ) ; <nl> protected virtual void InstallSampleCustomers ( ) <nl> _genericAttributeService . SaveAttribute ( fourthUser , NopCustomerDefaults . LastNameAttribute , defaultFourthUserAddress . LastName ) ; <nl> <nl> / / set customer password <nl> - _customerPasswordRepository . Insert ( new CustomerPassword <nl> + InsertInstallationData ( new CustomerPassword <nl> { <nl> CustomerId = fourthUser . Id , <nl> Password = \" 123456 \" , <nl> protected virtual void InstallSampleCustomers ( ) <nl> fifthUser . BillingAddressId = defaultFifthUserAddress . Id ; <nl> fifthUser . ShippingAddressId = defaultFifthUserAddress . Id ; <nl> <nl> - _customerRepository . Insert ( fifthUser ) ; <nl> + InsertInstallationData ( fifthUser ) ; <nl> <nl> InsertInstallationData ( new CustomerAddressMapping { CustomerId = fifthUser . Id , AddressId = defaultFifthUserAddress . Id } ) ; <nl> InsertInstallationData ( new CustomerCustomerRoleMapping { CustomerId = fifthUser . Id , CustomerRoleId = crRegistered . Id } ) ; <nl> protected virtual void InstallSampleCustomers ( ) <nl> defaultFifthUserAddress . LastName ) ; <nl> <nl> / / set customer password <nl> - _customerPasswordRepository . Insert ( new CustomerPassword <nl> + InsertInstallationData ( new CustomerPassword <nl> { <nl> CustomerId = fifthUser . Id , <nl> Password = \" 123456 \" , <nl> protected virtual void InstallSampleCustomers ( ) <nl> sixthUser . BillingAddressId = defaultSixthUserAddress . Id ; <nl> sixthUser . ShippingAddressId = defaultSixthUserAddress . Id ; <nl> <nl> - _customerRepository . Insert ( sixthUser ) ; <nl> + InsertInstallationData ( sixthUser ) ; <nl> <nl> InsertInstallationData ( new CustomerAddressMapping { CustomerId = sixthUser . Id , AddressId = defaultSixthUserAddress . Id } ) ; <nl> InsertInstallationData ( new CustomerCustomerRoleMapping { CustomerId = sixthUser . Id , CustomerRoleId = crRegistered . Id } ) ; <nl> protected virtual void InstallSampleCustomers ( ) <nl> _genericAttributeService . SaveAttribute ( sixthUser , NopCustomerDefaults . LastNameAttribute , defaultSixthUserAddress . LastName ) ; <nl> <nl> / / set customer password <nl> - _customerPasswordRepository . Insert ( new CustomerPassword <nl> + InsertInstallationData ( new CustomerPassword <nl> { <nl> CustomerId = sixthUser . Id , <nl> Password = \" 123456 \" , <nl> protected virtual void InstallCustomersAndUsers ( string defaultUserEmail , string <nl> crGuests , <nl> crVendors <nl> } ; <nl> - _customerRoleRepository . Insert ( customerRoles ) ; <nl> + InsertInstallationData ( customerRoles ) ; <nl> <nl> / / default store <nl> var defaultStore = _storeRepository . Table . FirstOrDefault ( ) ; <nl> protected virtual void InstallCustomersAndUsers ( string defaultUserEmail , string <nl> adminUser . BillingAddressId = defaultAdminUserAddress . Id ; <nl> adminUser . ShippingAddressId = defaultAdminUserAddress . Id ; <nl> <nl> - _customerRepository . Insert ( adminUser ) ; <nl> + InsertInstallationData ( adminUser ) ; <nl> <nl> InsertInstallationData ( new CustomerAddressMapping { CustomerId = adminUser . Id , AddressId = defaultAdminUserAddress . Id } ) ; <nl> <nl> protected virtual void InstallCustomersAndUsers ( string defaultUserEmail , string <nl> RegisteredInStoreId = storeId <nl> } ; <nl> <nl> - _customerRepository . Insert ( searchEngineUser ) ; <nl> + InsertInstallationData ( searchEngineUser ) ; <nl> <nl> InsertInstallationData ( new CustomerCustomerRoleMapping { CustomerRoleId = crGuests . Id , CustomerId = searchEngineUser . Id } ) ; <nl> <nl> protected virtual void InstallCustomersAndUsers ( string defaultUserEmail , string <nl> RegisteredInStoreId = storeId <nl> } ; <nl> <nl> - _customerRepository . Insert ( backgroundTaskUser ) ; <nl> + InsertInstallationData ( backgroundTaskUser ) ; <nl> <nl> InsertInstallationData ( new CustomerCustomerRoleMapping { CustomerId = backgroundTaskUser . Id , CustomerRoleId = crGuests . Id } ) ; <nl> } <nl> protected virtual void InstallOrders ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> CustomOrderNumber = string . Empty <nl> } ; <nl> - _orderRepository . Insert ( firstOrder ) ; <nl> + InsertInstallationData ( firstOrder ) ; <nl> firstOrder . CustomOrderNumber = firstOrder . Id . ToString ( ) ; <nl> - _orderRepository . Update ( firstOrder ) ; <nl> + UpdateInstallationData ( firstOrder ) ; <nl> <nl> / / item Apple iCam <nl> var firstOrderItem1 = new OrderItem <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( firstOrderItem1 ) ; <nl> + InsertInstallationData ( firstOrderItem1 ) ; <nl> <nl> / / item Leica T Mirrorless Digital Camera <nl> var fierstOrderItem2 = new OrderItem <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( fierstOrderItem2 ) ; <nl> + InsertInstallationData ( fierstOrderItem2 ) ; <nl> <nl> / / item $ 25 Virtual Gift Card <nl> var firstOrderItem3 = new OrderItem <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( firstOrderItem3 ) ; <nl> + InsertInstallationData ( firstOrderItem3 ) ; <nl> <nl> var firstOrderGiftcard = new GiftCard <nl> { <nl> protected virtual void InstallOrders ( ) <nl> IsRecipientNotified = false , <nl> CreatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _giftCardRepository . Insert ( firstOrderGiftcard ) ; <nl> + InsertInstallationData ( firstOrderGiftcard ) ; <nl> <nl> / / order notes <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order placed \" , <nl> OrderId = firstOrder . Id <nl> } ) ; <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order paid \" , <nl> protected virtual void InstallOrders ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> CustomOrderNumber = string . Empty <nl> } ; <nl> - _orderRepository . Insert ( secondOrder ) ; <nl> + InsertInstallationData ( secondOrder ) ; <nl> secondOrder . CustomOrderNumber = secondOrder . Id . ToString ( ) ; <nl> - _orderRepository . Update ( secondOrder ) ; <nl> + UpdateInstallationData ( secondOrder ) ; <nl> <nl> / / order notes <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order placed \" , <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( secondOrderItem1 ) ; <nl> + InsertInstallationData ( secondOrderItem1 ) ; <nl> <nl> / / item Flower Girl Bracelet <nl> var secondOrderItem2 = new OrderItem <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( secondOrderItem2 ) ; <nl> + InsertInstallationData ( secondOrderItem2 ) ; <nl> <nl> / / third order <nl> var thirdCustomer = _customerRepository . Table . First ( c = > c . Email = = \" james_pan @ nopCommerce . com \" ) ; <nl> protected virtual void InstallOrders ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> CustomOrderNumber = string . Empty <nl> } ; <nl> - _orderRepository . Insert ( thirdOrder ) ; <nl> + InsertInstallationData ( thirdOrder ) ; <nl> thirdOrder . CustomOrderNumber = thirdOrder . Id . ToString ( ) ; <nl> - _orderRepository . Update ( thirdOrder ) ; <nl> + UpdateInstallationData ( thirdOrder ) ; <nl> <nl> / / order notes <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order placed \" , <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( thirdOrderItem1 ) ; <nl> + InsertInstallationData ( thirdOrderItem1 ) ; <nl> <nl> / / item Night Visions <nl> var thirdOrderItem2 = new OrderItem <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( thirdOrderItem2 ) ; <nl> + InsertInstallationData ( thirdOrderItem2 ) ; <nl> <nl> / / item Science & Faith <nl> var thirdOrderItem3 = new OrderItem <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( thirdOrderItem3 ) ; <nl> + InsertInstallationData ( thirdOrderItem3 ) ; <nl> <nl> / / fourth order <nl> var fourthCustomer = _customerRepository . Table . First ( c = > c . Email = = \" brenda_lindgren @ nopCommerce . com \" ) ; <nl> protected virtual void InstallOrders ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> CustomOrderNumber = string . Empty <nl> } ; <nl> - _orderRepository . Insert ( fourthOrder ) ; <nl> + InsertInstallationData ( fourthOrder ) ; <nl> fourthOrder . CustomOrderNumber = fourthOrder . Id . ToString ( ) ; <nl> - _orderRepository . Update ( fourthOrder ) ; <nl> + UpdateInstallationData ( fourthOrder ) ; <nl> <nl> / / order notes <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order placed \" , <nl> OrderId = fourthOrder . Id <nl> } ) ; <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order paid \" , <nl> OrderId = fourthOrder . Id <nl> } ) ; <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order shipped \" , <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( fourthOrderItem1 ) ; <nl> + InsertInstallationData ( fourthOrderItem1 ) ; <nl> <nl> / / item First Prize Pies <nl> var fourthOrderItem2 = new OrderItem <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( fourthOrderItem2 ) ; <nl> + InsertInstallationData ( fourthOrderItem2 ) ; <nl> <nl> / / item Fahrenheit 451 by Ray Bradbury <nl> var fourthOrderItem3 = new OrderItem <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( fourthOrderItem3 ) ; <nl> + InsertInstallationData ( fourthOrderItem3 ) ; <nl> <nl> / / shipments <nl> / / shipment 1 <nl> protected virtual void InstallOrders ( ) <nl> AdminComment = string . Empty , <nl> CreatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _shipmentRepository . Insert ( fourthOrderShipment1 ) ; <nl> + InsertInstallationData ( fourthOrderShipment1 ) ; <nl> <nl> var fourthOrderShipment1Item1 = new ShipmentItem <nl> { <nl> protected virtual void InstallOrders ( ) <nl> WarehouseId = 0 , <nl> ShipmentId = fourthOrderShipment1 . Id <nl> } ; <nl> - _shipmentItemRepository . Insert ( fourthOrderShipment1Item1 ) ; <nl> + InsertInstallationData ( fourthOrderShipment1Item1 ) ; <nl> <nl> var fourthOrderShipment1Item2 = new ShipmentItem <nl> { <nl> protected virtual void InstallOrders ( ) <nl> WarehouseId = 0 , <nl> ShipmentId = fourthOrderShipment1 . Id <nl> } ; <nl> - _shipmentItemRepository . Insert ( fourthOrderShipment1Item2 ) ; <nl> + InsertInstallationData ( fourthOrderShipment1Item2 ) ; <nl> <nl> / / shipment 2 <nl> var fourthOrderShipment2 = new Shipment <nl> protected virtual void InstallOrders ( ) <nl> AdminComment = string . Empty , <nl> CreatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _shipmentRepository . Insert ( fourthOrderShipment2 ) ; <nl> + InsertInstallationData ( fourthOrderShipment2 ) ; <nl> <nl> var fourthOrderShipment2Item1 = new ShipmentItem <nl> { <nl> protected virtual void InstallOrders ( ) <nl> WarehouseId = 0 , <nl> ShipmentId = fourthOrderShipment2 . Id <nl> } ; <nl> - _shipmentItemRepository . Insert ( fourthOrderShipment2Item1 ) ; <nl> + InsertInstallationData ( fourthOrderShipment2Item1 ) ; <nl> <nl> / / fifth order <nl> var fifthCustomer = _customerRepository . Table . First ( c = > c . Email = = \" victoria_victoria @ nopCommerce . com \" ) ; <nl> protected virtual void InstallOrders ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> CustomOrderNumber = string . Empty <nl> } ; <nl> - _orderRepository . Insert ( fifthOrder ) ; <nl> + InsertInstallationData ( fifthOrder ) ; <nl> fifthOrder . CustomOrderNumber = fifthOrder . Id . ToString ( ) ; <nl> - _orderRepository . Update ( fifthOrder ) ; <nl> + UpdateInstallationData ( fifthOrder ) ; <nl> <nl> / / order notes <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order placed \" , <nl> OrderId = fifthOrder . Id <nl> } ) ; <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order paid \" , <nl> OrderId = fifthOrder . Id <nl> } ) ; <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order shipped \" , <nl> OrderId = fifthOrder . Id <nl> } ) ; <nl> - _orderNoteRepository . Insert ( new OrderNote <nl> + InsertInstallationData ( new OrderNote <nl> { <nl> CreatedOnUtc = DateTime . UtcNow , <nl> Note = \" Order delivered \" , <nl> protected virtual void InstallOrders ( ) <nl> RentalStartDateUtc = null , <nl> RentalEndDateUtc = null <nl> } ; <nl> - _orderItemRepository . Insert ( fifthOrderItem1 ) ; <nl> + InsertInstallationData ( fifthOrderItem1 ) ; <nl> <nl> / / shipment 1 <nl> var fifthOrderShipment1 = new Shipment <nl> protected virtual void InstallOrders ( ) <nl> AdminComment = string . Empty , <nl> CreatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _shipmentRepository . Insert ( fifthOrderShipment1 ) ; <nl> + InsertInstallationData ( fifthOrderShipment1 ) ; <nl> <nl> var fifthOrderShipment1Item1 = new ShipmentItem <nl> { <nl> protected virtual void InstallOrders ( ) <nl> WarehouseId = 0 , <nl> ShipmentId = fifthOrderShipment1 . Id <nl> } ; <nl> - _shipmentItemRepository . Insert ( fifthOrderShipment1Item1 ) ; <nl> + InsertInstallationData ( fifthOrderShipment1Item1 ) ; <nl> } <nl> <nl> protected virtual void InstallActivityLog ( string defaultUserEmail ) <nl> protected virtual void InstallActivityLog ( string defaultUserEmail ) <nl> if ( defaultCustomer = = null ) <nl> throw new Exception ( \" Cannot load default customer \" ) ; <nl> <nl> - _activityLogRepository . Insert ( new ActivityLog <nl> + InsertInstallationData ( new ActivityLog <nl> { <nl> ActivityLogTypeId = _activityLogTypeRepository . Table . FirstOrDefault ( alt = > alt . SystemKeyword = = \" EditCategory \" ) ? . Id ? ? throw new Exception ( \" Cannot load LogType : EditCategory \" ) , <nl> Comment = \" Edited a category ( ' Computers ' ) \" , <nl> protected virtual void InstallActivityLog ( string defaultUserEmail ) <nl> IpAddress = \" 127 . 0 . 0 . 1 \" <nl> } ) ; <nl> <nl> - _activityLogRepository . Insert ( new ActivityLog <nl> + InsertInstallationData ( new ActivityLog <nl> { <nl> ActivityLogTypeId = _activityLogTypeRepository . Table . FirstOrDefault ( alt = > alt . SystemKeyword = = \" EditDiscount \" ) ? . Id ? ? throw new Exception ( \" Cannot load LogType : EditDiscount \" ) , <nl> Comment = \" Edited a discount ( ' Sample discount with coupon code ' ) \" , <nl> protected virtual void InstallActivityLog ( string defaultUserEmail ) <nl> IpAddress = \" 127 . 0 . 0 . 1 \" <nl> } ) ; <nl> <nl> - _activityLogRepository . Insert ( new ActivityLog <nl> + InsertInstallationData ( new ActivityLog <nl> { <nl> ActivityLogTypeId = _activityLogTypeRepository . Table . FirstOrDefault ( alt = > alt . SystemKeyword = = \" EditSpecAttribute \" ) ? . Id ? ? throw new Exception ( \" Cannot load LogType : EditSpecAttribute \" ) , <nl> Comment = \" Edited a specification attribute ( ' CPU Type ' ) \" , <nl> protected virtual void InstallActivityLog ( string defaultUserEmail ) <nl> IpAddress = \" 127 . 0 . 0 . 1 \" <nl> } ) ; <nl> <nl> - _activityLogRepository . Insert ( new ActivityLog <nl> + InsertInstallationData ( new ActivityLog <nl> { <nl> ActivityLogTypeId = _activityLogTypeRepository . Table . FirstOrDefault ( alt = > alt . SystemKeyword = = \" AddNewProductAttribute \" ) ? . Id ? ? throw new Exception ( \" Cannot load LogType : AddNewProductAttribute \" ) , <nl> Comment = \" Added a new product attribute ( ' Some attribute ' ) \" , <nl> protected virtual void InstallActivityLog ( string defaultUserEmail ) <nl> IpAddress = \" 127 . 0 . 0 . 1 \" <nl> } ) ; <nl> <nl> - _activityLogRepository . Insert ( new ActivityLog <nl> + InsertInstallationData ( new ActivityLog <nl> { <nl> ActivityLogTypeId = _activityLogTypeRepository . Table . FirstOrDefault ( alt = > alt . SystemKeyword = = \" DeleteGiftCard \" ) ? . Id ? ? throw new Exception ( \" Cannot load LogType : DeleteGiftCard \" ) , <nl> Comment = \" Deleted a gift card ( ' bdbbc0ef - be57 ' ) \" , <nl> protected virtual void InstallSearchTerms ( ) <nl> if ( defaultStore = = null ) <nl> throw new Exception ( \" No default store could be loaded \" ) ; <nl> <nl> - _searchTermRepository . Insert ( new SearchTerm <nl> + InsertInstallationData ( new SearchTerm <nl> { <nl> Count = 34 , <nl> Keyword = \" computer \" , <nl> StoreId = defaultStore . Id <nl> } ) ; <nl> - _searchTermRepository . Insert ( new SearchTerm <nl> + InsertInstallationData ( new SearchTerm <nl> { <nl> Count = 30 , <nl> Keyword = \" camera \" , <nl> StoreId = defaultStore . Id <nl> } ) ; <nl> - _searchTermRepository . Insert ( new SearchTerm <nl> + InsertInstallationData ( new SearchTerm <nl> { <nl> Count = 27 , <nl> Keyword = \" jewelry \" , <nl> StoreId = defaultStore . Id <nl> } ) ; <nl> - _searchTermRepository . Insert ( new SearchTerm <nl> + InsertInstallationData ( new SearchTerm <nl> { <nl> Count = 26 , <nl> Keyword = \" shoes \" , <nl> StoreId = defaultStore . Id <nl> } ) ; <nl> - _searchTermRepository . Insert ( new SearchTerm <nl> + InsertInstallationData ( new SearchTerm <nl> { <nl> Count = 19 , <nl> Keyword = \" jeans \" , <nl> StoreId = defaultStore . Id <nl> } ) ; <nl> - _searchTermRepository . Insert ( new SearchTerm <nl> + InsertInstallationData ( new SearchTerm <nl> { <nl> Count = 10 , <nl> Keyword = \" gift \" , <nl> protected virtual void InstallEmailAccounts ( ) <nl> UseDefaultCredentials = false <nl> } <nl> } ; <nl> - _emailAccountRepository . Insert ( emailAccounts ) ; <nl> + InsertInstallationData ( emailAccounts ) ; <nl> } <nl> <nl> protected virtual void InstallMessageTemplates ( ) <nl> protected virtual void InstallMessageTemplates ( ) <nl> EmailAccountId = eaGeneral . Id <nl> } <nl> } ; <nl> - _messageTemplateRepository . Insert ( messageTemplates ) ; <nl> + InsertInstallationData ( messageTemplates ) ; <nl> } <nl> <nl> protected virtual void InstallTopics ( ) <nl> protected virtual void InstallTopics ( ) <nl> TopicTemplateId = defaultTopicTemplate . Id <nl> } <nl> } ; <nl> - _topicRepository . Insert ( topics ) ; <nl> + InsertInstallationData ( topics ) ; <nl> <nl> / / search engine names <nl> foreach ( var topic in topics ) <nl> { <nl> - _urlRecordRepository . Insert ( new UrlRecord <nl> + InsertInstallationData ( new UrlRecord <nl> { <nl> EntityId = topic . Id , <nl> EntityName = nameof ( Topic ) , <nl> protected virtual void InstallProductAttributes ( ) <nl> Name = \" Software \" <nl> } <nl> } ; <nl> - _productAttributeRepository . Insert ( productAttributes ) ; <nl> + InsertInstallationData ( productAttributes ) ; <nl> } <nl> <nl> protected virtual void InstallCategories ( ) <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryComputers ) ; <nl> - _categoryRepository . Insert ( categoryComputers ) ; <nl> + InsertInstallationData ( categoryComputers ) ; <nl> <nl> var categoryDesktops = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryDesktops ) ; <nl> - _categoryRepository . Insert ( categoryDesktops ) ; <nl> + InsertInstallationData ( categoryDesktops ) ; <nl> <nl> var categoryNotebooks = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryNotebooks ) ; <nl> - _categoryRepository . Insert ( categoryNotebooks ) ; <nl> + InsertInstallationData ( categoryNotebooks ) ; <nl> <nl> var categorySoftware = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categorySoftware ) ; <nl> - _categoryRepository . Insert ( categorySoftware ) ; <nl> + InsertInstallationData ( categorySoftware ) ; <nl> <nl> var categoryElectronics = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryElectronics ) ; <nl> - _categoryRepository . Insert ( categoryElectronics ) ; <nl> + InsertInstallationData ( categoryElectronics ) ; <nl> <nl> var categoryCameraPhoto = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryCameraPhoto ) ; <nl> - _categoryRepository . Insert ( categoryCameraPhoto ) ; <nl> + InsertInstallationData ( categoryCameraPhoto ) ; <nl> <nl> var categoryCellPhones = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryCellPhones ) ; <nl> - _categoryRepository . Insert ( categoryCellPhones ) ; <nl> + InsertInstallationData ( categoryCellPhones ) ; <nl> <nl> var categoryOthers = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryOthers ) ; <nl> - _categoryRepository . Insert ( categoryOthers ) ; <nl> + InsertInstallationData ( categoryOthers ) ; <nl> <nl> var categoryApparel = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryApparel ) ; <nl> - _categoryRepository . Insert ( categoryApparel ) ; <nl> + InsertInstallationData ( categoryApparel ) ; <nl> <nl> var categoryShoes = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryShoes ) ; <nl> - _categoryRepository . Insert ( categoryShoes ) ; <nl> + InsertInstallationData ( categoryShoes ) ; <nl> <nl> var categoryClothing = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryClothing ) ; <nl> - _categoryRepository . Insert ( categoryClothing ) ; <nl> + InsertInstallationData ( categoryClothing ) ; <nl> <nl> var categoryAccessories = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryAccessories ) ; <nl> - _categoryRepository . Insert ( categoryAccessories ) ; <nl> + InsertInstallationData ( categoryAccessories ) ; <nl> <nl> var categoryDigitalDownloads = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryDigitalDownloads ) ; <nl> - _categoryRepository . Insert ( categoryDigitalDownloads ) ; <nl> + InsertInstallationData ( categoryDigitalDownloads ) ; <nl> <nl> var categoryBooks = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryBooks ) ; <nl> - _categoryRepository . Insert ( categoryBooks ) ; <nl> + InsertInstallationData ( categoryBooks ) ; <nl> <nl> var categoryJewelry = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryJewelry ) ; <nl> - _categoryRepository . Insert ( categoryJewelry ) ; <nl> + InsertInstallationData ( categoryJewelry ) ; <nl> <nl> var categoryGiftCards = new Category <nl> { <nl> protected virtual void InstallCategories ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> allCategories . Add ( categoryGiftCards ) ; <nl> - _categoryRepository . Insert ( categoryGiftCards ) ; <nl> + InsertInstallationData ( categoryGiftCards ) ; <nl> <nl> / / search engine names <nl> foreach ( var category in allCategories ) <nl> { <nl> - _urlRecordRepository . Insert ( new UrlRecord <nl> + InsertInstallationData ( new UrlRecord <nl> { <nl> EntityId = category . Id , <nl> EntityName = nameof ( Category ) , <nl> protected virtual void InstallManufacturers ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _manufacturerRepository . Insert ( manufacturerAsus ) ; <nl> + InsertInstallationData ( manufacturerAsus ) ; <nl> allManufacturers . Add ( manufacturerAsus ) ; <nl> <nl> var manufacturerHp = new Manufacturer <nl> protected virtual void InstallManufacturers ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _manufacturerRepository . Insert ( manufacturerHp ) ; <nl> + InsertInstallationData ( manufacturerHp ) ; <nl> allManufacturers . Add ( manufacturerHp ) ; <nl> <nl> var manufacturerNike = new Manufacturer <nl> protected virtual void InstallManufacturers ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _manufacturerRepository . Insert ( manufacturerNike ) ; <nl> + InsertInstallationData ( manufacturerNike ) ; <nl> allManufacturers . Add ( manufacturerNike ) ; <nl> <nl> / / search engine names <nl> foreach ( var manufacturer in allManufacturers ) <nl> { <nl> - _urlRecordRepository . Insert ( new UrlRecord <nl> + InsertInstallationData ( new UrlRecord <nl> { <nl> EntityId = manufacturer . Id , <nl> EntityName = nameof ( Manufacturer ) , <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> <nl> allProducts . Add ( productBuildComputer ) ; <nl> <nl> - _productRepository . Insert ( productBuildComputer ) ; <nl> + InsertInstallationData ( productBuildComputer ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( productDigitalStorm ) ; <nl> <nl> - _productRepository . Insert ( productDigitalStorm ) ; <nl> + InsertInstallationData ( productDigitalStorm ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( productLenovoIdeaCentre ) ; <nl> <nl> - _productRepository . Insert ( productLenovoIdeaCentre ) ; <nl> + InsertInstallationData ( productLenovoIdeaCentre ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( productAppleMacBookPro ) ; <nl> <nl> - _productRepository . Insert ( productAppleMacBookPro ) ; <nl> + InsertInstallationData ( productAppleMacBookPro ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> <nl> allProducts . Add ( productAsusN551JK ) ; <nl> <nl> - _productRepository . Insert ( productAsusN551JK ) ; <nl> + InsertInstallationData ( productAsusN551JK ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( productSamsungSeries ) ; <nl> <nl> - _productRepository . Insert ( productSamsungSeries ) ; <nl> + InsertInstallationData ( productSamsungSeries ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( productHpSpectre ) ; <nl> <nl> - _productRepository . Insert ( productHpSpectre ) ; <nl> + InsertInstallationData ( productHpSpectre ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( productHpEnvy ) ; <nl> <nl> - _productRepository . Insert ( productHpEnvy ) ; <nl> + InsertInstallationData ( productHpEnvy ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( productLenovoThinkpad ) ; <nl> <nl> - _productRepository . Insert ( productLenovoThinkpad ) ; <nl> + InsertInstallationData ( productLenovoThinkpad ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( productAdobePhotoshop ) ; <nl> <nl> - _productRepository . Insert ( productAdobePhotoshop ) ; <nl> + InsertInstallationData ( productAdobePhotoshop ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( productWindows8Pro ) ; <nl> <nl> - _productRepository . Insert ( productWindows8Pro ) ; <nl> + InsertInstallationData ( productWindows8Pro ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallComputers ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( productSoundForge ) ; <nl> <nl> - _productRepository . Insert ( productSoundForge ) ; <nl> + InsertInstallationData ( productSoundForge ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productNikonD5500DSLR ) ; <nl> <nl> - _productRepository . Insert ( productNikonD5500DSLR ) ; <nl> + InsertInstallationData ( productNikonD5500DSLR ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productNikonD5500DSLR_associated_1 ) ; <nl> <nl> - _productRepository . Insert ( productNikonD5500DSLR_associated_1 ) ; <nl> + InsertInstallationData ( productNikonD5500DSLR_associated_1 ) ; <nl> <nl> InsertProductPicture ( productNikonD5500DSLR_associated_1 , \" product_NikonCamera_black . jpeg \" ) ; <nl> <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productNikonD5500DSLR_associated_2 ) ; <nl> <nl> - _productRepository . Insert ( productNikonD5500DSLR_associated_2 ) ; <nl> + InsertInstallationData ( productNikonD5500DSLR_associated_2 ) ; <nl> <nl> InsertProductPicture ( productNikonD5500DSLR_associated_2 , \" product_NikonCamera_red . jpeg \" ) ; <nl> <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productLeica ) ; <nl> <nl> - _productRepository . Insert ( productLeica ) ; <nl> + InsertInstallationData ( productLeica ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productAppleICam ) ; <nl> <nl> - _productRepository . Insert ( productAppleICam ) ; <nl> + InsertInstallationData ( productAppleICam ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productHtcOne ) ; <nl> <nl> - _productRepository . Insert ( productHtcOne ) ; <nl> + InsertInstallationData ( productHtcOne ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productHtcOneMini ) ; <nl> <nl> - _productRepository . Insert ( productHtcOneMini ) ; <nl> + InsertInstallationData ( productHtcOneMini ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productNokiaLumia ) ; <nl> <nl> - _productRepository . Insert ( productNokiaLumia ) ; <nl> + InsertInstallationData ( productNokiaLumia ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productBeatsPill ) ; <nl> <nl> - _productRepository . Insert ( productBeatsPill ) ; <nl> + InsertInstallationData ( productBeatsPill ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> InsertProductPicture ( productBeatsPill , \" product_PillBeats_1 . jpeg \" ) ; <nl> InsertProductPicture ( productBeatsPill , \" product_PillBeats_2 . jpeg \" , 2 ) ; <nl> <nl> - _tierPriceRepository . Insert ( new List < TierPrice > <nl> + InsertInstallationData ( new List < TierPrice > <nl> { <nl> new TierPrice <nl> { <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productUniversalTabletCover ) ; <nl> <nl> - _productRepository . Insert ( productUniversalTabletCover ) ; <nl> + InsertInstallationData ( productUniversalTabletCover ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallElectronics ( ProductTemplate productTemplateSimple , <nl> } ; <nl> allProducts . Add ( productPortableSoundSpeakers ) ; <nl> <nl> - _productRepository . Insert ( productPortableSoundSpeakers ) ; <nl> + InsertInstallationData ( productPortableSoundSpeakers ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productNikeFloral ) ; <nl> <nl> - _productRepository . Insert ( productNikeFloral ) ; <nl> + InsertInstallationData ( productNikeFloral ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> AddProductTag ( productNikeFloral , \" shoes \" ) ; <nl> AddProductTag ( productNikeFloral , \" apparel \" ) ; <nl> <nl> - _productRepository . Update ( productNikeFloral ) ; <nl> + UpdateInstallationData ( productNikeFloral ) ; <nl> <nl> var productAdidas = new Product <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productAdidas ) ; <nl> <nl> - _productRepository . Insert ( productAdidas ) ; <nl> + InsertInstallationData ( productAdidas ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> AddProductTag ( productAdidas , \" shoes \" ) ; <nl> AddProductTag ( productAdidas , \" apparel \" ) ; <nl> <nl> - _productRepository . Update ( productAdidas ) ; <nl> + UpdateInstallationData ( productAdidas ) ; <nl> <nl> var productNikeZoom = new Product <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> <nl> allProducts . Add ( productNikeZoom ) ; <nl> <nl> - _productRepository . Insert ( productNikeZoom ) ; <nl> + InsertInstallationData ( productNikeZoom ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productNikeTailwind ) ; <nl> <nl> - _productRepository . Insert ( productNikeTailwind ) ; <nl> + InsertInstallationData ( productNikeTailwind ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> <nl> allProducts . Add ( productOversizedWomenTShirt ) ; <nl> <nl> - _productRepository . Insert ( productOversizedWomenTShirt ) ; <nl> + InsertInstallationData ( productOversizedWomenTShirt ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> <nl> InsertProductPicture ( productOversizedWomenTShirt , \" product_WomenTShirt . jpg \" ) ; <nl> <nl> - _tierPriceRepository . Insert ( new List < TierPrice > <nl> + InsertInstallationData ( new List < TierPrice > <nl> { <nl> new TierPrice <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productCustomTShirt ) ; <nl> <nl> - _productRepository . Insert ( productCustomTShirt ) ; <nl> + InsertInstallationData ( productCustomTShirt ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> <nl> InsertProductPicture ( productCustomTShirt , \" product_CustomTShirt . jpeg \" ) ; <nl> <nl> - _productAttributeMappingRepository . Insert ( <nl> + InsertInstallationData ( <nl> new ProductAttributeMapping <nl> { <nl> ProductId = productCustomTShirt . Id , <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productLeviJeans ) ; <nl> <nl> - _productRepository . Insert ( productLeviJeans ) ; <nl> + InsertInstallationData ( productLeviJeans ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> InsertProductPicture ( productLeviJeans , \" product_LeviJeans_1 . jpg \" ) ; <nl> InsertProductPicture ( productLeviJeans , \" product_LeviJeans_2 . jpg \" , 2 ) ; <nl> <nl> - _tierPriceRepository . Insert ( new List < TierPrice > <nl> + InsertInstallationData ( new List < TierPrice > <nl> { <nl> new TierPrice <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productObeyHat ) ; <nl> <nl> - _productRepository . Insert ( productObeyHat ) ; <nl> + InsertInstallationData ( productObeyHat ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productBelt ) ; <nl> <nl> - _productRepository . Insert ( productBelt ) ; <nl> + InsertInstallationData ( productBelt ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallApparel ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productSunglasses ) ; <nl> <nl> - _productRepository . Insert ( productSunglasses ) ; <nl> + InsertInstallationData ( productSunglasses ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallDigitalDownloads ( ProductTemplate productTemplateSi <nl> } ; <nl> allProducts . Add ( productNightVision ) ; <nl> <nl> - _productRepository . Insert ( productNightVision ) ; <nl> + InsertInstallationData ( productNightVision ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallDigitalDownloads ( ProductTemplate productTemplateSi <nl> } ; <nl> allProducts . Add ( productIfYouWait ) ; <nl> <nl> - _productRepository . Insert ( productIfYouWait ) ; <nl> + InsertInstallationData ( productIfYouWait ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallDigitalDownloads ( ProductTemplate productTemplateSi <nl> } ; <nl> allProducts . Add ( productScienceAndFaith ) ; <nl> <nl> - _productRepository . Insert ( productScienceAndFaith ) ; <nl> + InsertInstallationData ( productScienceAndFaith ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallBooks ( ProductTemplate productTemplateSimple , List < <nl> } ; <nl> allProducts . Add ( productFahrenheit ) ; <nl> <nl> - _productRepository . Insert ( productFahrenheit ) ; <nl> + InsertInstallationData ( productFahrenheit ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallBooks ( ProductTemplate productTemplateSimple , List < <nl> } ; <nl> allProducts . Add ( productFirstPrizePies ) ; <nl> <nl> - _productRepository . Insert ( productFirstPrizePies ) ; <nl> + InsertInstallationData ( productFirstPrizePies ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallBooks ( ProductTemplate productTemplateSimple , List < <nl> } ; <nl> allProducts . Add ( productPrideAndPrejudice ) ; <nl> <nl> - _productRepository . Insert ( productPrideAndPrejudice ) ; <nl> + InsertInstallationData ( productPrideAndPrejudice ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallJewelry ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productElegantGemstoneNecklace ) ; <nl> <nl> - _productRepository . Insert ( productElegantGemstoneNecklace ) ; <nl> + InsertInstallationData ( productElegantGemstoneNecklace ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallJewelry ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productFlowerGirlBracelet ) ; <nl> <nl> - _productRepository . Insert ( productFlowerGirlBracelet ) ; <nl> + InsertInstallationData ( productFlowerGirlBracelet ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallJewelry ( ProductTemplate productTemplateSimple , Lis <nl> } ; <nl> allProducts . Add ( productEngagementRing ) ; <nl> <nl> - _productRepository . Insert ( productEngagementRing ) ; <nl> + InsertInstallationData ( productEngagementRing ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallGiftCards ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( product25GiftCard ) ; <nl> <nl> - _productRepository . Insert ( product25GiftCard ) ; <nl> + InsertInstallationData ( product25GiftCard ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallGiftCards ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( product50GiftCard ) ; <nl> <nl> - _productRepository . Insert ( product50GiftCard ) ; <nl> + InsertInstallationData ( product50GiftCard ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallGiftCards ( ProductTemplate productTemplateSimple , L <nl> } ; <nl> allProducts . Add ( product100GiftCard ) ; <nl> <nl> - _productRepository . Insert ( product100GiftCard ) ; <nl> + InsertInstallationData ( product100GiftCard ) ; <nl> <nl> InsertInstallationData ( new ProductCategory <nl> { <nl> protected virtual void InstallProducts ( string defaultUserEmail ) <nl> / / search engine names <nl> foreach ( var product in allProducts ) <nl> { <nl> - _urlRecordRepository . Insert ( new UrlRecord <nl> + InsertInstallationData ( new UrlRecord <nl> { <nl> EntityId = product . Id , <nl> EntityName = nameof ( Product ) , <nl> protected virtual void InstallProducts ( string defaultUserEmail ) <nl> } <nl> <nl> / / related products <nl> - _relatedProductRepository . Insert ( relatedProducts ) ; <nl> + InsertInstallationData ( relatedProducts ) ; <nl> <nl> / / reviews <nl> using ( var random = new SecureRandomNumberGenerator ( ) ) <nl> protected virtual void InstallProducts ( string defaultUserEmail ) <nl> } <nl> } <nl> <nl> - _productRepository . Update ( allProducts ) ; <nl> + UpdateInstallationData ( allProducts ) ; <nl> <nl> / / stock quantity history <nl> foreach ( var product in allProducts ) <nl> { <nl> if ( product . StockQuantity > 0 ) <nl> - _stockQuantityHistoryRepository . Insert ( new StockQuantityHistory <nl> + InsertInstallationData ( new StockQuantityHistory <nl> { <nl> ProductId = product . Id , <nl> WarehouseId = product . WarehouseId > 0 ? ( int ? ) product . WarehouseId : null , <nl> protected virtual void InstallForums ( ) <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> <nl> - _forumGroupRepository . Insert ( forumGroup ) ; <nl> + InsertInstallationData ( forumGroup ) ; <nl> <nl> var newProductsForum = new Forum <nl> { <nl> protected virtual void InstallForums ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _forumRepository . Insert ( newProductsForum ) ; <nl> + InsertInstallationData ( newProductsForum ) ; <nl> <nl> var mobileDevicesForum = new Forum <nl> { <nl> protected virtual void InstallForums ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _forumRepository . Insert ( mobileDevicesForum ) ; <nl> + InsertInstallationData ( mobileDevicesForum ) ; <nl> <nl> var packagingShippingForum = new Forum <nl> { <nl> protected virtual void InstallForums ( ) <nl> CreatedOnUtc = DateTime . UtcNow , <nl> UpdatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _forumRepository . Insert ( packagingShippingForum ) ; <nl> + InsertInstallationData ( packagingShippingForum ) ; <nl> } <nl> <nl> protected virtual void InstallDiscounts ( ) <nl> protected virtual void InstallDiscounts ( ) <nl> CouponCode = \" 456 \" <nl> } <nl> } ; <nl> - _discountRepository . Insert ( discounts ) ; <nl> + InsertInstallationData ( discounts ) ; <nl> } <nl> <nl> protected virtual void InstallBlogPosts ( string defaultUserEmail ) <nl> protected virtual void InstallBlogPosts ( string defaultUserEmail ) <nl> } <nl> } ; <nl> <nl> - _blogPostRepository . Insert ( blogPosts ) ; <nl> + InsertInstallationData ( blogPosts ) ; <nl> <nl> / / search engine names <nl> foreach ( var blogPost in blogPosts ) <nl> { <nl> - _urlRecordRepository . Insert ( new UrlRecord <nl> + InsertInstallationData ( new UrlRecord <nl> { <nl> EntityId = blogPost . Id , <nl> EntityName = nameof ( BlogPost ) , <nl> protected virtual void InstallBlogPosts ( string defaultUserEmail ) <nl> } ) ; <nl> } <nl> <nl> - _blogPostRepository . Update ( blogPosts ) ; <nl> + UpdateInstallationData ( blogPosts ) ; <nl> } <nl> <nl> protected virtual void InstallNews ( string defaultUserEmail ) <nl> protected virtual void InstallNews ( string defaultUserEmail ) <nl> CreatedOnUtc = DateTime . UtcNow . AddSeconds ( 2 ) <nl> } <nl> } ; <nl> - _newsItemRepository . Insert ( news ) ; <nl> + InsertInstallationData ( news ) ; <nl> <nl> / / search engine names <nl> foreach ( var newsItem in news ) <nl> { <nl> - _urlRecordRepository . Insert ( new UrlRecord <nl> + InsertInstallationData ( new UrlRecord <nl> { <nl> EntityId = newsItem . Id , <nl> EntityName = nameof ( NewsItem ) , <nl> protected virtual void InstallNews ( string defaultUserEmail ) <nl> } ) ; <nl> } <nl> <nl> - _newsItemRepository . Update ( news ) ; <nl> + UpdateInstallationData ( news ) ; <nl> } <nl> <nl> protected virtual void InstallPolls ( ) <nl> protected virtual void InstallPolls ( ) <nl> DisplayOrder = 1 <nl> } ; <nl> <nl> - _pollRepository . Insert ( poll1 ) ; <nl> + InsertInstallationData ( poll1 ) ; <nl> <nl> var answers = new List < PollAnswer > ( ) <nl> { <nl> protected virtual void InstallPolls ( ) <nl> } <nl> } ; <nl> <nl> - _pollAnswerRepository . Insert ( answers ) ; <nl> + InsertInstallationData ( answers ) ; <nl> } <nl> <nl> protected virtual void InstallActivityLogTypes ( ) <nl> protected virtual void InstallActivityLogTypes ( ) <nl> Name = \" Upload a favicon and app icons \" <nl> } <nl> } ; <nl> - _activityLogTypeRepository . Insert ( activityLogTypes ) ; <nl> + InsertInstallationData ( activityLogTypes ) ; <nl> } <nl> <nl> protected virtual void InstallProductTemplates ( ) <nl> protected virtual void InstallProductTemplates ( ) <nl> IgnoredProductTypes = ( ( int ) ProductType . SimpleProduct ) . ToString ( ) <nl> } <nl> } ; <nl> - _productTemplateRepository . Insert ( productTemplates ) ; <nl> + InsertInstallationData ( productTemplates ) ; <nl> } <nl> <nl> protected virtual void InstallCategoryTemplates ( ) <nl> protected virtual void InstallCategoryTemplates ( ) <nl> DisplayOrder = 1 <nl> } <nl> } ; <nl> - _categoryTemplateRepository . Insert ( categoryTemplates ) ; <nl> + InsertInstallationData ( categoryTemplates ) ; <nl> } <nl> <nl> protected virtual void InstallManufacturerTemplates ( ) <nl> protected virtual void InstallManufacturerTemplates ( ) <nl> DisplayOrder = 1 <nl> } <nl> } ; <nl> - _manufacturerTemplateRepository . Insert ( manufacturerTemplates ) ; <nl> + InsertInstallationData ( manufacturerTemplates ) ; <nl> } <nl> <nl> protected virtual void InstallTopicTemplates ( ) <nl> protected virtual void InstallTopicTemplates ( ) <nl> DisplayOrder = 1 <nl> } <nl> } ; <nl> - _topicTemplateRepository . Insert ( topicTemplates ) ; <nl> + InsertInstallationData ( topicTemplates ) ; <nl> } <nl> <nl> protected virtual void InstallScheduleTasks ( ) <nl> protected virtual void InstallScheduleTasks ( ) <nl> } <nl> } ; <nl> <nl> - _scheduleTaskRepository . Insert ( tasks ) ; <nl> + InsertInstallationData ( tasks ) ; <nl> } <nl> <nl> protected virtual void InstallReturnRequestReasons ( ) <nl> protected virtual void InstallReturnRequestReasons ( ) <nl> DisplayOrder = 3 <nl> } <nl> } ; <nl> - _returnRequestReasonRepository . Insert ( returnRequestReasons ) ; <nl> + InsertInstallationData ( returnRequestReasons ) ; <nl> } <nl> <nl> protected virtual void InstallReturnRequestActions ( ) <nl> protected virtual void InstallReturnRequestActions ( ) <nl> DisplayOrder = 3 <nl> } <nl> } ; <nl> - _returnRequestActionRepository . Insert ( returnRequestActions ) ; <nl> + InsertInstallationData ( returnRequestActions ) ; <nl> } <nl> <nl> protected virtual void InstallWarehouses ( ) <nl> protected virtual void InstallWarehouses ( ) <nl> ZipPostalCode = \" 10021 \" , <nl> CreatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _addressRepository . Insert ( warehouse1address ) ; <nl> + InsertInstallationData ( warehouse1address ) ; <nl> var warehouse2address = new Address <nl> { <nl> Address1 = \" 300 South Spring Stree \" , <nl> protected virtual void InstallWarehouses ( ) <nl> ZipPostalCode = \" 90013 \" , <nl> CreatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _addressRepository . Insert ( warehouse2address ) ; <nl> + InsertInstallationData ( warehouse2address ) ; <nl> var warehouses = new List < Warehouse > <nl> { <nl> new Warehouse <nl> protected virtual void InstallWarehouses ( ) <nl> } <nl> } ; <nl> <nl> - _warehouseRepository . Insert ( warehouses ) ; <nl> + InsertInstallationData ( warehouses ) ; <nl> } <nl> <nl> protected virtual void InstallVendors ( ) <nl> protected virtual void InstallVendors ( ) <nl> } <nl> } ; <nl> <nl> - _vendorRepository . Insert ( vendors ) ; <nl> + InsertInstallationData ( vendors ) ; <nl> <nl> / / search engine names <nl> foreach ( var vendor in vendors ) <nl> { <nl> - _urlRecordRepository . Insert ( new UrlRecord <nl> + InsertInstallationData ( new UrlRecord <nl> { <nl> EntityId = vendor . Id , <nl> EntityName = nameof ( Vendor ) , <nl> protected virtual void InstallAffiliates ( ) <nl> CountryId = _countryRepository . Table . FirstOrDefault ( c = > c . ThreeLetterIsoCode = = \" USA \" ) ? . Id , <nl> CreatedOnUtc = DateTime . UtcNow <nl> } ; <nl> - _addressRepository . Insert ( affiliateAddress ) ; <nl> + InsertInstallationData ( affiliateAddress ) ; <nl> var affilate = new Affiliate <nl> { <nl> Active = true , <nl> AddressId = affiliateAddress . Id <nl> } ; <nl> - _affiliateRepository . Insert ( affilate ) ; <nl> + InsertInstallationData ( affilate ) ; <nl> } <nl> <nl> private void AddProductTag ( Product product , string tag ) <nl> private void AddProductTag ( Product product , string tag ) <nl> { <nl> Name = tag <nl> } ; <nl> - _productTagRepository . Insert ( productTag ) ; <nl> + InsertInstallationData ( productTag ) ; <nl> <nl> / / search engine name <nl> - _urlRecordRepository . Insert ( new UrlRecord <nl> + InsertInstallationData ( new UrlRecord <nl> { <nl> EntityId = productTag . Id , <nl> EntityName = nameof ( ProductTag ) , <nl> private void AddProductTag ( Product product , string tag ) <nl> } ) ; <nl> } <nl> <nl> - _productProductTagMappingRepository . Insert ( new ProductProductTagMapping { ProductTagId = productTag . Id , ProductId = product . Id } ) ; <nl> + InsertInstallationData ( new ProductProductTagMapping { ProductTagId = productTag . Id , ProductId = product . Id } ) ; <nl> } <nl> <nl> # endregion <nl>\n", "msg": "Simplified insert and update data during the installation process\n", "score": 1}
{"diff_id": 2634, "repo": "migueldeicaza/gui.cs\n", "sha": "356b0f8618ea5b644c322c59808d7142d913c369\n", "time": "2020-10-31T01:11:13Z\n", "diff": "mmm a / Terminal . Gui / ConsoleDrivers / CursesDriver / CursesDriver . cs <nl> ppp b / Terminal . Gui / ConsoleDrivers / CursesDriver / CursesDriver . cs <nl> public override void Init ( Action terminalResized ) <nl> if ( reportableMouseEvents . HasFlag ( Curses . Event . ReportMousePosition ) ) <nl> StartReportingMouseMoves ( ) ; <nl> <nl> - HLine = Curses . ACS_HLINE ; <nl> - VLine = Curses . ACS_VLINE ; <nl> - Stipple = Curses . ACS_CKBOARD ; <nl> - Diamond = Curses . ACS_DIAMOND ; <nl> - ULCorner = Curses . ACS_ULCORNER ; <nl> - LLCorner = Curses . ACS_LLCORNER ; <nl> - URCorner = Curses . ACS_URCORNER ; <nl> - LRCorner = Curses . ACS_LRCORNER ; <nl> - LeftTee = Curses . ACS_LTEE ; <nl> - RightTee = Curses . ACS_RTEE ; <nl> - TopTee = Curses . ACS_TTEE ; <nl> - BottomTee = Curses . ACS_BTEE ; <nl> - RightArrow = Curses . ACS_RARROW ; <nl> - LeftArrow = Curses . ACS_LARROW ; <nl> - UpArrow = Curses . ACS_UARROW ; <nl> - DownArrow = Curses . ACS_DARROW ; <nl> + / / HLine = Curses . ACS_HLINE ; <nl> + / / VLine = Curses . ACS_VLINE ; <nl> + / / Stipple = Curses . ACS_CKBOARD ; <nl> + / / Diamond = Curses . ACS_DIAMOND ; <nl> + / / ULCorner = Curses . ACS_ULCORNER ; <nl> + / / LLCorner = Curses . ACS_LLCORNER ; <nl> + / / URCorner = Curses . ACS_URCORNER ; <nl> + / / LRCorner = Curses . ACS_LRCORNER ; <nl> + / / LeftTee = Curses . ACS_LTEE ; <nl> + / / RightTee = Curses . ACS_RTEE ; <nl> + / / TopTee = Curses . ACS_TTEE ; <nl> + / / BottomTee = Curses . ACS_BTEE ; <nl> + / / RightArrow = Curses . ACS_RARROW ; <nl> + / / LeftArrow = Curses . ACS_LARROW ; <nl> + / / UpArrow = Curses . ACS_UARROW ; <nl> + / / DownArrow = Curses . ACS_DARROW ; <nl> <nl> Colors . TopLevel = new ColorScheme ( ) ; <nl> Colors . Base = new ColorScheme ( ) ; <nl>\n", "msg": "CursesDriver now use the ConsoleDriver definition for this runes .\n", "score": 1}
{"diff_id": 2730, "repo": "Sonarr/Sonarr\n", "sha": "bd4bd47e4e7721b67a050c3ffa186fd693704a87\n", "time": "2013-08-19T15:19:39Z\n", "diff": "mmm a / NzbDrone . Core / MediaFiles / EpisodeImport / Specifications / FreeSpaceSpecification . cs <nl> ppp b / NzbDrone . Core / MediaFiles / EpisodeImport / Specifications / FreeSpaceSpecification . cs <nl> <nl> -  using System . IO ; <nl> +  using System ; <nl> + using System . IO ; <nl> using System . Linq ; <nl> using NLog ; <nl> using NzbDrone . Common ; <nl> public FreeSpaceSpecification ( IDiskProvider diskProvider , Logger logger ) <nl> <nl> public bool IsSatisfiedBy ( LocalEpisode localEpisode ) <nl> { <nl> - var path = Directory . GetParent ( localEpisode . Series . Path ) ; <nl> - var freeSpace = _diskProvider . GetAvilableSpace ( path . FullName ) ; <nl> + try <nl> + { <nl> + var path = Directory . GetParent ( localEpisode . Series . Path ) ; <nl> + var freeSpace = _diskProvider . GetAvilableSpace ( path . FullName ) ; <nl> + <nl> + if ( freeSpace < localEpisode . Size + 100 . Megabytes ( ) ) <nl> + { <nl> + _logger . Warn ( \" Not enough free space to import : { 0 } \" , localEpisode ) ; <nl> + return false ; <nl> + } <nl> <nl> - if ( freeSpace < localEpisode . Size + 100 . Megabytes ( ) ) <nl> + return true ; <nl> + } <nl> + catch ( Exception ex ) <nl> { <nl> - _logger . Warn ( \" Not enough free space to import : { 0 } \" , localEpisode ) ; <nl> - return false ; <nl> + _logger . ErrorException ( \" Unable to check free disk space while importing : \" + localEpisode . Path , ex ) ; <nl> + throw ; <nl> } <nl> - <nl> - return true ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Added more logging when free disk space check fails on import\n", "score": 1}
{"diff_id": 3186, "repo": "mono/mono\n", "sha": "5524846de165e5ddf86dd66505c8a62d551fbd26\n", "time": "2013-12-03T07:51:31Z\n", "diff": "mmm a / mcs / class / Microsoft . Build / Microsoft . Build . Internal / ExpressionEvaluator . cs <nl> ppp b / mcs / class / Microsoft . Build / Microsoft . Build . Internal / ExpressionEvaluator . cs <nl> object DoEvaluateAsObject ( EvaluationContext context ) <nl> var args = Access . Arguments . Select ( e = > e . EvaluateAsObject ( context ) ) . ToArray ( ) ; <nl> var method = FindMethod ( type , Access . Name . Name , args ) ; <nl> if ( method = = null ) <nl> - throw new InvalidProjectFileException ( Location , string . Format ( \" access to undefined method ' { 0 } ' of ' { 1 } ' at { 2 } \" , Access . Name . Name , Access . Target . EvaluateAsString ( context ) , Location ) ) ; <nl> + throw new InvalidProjectFileException ( Location , string . Format ( \" access to undefined static method ' { 0 } ' of ' { 1 } ' at { 2 } \" , Access . Name . Name , Access . Target . EvaluateAsString ( context ) , Location ) ) ; <nl> return method . Invoke ( null , AdjustArgsForCall ( method , args ) ) ; <nl> } else { <nl> var prop = type . GetProperty ( Access . Name . Name ) ; <nl> if ( prop = = null ) <nl> - throw new InvalidProjectFileException ( Location , string . Format ( \" access to undefined property ' { 0 } ' of ' { 1 } ' at { 2 } \" , Access . Name . Name , Access . Target . EvaluateAsString ( context ) , Location ) ) ; <nl> + throw new InvalidProjectFileException ( Location , string . Format ( \" access to undefined static property ' { 0 } ' of ' { 1 } ' at { 2 } \" , Access . Name . Name , Access . Target . EvaluateAsString ( context ) , Location ) ) ; <nl> return prop . GetValue ( null , null ) ; <nl> } <nl> } <nl>\n", "msg": "slightly improve property access error message .\n", "score": 1}
{"diff_id": 3351, "repo": "dotnet/roslyn\n", "sha": "7b70e06bf41af900189f390bf917e6bb91cfe6b9\n", "time": "2020-07-31T22:54:28Z\n", "diff": "mmm a / src / VisualStudio / Core / Def / ExternalAccess / VSTypeScript / Api / VSTypeScriptContainedLanguageWrapper . cs <nl> ppp b / src / VisualStudio / Core / Def / ExternalAccess / VSTypeScript / Api / VSTypeScriptContainedLanguageWrapper . cs <nl> internal struct VSTypeScriptContainedLanguageWrapper <nl> Guid languageServiceGuid ) <nl> { <nl> var filePath = ContainedLanguage . GetFilePathFromHierarchyAndItemId ( hierarchy , itemid ) ; <nl> + var projectId = ProjectId . CreateNewId ( $ \" Project for { filePath } \" ) ; <nl> + workspace . OnProjectAdded ( ProjectInfo . Create ( projectId , VersionStamp . Default , filePath , string . Empty , \" TypeScript \" ) ) ; <nl> <nl> _underlyingObject = new ContainedLanguage ( <nl> bufferCoordinator , <nl> componentModel , <nl> workspace , <nl> - ProjectId . CreateNewId ( $ \" Project for { filePath } \" ) , <nl> + projectId , <nl> null , <nl> filePath , <nl> languageServiceGuid , <nl>\n", "msg": "Create dedicated project for script block document\n", "score": 1}
{"diff_id": 3572, "repo": "Wox-launcher/Wox\n", "sha": "db0f228f4d112e4d01f9953c4a3d309769c871f9\n", "time": "2014-08-25T08:20:08Z\n", "diff": "mmm a / Wox . Plugin . SystemPlugins / WebSearch / WebSearchPlugin . cs <nl> ppp b / Wox . Plugin . SystemPlugins / WebSearch / WebSearchPlugin . cs <nl> <nl> -  using System ; <nl> + using System ; <nl> using System . Collections . Generic ; <nl> using System . Diagnostics ; <nl> using System . IO ; <nl> protected override List < Result > QueryInternal ( Query query ) <nl> IcoPath = webSearch . IconPath , <nl> Action = ( c ) = > <nl> { <nl> - Process . Start ( webSearch . Url . Replace ( \" { q } \" , keyword ) ) ; <nl> + Process . Start ( webSearch . Url . Replace ( \" { q } \" , Uri . EscapeDataString ( keyword ) ) ) ; <nl> return true ; <nl> } <nl> } <nl> protected override List < Result > QueryInternal ( Query query ) <nl> IcoPath = webSearch . IconPath , <nl> Action = ( c ) = > <nl> { <nl> - Process . Start ( webSearch . Url . Replace ( \" { q } \" , o ) ) ; <nl> + Process . Start ( webSearch . Url . Replace ( \" { q } \" , Uri . EscapeDataString ( o ) ) ) ; <nl> return true ; <nl> } <nl> } ) . ToList ( ) ) ; <nl>\n", "msg": "WebSearch : convert search word to url encoding before opening the url\n", "score": 1}
{"diff_id": 3902, "repo": "dotnet/runtime\n", "sha": "47ace5b15bfa40fe0d433c0275719c2c9cc79310\n", "time": "2016-11-28T19:18:42Z\n", "diff": "mmm a / src / libraries / System . Linq . Expressions / src / System / Runtime / CompilerServices / ReadOnlyCollectionBuilder . cs <nl> ppp b / src / libraries / System . Linq . Expressions / src / System / Runtime / CompilerServices / ReadOnlyCollectionBuilder . cs <nl> public ReadOnlyCollectionBuilder ( ) <nl> / / / < param name = \" capacity \" > Initial capacity of the builder . < / param > <nl> public ReadOnlyCollectionBuilder ( int capacity ) <nl> { <nl> - ContractUtils . Requires ( capacity > = 0 , nameof ( capacity ) ) ; <nl> + if ( capacity < 0 ) <nl> + throw new ArgumentOutOfRangeException ( nameof ( capacity ) ) ; <nl> + <nl> _items = new T [ capacity ] ; <nl> } <nl> <nl> public ReadOnlyCollectionBuilder ( int capacity ) <nl> / / / < param name = \" collection \" > The collection whose elements to copy to the builder . < / param > <nl> public ReadOnlyCollectionBuilder ( IEnumerable < T > collection ) <nl> { <nl> - ContractUtils . Requires ( collection ! = null , nameof ( collection ) ) ; <nl> + if ( collection = = null ) <nl> + throw new ArgumentNullException ( nameof ( collection ) ) ; <nl> <nl> ICollection < T > c = collection as ICollection < T > ; <nl> if ( c ! = null ) <nl> public int Capacity <nl> get { return _items . Length ; } <nl> set <nl> { <nl> - ContractUtils . Requires ( value > = _size , nameof ( value ) ) ; <nl> + if ( value < _size ) <nl> + throw new ArgumentOutOfRangeException ( nameof ( value ) ) ; <nl> <nl> if ( value ! = _items . Length ) <nl> { <nl> public int IndexOf ( T item ) <nl> / / / < param name = \" item \" > The object to insert into the < see cref = \" ReadOnlyCollectionBuilder { T } \" / > . < / param > <nl> public void Insert ( int index , T item ) <nl> { <nl> - ContractUtils . Requires ( index < = _size , nameof ( index ) ) ; <nl> + if ( index > _size ) <nl> + throw new ArgumentOutOfRangeException ( nameof ( index ) ) ; <nl> <nl> if ( _size = = _items . Length ) <nl> { <nl> public void Insert ( int index , T item ) <nl> / / / < param name = \" index \" > The zero - based index of the item to remove . < / param > <nl> public void RemoveAt ( int index ) <nl> { <nl> - ContractUtils . Requires ( index > = 0 & & index < _size , nameof ( index ) ) ; <nl> + if ( index < 0 | | index > = _size ) <nl> + throw new ArgumentOutOfRangeException ( nameof ( index ) ) ; <nl> <nl> _size - - ; <nl> if ( index < _size ) <nl> public void RemoveAt ( int index ) <nl> { <nl> get <nl> { <nl> - ContractUtils . Requires ( index < _size , nameof ( index ) ) ; <nl> + if ( index > = _size ) <nl> + throw new ArgumentOutOfRangeException ( nameof ( index ) ) ; <nl> + <nl> return _items [ index ] ; <nl> } <nl> set <nl> { <nl> - ContractUtils . Requires ( index < _size , nameof ( index ) ) ; <nl> + if ( index > = _size ) <nl> + throw new ArgumentOutOfRangeException ( nameof ( index ) ) ; <nl> + <nl> _items [ index ] = value ; <nl> _version + + ; <nl> } <nl> void System . Collections . IList . Remove ( object value ) <nl> <nl> void System . Collections . ICollection . CopyTo ( Array array , int index ) <nl> { <nl> - ContractUtils . RequiresNotNull ( array , nameof ( array ) ) ; <nl> - ContractUtils . Requires ( array . Rank = = 1 , nameof ( array ) ) ; <nl> + if ( array = = null ) <nl> + throw new ArgumentNullException ( nameof ( array ) ) ; <nl> + if ( array . Rank ! = 1 ) <nl> + throw new ArgumentException ( nameof ( array ) ) ; <nl> + <nl> Array . Copy ( _items , 0 , array , index , _size ) ; <nl> } <nl> <nl> public void Reverse ( ) <nl> / / / < param name = \" count \" > The number of elements in the range to reverse . < / param > <nl> public void Reverse ( int index , int count ) <nl> { <nl> - ContractUtils . Requires ( index > = 0 , nameof ( index ) ) ; <nl> - ContractUtils . Requires ( count > = 0 , nameof ( count ) ) ; <nl> + if ( index < 0 ) <nl> + throw new ArgumentOutOfRangeException ( nameof ( index ) ) ; <nl> + if ( count < 0 ) <nl> + throw new ArgumentOutOfRangeException ( nameof ( count ) ) ; <nl> <nl> Array . Reverse ( _items , index , count ) ; <nl> _version + + ; <nl>\n", "msg": "Throwing more derived exception types in ReadOnlyCollectionBuilder .\n", "score": 1}
{"diff_id": 3908, "repo": "icsharpcode/ILSpy\n", "sha": "129fd876d42f968b345fd4ad68d3b277c226b04a\n", "time": "2019-07-26T17:15:49Z\n", "diff": "mmm a / ICSharpCode . Decompiler / CSharp / Transforms / IntroduceExtensionMethods . cs <nl> ppp b / ICSharpCode . Decompiler / CSharp / Transforms / IntroduceExtensionMethods . cs <nl> public override void VisitInvocationExpression ( InvocationExpression invocationEx <nl> var or = rr . PerformOverloadResolution ( resolver . CurrentTypeResolveContext . Compilation , arguments , argumentNames , allowExtensionMethods : true ) ; <nl> if ( or = = null | | or . IsAmbiguous ) <nl> return false ; <nl> - return method . Equals ( or . GetBestCandidateWithSubstitutedTypeArguments ( ) ) ; <nl> + return method . Equals ( or . GetBestCandidateWithSubstitutedTypeArguments ( ) ) <nl> + & & CSharpResolver . IsEligibleExtensionMethod ( target . Type , method , useTypeInference : false , out _ ) ; <nl> } <nl> <nl> public static bool CanTransformToExtensionMethodCall ( IMethod method , CSharpTypeResolveContext resolveContext , bool ignoreTypeArguments = false , bool ignoreArgumentNames = true ) <nl>\n", "msg": "Use extension method syntax only if the extension method is eligible .\n", "score": 1}
{"diff_id": 4167, "repo": "MonoGame/MonoGame\n", "sha": "9133246a5df2acda4d2b50264c789128e5e2b103\n", "time": "2015-11-27T09:13:54Z\n", "diff": "mmm a / Tools / Pipeline / Common / PipelineController . cs <nl> ppp b / Tools / Pipeline / Common / PipelineController . cs <nl> <nl> using System ; <nl> using System . Collections . Generic ; <nl> using System . Diagnostics ; <nl> + using System . Globalization ; <nl> using System . IO ; <nl> using System . Linq ; <nl> using System . Reflection ; <nl> + using System . Text ; <nl> using System . Threading . Tasks ; <nl> using MGCB ; <nl> using PathHelper = MonoGame . Framework . Content . Pipeline . Builder . PathHelper ; <nl> private void DoBuild ( string commands ) <nl> _buildProcess . StartInfo . WindowStyle = ProcessWindowStyle . Hidden ; <nl> _buildProcess . StartInfo . UseShellExecute = false ; <nl> _buildProcess . StartInfo . RedirectStandardOutput = true ; <nl> + _buildProcess . StartInfo . StandardOutputEncoding = Encoding . GetEncoding ( CultureInfo . CurrentCulture . TextInfo . OEMCodePage ) ; <nl> _buildProcess . OutputDataReceived + = ( sender , args ) = > View . OutputAppend ( args . Data ) ; <nl> <nl> / / Fire off the process . <nl>\n", "msg": "[ Pipeline ] International Support for Console text encoding\n", "score": 1}
{"diff_id": 4416, "repo": "duplicati/duplicati\n", "sha": "3fd83514f4115f7f9d3dc720eb77dc31321c1bb8\n", "time": "2013-09-25T21:31:48Z\n", "diff": "mmm a / Duplicati / Library / Main / Database / LocalDatabase . cs <nl> ppp b / Duplicati / Library / Main / Database / LocalDatabase . cs <nl> public void VerifyConsistency ( System . Data . IDbTransaction transaction ) <nl> using ( var cmd = m_connection . CreateCommand ( ) ) <nl> { <nl> cmd . Transaction = transaction ; <nl> - using ( var rd = cmd . ExecuteReader ( @ \" SELECT * FROM ( SELECT SUM ( \" \" Block \" \" . \" \" Size \" \" ) AS \" \" CalcLen \" \" , \" \" Blockset \" \" . \" \" Length \" \" AS \" \" Length \" \" , \" \" Blockset \" \" . \" \" ID \" \" , \" \" File \" \" . \" \" Path \" \" FROM \" \" Block \" \" , \" \" BlocksetEntry \" \" , \" \" Blockset \" \" , \" \" File \" \" WHERE \" \" BlocksetEntry \" \" . \" \" BlockID \" \" = \" \" Block \" \" . \" \" ID \" \" AND \" \" Blockset \" \" . \" \" ID \" \" = \" \" BlocksetEntry \" \" . \" \" BlocksetID \" \" AND \" \" File \" \" . \" \" BlocksetID \" \" = \" \" Blockset \" \" . \" \" ID \" \" GROUP BY \" \" Blockset \" \" . \" \" ID \" \" , \" \" File \" \" . \" \" ID \" \" ) WHERE \" \" CalcLen \" \" ! = \" \" Length \" \" \" ) ) <nl> + <nl> + / / Calculate the lengths for each blockset <nl> + var combinedLengths = @ \" SELECT \" \" BlocksetEntry \" \" . \" \" BlocksetID \" \" AS \" \" BlocksetID \" \" , SUM ( \" \" Block \" \" . \" \" Size \" \" ) AS \" \" CalcLen \" \" , \" \" Blockset \" \" . \" \" Length \" \" AS \" \" Length \" \" FROM \" \" Block \" \" , \" \" BlocksetEntry \" \" , \" \" Blockset \" \" WHERE \" \" BlocksetEntry \" \" . \" \" BlockID \" \" = \" \" Block \" \" . \" \" ID \" \" AND \" \" BlocksetEntry \" \" . \" \" BlocksetID \" \" = \" \" Blockset \" \" . \" \" ID \" \" GROUP BY \" \" BlocksetEntry \" \" . \" \" BlocksetID \" \" \" ; <nl> + / / For each blockset with wrong lengths , fetch the file path <nl> + var reportDetails = @ \" SELECT \" \" CalcLen \" \" , \" \" Length \" \" , \" \" A \" \" . \" \" BlocksetID \" \" , \" \" File \" \" . \" \" Path \" \" FROM ( \" + combinedLengths + @ \" ) A , \" \" File \" \" WHERE \" \" A \" \" . \" \" BlocksetID \" \" = \" \" File \" \" . \" \" BlocksetID \" \" AND \" \" A \" \" . \" \" CalcLen \" \" ! = \" \" A \" \" . \" \" Length \" \" \" ; <nl> + <nl> + using ( var rd = cmd . ExecuteReader ( reportDetails ) ) <nl> if ( rd . Read ( ) ) <nl> { <nl> var sb = new StringBuilder ( ) ; <nl>\n", "msg": "Improved speed for verifying database consistency\n", "score": 1}
{"diff_id": 4419, "repo": "SignalR/SignalR\n", "sha": "cf84f1c094a4a689058ed37d062ec45938118c8f\n", "time": "2012-04-24T07:06:44Z\n", "diff": "mmm a / SignalR . Hosting . AspNet / Routing / RouteExtensions . cs <nl> ppp b / SignalR . Hosting . AspNet / Routing / RouteExtensions . cs <nl> public static RouteBase MapConnection ( this RouteCollection routes , string name , <nl> return MapConnection ( routes , name , url , type , GlobalHost . DependencyResolver ) ; <nl> } <nl> <nl> + / / / < summary > <nl> + / / / Changes the dependency resolver for the default hub route ( ~ / signalr ) . <nl> + / / / < / summary > <nl> + / / / < param name = \" routes \" > The route table < / param > <nl> + / / / < param name = \" resolver \" > The dependency resolver to use for the hub connection < / param > <nl> + / / / < returns > The registered route < / returns > <nl> + public static RouteBase MapHubs ( this RouteCollection routes , IDependencyResolver resolver ) <nl> + { <nl> + return MapHubs ( routes , \" ~ / signalr \" , resolver ) ; <nl> + } <nl> + <nl> / / / < summary > <nl> / / / Changes the default hub route from ~ / signalr to a specified url . <nl> / / / < / summary > <nl> + / / / < param name = \" routes \" > The route table < / param > <nl> / / / < param name = \" url \" > The url of the hubs route . This should * NOT * contain catch - all parameter . < / param > <nl> / / / < returns > The registered route < / returns > <nl> public static RouteBase MapHubs ( this RouteCollection routes , string url ) <nl>\n", "msg": "Allow changing the default dependency resolver for the hubs route .\n", "score": 1}
{"diff_id": 4753, "repo": "mono/mono\n", "sha": "4cbaff75a54dd5045983b8dbb215f1d02d327962\n", "time": "2013-12-03T07:52:36Z\n", "diff": "mmm a / mcs / class / Microsoft . Build / Microsoft . Build . Internal / BuildNodeManager . cs <nl> ppp b / mcs / class / Microsoft . Build / Microsoft . Build . Internal / BuildNodeManager . cs <nl> public BuildNodeManager ( BuildManager buildManager ) <nl> void RunLoop ( ) <nl> { <nl> while ( run_loop ) { <nl> - if ( queued_builds . Count = = 0 ) { <nl> - queue_wait_handle . WaitOne ( ) ; <nl> + try { <nl> + if ( queued_builds . Count = = 0 ) { <nl> + queue_wait_handle . WaitOne ( ) ; <nl> + } <nl> + if ( ! run_loop ) <nl> + break ; <nl> + if ( ! queued_builds . Any ( ) ) <nl> + continue ; <nl> + var build = queued_builds . Dequeue ( ) ; <nl> + StartOneBuild ( build ) ; <nl> + } catch ( Exception ex ) { <nl> + Console . Error . WriteLine ( \" Uncaught build node exception occured \" ) ; <nl> + Console . Error . WriteLine ( ex ) ; <nl> } <nl> - if ( ! run_loop ) <nl> - break ; <nl> - if ( ! queued_builds . Any ( ) ) <nl> - continue ; <nl> - var build = queued_builds . Dequeue ( ) ; <nl> - StartOneBuild ( build ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "dump possible build node exceptions that would have been silently ignored .\n", "score": 1}
{"diff_id": 5007, "repo": "AvaloniaUI/Avalonia\n", "sha": "870e591f99176abc53db747dece2d681de06aede\n", "time": "2019-04-19T13:31:43Z\n", "diff": "mmm a / src / Avalonia . Build . Tasks / XamlCompilerTaskExecutor . Helpers . cs <nl> ppp b / src / Avalonia . Build . Tasks / XamlCompilerTaskExecutor . Helpers . cs <nl> public WrappedResource ( AssemblyDefinition asm , EmbeddedResource res ) <nl> _res = res ; <nl> } <nl> <nl> - public string Uri = > $ \" resm : { Name } ? assembly = { _asm . Name } \" ; <nl> + public string Uri = > $ \" resm : { Name } ? assembly = { _asm . Name . Name } \" ; <nl> public string Name = > _res . Name ; <nl> public byte [ ] GetData ( ) = > _res . GetResourceData ( ) ; <nl> public string FilePath = > Name ; <nl> class AvaloniaResource : IResource <nl> _data = data ; <nl> Name = name ; <nl> FilePath = Path . Combine ( projectDir , name . TrimStart ( ' / ' ) ) ; <nl> - Uri = $ \" avares : / / { grp . _asm . Name } / { name . TrimStart ( ' / ' ) } \" ; <nl> + Uri = $ \" avares : / / { grp . _asm . Name . Name } / { name . TrimStart ( ' / ' ) } \" ; <nl> } <nl> public string Uri { get ; } <nl> public string Name { get ; } <nl>\n", "msg": "Use regular assembly names for resource uris\n", "score": 1}
{"diff_id": 5153, "repo": "dotnet/aspnetcore\n", "sha": "3865136b97ed6dde2f1ef4b5ebc79f3a8e5007c8\n", "time": "2016-06-15T18:36:29Z\n", "diff": "mmm a / src / Microsoft . AspNetCore . Http . Abstractions / StatusCodes . cs <nl> ppp b / src / Microsoft . AspNetCore . Http . Abstractions / StatusCodes . cs <nl> public static class StatusCodes <nl> public const int Status422UnprocessableEntity = 422 ; <nl> public const int Status423Locked = 423 ; <nl> public const int Status424FailedDependency = 424 ; <nl> + public const int Status451UnavailableForLegalReasons = 451 ; <nl> <nl> public const int Status500InternalServerError = 500 ; <nl> public const int Status501NotImplemented = 501 ; <nl>\n", "msg": "Added \" 451 Unavailable For Legal Reasons \" to StatusCodes\n", "score": 1}
{"diff_id": 5264, "repo": "MathewSachin/Captura\n", "sha": "787f02ad4544dffb3bf7c21c437cd58cd50c612c\n", "time": "2018-07-10T06:14:07Z\n", "diff": "mmm a / src / Captura / Windows / MainWindow . xaml . cs <nl> ppp b / src / Captura / Windows / MainWindow . xaml . cs <nl> <nl>  using System . Drawing ; <nl> + using System . Linq ; <nl> using Captura . Models ; <nl> using Captura . ViewModels ; <nl> using Captura . Views ; <nl> using System . Windows ; <nl> + using System . Windows . Forms ; <nl> using System . Windows . Input ; <nl> using System . Windows . Interop ; <nl> using Screna ; <nl> void RepositionWindowIfOutside ( ) <nl> ( int ) ( ActualWidth * Dpi . X ) , <nl> ( int ) ( ActualHeight * Dpi . Y ) ) ; <nl> <nl> - if ( ! WindowProvider . DesktopRectangle . Contains ( rect ) ) <nl> + if ( ! Screen . AllScreens . Any ( M = > M . Bounds . Contains ( rect ) ) ) <nl> { <nl> Left = 50 ; <nl> Top = 50 ; <nl>\n", "msg": "More reliable window repositioning on startup\n", "score": 1}
{"diff_id": 5425, "repo": "duplicati/duplicati\n", "sha": "a560eeef1abcce573e43b5be55bfb13c316f7b86\n", "time": "2014-03-09T23:24:41Z\n", "diff": "mmm a / Duplicati / Server / WebServer . cs <nl> ppp b / Duplicati / Server / WebServer . cs <nl> private void ListSupportedActions ( HttpServer . IHttpRequest request , HttpServer . IH <nl> <nl> private void ListBackups ( HttpServer . IHttpRequest request , HttpServer . IHttpResponse response , HttpServer . Sessions . IHttpSession session , BodyWriter bw ) <nl> { <nl> - OutputObject ( bw , Program . DataConnection . Backups ) ; <nl> + var schedules = Program . DataConnection . Schedules ; <nl> + var backups = Program . DataConnection . Backups ; <nl> + <nl> + var all = from n in backups <nl> + select new AddOrUpdateBackupData ( ) { <nl> + Backup = ( Database . Backup ) n , <nl> + Schedule = <nl> + ( from x in schedules <nl> + where x . Tags ! = null & & x . Tags . Contains ( \" ID = \" + n . ID ) <nl> + select ( Database . Schedule ) x ) . FirstOrDefault ( ) <nl> + } ; <nl> + <nl> + OutputObject ( bw , all . ToArray ( ) ) ; <nl> } <nl> <nl> private void ListTags ( HttpServer . IHttpRequest request , HttpServer . IHttpResponse response , HttpServer . Sessions . IHttpSession session , BodyWriter bw ) <nl>\n", "msg": "Added associated schedules to list of backups\n", "score": 1}
{"diff_id": 5803, "repo": "gitextensions/gitextensions\n", "sha": "1ec4769731f0aa340097f6823fb3509b163ba7fe\n", "time": "2018-07-18T14:07:49Z\n", "diff": "mmm a / GitUI / WindowPositionList . cs <nl> ppp b / GitUI / WindowPositionList . cs <nl> public class WindowPositionList <nl> Environment . GetFolderPath ( Environment . SpecialFolder . LocalApplicationData ) , \" GitExtensions \" ) ; <nl> <nl> private static readonly string ConfigFilePath = Path . Combine ( AppDataDir , \" WindowPositions . xml \" ) ; <nl> + private static readonly XmlSerializer _serializer = new XmlSerializer ( typeof ( WindowPositionList ) ) ; <nl> <nl> static WindowPositionList ( ) <nl> { <nl> public static WindowPositionList Load ( ) <nl> <nl> try <nl> { <nl> - using ( <nl> - var stream = File . Open ( ConfigFilePath , FileMode . OpenOrCreate , FileAccess . Read , FileShare . ReadWrite ) ) <nl> + using ( var stream = File . Open ( ConfigFilePath , FileMode . OpenOrCreate , FileAccess . Read , FileShare . ReadWrite ) ) <nl> { <nl> - return new XmlSerializer ( typeof ( WindowPositionList ) ) . Deserialize ( stream ) as WindowPositionList ; <nl> + return ( WindowPositionList ) _serializer . Deserialize ( stream ) ; <nl> } <nl> } <nl> catch <nl> public void Save ( ) <nl> { <nl> using ( var stream = File . Open ( ConfigFilePath , FileMode . Create , FileAccess . Write ) ) <nl> { <nl> - new XmlSerializer ( typeof ( WindowPositionList ) ) . Serialize ( stream , this ) ; <nl> + _serializer . Serialize ( stream , this ) ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Extract serialiser to field and reuse\n", "score": 1}
{"diff_id": 5894, "repo": "OpenRA/OpenRA\n", "sha": "2747fadd9624357db4f34502106bc39ad17b68e9\n", "time": "2011-12-03T06:23:14Z\n", "diff": "mmm a / OpenRA . Game / Graphics / Sequence . cs <nl> ppp b / OpenRA . Game / Graphics / Sequence . cs <nl> <nl> * / <nl> # endregion <nl> <nl> + using System ; <nl> using System . Xml ; <nl> - using OpenRA . FileFormats ; <nl> using System . Collections . Generic ; <nl> + using OpenRA . FileFormats ; <nl> <nl> namespace OpenRA . Graphics <nl> { <nl> public Sequence ( string unit , string name , MiniYaml info ) <nl> Name = name ; <nl> var d = info . NodesDict ; <nl> <nl> - sprites = Game . modData . SpriteLoader . LoadAllSprites ( string . IsNullOrEmpty ( srcOverride ) ? unit : srcOverride ) ; <nl> + sprites = Game . modData . SpriteLoader . LoadAllSprites ( srcOverride ? ? unit ) ; <nl> start = int . Parse ( d [ \" Start \" ] . Value ) ; <nl> <nl> if ( ! d . ContainsKey ( \" Length \" ) ) <nl> public Sequence ( string unit , string name , MiniYaml info ) <nl> tick = int . Parse ( d [ \" Tick \" ] . Value ) ; <nl> else <nl> tick = 40 ; <nl> + <nl> + if ( start < 0 | | start + facings * length > sprites . Length ) <nl> + throw new InvalidOperationException ( <nl> + \" { 6 } : Sequence { 0 } . { 1 } uses frames [ { 2 } . . { 3 } ] of SHP ` { 4 } ` , but only 0 . . { 5 } actually exist \" <nl> + . F ( unit , name , start , start + facings * length - 1 , srcOverride ? ? unit , sprites . Length - 1 , <nl> + info . Nodes [ 0 ] . Location ) ) ; <nl> } <nl> <nl> public MiniYaml Save ( ) <nl>\n", "msg": "give a useful error message when a sequence references frames outside the range that actually exist\n", "score": 1}
{"diff_id": 6064, "repo": "OrchardCMS/OrchardCore\n", "sha": "877886cece379f9b4afb96ea24a29387646d6c6f\n", "time": "2020-12-17T14:56:05Z\n", "diff": "mmm a / src / OrchardCore / OrchardCore . DisplayManagement / LocationExpander / ThemeViewLocationExpanderProvider . cs <nl> ppp b / src / OrchardCore / OrchardCore . DisplayManagement / LocationExpander / ThemeViewLocationExpanderProvider . cs <nl> <nl> using System . Collections . Generic ; <nl> using System . Linq ; <nl> using Microsoft . AspNetCore . Mvc . Razor ; <nl> + using Microsoft . Extensions . Hosting ; <nl> using OrchardCore . DisplayManagement . Extensions ; <nl> using OrchardCore . DisplayManagement . Razor ; <nl> using OrchardCore . Environment . Extensions ; <nl> namespace OrchardCore . DisplayManagement . LocationExpander <nl> { <nl> public class ThemeViewLocationExpanderProvider : IViewLocationExpanderProvider <nl> { <nl> + private readonly IHostEnvironment _hostingEnvironment ; <nl> private readonly IExtensionManager _extensionManager ; <nl> <nl> - public ThemeViewLocationExpanderProvider ( IExtensionManager extensionManager ) <nl> + public ThemeViewLocationExpanderProvider ( IHostEnvironment hostingEnvironment , IExtensionManager extensionManager ) <nl> { <nl> + _hostingEnvironment = hostingEnvironment ; <nl> _extensionManager = extensionManager ; <nl> } <nl> <nl> public void PopulateValues ( ViewLocationExpanderContext context ) <nl> var currentThemeAndBaseThemesOrdered = _extensionManager <nl> . GetFeatures ( new [ ] { currentThemeId } ) <nl> . Where ( x = > x . Extension . IsTheme ( ) ) <nl> - . Reverse ( ) ; <nl> + . Reverse ( ) <nl> + . ToList ( ) ; <nl> + <nl> + / / let the application acting as a super theme also for mvc views discovering . <nl> + var applicationTheme = _extensionManager <nl> + . GetFeatures ( ) <nl> + . FirstOrDefault ( x = > x . Id = = _hostingEnvironment . ApplicationName ) ; <nl> + <nl> + if ( applicationTheme ! = null ) <nl> + { <nl> + currentThemeAndBaseThemesOrdered . Insert ( 0 , applicationTheme ) ; <nl> + } <nl> <nl> var result = new List < string > ( ) ; <nl> <nl>\n", "msg": "Application as a super theme also for pure mvc views ( )\n", "score": 1}
{"diff_id": 6268, "repo": "dotnet/runtime\n", "sha": "5bb54ccde882f6014adb8b1ff1e88b54c4d92e39\n", "time": "2017-05-04T00:04:58Z\n", "diff": "mmm a / src / installer / test / Microsoft . Extensions . DependencyModel . Tests / PackageResolverTest . cs <nl> ppp b / src / installer / test / Microsoft . Extensions . DependencyModel . Tests / PackageResolverTest . cs <nl> public class PackageResolverTest <nl> { <nl> private static string PackagesPath = Path . Combine ( \" package \" , \" directory \" , \" location \" ) ; <nl> <nl> - / / This test does not work on . NET Core 2 . 0 . <nl> - / / [ Fact ] <nl> + [ Fact ] <nl> public void ShouldUseEnvironmentVariableToGetDefaultLocation ( ) <nl> { <nl> var environment = EnvironmentMockBuilder . Create ( ) <nl> public void ShouldUseEnvironmentVariableToGetDefaultLocation ( ) <nl> . Build ( ) ; <nl> <nl> var result = PackageCompilationAssemblyResolver . GetDefaultProbeDirectories ( Platform . Unknown , environment ) ; <nl> - result . Should ( ) . Contain ( PackagesPath ) ; <nl> + / / The host for . NET Core 2 . 0 always sets the PROBING_DIRECTORIES property on the AppContext . Because of that , <nl> + / / no additional package directories should be returned from this , even if they are set as environment variables . <nl> + result . Should ( ) . NotContain ( PackagesPath ) ; <nl> } <nl> <nl> <nl> - / / This test does not work on . NET Core 2 . 0 . <nl> - / / [ Fact ] <nl> + [ Fact ] <nl> public void ShouldUseNugetUnderUserProfileOnWindows ( ) <nl> { <nl> var environment = EnvironmentMockBuilder . Create ( ) <nl> public void ShouldUseNugetUnderUserProfileOnWindows ( ) <nl> . Build ( ) ; <nl> <nl> var result = PackageCompilationAssemblyResolver . GetDefaultProbeDirectories ( Platform . Windows , environment ) ; <nl> - result . Should ( ) . Contain ( Path . Combine ( \" User Profile \" , \" . nuget \" , \" packages \" ) ) ; <nl> + / / The host for . NET Core 2 . 0 always sets the PROBING_DIRECTORIES property on the AppContext . Because of that , <nl> + / / no additional package directories should be returned from this , even if they are set as environment variables . <nl> + result . Should ( ) . NotContain ( Path . Combine ( \" User Profile \" , \" . nuget \" , \" packages \" ) ) ; <nl> } <nl> <nl> - / / This test does not work on . NET Core 2 . 0 . <nl> - / / [ Fact ] <nl> + [ Fact ] <nl> public void ShouldUseNugetUnderHomeOnNonWindows ( ) <nl> { <nl> var environment = EnvironmentMockBuilder . Create ( ) <nl> public void ShouldUseNugetUnderHomeOnNonWindows ( ) <nl> . Build ( ) ; <nl> <nl> var result = PackageCompilationAssemblyResolver . GetDefaultProbeDirectories ( Platform . Linux , environment ) ; <nl> - result . Should ( ) . Contain ( Path . Combine ( \" User Home \" , \" . nuget \" , \" packages \" ) ) ; <nl> + / / The host for . NET Core 2 . 0 always sets the PROBING_DIRECTORIES property on the AppContext . Because of that , <nl> + / / no additional package directories should be returned from this , even if they are set as environment variables . <nl> + result . Should ( ) . NotContain ( Path . Combine ( \" User Home \" , \" . nuget \" , \" packages \" ) ) ; <nl> } <nl> <nl> [ Fact ] <nl>\n", "msg": "More minor test project and code cleanup .\n", "score": 1}
{"diff_id": 6425, "repo": "QuantConnect/Lean\n", "sha": "1b8a752451187202897763352fe4095f33602696\n", "time": "2016-01-13T20:50:45Z\n", "diff": "mmm a / Configuration / Config . cs <nl> ppp b / Configuration / Config . cs <nl> public static T GetValue < T > ( string key , T defaultValue = default ( T ) ) <nl> } <nl> <nl> var type = typeof ( T ) ; <nl> - var value = token . Value < string > ( ) ; <nl> + string value ; <nl> + try <nl> + { <nl> + value = token . Value < string > ( ) ; <nl> + } <nl> + catch ( Exception err ) <nl> + { <nl> + value = token . ToString ( ) ; <nl> + } <nl> + <nl> if ( type . IsEnum ) <nl> { <nl> return ( T ) Enum . Parse ( type , value ) ; <nl>\n", "msg": "Provides Config supprt for random types T\n", "score": 1}
{"diff_id": 6472, "repo": "Sonarr/Sonarr\n", "sha": "bc0bd647df10c9383249b5d284bdbf03f33f6395\n", "time": "2013-11-21T06:29:34Z\n", "diff": "mmm a / src / NzbDrone . Core / Download / FailedDownloadService . cs <nl> ppp b / src / NzbDrone . Core / Download / FailedDownloadService . cs <nl> public class FailedDownloadService : IFailedDownloadService , IExecute < FailedDown <nl> private readonly IConfigService _configService ; <nl> private readonly Logger _logger ; <nl> <nl> - private readonly IDownloadClient _downloadClient ; <nl> - <nl> private static string DOWNLOAD_CLIENT = \" downloadClient \" ; <nl> private static string DOWNLOAD_CLIENT_ID = \" downloadClientId \" ; <nl> <nl> public class FailedDownloadService : IFailedDownloadService , IExecute < FailedDown <nl> _eventAggregator = eventAggregator ; <nl> _configService = configService ; <nl> _logger = logger ; <nl> - <nl> - _downloadClient = _downloadClientProvider . GetDownloadClient ( ) ; <nl> } <nl> <nl> public void MarkAsFailed ( int historyId ) <nl> private void CheckForFailedDownloads ( ) <nl> <nl> private void CheckQueue ( List < History . History > grabbedHistory , List < History . History > failedHistory ) <nl> { <nl> - var downloadClientQueue = _downloadClient . GetQueue ( ) . ToList ( ) ; <nl> + var downloadClientQueue = GetDownloadClient ( ) . GetQueue ( ) . ToList ( ) ; <nl> var failedItems = downloadClientQueue . Where ( q = > q . Title . StartsWith ( \" ENCRYPTED / \" ) ) . ToList ( ) ; <nl> <nl> if ( ! failedItems . Any ( ) ) <nl> private void CheckQueue ( List < History . History > grabbedHistory , List < History . Histo <nl> if ( _configService . RemoveFailedDownloads ) <nl> { <nl> _logger . Info ( \" Removing encrypted download from queue : { 0 } \" , failedItem . Title . Replace ( \" ENCRYPTED / \" , \" \" ) ) ; <nl> - _downloadClient . RemoveFromQueue ( failedItem . Id ) ; <nl> + GetDownloadClient ( ) . RemoveFromQueue ( failedItem . Id ) ; <nl> } <nl> } <nl> } <nl> <nl> private void CheckHistory ( List < History . History > grabbedHistory , List < History . History > failedHistory ) <nl> { <nl> - var downloadClientHistory = _downloadClient . GetHistory ( 0 , 20 ) . ToList ( ) ; <nl> + var downloadClientHistory = GetDownloadClient ( ) . GetHistory ( 0 , 20 ) . ToList ( ) ; <nl> var failedItems = downloadClientHistory . Where ( h = > h . Status = = HistoryStatus . Failed ) . ToList ( ) ; <nl> <nl> if ( ! failedItems . Any ( ) ) <nl> private void CheckHistory ( List < History . History > grabbedHistory , List < History . His <nl> if ( _configService . RemoveFailedDownloads ) <nl> { <nl> _logger . Info ( \" Removing failed download from history : { 0 } \" , failedItem . Title ) ; <nl> - _downloadClient . RemoveFromHistory ( failedItem . Id ) ; <nl> + GetDownloadClient ( ) . RemoveFromHistory ( failedItem . Id ) ; <nl> } <nl> } <nl> } <nl> private void PublishDownloadFailedEvent ( List < History . History > historyItems , stri <nl> } ) ; <nl> } <nl> <nl> + private IDownloadClient GetDownloadClient ( ) <nl> + { <nl> + return _downloadClientProvider . GetDownloadClient ( ) ; <nl> + } <nl> + <nl> public void Execute ( FailedDownloadCommand message ) <nl> { <nl> CheckForFailedDownloads ( ) ; <nl>\n", "msg": "No longer saving download client for entire the life cycle\n", "score": 1}
{"diff_id": 6928, "repo": "SignalR/SignalR\n", "sha": "4bcda591231b0b55fd1b69f16d03de41da6fe45e\n", "time": "2013-06-11T22:39:41Z\n", "diff": "mmm a / src / Microsoft . AspNet . SignalR . Core / Infrastructure / Connection . cs <nl> ppp b / src / Microsoft . AspNet . SignalR . Core / Infrastructure / Connection . cs <nl> public Task Send ( ConnectionMessage message ) <nl> <nl> private Message CreateMessage ( string key , object value ) <nl> { <nl> - var command = value as Command ; <nl> - <nl> - ArraySegment < byte > messageBuffer = GetMessageBuffer ( value ) ; <nl> + ArraySegment < byte > messageBuffer ; <nl> + / / We can ' t use \" as \" like we do for Command since ArraySegment is a struct <nl> + if ( value is ArraySegment < byte > ) <nl> + { <nl> + / / We assume that any ArraySegment < byte > is already JSON serialized <nl> + messageBuffer = ( ArraySegment < byte > ) value ; <nl> + } <nl> + else <nl> + { <nl> + messageBuffer = GetMessageBuffer ( value ) ; <nl> + } <nl> <nl> var message = new Message ( _connectionId , key , messageBuffer ) ; <nl> <nl> + var command = value as Command ; <nl> if ( command ! = null ) <nl> { <nl> / / Set the command id <nl>\n", "msg": "Added ability to send pre - serialized JSON via ArraySegment < byte >\n", "score": 1}
{"diff_id": 7130, "repo": "mono/mono\n", "sha": "dc4c79a52f60b2657fb99fa3cf4c44efe2ee350a\n", "time": "2017-07-27T15:00:10Z\n", "diff": "mmm a / mcs / class / corlib / Test / System . Reflection . Emit / TypeBuilderTest . cs <nl> ppp b / mcs / class / corlib / Test / System . Reflection . Emit / TypeBuilderTest . cs <nl> interface IFoo { <nl> <nl> assembly . Save ( ASSEMBLY_NAME + \" . dll \" ) ; <nl> } <nl> + <nl> + [ Test ] <nl> + public void TwoAssembliesMidFlightTest ( ) { <nl> + / / Check that one AssemblyBuilder can refer to a TypeBuilder from another AssemblyBuilder . <nl> + / / Regression test for https : / / bugzilla . xamarin . com / show_bug . cgi ? id = 58421 <nl> + var name2 = \" MonoTests . System . Reflection . Emit . TypeBuilderTest2 \" ; <nl> + var assemblyName2 = new AssemblyName ( name2 ) ; <nl> + var assembly2 = <nl> + Thread . GetDomain ( ) . DefineDynamicAssembly ( <nl> + assemblyName2 , AssemblyBuilderAccess . RunAndSave , tempDir ) ; <nl> + <nl> + var module2 = assembly2 . DefineDynamicModule ( name2 , name2 + \" . dll \" ) ; <nl> + <nl> + var tb = module . DefineType ( \" Foo \" , TypeAttributes . Public ) ; <nl> + var tb2 = module2 . DefineType ( \" Foo2 \" , TypeAttributes . Public ) ; <nl> + <nl> + var cb = tb . DefineConstructor ( MethodAttributes . Public , CallingConventions . Standard , <nl> + Type . EmptyTypes ) ; <nl> + <nl> + var ilg = cb . GetILGenerator ( ) ; <nl> + <nl> + ilg . Emit ( OpCodes . Ldtoken , tb2 ) ; / / N . B . type from the other AssemblyBuilder <nl> + ilg . Emit ( OpCodes . Pop ) ; <nl> + ilg . Emit ( OpCodes . Ret ) ; <nl> + <nl> + var t = tb . CreateType ( ) ; <nl> + tb2 . CreateType ( ) ; <nl> + <nl> + var ci = t . GetConstructor ( Type . EmptyTypes ) ; <nl> + var x = ci . Invoke ( null ) ; <nl> + assembly . Save ( ASSEMBLY_NAME + \" . dll \" ) ; <nl> + assembly2 . Save ( name2 + \" . dll \" ) ; <nl> + } <nl> + <nl> } <nl> } <nl>\n", "msg": "[ test ] Check that one AssemblyBuilder can refer to a TypeBuilder from another .\n", "score": 1}
{"diff_id": 7402, "repo": "StackExchange/StackExchange.Redis\n", "sha": "ca4b43fd9e24bfdd30d9c941a9dd5f57a7f8d290\n", "time": "2015-08-13T14:06:21Z\n", "diff": "mmm a / StackExchange . Redis / StackExchange / Redis / ServerSelectionStrategy . cs <nl> ppp b / StackExchange . Redis / StackExchange / Redis / ServerSelectionStrategy . cs <nl> public bool TryResend ( int hashSlot , Message message , EndPoint endpoint , bool isM <nl> var command = message . Command ; <nl> switch ( Message . GetMasterSlaveFlags ( message . Flags ) ) <nl> { <nl> - case CommandFlags . DemandMaster : <nl> - resendVia = server . IsSelectable ( command ) ? null : server ; <nl> + case CommandFlags . DemandMaster : <nl> + resendVia = server . IsSelectable ( command ) ? server : null ; <nl> break ; <nl> - case CommandFlags . PreferMaster : <nl> - resendVia = server . IsSelectable ( command ) ? FindSlave ( server , command ) : server ; <nl> + case CommandFlags . PreferMaster : <nl> + resendVia = server . IsSelectable ( command ) ? server : FindSlave ( server , command ) ; <nl> break ; <nl> - case CommandFlags . PreferSlave : <nl> - resendVia = FindSlave ( server , command ) ? ? ( server . IsSelectable ( command ) ? null : server ) ; <nl> + case CommandFlags . PreferSlave : <nl> + resendVia = FindSlave ( server , command ) ? ? ( server . IsSelectable ( command ) ? server : null ) ; <nl> break ; <nl> case CommandFlags . DemandSlave : <nl> resendVia = FindSlave ( server , command ) ; <nl>\n", "msg": "Exchanging operands in the ternary operators of server selection in TryResend in ServerSelectionStrategy\n", "score": 1}
{"diff_id": 7549, "repo": "aspnetboilerplate/aspnetboilerplate\n", "sha": "24af658d1072ae2605b082ede1e81aec75cd2b62\n", "time": "2016-02-15T07:03:09Z\n", "diff": "mmm a / src / Abp / AbpConsts . cs <nl> ppp b / src / Abp / AbpConsts . cs <nl> public static class AbpConsts <nl> / / / < summary > <nl> / / / Current version of the ABP . <nl> / / / < / summary > <nl> - public const string CurrentVersion = \" 0 . 7 . 8 . 1 \" ; <nl> + public const string CurrentVersion = \" 0 . 8 . 0 . 0 \" ; <nl> <nl> / / / < summary > <nl> / / / Localization source name of ASP . NET Boilerplate framework . <nl>\n", "msg": "Incremented version for the next release .\n", "score": 1}
{"diff_id": 8191, "repo": "IdentityServer/IdentityServer4\n", "sha": "c7eade457ec75a6ea99af307293776011a8d1717\n", "time": "2017-12-21T17:35:52Z\n", "diff": "mmm a / src / IdentityServer4 / Validation / TokenRequestValidator . cs <nl> ppp b / src / IdentityServer4 / Validation / TokenRequestValidator . cs <nl> <nl> -  / / Copyright ( c ) Brock Allen & Dominick Baier . All rights reserved . <nl> + / / Copyright ( c ) Brock Allen & Dominick Baier . All rights reserved . <nl> / / Licensed under the Apache License , Version 2 . 0 . See LICENSE in the project root for license information . <nl> <nl> <nl> private async Task < TokenRequestValidationResult > ValidateResourceOwnerCredential <nl> errorDescription = resourceOwnerContext . Result . ErrorDescription ; <nl> } <nl> <nl> - LogError ( \" User authentication failed : { error } \" , errorDescription ? ? resourceOwnerContext . Result . Error ) ; <nl> + LogInfo ( \" User authentication failed : { error } \" , errorDescription ? ? resourceOwnerContext . Result . Error ) ; <nl> await RaiseFailedResourceOwnerAuthenticationEventAsync ( userName , errorDescription ) ; <nl> <nl> return Invalid ( OidcConstants . TokenErrors . InvalidGrant , errorDescription , resourceOwnerContext . Result . CustomResponse ) ; <nl> private void LogError ( string message = null , params object [ ] values ) <nl> _logger . LogError ( \" { details } \" , details ) ; <nl> } <nl> <nl> + private void LogInfo ( string message = null , params object [ ] values ) <nl> + { <nl> + if ( message . IsPresent ( ) ) <nl> + { <nl> + try <nl> + { <nl> + _logger . LogInformation ( message , values ) ; <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + _logger . LogError ( \" Error logging { exception } \" , ex . Message ) ; <nl> + } <nl> + } <nl> + <nl> + var details = new TokenRequestValidationLog ( _validatedRequest ) ; <nl> + _logger . LogInformation ( \" { details } \" , details ) ; <nl> + } <nl> + <nl> private void LogSuccess ( ) <nl> { <nl> var details = new TokenRequestValidationLog ( _validatedRequest ) ; <nl>\n", "msg": "reduce log level for failed resource owner password flow\n", "score": 1}
{"diff_id": 8580, "repo": "dotnet/roslyn\n", "sha": "9efbe9fdb37da7794eaec84fa3c38a28e3422bf4\n", "time": "2018-04-11T22:24:56Z\n", "diff": "mmm a / src / Compilers / CSharp / Portable / Binder / Binder_Patterns . cs <nl> ppp b / src / Compilers / CSharp / Portable / Binder / Binder_Patterns . cs <nl> internal BoundExpression ConvertPatternExpression ( TypeSymbol inputType , CSharpSy <nl> / / If we are pattern - matching against an open type , we do not convert the constant to the type of the input . <nl> / / This permits us to match a value of type ` IComparable < T > ` with a pattern of type ` int ` . <nl> bool inputContainsTypeParameter = inputType . ContainsTypeParameter ( ) ; <nl> - HashSet < DiagnosticInfo > useSiteDiagnostics = null ; <nl> if ( inputContainsTypeParameter ) <nl> { <nl> convertedExpression = expression ; <nl> + HashSet < DiagnosticInfo > useSiteDiagnostics = null ; <nl> if ( expression . ConstantValue = = ConstantValue . Null ) <nl> { <nl> if ( inputType . IsNonNullableValueType ( ) ) <nl>\n", "msg": "Move a declaration closer to its point of use .\n", "score": 1}
{"diff_id": 9077, "repo": "mono/mono\n", "sha": "c44697642e52d4d84a01419887ad0d700b59987a\n", "time": "2006-09-03T06:48:07Z\n", "diff": "mmm a / mcs / class / System . Data / Mainsoft . Data . Jdbc . Providers . jvm / GenericProvider . cs <nl> ppp b / mcs / class / System . Data / Mainsoft . Data . Jdbc . Providers . jvm / GenericProvider . cs <nl> sealed class JdbcUrlConnector { <nl> properties . put ( key , value ) ; <nl> } <nl> <nl> - ActivateJdbcDriver ( ) ; <nl> - <nl> + Driver d = ActivateJdbcDriver ( ) ; <nl> / / TBD : add DriverManager . setLoginTimeout <nl> + if ( d ! = null ) <nl> + return d . connect ( url , properties ) ; <nl> + <nl> return DriverManager . getConnection ( url , properties ) ; <nl> } <nl> } <nl> sealed class JdbcUrlConnector { <nl> return value ; <nl> } <nl> <nl> - private void ActivateJdbcDriver ( ) { <nl> + private Driver ActivateJdbcDriver ( ) { <nl> string driver = ( string ) _keyMapper [ \" JdbcDriverClassName \" ] ; <nl> if ( driver = = null ) <nl> driver = ( string ) _provider . ProviderInfo [ ConfigurationConsts . JdbcDriverClassName ] ; <nl> <nl> if ( driver ! = null & & driver . Length ! = 0 ) { <nl> try { <nl> - java . lang . Class . forName ( driver ) . newInstance ( ) ; <nl> + return ( Driver ) java . lang . Class . forName ( driver ) . newInstance ( ) ; <nl> } <nl> catch ( java . lang . ClassNotFoundException e ) { <nl> throw new TypeLoadException ( e . Message , e ) ; <nl> sealed class JdbcUrlConnector { <nl> throw new MissingMethodException ( e . Message , e ) ; <nl> } <nl> } <nl> + <nl> + return null ; <nl> } <nl> <nl> # endregion / / Methods <nl>\n", "msg": "prefer using newly created driver instance for opening a connection\n", "score": 1}
{"diff_id": 9653, "repo": "cefsharp/CefSharp\n", "sha": "4b3c04a615d65e095450ba09092a8ec7249963a2\n", "time": "2018-01-23T08:41:13Z\n", "diff": "mmm a / CefSharp / IJavascriptObjectRepository . cs <nl> ppp b / CefSharp / IJavascriptObjectRepository . cs <nl> public interface IJavascriptObjectRepository : IDisposable <nl> / / / < / summary > <nl> / / / < param name = \" name \" > name < / param > <nl> / / / < param name = \" objectToBind \" > object < / param > <nl> - / / / < param name = \" isAsync \" > is async < / param > <nl> + / / / < param name = \" isAsync \" > <nl> + / / / if true the object will be registered for async communication , <nl> + / / / only methods will be exposed and when called from javascript will return a Promise to be awaited . <nl> + / / / This method is newer and recommended for everyone starting out as it is faster and more reliable . <nl> + / / / If false then methods and properties will be registered , this method relies on a WCF service to communicate . <nl> + / / / < / param > <nl> / / / < param name = \" options \" > binding options < / param > <nl> void Register ( string name , object objectToBind , bool isAsync = false , BindingOptions options = null ) ; <nl> / / / < summary > <nl>\n", "msg": "IJavascriptObjectRepository . Register - Improve isAsync xml doco comment\n", "score": 1}
{"diff_id": 9889, "repo": "QuantConnect/Lean\n", "sha": "118f037e43d6558bb0d48cf82de5fe865686cc36\n", "time": "2015-02-27T17:08:59Z\n", "diff": "mmm a / Algorithm / QCAlgorithm . Trading . cs <nl> ppp b / Algorithm / QCAlgorithm . Trading . cs <nl> public int MarketOrder ( string symbol , int quantity , bool asynchronous = false , s <nl> <nl> var order = new MarketOrder ( symbol , quantity , Time , tag , Securities [ symbol ] . Type ) ; <nl> <nl> + / / Set the rough price of the order for buying power calculations <nl> + order . Price = Securities [ symbol ] . Price ; <nl> + <nl> / / Add the order and create a new order Id . <nl> var orderId = Transactions . AddOrder ( order ) ; <nl> <nl>\n", "msg": "Set market price for market orders in QCAlgorithm Trading\n", "score": 1}
{"diff_id": 10141, "repo": "dotnet/BenchmarkDotNet\n", "sha": "cc974e915b87536fd67b7fd24058c06d1221dc61\n", "time": "2016-12-03T14:17:22Z\n", "diff": "mmm a / src / BenchmarkDotNet . Core / Portability / RuntimeInformation . cs <nl> ppp b / src / BenchmarkDotNet . Core / Portability / RuntimeInformation . cs <nl> internal static string GetJitInfo ( ) <nl> # else <nl> / / We are working on Full CLR , so there are only LegacyJIT and RyuJIT <nl> var modules = GetJitModules ( ) . ToArray ( ) ; <nl> - string modulesInfo = GetJitModulesInfo ( ) ; <nl> - if ( HasRyuJit ( ) ) <nl> + string jitName = HasRyuJit ( ) ? \" RyuJIT \" : \" LegacyJIT \" ; <nl> + if ( modules . Length = = 1 ) <nl> { <nl> - var targetModule = modules . FirstOrDefault ( m = > m . Name = = \" clrjit \" ) ; <nl> - return targetModule ! = null <nl> - ? \" RyuJIT - v \" + targetModule . Version <nl> - : \" RyuJIT / \" + modulesInfo ; <nl> + / / If we have only one JIT module , we know the version of the current JIT compiler <nl> + return jitName + \" - v \" + modules [ 0 ] . Version ; <nl> } <nl> else <nl> { <nl> - var targetModule = modules . FirstOrDefault ( m = > m . Name = = \" compatjit \" | | m . Name = = \" mscorjit \" ) ; <nl> - return targetModule ! = null <nl> - ? \" LegacyJIT - v \" + targetModule . Version <nl> - : \" LegacyJIT / \" + modulesInfo ; <nl> + / / Otherwise , let ' s just print information about all modules <nl> + return jitName + \" / \" + GetJitModulesInfo ( ) ; <nl> } <nl> # endif <nl> } <nl>\n", "msg": "Improved information about job environments in summary , part 3\n", "score": 1}
{"diff_id": 10393, "repo": "nopSolutions/nopCommerce\n", "sha": "1f3883097117d47d090b1fe3afef83ed85fe8612\n", "time": "2012-02-09T05:27:52Z\n", "diff": "mmm a / src / Presentation / Nop . Web / Administration / Controllers / MeasureController . cs <nl> ppp b / src / Presentation / Nop . Web / Administration / Controllers / MeasureController . cs <nl> public ActionResult WeightDelete ( int id , GridCommand command ) <nl> var weight = _measureService . GetMeasureWeightById ( id ) ; <nl> if ( weight = = null ) <nl> throw new ArgumentException ( \" No weight found with the specified id \" ) ; <nl> + <nl> + if ( weight . Id = = _measureSettings . BaseWeightId ) <nl> + return Content ( \" The primary weight can ' t be deleted . \" ) ; <nl> + <nl> _measureService . DeleteMeasureWeight ( weight ) ; <nl> <nl> return Weights ( command ) ; <nl> public ActionResult DimensionDelete ( int id , GridCommand command ) <nl> var dimension = _measureService . GetMeasureDimensionById ( id ) ; <nl> if ( dimension = = null ) <nl> throw new ArgumentException ( \" No dimension found with the specified id \" ) ; <nl> + <nl> + if ( dimension . Id = = _measureSettings . BaseDimensionId ) <nl> + return Content ( \" The primary dimension can ' t be deleted . \" ) ; <nl> + <nl> _measureService . DeleteMeasureDimension ( dimension ) ; <nl> <nl> return Dimensions ( command ) ; <nl>\n", "msg": "Do not allow store owner to delete the primary weight and the primary dimension .\n", "score": 1}
{"diff_id": 10829, "repo": "dotnet/maui\n", "sha": "69944f1be338d4fadc7b3d0f7a4163829cfd1c88\n", "time": "2020-04-16T17:56:40Z\n", "diff": "mmm a / Xamarin . Essentials / Clipboard / Clipboard . mac . cs <nl> ppp b / Xamarin . Essentials / Clipboard / Clipboard . mac . cs <nl> <nl> -  using System . Threading . Tasks ; <nl> +  using System . Collections . Generic ; <nl> + using System . Threading . Tasks ; <nl> using AppKit ; <nl> using Foundation ; <nl> <nl> static Task PlatformSetTextAsync ( string text ) <nl> static bool PlatformHasText = > <nl> Pasteboard . GetStringForType ( pasteboardType ) ! = null ; <nl> <nl> - static Task < string > PlatformGetTextAsync ( ) = > <nl> - Task . FromResult ( Pasteboard . GetStringForType ( pasteboardType ) ) ; <nl> + static Task < string > PlatformGetTextAsync ( ) <nl> + { <nl> + var strs = Pasteboard . ReadObjectsForClasses ( <nl> + new ObjCRuntime . Class [ ] { new ObjCRuntime . Class ( typeof ( NSString ) ) } , <nl> + null ) ; <nl> + <nl> + return Task . FromResult ( strs ? [ 0 ] ? . ToString ( ) ) ; <nl> + } <nl> <nl> static void StartClipboardListeners ( ) <nl> = > throw ExceptionUtils . NotSupportedOrImplementedException ; <nl>\n", "msg": "Support more pasteboard string types for macOS\n", "score": 1}
{"diff_id": 10877, "repo": "microsoft/VFSForGit\n", "sha": "ec64afbcd8f7a5a7bd0112f85fcffcdabf4a401c\n", "time": "2019-08-05T02:52:51Z\n", "diff": "mmm a / GVFS / GVFS . FunctionalTests / Tests / EnlistmentPerFixture / IncludedFolderTests . cs <nl> ppp b / GVFS / GVFS . FunctionalTests / Tests / EnlistmentPerFixture / IncludedFolderTests . cs <nl> public void AddingSubfolderShouldKeepParentRecursive ( ) <nl> } <nl> <nl> [ TestCase , Order ( 5 ) ] <nl> + [ Category ( Categories . WindowsOnly ) ] <nl> public void CreatingFolderShouldAddToIncludedListAndStartProjecting ( ) <nl> { <nl> this . gvfsProcess . AddIncludedFolders ( this . mainIncludedFolder ) ; <nl> public void CreatingFolderShouldAddToIncludedListAndStartProjecting ( ) <nl> projectedFile . ShouldBeAFile ( this . fileSystem ) ; <nl> } <nl> <nl> + [ TestCase , Order ( 5 ) ] <nl> + [ Category ( Categories . MacOnly ) ] <nl> + public void CreateFolderThenFileShouldAddToIncludedListAndStartProjecting ( ) <nl> + { <nl> + this . gvfsProcess . AddIncludedFolders ( this . mainIncludedFolder ) ; <nl> + this . ValidateIncludedFolders ( this . mainIncludedFolder ) ; <nl> + <nl> + string newFolderPath = Path . Combine ( this . Enlistment . RepoRoot , \" GVFS \" , \" GVFS . Common \" ) ; <nl> + newFolderPath . ShouldNotExistOnDisk ( this . fileSystem ) ; <nl> + Directory . CreateDirectory ( newFolderPath ) ; <nl> + string newFilePath = Path . Combine ( newFolderPath , \" test . txt \" ) ; <nl> + File . WriteAllText ( newFilePath , \" New file content \" ) ; <nl> + newFolderPath . ShouldBeADirectory ( this . fileSystem ) ; <nl> + newFilePath . ShouldBeAFile ( this . fileSystem ) ; <nl> + string [ ] fileSystemEntries = Directory . GetFileSystemEntries ( newFolderPath ) ; <nl> + fileSystemEntries . Length . ShouldEqual ( 33 ) ; <nl> + <nl> + string projectedFolder = Path . Combine ( newFolderPath , \" Git \" ) ; <nl> + projectedFolder . ShouldBeADirectory ( this . fileSystem ) ; <nl> + fileSystemEntries = Directory . GetFileSystemEntries ( projectedFolder ) ; <nl> + fileSystemEntries . Length . ShouldEqual ( 13 ) ; <nl> + <nl> + string projectedFile = Path . Combine ( newFolderPath , \" ReturnCode . cs \" ) ; <nl> + projectedFile . ShouldBeAFile ( this . fileSystem ) ; <nl> + } <nl> + <nl> [ TestCase , Order ( 6 ) ] <nl> public void ReadFileThenChangingIncludeFoldersShouldRemoveFileAndFolder ( ) <nl> { <nl>\n", "msg": "Add different method for creating a folder for windows and mac\n", "score": 1}
{"diff_id": 11130, "repo": "ppy/osu\n", "sha": "f9d7e7c6b89dc1335f2a260d4004ae890e218ef8\n", "time": "2020-02-21T10:16:08Z\n", "diff": "mmm a / osu . Game / Updater / SimpleUpdateManager . cs <nl> ppp b / osu . Game / Updater / SimpleUpdateManager . cs <nl> private string getBestUrl ( GitHubRelease release ) <nl> bestAsset = release . Assets ? . Find ( f = > f . Name . EndsWith ( \" . app . zip \" ) ) ; <nl> break ; <nl> <nl> + case RuntimeInfo . Platform . Linux : <nl> + bestAsset = release . Assets ? . Find ( f = > f . Name . EndsWith ( \" . AppImage \" ) ) ; <nl> + break ; <nl> + <nl> case RuntimeInfo . Platform . Android : <nl> / / on our testing device this causes the download to magically disappear . <nl> / / bestAsset = release . Assets ? . Find ( f = > f . Name . EndsWith ( \" . apk \" ) ) ; <nl>\n", "msg": "Add simple updater support for linux AppImages\n", "score": 1}
{"diff_id": 11720, "repo": "reactiveui/refit\n", "sha": "48dcdda60d154aa72832fd59b08bda79e7951519\n", "time": "2014-10-12T05:12:11Z\n", "diff": "mmm a / InterfaceStubGenerator / Program . cs <nl> ppp b / InterfaceStubGenerator / Program . cs <nl> static void Main ( string [ ] args ) <nl> using ( var of = File . OpenWrite ( target . FullName ) ) { <nl> var bytes = Encoding . UTF8 . GetBytes ( template ) ; <nl> of . Write ( bytes , 0 , bytes . Length ) ; <nl> + of . Flush ( ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Blindly try to fix weird file skew issues\n", "score": 1}
{"diff_id": 11832, "repo": "reactiveui/ReactiveUI\n", "sha": "4ac20261243131dfdcfe10c153f7a31fc021d73b\n", "time": "2014-03-02T20:20:48Z\n", "diff": "mmm a / ReactiveUI . Platforms / Xaml / TransitioningContentControl . cs <nl> ppp b / ReactiveUI . Platforms / Xaml / TransitioningContentControl . cs <nl> void QueueTransition ( object oldContent , object newContent ) <nl> this . RaiseTransitionStarted ( ) ; <nl> VisualStateManager . GoToState ( this , startingTransitionName , false ) ; <nl> } <nl> + } else { <nl> + if ( this . currentContentPresentationSite ! = null ) <nl> + this . currentContentPresentationSite . Content = newContent ; <nl> } <nl> } <nl> <nl> public override void OnApplyTemplate ( ) <nl> <nl> this . previousContentPresentationSite = <nl> ( ContentPresenter ) GetTemplateChild ( \" PART_PreviousContentPresentationSite \" ) ; <nl> - if ( this . previousContentPresentationSite = = null ) { <nl> - throw new ArgumentException ( \" PART_PreviousContentPresentationSite not found . \" ) ; <nl> - } <nl> <nl> / / Set the current content site to the first piece of content . <nl> this . currentContentPresentationSite . Content = Content ; <nl>\n", "msg": "Allow templates for TCC not to have previous site\n", "score": 1}
{"diff_id": 12962, "repo": "icsharpcode/ILSpy\n", "sha": "9ebfbe57ddc4f8866be00c91dbd65f911c15ab93\n", "time": "2018-05-09T19:33:44Z\n", "diff": "mmm a / ICSharpCode . Decompiler / IL / Transforms / TransformAssignment . cs <nl> ppp b / ICSharpCode . Decompiler / IL / Transforms / TransformAssignment . cs <nl> namespace ICSharpCode . Decompiler . IL . Transforms <nl> public class TransformAssignment : IStatementTransform <nl> { <nl> StatementTransformContext context ; <nl> - <nl> + <nl> void IStatementTransform . Run ( Block block , int pos , StatementTransformContext context ) <nl> { <nl> this . context = context ; <nl> void IStatementTransform . Run ( Block block , int pos , StatementTransformContext con <nl> } <nl> if ( TransformPostIncDecOperatorWithInlineStore ( block , pos ) <nl> | | TransformPostIncDecOperator ( block , pos ) <nl> - | | TransformPostIncDecOperatorLocal ( block , pos ) ) <nl> + | | TransformPostIncDecOperatorLocal ( block , pos ) <nl> + | | TransformCustomPostIncDecOperator ( block , pos ) ) <nl> { <nl> / / again , new top - level stloc might need inlining : <nl> context . RequestRerun ( ) ; <nl> bool TransformInlineAssignmentStObjOrCall ( Block block , int pos ) <nl> return false ; <nl> if ( ! SemanticHelper . IsPure ( stobj . Target . Flags ) | | inst . Variable . IsUsedWithin ( stobj . Target ) ) <nl> return false ; <nl> - if ( IsImplicitTruncation ( inst . Value , stobj . Type ) ) { <nl> + var newType = stobj . Target . InferType ( ) ; <nl> + if ( newType is ByReferenceType byref ) <nl> + newType = byref . ElementType ; <nl> + else if ( newType is PointerType pointer ) <nl> + newType = pointer . ElementType ; <nl> + else <nl> + newType = stobj . Type ; <nl> + if ( IsImplicitTruncation ( inst . Value , newType ) ) { <nl> / / ' stobj ' is implicitly truncating the value <nl> return false ; <nl> } <nl> + stobj . Type = newType ; <nl> context . Step ( \" Inline assignment stobj \" , stobj ) ; <nl> block . Instructions . Remove ( localStore ) ; <nl> block . Instructions . Remove ( stobj ) ; <nl> bool TransformInlineAssignmentStObjOrCall ( Block block , int pos ) <nl> } ; <nl> inst . ReplaceWith ( new StLoc ( local , inlineBlock ) ) ; <nl> / / because the ExpressionTransforms don ' t look into inline blocks , manually trigger HandleCallCompoundAssign <nl> - if ( HandleCallCompoundAssign ( call , context ) ) { <nl> + if ( HandleCallCompoundAssign ( call , context ) | | HandleUserDefinedCompoundAssignOnCall ( call , context ) ) { <nl> / / if we did construct a compound assignment , it should have made our inline block redundant : <nl> if ( inlineBlock . Instructions . Single ( ) . MatchStLoc ( newVar , out var compoundAssign ) ) { <nl> Debug . Assert ( newVar . IsSingleDefinition & & newVar . LoadCount = = 1 ) ; <nl> bool TransformInlineAssignmentStObjOrCall ( Block block , int pos ) <nl> return false ; <nl> } <nl> } <nl> - <nl> + <nl> static ILInstruction UnwrapSmallIntegerConv ( ILInstruction inst , out Conv conv ) <nl> { <nl> conv = inst as Conv ; <nl> static ILInstruction UnwrapSmallIntegerConv ( ILInstruction inst , out Conv conv ) <nl> <nl> static bool ValidateCompoundAssign ( BinaryNumericInstruction binary , Conv conv , IType targetType ) <nl> { <nl> - if ( ! CompoundAssignmentInstruction . IsBinaryCompatibleWithType ( binary , targetType ) ) <nl> + if ( ! NumericCompoundAssign . IsBinaryCompatibleWithType ( binary , targetType ) ) <nl> return false ; <nl> if ( conv ! = null & & ! ( conv . TargetType = = targetType . ToPrimitiveType ( ) & & conv . CheckForOverflow = = binary . CheckForOverflow ) ) <nl> return false ; / / conv does not match binary operation <nl> return true ; <nl> } <nl> - <nl> + <nl> static bool MatchingGetterAndSetterCalls ( CallInstruction getterCall , CallInstruction setterCall ) <nl> { <nl> if ( getterCall = = null | | setterCall = = null | | ! IsSameMember ( getterCall . Method . AccessorOwner , setterCall . Method . AccessorOwner ) ) <nl> return false ; <nl> + if ( setterCall . OpCode ! = getterCall . OpCode ) <nl> + return false ; <nl> var owner = getterCall . Method . AccessorOwner as IProperty ; <nl> if ( owner = = null | | ! IsSameMember ( getterCall . Method , owner . Getter ) | | ! IsSameMember ( setterCall . Method , owner . Setter ) ) <nl> return false ; <nl> internal static bool HandleCallCompoundAssign ( CallInstruction setterCall , Statem <nl> return false ; <nl> } <nl> context . Step ( $ \" Compound assignment to ' { getterCall . Method . AccessorOwner . Name } ' \" , setterCall ) ; <nl> - ILInstruction newInst = new CompoundAssignmentInstruction ( <nl> + ILInstruction newInst = new NumericCompoundAssign ( <nl> binary , getterCall , binary . Right , <nl> getterCall . Method . ReturnType , CompoundAssignmentType . EvaluatesToNewValue ) ; <nl> if ( storeInSetter ! = null ) { <nl> internal static bool HandleStObjCompoundAssign ( StObj inst , ILTransformContext co <nl> if ( ! ValidateCompoundAssign ( binary , conv , targetType ) ) <nl> return false ; <nl> context . Step ( \" compound assignment \" , inst ) ; <nl> - inst . ReplaceWith ( new CompoundAssignmentInstruction ( <nl> + inst . ReplaceWith ( new NumericCompoundAssign ( <nl> binary , binary . Left , binary . Right , <nl> targetType , CompoundAssignmentType . EvaluatesToNewValue ) ) ; <nl> return true ; <nl> static internal bool IsImplicitTruncation ( ILInstruction value , IType type , bool <nl> } <nl> return true ; <nl> } <nl> - <nl> + <nl> / / / < code > <nl> / / / stloc s ( ldloc l ) <nl> / / / stloc l ( binary . op ( ldloc s , ldc . i4 1 ) ) <nl> bool TransformPostIncDecOperatorLocal ( Block block , int pos ) <nl> block . Instructions . RemoveAt ( pos + 1 ) ; / / remove nextInst <nl> return true ; <nl> } <nl> - <nl> + <nl> / / / < summary > <nl> / / / Gets whether ' inst ' is a possible store for use as a compound store . <nl> / / / < / summary > <nl> bool IsCompoundStore ( ILInstruction inst , out IType storeType , out ILInstruction <nl> value = null ; <nl> storeType = null ; <nl> if ( inst is StObj stobj ) { <nl> - storeType = stobj . Type ; <nl> + storeType = stobj . Target . InferType ( ) ; <nl> + if ( storeType is ByReferenceType refType ) { <nl> + storeType = refType . ElementType ; <nl> + } else if ( storeType is PointerType pointerType ) { <nl> + storeType = pointerType . ElementType ; <nl> + } else { <nl> + storeType = stobj . Type ; <nl> + } <nl> value = stobj . Value ; <nl> return SemanticHelper . IsPure ( stobj . Target . Flags ) ; <nl> } else if ( inst is CallInstruction call & & ( call . OpCode = = OpCode . Call | | call . OpCode = = OpCode . CallVirt ) ) { <nl> bool TransformPostIncDecOperatorWithInlineStore ( Block block , int pos ) <nl> if ( ! IsCompoundStore ( store , out var targetType , out var value ) ) <nl> return false ; <nl> var binary = UnwrapSmallIntegerConv ( value , out var conv ) as BinaryNumericInstruction ; <nl> - if ( binary = = null | | ! binary . Right . MatchLdcI4 ( 1 ) ) <nl> + if ( binary = = null | | ! binary . Right . MatchLdcI ( 1 ) ) <nl> return false ; <nl> if ( ! ( binary . Operator = = BinaryNumericOperator . Add | | binary . Operator = = BinaryNumericOperator . Sub ) ) <nl> return false ; <nl> bool TransformPostIncDecOperatorWithInlineStore ( Block block , int pos ) <nl> if ( IsImplicitTruncation ( stloc . Value , stloc . Variable . Type ) ) <nl> return false ; <nl> context . Step ( \" TransformPostIncDecOperatorWithInlineStore \" , store ) ; <nl> - block . Instructions [ pos ] = new StLoc ( stloc . Variable , new CompoundAssignmentInstruction ( <nl> + block . Instructions [ pos ] = new StLoc ( stloc . Variable , new NumericCompoundAssign ( <nl> binary , stloc . Value , binary . Right , targetType , CompoundAssignmentType . EvaluatesToOldValue ) ) ; <nl> return true ; <nl> } <nl> bool TransformPostIncDecOperator ( Block block , int i ) <nl> if ( ! IsMatchingCompoundLoad ( inst . Value , store , inst . Variable ) ) <nl> return false ; <nl> var binary = UnwrapSmallIntegerConv ( value , out var conv ) as BinaryNumericInstruction ; <nl> - if ( binary = = null | | ! binary . Left . MatchLdLoc ( inst . Variable ) | | ! binary . Right . MatchLdcI4 ( 1 ) ) <nl> + if ( binary = = null | | ! binary . Left . MatchLdLoc ( inst . Variable ) | | ! binary . Right . MatchLdcI ( 1 ) ) <nl> return false ; <nl> if ( ! ( binary . Operator = = BinaryNumericOperator . Add | | binary . Operator = = BinaryNumericOperator . Sub ) ) <nl> return false ; <nl> bool TransformPostIncDecOperator ( Block block , int i ) <nl> if ( IsImplicitTruncation ( value , targetType ) ) <nl> return false ; <nl> context . Step ( \" TransformPostIncDecOperator \" , inst ) ; <nl> - inst . Value = new CompoundAssignmentInstruction ( binary , inst . Value , binary . Right , targetType , CompoundAssignmentType . EvaluatesToOldValue ) ; <nl> + inst . Value = new NumericCompoundAssign ( binary , inst . Value , binary . Right , targetType , CompoundAssignmentType . EvaluatesToOldValue ) ; <nl> + block . Instructions . RemoveAt ( i + 1 ) ; <nl> + if ( inst . Variable . IsSingleDefinition & & inst . Variable . LoadCount = = 0 ) { <nl> + / / dead store - > it was a statement - level post - increment <nl> + inst . ReplaceWith ( inst . Value ) ; <nl> + } <nl> + return true ; <nl> + } <nl> + <nl> + / / / < code > <nl> + / / / stloc l ( callvirt get_Property ( target ) ) <nl> + / / / callvirt set_Property ( target , call op_Method ( ldloc l ) ) <nl> + / / / target is pure and does not use ' l ' , ' stloc does not truncate ' <nl> + / / / - - > <nl> + / / / stloc l ( compound . op . old ( ldobj ( target ) , ldc . i4 1 ) ) <nl> + / / / < / code > <nl> + / / / < remarks > <nl> + / / / This pattern occurs with legacy csc for static fields , and with Roslyn for most post - increments . <nl> + / / / < / remarks > <nl> + bool TransformCustomPostIncDecOperator ( Block block , int i ) <nl> + { <nl> + var inst = block . Instructions [ i ] as StLoc ; <nl> + var store = block . Instructions . ElementAtOrDefault ( i + 1 ) ; <nl> + if ( inst = = null | | store = = null ) <nl> + return false ; <nl> + if ( IsImplicitTruncation ( inst . Value , inst . Variable . Type ) ) { <nl> + / / ' stloc s ' is implicitly truncating the value <nl> + return false ; <nl> + } <nl> + if ( ! IsCompoundStore ( store , out var targetType , out var value ) ) <nl> + return false ; <nl> + if ( ! IsMatchingCompoundLoad ( inst . Value , store , inst . Variable ) ) <nl> + return false ; <nl> + if ( ! ( value is CallInstruction operatorCall & & operatorCall . Method . IsOperator & & operatorCall . Arguments . Count = = 1 ) ) <nl> + return false ; <nl> + if ( ! operatorCall . Arguments [ 0 ] . MatchLdLoc ( inst . Variable ) ) <nl> + return false ; <nl> + if ( ! ( operatorCall . Method . Name = = \" op_Increment \" | | operatorCall . Method . Name = = \" op_Decrement \" ) ) <nl> + return false ; <nl> + context . Step ( \" TransformCustomPostIncDecOperator \" , inst ) ; <nl> + / / Reuse instruction for binary user - defined compound assign : <nl> + / / Adds dummy ldc . i4 1 instruction as value , which is actually not used , because we know that there is only argument <nl> + / / in the IMethod definition of op_Increment and op_Decrement , see special case in ExpressionBuilder . <nl> + / / TODO : should we use a different specially tailored instruction for this ? <nl> + inst . Value = new UserDefinedCompoundAssign ( operatorCall . Method , CompoundAssignmentType . EvaluatesToOldValue , inst . Value , new LdcI4 ( 1 ) , false ) ; <nl> block . Instructions . RemoveAt ( i + 1 ) ; <nl> if ( inst . Variable . IsSingleDefinition & & inst . Variable . LoadCount = = 0 ) { <nl> / / dead store - > it was a statement - level post - increment <nl> bool TransformPostIncDecOperator ( Block block , int i ) <nl> } <nl> return true ; <nl> } <nl> - <nl> + <nl> static bool IsSameMember ( IMember a , IMember b ) <nl> { <nl> if ( a = = null | | b = = null ) <nl> static bool IsSameMember ( IMember a , IMember b ) <nl> b = b . MemberDefinition ; <nl> return a . Equals ( b ) ; <nl> } <nl> + <nl> + / / / < summary > <nl> + / / / stobj ( ldloc target , call op_Addition ( ldobj ( ldloc target ) , value ) ) <nl> + / / / where target is pure <nl> + / / / = > compound . op ( target , . . . ) <nl> + / / / < / summary > <nl> + / / / < remarks > <nl> + / / / Called by ExpressionTransforms . <nl> + / / / < / remarks > <nl> + internal static bool HandleUserDefinedCompoundAssignOnReference ( StObj inst , StatementTransformContext context ) <nl> + { <nl> + if ( ! ( inst . Value is CallInstruction operatorCall & & operatorCall . Method . IsOperator ) ) <nl> + return false ; <nl> + ILInstruction value ; <nl> + CompoundAssignmentType assignmentType ; <nl> + if ( operatorCall . Arguments . Count = = 2 ) { <nl> + if ( CSharp . ExpressionBuilder . GetAssignmentOperatorTypeFromMetadataName ( operatorCall . Method . Name ) = = null ) <nl> + return false ; <nl> + value = operatorCall . Arguments [ 1 ] ; <nl> + assignmentType = CompoundAssignmentType . EvaluatesToNewValue ; <nl> + } else if ( operatorCall . Arguments . Count = = 1 ) { <nl> + if ( ! ( operatorCall . Method . Name = = \" op_Increment \" | | operatorCall . Method . Name = = \" op_Decrement \" ) ) <nl> + return false ; <nl> + assignmentType = CompoundAssignmentType . EvaluatesToNewValue ; <nl> + IType targetType = operatorCall . Method . Parameters [ 0 ] . Type ; <nl> + if ( targetType . IsReferenceType = = true ) <nl> + value = new LdNull ( ) ; <nl> + else <nl> + value = new DefaultValue ( targetType ) ; <nl> + } else { <nl> + return false ; <nl> + } <nl> + var getter = operatorCall . Arguments [ 0 ] ; <nl> + var storeInGetter = getter as StLoc ; <nl> + if ( storeInGetter ! = null ) { <nl> + assignmentType = CompoundAssignmentType . EvaluatesToOldValue ; <nl> + getter = storeInGetter . Value ; <nl> + } <nl> + if ( ! ( getter is LdObj ldobj ) ) <nl> + return false ; <nl> + if ( ! inst . Target . Match ( ldobj . Target ) . Success ) <nl> + return false ; <nl> + if ( ! SemanticHelper . IsPure ( ldobj . Target . Flags ) ) <nl> + return false ; <nl> + context . Step ( $ \" compound assignment to ' { ldobj } ' \" , inst ) ; <nl> + ILInstruction newInst = new UserDefinedCompoundAssign ( operatorCall . Method , assignmentType , <nl> + ldobj , value , false ) ; <nl> + if ( storeInGetter ! = null ) { <nl> + storeInGetter . Value = newInst ; <nl> + newInst = storeInGetter ; <nl> + context . RequestRerun ( ) ; / / moving might trigger inlining <nl> + } <nl> + inst . ReplaceWith ( newInst ) ; <nl> + return true ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / binary : <nl> + / / / <nl> + / / / call set_Property ( ldloc s , call op_Method ( call get_Property ( ldloc s ) , value ) ) <nl> + / / / = > <nl> + / / / user . compound op_Method ( call get_Property ( ldloc s ) , value ) <nl> + / / / <nl> + / / / - or - <nl> + / / / <nl> + / / / unary : <nl> + / / / <nl> + / / / call set_Property ( ldloc s , call op_Method ( call get_Property ( ldloc s ) ) ) <nl> + / / / = > <nl> + / / / user . compound op_Method ( call get_Property ( ldloc s ) , value ) <nl> + / / / <nl> + / / / where value is either ldc . * 1 or ldnull or default . value depending on the target type . <nl> + / / / < / summary > <nl> + / / / < remarks > <nl> + / / / Called by ExpressionTransforms . <nl> + / / / < / remarks > <nl> + internal static bool HandleUserDefinedCompoundAssignOnCall ( CallInstruction setterCall , StatementTransformContext context ) <nl> + { <nl> + var setterValue = setterCall . Arguments . LastOrDefault ( ) ; <nl> + var storeInSetter = setterValue as StLoc ; <nl> + if ( storeInSetter ! = null ) { <nl> + / / callvirt set_Property ( ldloc S_1 , stloc v ( call op_Method ( call get_Property ( ldloc s ) , value ) ) ) <nl> + / / = = > stloc v ( compound . op . new ( callvirt get_Property ( ldloc S_1 ) , value ) ) <nl> + setterValue = storeInSetter . Value ; <nl> + } <nl> + if ( ! ( setterValue is CallInstruction operatorCall & & operatorCall . Method . IsOperator ) ) <nl> + return false ; <nl> + ; <nl> + ILInstruction value ; <nl> + CompoundAssignmentType assignmentType ; <nl> + if ( operatorCall . Arguments . Count = = 2 ) { <nl> + if ( CSharp . ExpressionBuilder . GetAssignmentOperatorTypeFromMetadataName ( operatorCall . Method . Name ) = = null ) <nl> + return false ; <nl> + value = operatorCall . Arguments [ 1 ] ; <nl> + assignmentType = CompoundAssignmentType . EvaluatesToNewValue ; <nl> + } else if ( operatorCall . Arguments . Count = = 1 ) { <nl> + if ( ! ( operatorCall . Method . Name = = \" op_Increment \" | | operatorCall . Method . Name = = \" op_Decrement \" ) ) <nl> + return false ; <nl> + assignmentType = CompoundAssignmentType . EvaluatesToNewValue ; <nl> + IType targetType = operatorCall . Method . Parameters [ 0 ] . Type ; <nl> + if ( targetType . IsReferenceType = = true ) <nl> + value = new LdNull ( ) ; <nl> + else <nl> + value = new DefaultValue ( targetType ) ; <nl> + } else { <nl> + return false ; <nl> + } <nl> + var getter = operatorCall . Arguments [ 0 ] ; <nl> + var storeInGetter = getter as StLoc ; <nl> + if ( storeInGetter ! = null ) { <nl> + assignmentType = CompoundAssignmentType . EvaluatesToOldValue ; <nl> + getter = storeInGetter . Value ; <nl> + } <nl> + if ( ! ( getter is CallInstruction getterCall ) ) <nl> + return false ; <nl> + if ( ! MatchingGetterAndSetterCalls ( getterCall , setterCall ) ) <nl> + return false ; <nl> + context . Step ( $ \" Compound assignment to ' { getterCall . Method . AccessorOwner . Name } ' \" , setterCall ) ; <nl> + ILInstruction newInst = new UserDefinedCompoundAssign ( operatorCall . Method , assignmentType , <nl> + getterCall , value , false ) ; <nl> + if ( storeInSetter ! = null ) { <nl> + Debug . Assert ( storeInGetter = = null ) ; <nl> + storeInSetter . Value = newInst ; <nl> + newInst = storeInSetter ; <nl> + context . RequestRerun ( ) ; / / moving stloc to top - level might trigger inlining <nl> + } <nl> + if ( storeInGetter ! = null ) { <nl> + Debug . Assert ( storeInSetter = = null ) ; <nl> + storeInGetter . Value = newInst ; <nl> + newInst = storeInGetter ; <nl> + context . RequestRerun ( ) ; / / moving might trigger inlining <nl> + } <nl> + setterCall . ReplaceWith ( newInst ) ; <nl> + return true ; <nl> + } <nl> } <nl> } <nl>\n", "msg": "Add transforms for userdef compound assignment\n", "score": 1}
{"diff_id": 13006, "repo": "reactiveui/ReactiveUI\n", "sha": "8c436c868d6ca091b2aded9fe0777e29f2e23866\n", "time": "2018-12-11T00:26:12Z\n", "diff": "mmm a / src / ReactiveUI / Platforms / windows - common / ReactiveUserControl . cs <nl> ppp b / src / ReactiveUI / Platforms / windows - common / ReactiveUserControl . cs <nl> namespace ReactiveUI <nl> / / / ] ] > <nl> / / / < / code > <nl> / / / < / para > <nl> + / / / < para > <nl> + / / / Note that UWP projects do not support the < c > TypeArguments < / c > attribute . The XAML designer window in WPF projects also does not <nl> + / / / support generic types . To use < see cref = \" ReactiveUserControl { TViewModel } \" / > in XAML documents you need to create a base class <nl> + / / / where you derive from < see cref = \" ReactiveUserControl { TViewModel } \" / > with the type argument filled in . <nl> + / / / < code > <nl> + / / / < ! [ CDATA [ <nl> + / / / internal class YourViewBase : ReactiveUserControl < YourViewModel > { / * No code needed here * / } <nl> + / / / <nl> + / / / public partial class YourView : YourViewBase <nl> + / / / { <nl> + / / / / * Your code * / <nl> + / / / } <nl> + / / / ] ] > <nl> + / / / < / code > <nl> + / / / Then you can use this base class as root in your XAML document . <nl> + / / / < code > <nl> + / / / < ! [ CDATA [ <nl> + / / / < views : YourViewBase <nl> + / / / x : Class = \" views : YourView \" <nl> + / / / xmlns : rxui = \" http : / / reactiveui . net \" <nl> + / / / xmlns : views = \" clr - namespace : Foo . Bar . Views \" <nl> + / / / xmlns : vms = \" clr - namespace : Foo . Bar . ViewModels \" > <nl> + / / / < ! - - view XAML here - - > <nl> + / / / < / views : YourViewBase > <nl> + / / / ] ] > <nl> + / / / < / code > <nl> + / / / < / para > <nl> / / / < / remarks > <nl> / / / < typeparam name = \" TViewModel \" > <nl> / / / The type of the view model backing the view . <nl>\n", "msg": "Housekeeping : Add documentation explaining how to use ReactiveUserControl in XAML ( )\n", "score": 1}
{"diff_id": 13245, "repo": "ppy/osu\n", "sha": "ed6d1ccd958622bbca51c8cab54f0c3dfd4a6296\n", "time": "2019-12-06T09:04:46Z\n", "diff": "new file mode 100644 <nl> index 00000000000 . . fe582b1461f <nl> mmm / dev / null <nl> ppp b / osu . Game / Configuration / SettingSourceAttribute . cs <nl> <nl> + / / Copyright ( c ) ppy Pty Ltd < contact @ ppy . sh > . Licensed under the MIT Licence . <nl> + / / See the LICENCE file in the repository root for full licence text . <nl> + <nl> + using System ; <nl> + using System . Collections . Generic ; <nl> + using System . Linq ; <nl> + using System . Reflection ; <nl> + using JetBrains . Annotations ; <nl> + using osu . Framework . Bindables ; <nl> + using osu . Framework . Graphics ; <nl> + using osu . Game . Overlays . Settings ; <nl> + <nl> + namespace osu . Game . Configuration <nl> + { <nl> + / / / < summary > <nl> + / / / An attribute to mark a bindable as being exposed to the user via settings controls . <nl> + / / / Can be used in conjunction with < see cref = \" SettingSourceExtensions . CreateSettingsControls \" / > to automatically create UI controls . <nl> + / / / < / summary > <nl> + [ MeansImplicitUse ] <nl> + [ AttributeUsage ( AttributeTargets . Property ) ] <nl> + public class SettingSourceAttribute : Attribute <nl> + { <nl> + public string Label { get ; } <nl> + <nl> + public string Description { get ; } <nl> + <nl> + public SettingSourceAttribute ( string label , string description = null ) <nl> + { <nl> + Label = label ? ? string . Empty ; <nl> + Description = description ? ? string . Empty ; <nl> + } <nl> + } <nl> + <nl> + public static class SettingSourceExtensions <nl> + { <nl> + public static IEnumerable < Drawable > CreateSettingsControls ( this object obj ) <nl> + { <nl> + var configProperties = obj . GetType ( ) . GetProperties ( BindingFlags . GetProperty | BindingFlags . Public | BindingFlags . Instance ) . Where ( p = > p . GetCustomAttribute < SettingSourceAttribute > ( true ) ! = null ) ; <nl> + <nl> + foreach ( var property in configProperties ) <nl> + { <nl> + var attr = property . GetCustomAttribute < SettingSourceAttribute > ( true ) ; <nl> + <nl> + switch ( property . GetValue ( obj ) ) <nl> + { <nl> + case BindableNumber < float > bNumber : <nl> + yield return new SettingsSlider < float > <nl> + { <nl> + LabelText = attr . Label , <nl> + Bindable = bNumber <nl> + } ; <nl> + <nl> + break ; <nl> + <nl> + case BindableNumber < double > bNumber : <nl> + yield return new SettingsSlider < double > <nl> + { <nl> + LabelText = attr . Label , <nl> + Bindable = bNumber <nl> + } ; <nl> + <nl> + break ; <nl> + <nl> + case BindableNumber < int > bNumber : <nl> + yield return new SettingsSlider < int > <nl> + { <nl> + LabelText = attr . Label , <nl> + Bindable = bNumber <nl> + } ; <nl> + <nl> + break ; <nl> + <nl> + case Bindable < bool > bBool : <nl> + yield return new SettingsCheckbox <nl> + { <nl> + LabelText = attr . Label , <nl> + Bindable = bBool <nl> + } ; <nl> + <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl>\n", "msg": "Add a method for getting settings UI components automatically from a target class\n", "score": 1}
{"diff_id": 13546, "repo": "Jackett/Jackett\n", "sha": "fa918481269ad8a401b38dc702fd970bc81c8d75\n", "time": "2017-02-14T10:36:46Z\n", "diff": "mmm a / src / Jackett / Utils / TorznabCapsUtil . cs <nl> ppp b / src / Jackett / Utils / TorznabCapsUtil . cs <nl> public static IEnumerable < ReleaseInfo > FilterResultsToTitle ( IEnumerable < ReleaseI <nl> var filteredResults = new List < ReleaseInfo > ( ) ; <nl> foreach ( var result in results ) <nl> { <nl> + / / don ' t filter results with IMDBID ( will be filtered seperately ) <nl> + if ( result . Imdb ! = null ) <nl> + { <nl> + filteredResults . Add ( result ) ; <nl> + continue ; <nl> + } <nl> + <nl> if ( result . Title = = null ) <nl> continue ; <nl> <nl>\n", "msg": "PotatoFeed : disable title filtering for torrents with imdbid\n", "score": 1}
{"diff_id": 13835, "repo": "AvaloniaUI/Avalonia\n", "sha": "2248a4b5a8d52def240b9485076c93215550266d\n", "time": "2015-12-05T19:09:53Z\n", "diff": "mmm a / src / iOS / Perspex . iOS / PerspexView . cs <nl> ppp b / src / iOS / Perspex . iOS / PerspexView . cs <nl> public override void TouchesMoved ( NSSet touches , UIEvent evt ) <nl> RawMouseEventType . Move , location , InputModifiers . LeftMouseButton ) ) ; <nl> else <nl> { <nl> - double x = location . X - _touchLastPoint . X ; <nl> - double y = location . Y - _touchLastPoint . Y ; <nl> + / / magic number based on test - correction of 0 . 02 is working perfect <nl> double correction = 0 . 02 ; <nl> - var scale = PerspexLocator . Current . GetService < IPlatformSettings > ( ) . RenderScalingFactor ; <nl> - scale = 1 ; <nl> <nl> Input ? . Invoke ( new RawMouseWheelEventArgs ( PerspexAppDelegate . MouseDevice , ( uint ) touch . Timestamp , <nl> - _inputRoot , location , new Vector ( x * correction / scale , y * correction / scale ) , InputModifiers . LeftMouseButton ) ) ; <nl> + _inputRoot , location , ( location - _touchLastPoint ) * correction , InputModifiers . LeftMouseButton ) ) ; <nl> } <nl> _touchLastPoint = location ; <nl> } <nl>\n", "msg": "no need for layout scale to be taken into account because touch events are already scaled\n", "score": 1}
{"diff_id": 14373, "repo": "dotnet/roslyn\n", "sha": "bddf78fc6883e80206904dff0fceae9292677726\n", "time": "2020-04-30T17:34:36Z\n", "diff": "mmm a / src / Analyzers / CSharp / Analyzers / MakeStructFieldsWritable / CSharpMakeStructFieldsWritableDiagnosticAnalyzer . cs <nl> ppp b / src / Analyzers / CSharp / Analyzers / MakeStructFieldsWritable / CSharpMakeStructFieldsWritableDiagnosticAnalyzer . cs <nl> private void AnalyzeAssignment ( OperationAnalysisContext operationContext , bool i <nl> } <nl> <nl> var operationAssigmnent = ( IAssignmentOperation ) operationContext . Operation ; <nl> - _hasTypeInstanceAssigment | = operationAssigmnent . Target is IInstanceReferenceOperation instance & & <nl> - instance . ReferenceKind = = InstanceReferenceKind . ContainingTypeInstance ; <nl> + if ( operationAssigmnent . Target is IInstanceReferenceOperation instance & & <nl> + instance . ReferenceKind = = InstanceReferenceKind . ContainingTypeInstance ) <nl> + { <nl> + _hasTypeInstanceAssigment = true ; <nl> + } <nl> } <nl> <nl> private void SymbolEndAction ( SymbolAnalysisContext symbolEndContext ) <nl>\n", "msg": "Only write ' true ' for a proper latch in concurrent code\n", "score": 1}
{"diff_id": 15359, "repo": "ppy/osu\n", "sha": "56fe97a147197bd4cba09a6f462829481fbfef25\n", "time": "2017-05-24T06:48:27Z\n", "diff": "mmm a / osu . Game . Rulesets . Taiko / UI / KiaiHitExplosion . cs <nl> ppp b / osu . Game . Rulesets . Taiko / UI / KiaiHitExplosion . cs <nl> public KiaiHitExplosion ( TaikoJudgement judgement , bool isRim ) <nl> Size = new Vector2 ( TaikoHitObject . DEFAULT_CIRCLE_DIAMETER , 1 ) ; <nl> <nl> Masking = true ; <nl> - Alpha = 0 . 15f ; <nl> + Alpha = 0 . 25f ; <nl> <nl> Children = new [ ] <nl> { <nl>\n", "msg": "Make kiai hit explosions slightly more prominent .\n", "score": 1}
{"diff_id": 15564, "repo": "OpenRA/OpenRA\n", "sha": "cd99e7850177436e68864525e7a1b0c771b1a2a3\n", "time": "2016-09-24T13:00:36Z\n", "diff": "mmm a / OpenRA . Mods . Common / Traits / World / SmudgeLayer . cs <nl> ppp b / OpenRA . Mods . Common / Traits / World / SmudgeLayer . cs <nl> public void AddSmudge ( CPos loc ) <nl> if ( ( ! dirty . ContainsKey ( loc ) | | dirty [ loc ] . Sprite = = null ) & & ! tiles . ContainsKey ( loc ) ) <nl> { <nl> / / No smudge ; create a new one <nl> - var st = smudges . Keys . Random ( world . SharedRandom ) ; <nl> + var st = smudges . Keys . Random ( Game . CosmeticRandom ) ; <nl> dirty [ loc ] = new Smudge { Type = st , Depth = 0 , Sprite = smudges [ st ] [ 0 ] } ; <nl> } <nl> else <nl>\n", "msg": "Use CosmeticRandom for picking smudge type .\n", "score": 1}
{"diff_id": 15855, "repo": "dotnet/roslyn\n", "sha": "c86184bacdaa2ea9b2d9c91fdae6f26ce792671a\n", "time": "2015-09-11T15:54:06Z\n", "diff": "mmm a / src / Features / CSharp / Portable / Completion / CompletionProviders / CrefCompletionProvider . cs <nl> ppp b / src / Features / CSharp / Portable / Completion / CompletionProviders / CrefCompletionProvider . cs <nl> private IEnumerable < ISymbol > GetOperatorsAndIndexers ( SyntaxToken token , Semantic <nl> private async Task < IEnumerable < CompletionItem > > CreateItemsAsync ( <nl> Workspace workspace , SemanticModel semanticModel , int textChangeSpanPosition , IEnumerable < ISymbol > symbols , SyntaxToken token , CancellationToken cancellationToken ) <nl> { <nl> - var items = new List < CompletionItem > ( ) ; <nl> + var builder = SharedPools . Default < StringBuilder > ( ) . AllocateAndClear ( ) ; <nl> + try <nl> + { <nl> + var items = new List < CompletionItem > ( ) ; <nl> + <nl> + foreach ( var symbol in symbols ) <nl> + { <nl> + var item = await CreateItemAsync ( workspace , semanticModel , textChangeSpanPosition , symbol , token , builder , cancellationToken ) . ConfigureAwait ( false ) ; <nl> + items . Add ( item ) ; <nl> + <nl> + builder . Clear ( ) ; <nl> + } <nl> <nl> - foreach ( var symbol in symbols ) <nl> + return items ; <nl> + } <nl> + finally <nl> { <nl> - var item = await CreateItemAsync ( workspace , semanticModel , textChangeSpanPosition , symbol , token , cancellationToken ) . ConfigureAwait ( false ) ; <nl> - items . Add ( item ) ; <nl> + SharedPools . Default < StringBuilder > ( ) . ClearAndFree ( builder ) ; <nl> } <nl> - <nl> - return items ; <nl> } <nl> <nl> private async Task < CompletionItem > CreateItemAsync ( <nl> - Workspace workspace , SemanticModel semanticModel , int textChangeSpanPosition , ISymbol symbol , SyntaxToken token , CancellationToken cancellationToken ) <nl> + Workspace workspace , SemanticModel semanticModel , int textChangeSpanPosition , ISymbol symbol , SyntaxToken token , StringBuilder builder , CancellationToken cancellationToken ) <nl> { <nl> - var builder = SharedPools . Default < StringBuilder > ( ) . AllocateAndClear ( ) ; <nl> - <nl> int tokenPosition = token . SpanStart ; <nl> <nl> if ( symbol is INamespaceOrTypeSymbol & & token . IsKind ( SyntaxKind . DotToken ) ) <nl> private IEnumerable < ISymbol > GetOperatorsAndIndexers ( SyntaxToken token , Semantic <nl> . Replace ( ' > ' , ' } ' ) <nl> . ToString ( ) ; <nl> <nl> - SharedPools . Default < StringBuilder > ( ) . ClearAndFree ( builder ) ; <nl> - <nl> var text = await semanticModel . SyntaxTree . GetTextAsync ( cancellationToken ) . ConfigureAwait ( false ) ; <nl> <nl> return new Item ( <nl>\n", "msg": "Reuse a single StringBuilder for all items when building C # cref completion items\n", "score": 1}
{"diff_id": 15857, "repo": "Sonarr/Sonarr\n", "sha": "9f34127565e5dcba69b5267c40d70d4b634951d6\n", "time": "2016-04-06T20:07:25Z\n", "diff": "mmm a / src / NzbDrone . Core / Download / Clients / Deluge / DelugeProxy . cs <nl> ppp b / src / NzbDrone . Core / Download / Clients / Deluge / DelugeProxy . cs <nl> protected TResult ProcessRequest < TResult > ( DelugeSettings settings , string method <nl> { <nl> var requestBuilder = BuildRequest ( settings ) ; <nl> <nl> - var response = ProcessRequest < TResult > ( requestBuilder , method , arguments ) ; <nl> + var response = ExecuteRequest < TResult > ( requestBuilder , method , arguments ) ; <nl> <nl> if ( response . Error ! = null ) <nl> { <nl> protected TResult ProcessRequest < TResult > ( DelugeSettings settings , string method <nl> { <nl> AuthenticateClient ( requestBuilder , settings , true ) ; <nl> <nl> - response = ProcessRequest < TResult > ( requestBuilder , method , arguments ) ; <nl> + response = ExecuteRequest < TResult > ( requestBuilder , method , arguments ) ; <nl> <nl> if ( response . Error = = null ) <nl> { <nl> protected TResult ProcessRequest < TResult > ( DelugeSettings settings , string method <nl> return response . Result ; <nl> } <nl> <nl> - private JsonRpcResponse < TResult > ProcessRequest < TResult > ( JsonRpcRequestBuilder requestBuilder , string method , params object [ ] arguments ) <nl> + private JsonRpcResponse < TResult > ExecuteRequest < TResult > ( JsonRpcRequestBuilder requestBuilder , string method , params object [ ] arguments ) <nl> { <nl> var request = requestBuilder . Call ( method , arguments ) . Build ( ) ; <nl> <nl> private JsonRpcResponse < TResult > ProcessRequest < TResult > ( JsonRpcRequestBuilder r <nl> } <nl> } <nl> <nl> + private void VerifyResponse < TResult > ( JsonRpcResponse < TResult > response ) <nl> + { <nl> + if ( response . Error ! = null ) <nl> + { <nl> + var error = response . Error . ToObject < DelugeError > ( ) ; <nl> + throw new DelugeException ( error . Message , error . Code ) ; <nl> + } <nl> + } <nl> + <nl> private void AuthenticateClient ( JsonRpcRequestBuilder requestBuilder , DelugeSettings settings , bool reauthenticate = false ) <nl> { <nl> var authKey = string . Format ( \" { 0 } : { 1 } \" , requestBuilder . BaseUrl , settings . Password ) ; <nl> private void AuthenticateClient ( JsonRpcRequestBuilder requestBuilder , DelugeSett <nl> <nl> private void ConnectDaemon ( JsonRpcRequestBuilder requestBuilder ) <nl> { <nl> - var resultConnected = ProcessRequest < bool > ( requestBuilder , \" web . connected \" ) ; <nl> + var resultConnected = ExecuteRequest < bool > ( requestBuilder , \" web . connected \" ) ; <nl> + VerifyResponse ( resultConnected ) ; <nl> <nl> if ( resultConnected . Result ) <nl> { <nl> return ; <nl> } <nl> <nl> - var resultHosts = ProcessRequest < List < object [ ] > > ( requestBuilder , \" web . get_hosts \" ) ; <nl> + var resultHosts = ExecuteRequest < List < object [ ] > > ( requestBuilder , \" web . get_hosts \" ) ; <nl> + VerifyResponse ( resultHosts ) ; <nl> <nl> if ( resultHosts . Result ! = null ) <nl> { <nl> private void ConnectDaemon ( JsonRpcRequestBuilder requestBuilder ) <nl> <nl> if ( connection ! = null ) <nl> { <nl> - ProcessRequest < object > ( requestBuilder , \" web . connect \" , new object [ ] { connection [ 0 ] } ) ; <nl> - } <nl> - else <nl> - { <nl> - throw new DownloadClientException ( \" Failed to connect to Deluge daemon . \" ) ; <nl> + var resultConnect = ExecuteRequest < object > ( requestBuilder , \" web . connect \" , new object [ ] { connection [ 0 ] } ) ; <nl> + VerifyResponse ( resultConnect ) ; <nl> + <nl> + return ; <nl> } <nl> } <nl> + <nl> + throw new DownloadClientException ( \" Failed to connect to Deluge daemon . \" ) ; <nl> } <nl> <nl> private DelugeTorrent [ ] GetTorrents ( DelugeUpdateUIResult result ) <nl>\n", "msg": "Better error handling in the Deluge ConnectDaemon code .\n", "score": 1}
{"diff_id": 17479, "repo": "mono/mono\n", "sha": "b5ed5a363111e8808ca6d02660d50ebc416874c0\n", "time": "2014-12-05T20:09:59Z\n", "diff": "mmm a / mcs / class / System / System . IO / KeventWatcher . cs <nl> ppp b / mcs / class / System / System . IO / KeventWatcher . cs <nl> public void Start ( ) <nl> <nl> startedEvent . WaitOne ( ) ; <nl> <nl> - if ( failedInit ) { <nl> + if ( monitorExc ! = null ) { <nl> thread . Join ( ) ; <nl> CleanUp ( ) ; <nl> - throw new IOException ( \" Monitor thread failed while initializing . \" ) ; <nl> + throw monitorExc ; <nl> } <nl> else <nl> started = true ; <nl> public void Stop ( ) <nl> <nl> CleanUp ( ) ; <nl> started = false ; <nl> + <nl> + if ( monitorExc ! = null ) <nl> + throw monitorExc ; <nl> } <nl> } <nl> <nl> void CleanUp ( ) <nl> <nl> void DoMonitor ( ) <nl> { <nl> - Exception exc = null ; <nl> - failedInit = false ; <nl> + monitorExc = null ; <nl> <nl> try { <nl> Setup ( ) ; <nl> } catch ( Exception e ) { <nl> - failedInit = true ; <nl> - exc = e ; <nl> + monitorExc = e ; <nl> } finally { <nl> startedEvent . Set ( ) ; <nl> } <nl> <nl> - if ( failedInit ) { <nl> - fsw . OnError ( new ErrorEventArgs ( exc ) ) ; <nl> + if ( monitorExc ! = null ) <nl> return ; <nl> - } <nl> <nl> try { <nl> Monitor ( ) ; <nl> } catch ( Exception e ) { <nl> - exc = e ; <nl> + monitorExc = e ; <nl> } finally { <nl> if ( ! requestStop ) { / / failure <nl> CleanUp ( ) ; <nl> started = false ; <nl> + if ( monitorExc ! = null ) <nl> + throw monitorExc ; <nl> } <nl> - if ( exc ! = null ) <nl> - fsw . OnError ( new ErrorEventArgs ( exc ) ) ; <nl> + <nl> } <nl> } <nl> <nl> void Setup ( ) <nl> { <nl> var initialFds = new List < int > ( ) ; <nl> <nl> + / / fsw . FullPath may end in ' / ' , see https : / / bugzilla . xamarin . com / show_bug . cgi ? id = 5747 <nl> + if ( fsw . FullPath . EndsWith ( \" / \" , StringComparison . Ordinal ) ) <nl> + fullPathNoLastSlash = fsw . FullPath . Substring ( 0 , fsw . FullPath . Length - 1 ) ; <nl> + else <nl> + fullPathNoLastSlash = fsw . FullPath ; <nl> + <nl> / / GetFilenameFromFd ( ) returns the * realpath * which can be different than fsw . FullPath because symlinks . <nl> / / If so , introduce a fixup step . <nl> - int fd = open ( fsw . FullPath , O_EVTONLY , 0 ) ; <nl> + int fd = open ( fullPathNoLastSlash , O_EVTONLY , 0 ) ; <nl> var resolvedFullPath = GetFilenameFromFd ( fd ) ; <nl> close ( fd ) ; <nl> <nl> - if ( resolvedFullPath ! = fsw . FullPath ) <nl> + if ( resolvedFullPath ! = fullPathNoLastSlash ) <nl> fixupPath = resolvedFullPath ; <nl> else <nl> fixupPath = null ; <nl> <nl> - Scan ( fsw . FullPath , false , ref initialFds ) ; <nl> + Scan ( fullPathNoLastSlash , false , ref initialFds ) ; <nl> <nl> var immediate_timeout = new timespec { tv_sec = ( IntPtr ) 0 , tv_usec = ( IntPtr ) 0 } ; <nl> var eventBuffer = new kevent [ 0 ] ; / / we don ' t want to take any events from the queue at this point <nl> void Monitor ( ) <nl> List < PathData > removeQueue = new List < PathData > ( ) ; <nl> List < string > rescanQueue = new List < string > ( ) ; <nl> <nl> + int retries = 0 ; <nl> + <nl> while ( ! requestStop ) { <nl> var changes = CreateChangeList ( ref newFds ) ; <nl> <nl> int numEvents = kevent ( conn , changes , changes . Length , eventBuffer , eventBuffer . Length , ref timeout ) ; <nl> <nl> if ( numEvents = = - 1 ) { <nl> - var errMsg = String . Format ( \" kevent ( ) error , error code = ' { 0 } ' \" , Marshal . GetLastWin32Error ( ) ) ; <nl> - fsw . OnError ( new ErrorEventArgs ( new IOException ( errMsg ) ) ) ; <nl> - } <nl> + if ( + + retries = = 3 ) <nl> + throw new IOException ( String . Format ( <nl> + \" persistent kevent ( ) error , error code = ' { 0 } ' \" , Marshal . GetLastWin32Error ( ) ) ) ; <nl> <nl> - if ( numEvents = = 0 ) <nl> continue ; <nl> + } <nl> + <nl> + retries = 0 ; <nl> <nl> for ( var i = 0 ; i < numEvents ; i + + ) { <nl> var kevt = eventBuffer [ i ] ; <nl> void Monitor ( ) <nl> fsw . OnError ( new ErrorEventArgs ( new IOException ( errMsg ) ) ) ; <nl> continue ; <nl> } <nl> - <nl> - if ( ( kevt . fflags & FilterFlags . VNodeDelete ) = = FilterFlags . VNodeDelete | | ( kevt . fflags & FilterFlags . VNodeRevoke ) = = FilterFlags . VNodeRevoke ) <nl> + <nl> + if ( ( kevt . fflags & FilterFlags . VNodeDelete ) = = FilterFlags . VNodeDelete | | ( kevt . fflags & FilterFlags . VNodeRevoke ) = = FilterFlags . VNodeRevoke ) { <nl> removeQueue . Add ( pathData ) ; <nl> + continue ; <nl> + } <nl> <nl> - else if ( ( kevt . fflags & FilterFlags . VNodeWrite ) = = FilterFlags . VNodeWrite ) { <nl> - if ( pathData . IsDirectory ) <nl> + if ( ( kevt . fflags & FilterFlags . VNodeRename ) = = FilterFlags . VNodeRename ) { <nl> + UpdatePath ( pathData ) ; <nl> + } <nl> + <nl> + if ( ( kevt . fflags & FilterFlags . VNodeWrite ) = = FilterFlags . VNodeWrite ) { <nl> + if ( pathData . IsDirectory ) / / TODO : Check if dirs trigger Changed events on . NET <nl> rescanQueue . Add ( pathData . Path ) ; <nl> else <nl> PostEvent ( FileAction . Modified , pathData . Path ) ; <nl> - } <nl> - <nl> - else if ( ( kevt . fflags & FilterFlags . VNodeRename ) = = FilterFlags . VNodeRename ) { <nl> - var newFilename = GetFilenameFromFd ( pathData . Fd ) ; <nl> - <nl> - if ( newFilename . StartsWith ( fsw . FullPath ) ) <nl> - Rename ( pathData , newFilename ) ; <nl> - else / / moved outside of our watched dir so stop watching <nl> - RemoveTree ( pathData ) ; <nl> - } <nl> - <nl> - else if ( ( kevt . fflags & FilterFlags . VNodeAttrib ) = = FilterFlags . VNodeAttrib | | ( kevt . fflags & FilterFlags . VNodeExtend ) = = FilterFlags . VNodeExtend ) <nl> + } <nl> + <nl> + if ( ( kevt . fflags & FilterFlags . VNodeAttrib ) = = FilterFlags . VNodeAttrib | | ( kevt . fflags & FilterFlags . VNodeExtend ) = = FilterFlags . VNodeExtend ) <nl> PostEvent ( FileAction . Modified , pathData . Path ) ; <nl> } <nl> <nl> PathData Add ( string path , bool postEvents , ref List < int > fds ) <nl> if ( pathData ! = null ) <nl> return pathData ; <nl> <nl> + if ( fdsDict . Count > = maxFds ) <nl> + throw new IOException ( \" kqueue ( ) FileSystemWatcher has reached the maximum nunmber of files to watch . \" ) ; <nl> + <nl> var fd = open ( path , O_EVTONLY , 0 ) ; <nl> <nl> if ( fd = = - 1 ) { <nl> void RemoveTree ( PathData pathData ) <nl> toRemove . ForEach ( Remove ) ; <nl> } <nl> <nl> - void Rename ( PathData pathData , string newRoot ) <nl> + void UpdatePath ( PathData pathData ) <nl> { <nl> + var newRoot = GetFilenameFromFd ( pathData . Fd ) ; <nl> + if ( ! newRoot . StartsWith ( fullPathNoLastSlash ) ) { / / moved outside of our watched path ( so stop observing it ) <nl> + RemoveTree ( pathData ) ; <nl> + return ; <nl> + } <nl> + <nl> var toRename = new List < PathData > ( ) ; <nl> var oldRoot = pathData . Path ; <nl> <nl> toRename . Add ( pathData ) ; <nl> <nl> - if ( pathData . IsDirectory ) { <nl> + if ( pathData . IsDirectory ) { / / anything under the directory must have their paths updated <nl> var prefix = oldRoot + Path . DirectorySeparatorChar ; <nl> foreach ( var path in pathsDict . Keys ) <nl> if ( path . StartsWith ( prefix ) ) <nl> toRename . Add ( pathsDict [ path ] ) ; <nl> } <nl> - <nl> - toRename . ForEach ( ( pd ) = > { <nl> - var oldPath = pd . Path ; <nl> + <nl> + foreach ( var renaming in toRename ) { <nl> + var oldPath = renaming . Path ; <nl> var newPath = newRoot + oldPath . Substring ( oldRoot . Length ) ; <nl> - pd . Path = newPath ; <nl> + <nl> + renaming . Path = newPath ; <nl> pathsDict . Remove ( oldPath ) ; <nl> - pathsDict . Add ( newPath , pd ) ; <nl> - } ) ; <nl> <nl> + / / destination may exist in our records from a Created event , take care of it <nl> + if ( pathsDict . ContainsKey ( newPath ) ) { <nl> + var conflict = pathsDict [ newPath ] ; <nl> + if ( GetFilenameFromFd ( renaming . Fd ) = = GetFilenameFromFd ( conflict . Fd ) ) <nl> + Remove ( conflict ) ; <nl> + else <nl> + UpdatePath ( conflict ) ; <nl> + } <nl> + <nl> + pathsDict . Add ( newPath , renaming ) ; <nl> + } <nl> + <nl> PostEvent ( FileAction . RenamedNewName , oldRoot , newRoot ) ; <nl> } <nl> <nl> void PostEvent ( FileAction action , string path , string newPath = null ) <nl> if ( action = = 0 ) <nl> return ; <nl> <nl> + / / e . Name <nl> + string name = path . Substring ( fullPathNoLastSlash . Length + 1 ) ; <nl> + <nl> / / only post events that match filter pattern . check both old and new paths for renames <nl> - if ( ! fsw . Pattern . IsMatch ( path ) & & ( newPath = = null | | ! fsw . Pattern . IsMatch ( newPath ) ) ) <nl> + if ( ! fsw . Pattern . IsMatch ( path ) & & ( newPath = = null | | ! fsw . Pattern . IsMatch ( newPath ) ) ) <nl> return ; <nl> <nl> - if ( action = = FileAction . RenamedNewName ) <nl> - renamed = new RenamedEventArgs ( WatcherChangeTypes . Renamed , \" \" , newPath , path ) ; <nl> + if ( action = = FileAction . RenamedNewName ) { <nl> + string newName = newPath . Substring ( fullPathNoLastSlash . Length + 1 ) ; <nl> + renamed = new RenamedEventArgs ( WatcherChangeTypes . Renamed , fsw . Path , newName , name ) ; <nl> + } <nl> <nl> lock ( fsw ) { <nl> - fsw . DispatchEvents ( action , path , ref renamed ) ; <nl> + fsw . DispatchEvents ( action , name , ref renamed ) ; <nl> <nl> if ( fsw . Waiting ) { <nl> fsw . Waiting = false ; <nl> private string GetFilenameFromFd ( int fd ) <nl> var sb = new StringBuilder ( __DARWIN_MAXPATHLEN ) ; <nl> <nl> if ( fcntl ( fd , F_GETPATH , sb ) ! = - 1 ) { <nl> - if ( fixupPath ! = null ) <nl> - sb . Replace ( fixupPath , fsw . FullPath , 0 , fixupPath . Length ) ; / / see Setup ( ) <nl> + if ( fixupPath ! = null ) <nl> + sb . Replace ( fixupPath , fullPathNoLastSlash , 0 , fixupPath . Length ) ; / / see Setup ( ) <nl> + <nl> return sb . ToString ( ) ; <nl> } else { <nl> fsw . OnError ( new ErrorEventArgs ( new IOException ( String . Format ( <nl> private string GetFilenameFromFd ( int fd ) <nl> const int F_GETPATH = 50 ; <nl> const int __DARWIN_MAXPATHLEN = 1024 ; <nl> static readonly kevent [ ] emptyEventList = new System . IO . kevent [ 0 ] ; <nl> + const int maxFds = 200 ; <nl> <nl> FileSystemWatcher fsw ; <nl> int conn ; <nl> private string GetFilenameFromFd ( int fd ) <nl> volatile bool requestStop = false ; <nl> AutoResetEvent startedEvent = new AutoResetEvent ( false ) ; <nl> bool started = false ; <nl> - bool failedInit = false ; <nl> + Exception monitorExc ; <nl> object stateLock = new object ( ) ; <nl> <nl> readonly Dictionary < string , PathData > pathsDict = new Dictionary < string , PathData > ( ) ; <nl> readonly Dictionary < int , PathData > fdsDict = new Dictionary < int , PathData > ( ) ; <nl> string fixupPath = null ; <nl> + string fullPathNoLastSlash = null ; <nl> <nl> [ DllImport ( \" libc \" , EntryPoint = \" fcntl \" , CharSet = CharSet . Auto , SetLastError = true ) ] <nl> static extern int fcntl ( int file_names_by_descriptor , int cmd , StringBuilder sb ) ; <nl>\n", "msg": "[ System . IO . KeventWatcher ] More fixes and MS behavior matching for the new implementation .\n", "score": 1}
{"diff_id": 17934, "repo": "dotnet/runtime\n", "sha": "432b2f1e82a4c46a7e66d75d8c1da5e6f8e67879\n", "time": "2017-02-16T22:09:38Z\n", "diff": "mmm a / src / mono / mono / mini / generics - interp . cs <nl> ppp b / src / mono / mono / mini / generics - interp . cs <nl> struct TestStruct { <nl> } <nl> # endif <nl> <nl> - public static int test_1_no_nullable_unbox ( ) <nl> + public static int test_1_nullable_unbox ( ) <nl> { <nl> - return Unbox < int > ( 1 ) ; <nl> + return Unbox < int ? > ( 1 ) . Value ; <nl> } <nl> <nl> public static int test_1_nullable_unbox_null ( ) <nl> public static int test_1_nullable_unbox_vtype ( ) <nl> return Unbox < TestStruct ? > ( new TestStruct ( 1 , 2 ) ) . Value . i ; <nl> } <nl> <nl> - <nl> public static int test_1_nullable_unbox_null_vtype ( ) <nl> { <nl> return Unbox < TestStruct ? > ( null ) . HasValue ? 0 : 1 ; <nl> public static int test_0_nullable_normal_unbox ( ) <nl> return newarr_multi < string > ( ) . GetType ( ) = = typeof ( string [ , ] ) ? 0 : 1 ; <nl> } <nl> <nl> + interface ITest <nl> + { <nl> + void Foo < T > ( ) ; <nl> + } <nl> + <nl> + public static int test_0_iface_call_null_bug_77442 ( ) { <nl> + ITest test = null ; <nl> + <nl> + try { <nl> + test . Foo < int > ( ) ; <nl> + } <nl> + catch ( NullReferenceException ) { <nl> + return 0 ; <nl> + } <nl> + <nl> + return 1 ; <nl> + } <nl> + <nl> + public static int test_18_ldobj_stobj_generics ( ) { <nl> + GenericClass < int > t = new GenericClass < int > ( ) ; <nl> + int i = 5 ; <nl> + int j = 6 ; <nl> + return t . ldobj_stobj ( ref i , ref j ) + i + j ; <nl> + } <nl> + <nl> + public static int test_5_ldelem_stelem_generics ( ) { <nl> + GenericClass < TestStruct > t = new GenericClass < TestStruct > ( ) ; <nl> + <nl> + TestStruct s = new TestStruct ( 5 , 5 ) ; <nl> + return t . ldelem_stelem ( s ) . i ; <nl> + } <nl> + <nl> + public static int test_0_constrained_vtype_box ( ) { <nl> + GenericClass < TestStruct > t = new GenericClass < TestStruct > ( ) ; <nl> + <nl> + # if __MOBILE__ <nl> + return t . toString ( new TestStruct ( ) ) = = \" GenericsTests + TestStruct \" ? 0 : 1 ; <nl> + # else <nl> + return t . toString ( new TestStruct ( ) ) = = \" Tests + TestStruct \" ? 0 : 1 ; <nl> + # endif <nl> + } <nl> + <nl> + public static int test_0_constrained_vtype ( ) { <nl> + GenericClass < int > t = new GenericClass < int > ( ) ; <nl> + <nl> + return t . toString ( 1234 ) = = \" 1234 \" ? 0 : 1 ; <nl> + } <nl> + <nl> + public static int test_0_constrained_reftype ( ) { <nl> + GenericClass < String > t = new GenericClass < String > ( ) ; <nl> + <nl> + return t . toString ( \" 1234 \" ) = = \" 1234 \" ? 0 : 1 ; <nl> + } <nl> + <nl> + public static int test_0_box_brtrue_optimizations ( ) { <nl> + if ( IsNull < int > ( 5 ) ) <nl> + return 1 ; <nl> + <nl> + if ( ! IsNull < object > ( null ) ) <nl> + return 1 ; <nl> + <nl> + return 0 ; <nl> + } <nl> + <nl> + [ Category ( \" ! FULLAOT \" ) ] <nl> + public static int test_0_generic_get_value_optimization_int ( ) { <nl> + int [ ] x = new int [ ] { 100 , 200 } ; <nl> + <nl> + if ( GenericClass < int > . Z ( x , 0 ) ! = 100 ) <nl> + return 2 ; <nl> + <nl> + if ( GenericClass < int > . Z ( x , 1 ) ! = 200 ) <nl> + return 3 ; <nl> + <nl> + return 0 ; <nl> + } <nl> + <nl> + public static int test_0_nullable_ldflda ( ) { <nl> + return GenericClass < string > . BIsAClazz = = false ? 0 : 1 ; <nl> + } <nl> + <nl> + public struct GenericStruct < T > { <nl> + public T t ; <nl> + <nl> + public GenericStruct ( T t ) { <nl> + this . t = t ; <nl> + } <nl> + } <nl> + <nl> + public class GenericClass < T > { <nl> + public T t ; <nl> + <nl> + public GenericClass ( T t ) { <nl> + this . t = t ; <nl> + } <nl> + <nl> + public GenericClass ( ) { <nl> + } <nl> + <nl> + public T ldobj_stobj ( ref T t1 , ref T t2 ) { <nl> + t1 = t2 ; <nl> + T t = t1 ; <nl> + <nl> + return t ; <nl> + } <nl> + <nl> + public T ldelem_stelem ( T t ) { <nl> + T [ ] arr = new T [ 10 ] ; <nl> + arr [ 0 ] = t ; <nl> + <nl> + return arr [ 0 ] ; <nl> + } <nl> + <nl> + public String toString ( T t ) { <nl> + return t . ToString ( ) ; <nl> + } <nl> + <nl> + public static IEnumerator < T > Y ( IEnumerable < T > x ) <nl> + { <nl> + return x . GetEnumerator ( ) ; <nl> + } <nl> + <nl> + public static T Z ( IList < T > x , int index ) <nl> + { <nl> + return x [ index ] ; <nl> + } <nl> + <nl> + protected static T NullB = default ( T ) ; <nl> + private static Nullable < bool > _BIsA = null ; <nl> + public static bool BIsAClazz { <nl> + get { <nl> + _BIsA = false ; <nl> + return _BIsA . Value ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + static bool IsNull < T > ( T t ) <nl> + { <nl> + if ( t = = null ) <nl> + return true ; <nl> + else <nl> + return false ; <nl> + } <nl> + <nl> static object Box < T > ( T t ) <nl> { <nl> return t ; <nl> static object Box < T > ( T t ) <nl> static T Unbox < T > ( object o ) { <nl> return ( T ) o ; <nl> } <nl> + <nl> + [ MethodImplAttribute ( MethodImplOptions . NoInlining ) ] <nl> + public static bool constrained_equals < T > ( T t1 , T t2 ) { <nl> + var c = EqualityComparer < T > . Default ; <nl> + <nl> + return c . Equals ( t1 , t2 ) ; <nl> + } <nl> + <nl> + [ MethodImplAttribute ( MethodImplOptions . NoInlining ) ] <nl> + public static int constrained_gethashcode < T > ( T t ) { <nl> + return t . GetHashCode ( ) ; <nl> + } <nl> + <nl> + enum AnEnum { <nl> + A , <nl> + B <nl> + } <nl> + <nl> + public static int test_0_constrained_partial_sharing ( ) { <nl> + if ( ! constrained_equals < int > ( 1 , 1 ) ) <nl> + return 3 ; <nl> + if ( constrained_equals < int > ( 1 , 2 ) ) <nl> + return 4 ; <nl> + if ( ! constrained_equals < AnEnum > ( AnEnum . A , AnEnum . A ) ) <nl> + return 5 ; <nl> + if ( constrained_equals < AnEnum > ( AnEnum . A , AnEnum . B ) ) <nl> + return 6 ; <nl> + <nl> + int i = constrained_gethashcode < int > ( 5 ) ; <nl> + if ( i ! = 5 ) <nl> + return 7 ; <nl> + i = constrained_gethashcode < AnEnum > ( AnEnum . B ) ; <nl> + if ( i ! = 1 ) <nl> + return 8 ; <nl> + return 0 ; <nl> + } <nl> } <nl>\n", "msg": "[ interpreter ] add more regression tests to generics - interp . cs\n", "score": 1}
{"diff_id": 19133, "repo": "hbons/SparkleShare\n", "sha": "871c8d13247c3d2f2d624213d36cbd5d0163be6e\n", "time": "2010-09-08T13:23:25Z\n", "diff": "mmm a / SparkleLib / SparkleRepo . cs <nl> ppp b / SparkleLib / SparkleRepo . cs <nl> public string GetRemoteOriginUrl ( ) <nl> process . StartInfo . RedirectStandardOutput = true ; <nl> process . StartInfo . UseShellExecute = false ; <nl> process . StartInfo . WorkingDirectory = LocalPath ; <nl> + <nl> + / / Get the user ' s timezone <nl> + process . StartInfo . FileName = \" date \" ; <nl> + process . StartInfo . Arguments = \" + % z \" ; <nl> + <nl> + <nl> + process . Start ( ) ; <nl> + process . WaitForExit ( ) ; <nl> + <nl> + string timezone = process . StandardOutput . ReadToEnd ( ) . Trim ( ) ; <nl> + int unix_timestamp = 0 ; <nl> + <nl> + / / Add the timezone difference in hours when in a positive timezone <nl> + if ( timezone . StartsWith ( \" + \" ) ) <nl> + unix_timestamp = 3600 * System . Convert . ToInt32 ( timezone . Substring ( 1 , 2 ) ) ; <nl> + <nl> + / / Remove the timezone difference in hours when in a negative timezone <nl> + if ( timezone . StartsWith ( \" - \" ) ) <nl> + unix_timestamp = - 3600 * System . Convert . ToInt32 ( timezone . Substring ( 1 , 2 ) ) ; <nl> + <nl> process . StartInfo . FileName = \" git \" ; <nl> process . StartInfo . Arguments = \" log - - format = \\ \" % at \\ t % an \\ t % ae \\ t % H \\ t % ad \\ \" - \" + count ; <nl> <nl> public string GetRemoteOriginUrl ( ) <nl> <nl> string [ ] parts = Regex . Split ( line , \" \\ t \" ) ; <nl> <nl> - int unix_timestamp = int . Parse ( parts [ 0 ] ) ; <nl> + unix_timestamp + = int . Parse ( parts [ 0 ] ) ; <nl> + <nl> string user_name = parts [ 1 ] ; <nl> string user_email = parts [ 2 ] ; <nl> string hash = parts [ 3 ] ; <nl> - string timezone = parts [ 4 ] . Substring ( parts [ 4 ] . Length - 5 ) ; <nl> - <nl> - / / Add the timezone difference in hours when in a positive timezone <nl> - if ( timezone . StartsWith ( \" + \" ) ) <nl> - unix_timestamp + = 3600 * System . Convert . ToInt32 ( timezone . Substring ( 1 , 2 ) ) ; <nl> - <nl> - / / Remove the timezone difference in hours when in a negative timezone <nl> - if ( timezone . StartsWith ( \" - \" ) ) <nl> - unix_timestamp - = 3600 * System . Convert . ToInt32 ( timezone . Substring ( 1 , 2 ) ) ; <nl> <nl> DateTime date_time = SparkleHelpers . UnixTimestampToDateTime ( unix_timestamp ) ; <nl> <nl>\n", "msg": "[ repo ] adjust previous commit to use the user ' s timezone instead of the tz of the commiter\n", "score": 1}
{"diff_id": 19236, "repo": "JustArchiNET/ArchiSteamFarm\n", "sha": "4915baa7cf2193462d08ac7b9781c5a6432ee7e0\n", "time": "2018-05-20T12:42:48Z\n", "diff": "mmm a / ArchiSteamFarm / ArchiWebHandler . cs <nl> ppp b / ArchiSteamFarm / ArchiWebHandler . cs <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> <nl> internal async Task < bool > ChangePrivacySettings ( Steam . UserPrivacy userPrivacy ) { <nl> - string request = GetAbsoluteProfileURL ( ) + \" / ajaxsetprivacy \" ; <nl> + if ( userPrivacy = = null ) { <nl> + Bot . ArchiLogger . LogNullError ( nameof ( userPrivacy ) ) ; <nl> + return false ; <nl> + } <nl> + <nl> + string profileURL = await GetAbsoluteProfileURL ( ) . ConfigureAwait ( false ) ; <nl> + if ( string . IsNullOrEmpty ( profileURL ) ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + return false ; <nl> + } <nl> + <nl> + string request = profileURL + \" / ajaxsetprivacy \" ; <nl> <nl> / / Extra entry for sessionID <nl> Dictionary < string , string > data = new Dictionary < string , string > ( 3 ) { <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> return false ; <nl> } <nl> <nl> - string request = GetAbsoluteProfileURL ( ) + \" / ajaxunpackbooster \" ; <nl> + string profileURL = await GetAbsoluteProfileURL ( ) . ConfigureAwait ( false ) ; <nl> + if ( string . IsNullOrEmpty ( profileURL ) ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + return false ; <nl> + } <nl> + <nl> + string request = profileURL + \" / ajaxunpackbooster \" ; <nl> <nl> / / Extra entry for sessionID <nl> Dictionary < string , string > data = new Dictionary < string , string > ( 3 ) { <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> return response ? . Result = = EResult . OK ; <nl> } <nl> <nl> - private string GetAbsoluteProfileURL ( ) = > ! string . IsNullOrEmpty ( VanityURL ) ? \" / id / \" + VanityURL : \" / profiles / \" + SteamID ; <nl> + private async Task < string > GetAbsoluteProfileURL ( ) { <nl> + if ( SteamID = = 0 ) { <nl> + for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> + await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + if ( SteamID = = 0 ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> + return string . IsNullOrEmpty ( VanityURL ) ? \" / profiles / \" + SteamID : \" / id / \" + VanityURL ; <nl> + } <nl> <nl> private async Task < string > GetApiKey ( ) { <nl> if ( CachedApiKey ! = null ) { <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> } <nl> <nl> - private bool IsProfileUri ( Uri uri ) { <nl> + private async Task < bool > IsProfileUri ( Uri uri ) { <nl> if ( uri = = null ) { <nl> ASF . ArchiLogger . LogNullError ( nameof ( uri ) ) ; <nl> return false ; <nl> } <nl> <nl> - return uri . AbsolutePath . Equals ( GetAbsoluteProfileURL ( ) ) ; <nl> + string profileURL = await GetAbsoluteProfileURL ( ) . ConfigureAwait ( false ) ; <nl> + if ( string . IsNullOrEmpty ( profileURL ) ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + return false ; <nl> + } <nl> + <nl> + return uri . AbsolutePath . Equals ( profileURL ) ; <nl> } <nl> <nl> private static bool IsSessionExpiredUri ( Uri uri ) { <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> <nl> / / Under special brain - damaged circumstances , Steam might just return our own profile as a response to the request , for absolutely no reason whatsoever - just try again in this case <nl> - if ( IsProfileUri ( response . FinalUri ) ) { <nl> + if ( await IsProfileUri ( response . FinalUri ) . ConfigureAwait ( false ) ) { <nl> Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . WarningWorkaroundTriggered , nameof ( IsProfileUri ) ) ) ; <nl> return await UnlockParentalAccountForService ( serviceURL , parentalPin , - - maxTries ) . ConfigureAwait ( false ) ; <nl> } <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> await SessionSemaphore . WaitAsync ( ) . ConfigureAwait ( false ) ; <nl> SessionSemaphore . Release ( ) ; <nl> <nl> - for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> - await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> - } <nl> - <nl> if ( SteamID = = 0 ) { <nl> - Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> - Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> - return null ; <nl> + for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> + await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + if ( SteamID = = 0 ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> + return null ; <nl> + } <nl> } <nl> <nl> WebBrowser . HtmlDocumentResponse response = await WebLimitRequest ( host , async ( ) = > await WebBrowser . UrlGetToHtmlDocument ( host + request ) . ConfigureAwait ( false ) ) . ConfigureAwait ( false ) ; <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> <nl> / / Under special brain - damaged circumstances , Steam might just return our own profile as a response to the request , for absolutely no reason whatsoever - just try again in this case <nl> - if ( IsProfileUri ( response . FinalUri ) ) { <nl> + if ( await IsProfileUri ( response . FinalUri ) . ConfigureAwait ( false ) ) { <nl> Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . WarningWorkaroundTriggered , nameof ( IsProfileUri ) ) ) ; <nl> return await UrlGetToHtmlDocumentWithSession ( host , request , - - maxTries ) . ConfigureAwait ( false ) ; <nl> } <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> await SessionSemaphore . WaitAsync ( ) . ConfigureAwait ( false ) ; <nl> SessionSemaphore . Release ( ) ; <nl> <nl> - for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> - await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> - } <nl> - <nl> if ( SteamID = = 0 ) { <nl> - Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> - Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> - return default ; <nl> + for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> + await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + if ( SteamID = = 0 ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> + return default ; <nl> + } <nl> } <nl> <nl> WebBrowser . ObjectResponse < T > response = await WebLimitRequest ( host , async ( ) = > await WebBrowser . UrlGetToJsonObject < T > ( host + request ) . ConfigureAwait ( false ) ) . ConfigureAwait ( false ) ; <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> <nl> / / Under special brain - damaged circumstances , Steam might just return our own profile as a response to the request , for absolutely no reason whatsoever - just try again in this case <nl> - if ( IsProfileUri ( response . FinalUri ) ) { <nl> + if ( await IsProfileUri ( response . FinalUri ) . ConfigureAwait ( false ) ) { <nl> Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . WarningWorkaroundTriggered , nameof ( IsProfileUri ) ) ) ; <nl> return await UrlGetToJsonObjectWithSession < T > ( host , request , - - maxTries ) . ConfigureAwait ( false ) ; <nl> } <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> await SessionSemaphore . WaitAsync ( ) . ConfigureAwait ( false ) ; <nl> SessionSemaphore . Release ( ) ; <nl> <nl> - for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> - await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> - } <nl> - <nl> if ( SteamID = = 0 ) { <nl> - Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> - Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> - return null ; <nl> + for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> + await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + if ( SteamID = = 0 ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> + return null ; <nl> + } <nl> } <nl> <nl> WebBrowser . XmlDocumentResponse response = await WebLimitRequest ( host , async ( ) = > await WebBrowser . UrlGetToXmlDocument ( host + request ) . ConfigureAwait ( false ) ) . ConfigureAwait ( false ) ; <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> <nl> / / Under special brain - damaged circumstances , Steam might just return our own profile as a response to the request , for absolutely no reason whatsoever - just try again in this case <nl> - if ( IsProfileUri ( response . FinalUri ) ) { <nl> + if ( await IsProfileUri ( response . FinalUri ) . ConfigureAwait ( false ) ) { <nl> Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . WarningWorkaroundTriggered , nameof ( IsProfileUri ) ) ) ; <nl> return await UrlGetToXmlDocumentWithSession ( host , request , - - maxTries ) . ConfigureAwait ( false ) ; <nl> } <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> await SessionSemaphore . WaitAsync ( ) . ConfigureAwait ( false ) ; <nl> SessionSemaphore . Release ( ) ; <nl> <nl> - for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> - await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> - } <nl> - <nl> if ( SteamID = = 0 ) { <nl> - Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> - Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> - return false ; <nl> + for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> + await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + if ( SteamID = = 0 ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> + return false ; <nl> + } <nl> } <nl> <nl> WebBrowser . BasicResponse response = await WebLimitRequest ( host , async ( ) = > await WebBrowser . UrlHead ( host + request ) . ConfigureAwait ( false ) ) . ConfigureAwait ( false ) ; <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> <nl> / / Under special brain - damaged circumstances , Steam might just return our own profile as a response to the request , for absolutely no reason whatsoever - just try again in this case <nl> - if ( IsProfileUri ( response . FinalUri ) ) { <nl> + if ( await IsProfileUri ( response . FinalUri ) . ConfigureAwait ( false ) ) { <nl> Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . WarningWorkaroundTriggered , nameof ( IsProfileUri ) ) ) ; <nl> return await UrlHeadWithSession ( host , request , - - maxTries ) . ConfigureAwait ( false ) ; <nl> } <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> await SessionSemaphore . WaitAsync ( ) . ConfigureAwait ( false ) ; <nl> SessionSemaphore . Release ( ) ; <nl> <nl> - for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> - await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> - } <nl> - <nl> if ( SteamID = = 0 ) { <nl> - Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> - Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> - return null ; <nl> + for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> + await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + if ( SteamID = = 0 ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> + return null ; <nl> + } <nl> } <nl> <nl> if ( session ! = ESession . None ) { <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> <nl> / / Under special brain - damaged circumstances , Steam might just return our own profile as a response to the request , for absolutely no reason whatsoever - just try again in this case <nl> - if ( IsProfileUri ( response . FinalUri ) ) { <nl> + if ( await IsProfileUri ( response . FinalUri ) . ConfigureAwait ( false ) ) { <nl> Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . WarningWorkaroundTriggered , nameof ( IsProfileUri ) ) ) ; <nl> return await UrlPostToHtmlDocumentWithSession ( host , request , data , referer , session , - - maxTries ) . ConfigureAwait ( false ) ; <nl> } <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> await SessionSemaphore . WaitAsync ( ) . ConfigureAwait ( false ) ; <nl> SessionSemaphore . Release ( ) ; <nl> <nl> - for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> - await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> - } <nl> - <nl> if ( SteamID = = 0 ) { <nl> - Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> - Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> - return null ; <nl> + for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> + await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + if ( SteamID = = 0 ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> + return null ; <nl> + } <nl> } <nl> <nl> if ( session ! = ESession . None ) { <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> <nl> / / Under special brain - damaged circumstances , Steam might just return our own profile as a response to the request , for absolutely no reason whatsoever - just try again in this case <nl> - if ( IsProfileUri ( response . FinalUri ) ) { <nl> + if ( await IsProfileUri ( response . FinalUri ) . ConfigureAwait ( false ) ) { <nl> Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . WarningWorkaroundTriggered , nameof ( IsProfileUri ) ) ) ; <nl> return await UrlPostToJsonObjectWithSession < T > ( host , request , data , referer , session , - - maxTries ) . ConfigureAwait ( false ) ; <nl> } <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> await SessionSemaphore . WaitAsync ( ) . ConfigureAwait ( false ) ; <nl> SessionSemaphore . Release ( ) ; <nl> <nl> - for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> - await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> - } <nl> - <nl> if ( SteamID = = 0 ) { <nl> - Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> - Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> - return null ; <nl> + for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> + await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + if ( SteamID = = 0 ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> + return null ; <nl> + } <nl> } <nl> <nl> if ( session ! = ESession . None ) { <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> <nl> / / Under special brain - damaged circumstances , Steam might just return our own profile as a response to the request , for absolutely no reason whatsoever - just try again in this case <nl> - if ( IsProfileUri ( response . FinalUri ) ) { <nl> + if ( await IsProfileUri ( response . FinalUri ) . ConfigureAwait ( false ) ) { <nl> Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . WarningWorkaroundTriggered , nameof ( IsProfileUri ) ) ) ; <nl> return await UrlPostToJsonObjectWithSession < T > ( host , request , data , referer , session , - - maxTries ) . ConfigureAwait ( false ) ; <nl> } <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> await SessionSemaphore . WaitAsync ( ) . ConfigureAwait ( false ) ; <nl> SessionSemaphore . Release ( ) ; <nl> <nl> - for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> - await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> - } <nl> - <nl> if ( SteamID = = 0 ) { <nl> - Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> - Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> - return false ; <nl> + for ( byte i = 0 ; ( i < Program . GlobalConfig . ConnectionTimeout ) & & ( SteamID = = 0 ) & & Bot . IsConnectedAndLoggedOn ; i + + ) { <nl> + await Task . Delay ( 1000 ) . ConfigureAwait ( false ) ; <nl> + } <nl> + <nl> + if ( SteamID = = 0 ) { <nl> + Bot . ArchiLogger . LogGenericWarning ( Strings . WarningFailed ) ; <nl> + Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . ErrorFailingRequest , host + request ) ) ; <nl> + return false ; <nl> + } <nl> } <nl> <nl> if ( session ! = ESession . None ) { <nl> internal sealed class ArchiWebHandler : IDisposable { <nl> } <nl> <nl> / / Under special brain - damaged circumstances , Steam might just return our own profile as a response to the request , for absolutely no reason whatsoever - just try again in this case <nl> - if ( IsProfileUri ( response . FinalUri ) ) { <nl> + if ( await IsProfileUri ( response . FinalUri ) . ConfigureAwait ( false ) ) { <nl> Bot . ArchiLogger . LogGenericDebug ( string . Format ( Strings . WarningWorkaroundTriggered , nameof ( IsProfileUri ) ) ) ; <nl> return await UrlPostWithSession ( host , request , data , referer , session , - - maxTries ) . ConfigureAwait ( false ) ; <nl> } <nl>\n", "msg": "Improve requests utilizing absolute profile URL\n", "score": 1}
{"diff_id": 19754, "repo": "QuantConnect/Lean\n", "sha": "94fbb5053675ddd31ecde65e22e9a6ed2250db30\n", "time": "2016-10-18T17:39:25Z\n", "diff": "mmm a / Engine / DataFeeds / ApiFileProvider . cs <nl> ppp b / Engine / DataFeeds / ApiFileProvider . cs <nl> namespace QuantConnect . Lean . Engine . DataFeeds <nl> / / / < / summary > <nl> public class ApiFileProvider : IFileProvider <nl> { <nl> + private readonly int _uid = Config . GetInt ( \" job - user - id \" , 0 ) ; <nl> + private readonly string _token = Config . Get ( \" api - access - token \" , \" 1 \" ) ; <nl> + private readonly string _dataPath = Config . Get ( \" data - folder \" , \" . . / . . / . . / Data / \" ) ; <nl> public bool Fetch ( Symbol symbol , Resolution resolution , DateTime date ) <nl> { <nl> - var uid = Config . GetInt ( \" job - user - id \" , 0 ) ; <nl> - var token = Config . Get ( \" api - access - token \" , \" 1 \" ) ; <nl> - var dataPath = Config . Get ( \" data - folder \" , \" . . / . . / . . / Data / \" ) ; <nl> - <nl> Log . Trace ( <nl> string . Format ( <nl> \" Attempting to get data from QuantConnect . com ' s data library for symbol ( { 0 } ) , resolution ( { 1 } ) and date ( { 2 } ) . \" , <nl> symbol . ID , resolution , date . Date . ToShortDateString ( ) ) ) ; <nl> <nl> var api = new Api . Api ( ) ; <nl> - api . Initialize ( uid , token , dataPath ) ; <nl> + api . Initialize ( _uid , _token , _dataPath ) ; <nl> <nl> var download = api . DownloadData ( symbol , resolution , date ) ; <nl> <nl>\n", "msg": "Changed uid , pid and dataPath to private readonly variables in ApiFileProvider .\n", "score": 1}
{"diff_id": 20400, "repo": "mono/mono\n", "sha": "2f1a136583c90cae805441e63b94bc4f277bb953\n", "time": "2014-12-11T20:44:54Z\n", "diff": "mmm a / mcs / class / System / System . IO / KeventWatcher . cs <nl> ppp b / mcs / class / System / System . IO / KeventWatcher . cs <nl> public void Start ( ) <nl> <nl> startedEvent . WaitOne ( ) ; <nl> <nl> - if ( monitorExc ! = null ) { <nl> + if ( exc ! = null ) { <nl> thread . Join ( ) ; <nl> CleanUp ( ) ; <nl> - throw monitorExc ; <nl> + throw exc ; <nl> } <nl> - else <nl> - started = true ; <nl> + <nl> + started = true ; <nl> } <nl> } <nl> <nl> public void Stop ( ) <nl> return ; <nl> <nl> requestStop = true ; <nl> - thread . Join ( ) ; <nl> - requestStop = false ; <nl> <nl> - CleanUp ( ) ; <nl> + if ( inDispatch ) <nl> + return ; <nl> + if ( ! thread . Join ( 2000 ) ) <nl> + thread . Abort ( ) ; <nl> + <nl> + requestStop = false ; <nl> started = false ; <nl> <nl> - if ( monitorExc ! = null ) <nl> - throw monitorExc ; <nl> + if ( exc ! = null ) <nl> + throw exc ; <nl> } <nl> } <nl> <nl> void CleanUp ( ) <nl> } <nl> <nl> void DoMonitor ( ) <nl> - { <nl> - monitorExc = null ; <nl> - <nl> + { <nl> try { <nl> Setup ( ) ; <nl> } catch ( Exception e ) { <nl> - monitorExc = e ; <nl> + exc = e ; <nl> } finally { <nl> startedEvent . Set ( ) ; <nl> } <nl> <nl> - if ( monitorExc ! = null ) <nl> + if ( exc ! = null ) { <nl> + fsw . OnError ( new ErrorEventArgs ( exc ) ) ; <nl> return ; <nl> <nl> try { <nl> void DoMonitor ( ) <nl> } catch ( Exception e ) { <nl> monitorExc = e ; <nl> } finally { <nl> + CleanUp ( ) ; <nl> if ( ! requestStop ) { / / failure <nl> - CleanUp ( ) ; <nl> started = false ; <nl> - if ( monitorExc ! = null ) <nl> - throw monitorExc ; <nl> + inDispatch = false ; <nl> + fsw . EnableRaisingEvents = false ; <nl> + throw exc ; <nl> } <nl> - <nl> + if ( exc ! = null ) <nl> + fsw . OnError ( new ErrorEventArgs ( exc ) ) ; <nl> + requestStop = false ; <nl> } <nl> } <nl> <nl> void PostEvent ( FileAction action , string path , string newPath = null ) <nl> { <nl> RenamedEventArgs renamed = null ; <nl> <nl> - if ( action = = 0 ) <nl> + if ( requestStop | | action = = 0 ) <nl> return ; <nl> <nl> / / e . Name <nl> void PostEvent ( FileAction action , string path , string newPath = null ) <nl> renamed = new RenamedEventArgs ( WatcherChangeTypes . Renamed , fsw . Path , newName , name ) ; <nl> } <nl> <nl> - lock ( fsw ) { <nl> - fsw . DispatchEvents ( action , name , ref renamed ) ; <nl> + inDispatch = true ; <nl> + fsw . DispatchEvents ( action , path , ref renamed ) ; <nl> + inDispatch = false ; <nl> <nl> - if ( fsw . Waiting ) { <nl> + if ( fsw . Waiting ) { <nl> + lock ( fsw ) { <nl> fsw . Waiting = false ; <nl> System . Threading . Monitor . PulseAll ( fsw ) ; <nl> } <nl> private string GetFilenameFromFd ( int fd ) <nl> volatile bool requestStop = false ; <nl> AutoResetEvent startedEvent = new AutoResetEvent ( false ) ; <nl> bool started = false ; <nl> - Exception monitorExc ; <nl> + bool inDispatch = false ; <nl> + Exception exc = null ; <nl> object stateLock = new object ( ) ; <nl> <nl> readonly Dictionary < string , PathData > pathsDict = new Dictionary < string , PathData > ( ) ; <nl>\n", "msg": "[ System . IO . KeventWatcher ] Fixed deadlock when watcher stopped / disposed from its own event handler .\n", "score": 1}
{"diff_id": 20966, "repo": "mono/mono\n", "sha": "ad51ba75f5125f387b340a4bb3c2af3875e1fd96\n", "time": "2002-11-29T02:12:02Z\n", "diff": "mmm a / mcs / class / corlib / System . Runtime . Remoting / ObjectHandle . cs <nl> ppp b / mcs / class / corlib / System . Runtime . Remoting / ObjectHandle . cs <nl> <nl> / / Authors : <nl> / / Dietmar Maurer ( dietmar @ ximian . com ) <nl> / / Gonzalo Paniagua ( gonzalo @ ximian . com ) <nl> + / / Jaime Anguiano Olarra ( jaime @ gnome . org ) <nl> / / <nl> / / ( C ) Ximian , Inc . http : / / www . ximian . com <nl> / / <nl> public ObjectHandle ( object o ) <nl> [ MonoTODO ] <nl> public override object InitializeLifetimeService ( ) <nl> { <nl> - life_ctrl = new object ( ) ; <nl> + life_ctrl = base . InitializeLifetimeService ( ) ; <nl> ILease ilife_ctrl = life_ctrl as ILease ; <nl> <nl> if ( ilife_ctrl ! = null ) <nl>\n", "msg": "Started implementation for the InitializeLifetimeService method .\n", "score": 1}
{"diff_id": 21112, "repo": "OpenRA/OpenRA\n", "sha": "986025ca76333ce90334f82a6c3382e8af97a6a7\n", "time": "2018-03-21T04:01:48Z\n", "diff": "mmm a / OpenRA . Mods . Common / Traits / World / ActorMap . cs <nl> ppp b / OpenRA . Mods . Common / Traits / World / ActorMap . cs <nl> class CellTrigger <nl> <nl> readonly Action < Actor > onActorEntered ; <nl> readonly Action < Actor > onActorExited ; <nl> - <nl> - IEnumerable < Actor > currentActors = Enumerable . Empty < Actor > ( ) ; <nl> + readonly HashSet < Actor > oldActors = new HashSet < Actor > ( ) ; <nl> + readonly HashSet < Actor > currentActors = new HashSet < Actor > ( ) ; <nl> <nl> public CellTrigger ( CPos [ ] footprint , Action < Actor > onActorEntered , Action < Actor > onActorExited ) <nl> { <nl> public void Tick ( ActorMap actorMap ) <nl> if ( ! Dirty ) <nl> return ; <nl> <nl> - var oldActors = currentActors ; <nl> - currentActors = Footprint . SelectMany ( actorMap . GetActorsAt ) . ToList ( ) ; <nl> + / / PERF : Reuse collection to avoid allocations . <nl> + oldActors . Clear ( ) ; <nl> + oldActors . UnionWith ( currentActors ) ; <nl> <nl> - var entered = currentActors . Except ( oldActors ) ; <nl> - var exited = oldActors . Except ( currentActors ) ; <nl> + currentActors . Clear ( ) ; <nl> + currentActors . UnionWith ( Footprint . SelectMany ( actorMap . GetActorsAt ) ) ; <nl> <nl> if ( onActorEntered ! = null ) <nl> - foreach ( var a in entered ) <nl> - onActorEntered ( a ) ; <nl> + foreach ( var a in currentActors ) <nl> + if ( ! oldActors . Contains ( a ) ) <nl> + onActorEntered ( a ) ; <nl> <nl> if ( onActorExited ! = null ) <nl> - foreach ( var a in exited ) <nl> - onActorExited ( a ) ; <nl> + foreach ( var a in oldActors ) <nl> + if ( ! currentActors . Contains ( a ) ) <nl> + onActorExited ( a ) ; <nl> <nl> Dirty = false ; <nl> } <nl> class ProximityTrigger : IDisposable <nl> <nl> readonly Action < Actor > onActorEntered ; <nl> readonly Action < Actor > onActorExited ; <nl> + readonly HashSet < Actor > oldActors = new HashSet < Actor > ( ) ; <nl> + readonly HashSet < Actor > currentActors = new HashSet < Actor > ( ) ; <nl> <nl> WPos position ; <nl> WDist range ; <nl> WDist vRange ; <nl> <nl> - IEnumerable < Actor > currentActors = Enumerable . Empty < Actor > ( ) ; <nl> - <nl> public ProximityTrigger ( WPos pos , WDist range , WDist vRange , Action < Actor > onActorEntered , Action < Actor > onActorExited ) <nl> { <nl> this . onActorEntered = onActorEntered ; <nl> public void Tick ( ActorMap am ) <nl> if ( ! Dirty ) <nl> return ; <nl> <nl> - var oldActors = currentActors ; <nl> + / / PERF : Reuse collection to avoid allocations . <nl> + oldActors . Clear ( ) ; <nl> + oldActors . UnionWith ( currentActors ) ; <nl> + <nl> var delta = new WVec ( range , range , WDist . Zero ) ; <nl> - currentActors = am . ActorsInBox ( position - delta , position + delta ) <nl> + currentActors . Clear ( ) ; <nl> + currentActors . UnionWith ( <nl> + am . ActorsInBox ( position - delta , position + delta ) <nl> . Where ( a = > ( a . CenterPosition - position ) . HorizontalLengthSquared < range . LengthSquared <nl> - & & ( vRange . Length = = 0 | | ( a . World . Map . DistanceAboveTerrain ( a . CenterPosition ) . LengthSquared < = vRange . LengthSquared ) ) ) <nl> - . ToList ( ) ; <nl> - <nl> - var entered = currentActors . Except ( oldActors ) ; <nl> - var exited = oldActors . Except ( currentActors ) ; <nl> + & & ( vRange . Length = = 0 | | ( a . World . Map . DistanceAboveTerrain ( a . CenterPosition ) . LengthSquared < = vRange . LengthSquared ) ) ) ) ; <nl> <nl> if ( onActorEntered ! = null ) <nl> - foreach ( var a in entered ) <nl> - onActorEntered ( a ) ; <nl> + foreach ( var a in currentActors ) <nl> + if ( ! oldActors . Contains ( a ) ) <nl> + onActorEntered ( a ) ; <nl> <nl> if ( onActorExited ! = null ) <nl> - foreach ( var a in exited ) <nl> - onActorExited ( a ) ; <nl> + foreach ( var a in oldActors ) <nl> + if ( ! currentActors . Contains ( a ) ) <nl> + onActorExited ( a ) ; <nl> <nl> Dirty = false ; <nl> } <nl>\n", "msg": "Reuse HashSets for actors entered / exited in CellTrigger & ProximityTrigger .\n", "score": 1}
{"diff_id": 21262, "repo": "Sonarr/Sonarr\n", "sha": "850552bf1769e663d6001a77b7cf76f88dad00a4\n", "time": "2020-11-18T06:20:56Z\n", "diff": "mmm a / src / NzbDrone . Core / Indexers / Nyaa / NyaaSettings . cs <nl> ppp b / src / NzbDrone . Core / Indexers / Nyaa / NyaaSettings . cs <nl> public class NyaaSettings : ITorrentIndexerSettings <nl> public NyaaSettings ( ) <nl> { <nl> BaseUrl = \" \" ; <nl> - AdditionalParameters = \" & cats = 1_37 & filter = 1 \" ; <nl> + AdditionalParameters = \" & cats = 1_0 & filter = 1 \" ; <nl> MinimumSeeders = IndexerDefaults . MINIMUM_SEEDERS ; <nl> } <nl> <nl>\n", "msg": "Update indexer category parameters for the other nyaa\n", "score": 1}
{"diff_id": 22070, "repo": "Sonarr/Sonarr\n", "sha": "2df51615b712c7fc5f2d8d4d4492398b6a94eb97\n", "time": "2013-08-12T07:12:05Z\n", "diff": "mmm a / NzbDrone . Core / MediaFiles / EpisodeImport / ImportApprovedEpisodes . cs <nl> ppp b / NzbDrone . Core / MediaFiles / EpisodeImport / ImportApprovedEpisodes . cs <nl> public List < ImportDecision > Import ( List < ImportDecision > decisions , bool newDownl <nl> if ( newDownload ) <nl> { <nl> episodeFile = _episodeFileUpgrader . UpgradeEpisodeFile ( episodeFile , localEpisode ) ; <nl> + <nl> + if ( episodeFile = = null ) <nl> + { <nl> + _logger . Error ( \" Failed to move [ { 0 } ] , aborting processing \" , localEpisode ) ; <nl> + continue ; <nl> + } <nl> + <nl> _messageAggregator . PublishEvent ( new EpisodeImportedEvent ( episodeFile ) ) ; <nl> } <nl> <nl>\n", "msg": "Preventing more errors when move fails\n", "score": 1}
{"diff_id": 22238, "repo": "dotnet/roslyn\n", "sha": "ff5714e16f8007263511761c06f1fcab7f1b4ab7\n", "time": "2017-04-19T08:06:41Z\n", "diff": "mmm a / src / Features / Core / Portable / NavigateTo / AbstractNavigateToSearchService . InProcess . cs <nl> ppp b / src / Features / Core / Portable / NavigateTo / AbstractNavigateToSearchService . InProcess . cs <nl> internal abstract partial class AbstractNavigateToSearchService <nl> { <nl> / / If the user created a dotted pattern then we ' ll grab the last part of the name <nl> var ( patternName , patternContainerOpt ) = PatternMatcher . GetNameAndContainer ( pattern ) ; <nl> - var nameMatcher = PatternMatcher . CreatePatternMatcher ( pattern , includeMatchedSpans : true , allowFuzzyMatching : true ) ; <nl> + var nameMatcher = PatternMatcher . CreatePatternMatcher ( patternName , includeMatchedSpans : true , allowFuzzyMatching : true ) ; <nl> <nl> var containerMatcher = patternContainerOpt ! = null <nl> ? PatternMatcher . CreateDotSeperatedContainerMatcher ( patternContainerOpt ) <nl>\n", "msg": "use the righ tname for pattern matching .\n", "score": 1}
{"diff_id": 22832, "repo": "dotnet-architecture/eShopOnContainers\n", "sha": "8f84bd3d09773fc28426e9f58cc538f492031404\n", "time": "2020-08-28T10:37:41Z\n", "diff": "mmm a / src / BuildingBlocks / EventBus / EventBusRabbitMQ / EventBusRabbitMQ . cs <nl> ppp b / src / BuildingBlocks / EventBus / EventBusRabbitMQ / EventBusRabbitMQ . cs <nl> namespace Microsoft . eShopOnContainers . BuildingBlocks . EventBusRabbitMQ <nl> public class EventBusRabbitMQ : IEventBus , IDisposable <nl> { <nl> const string BROKER_NAME = \" eshop_event_bus \" ; <nl> + const string AUTOFAC_SCOPE_NAME = \" eshop_event_bus \" ; <nl> <nl> private readonly IRabbitMQPersistentConnection _persistentConnection ; <nl> private readonly ILogger < EventBusRabbitMQ > _logger ; <nl> private readonly IEventBusSubscriptionsManager _subsManager ; <nl> private readonly ILifetimeScope _autofac ; <nl> - private readonly string AUTOFAC_SCOPE_NAME = \" eshop_event_bus \" ; <nl> private readonly int _retryCount ; <nl> <nl> private IModel _consumerChannel ; <nl> public void Publish ( IntegrationEvent @ event ) <nl> <nl> using ( var channel = _persistentConnection . CreateModel ( ) ) <nl> { <nl> - <nl> _logger . LogTrace ( \" Declaring RabbitMQ exchange to publish event : { EventId } \" , @ event . Id ) ; <nl> <nl> channel . ExchangeDeclare ( exchange : BROKER_NAME , type : \" direct \" ) ; <nl>\n", "msg": "Private readonly string changed to private const string ( )\n", "score": 1}
{"diff_id": 24094, "repo": "dotnet/roslyn\n", "sha": "c5a1ca01d628e02dc3329020d6731a6b3eb3481a\n", "time": "2016-08-01T23:35:18Z\n", "diff": "mmm a / src / Workspaces / Core / Portable / SymbolId / SymbolKey . SymbolKeyReader . cs <nl> ppp b / src / Workspaces / Core / Portable / SymbolId / SymbolKey . SymbolKeyReader . cs <nl> public override void Dispose ( ) <nl> Compilation = null ; <nl> IgnoreAssemblyKey = false ; <nl> Comparer = null ; <nl> + CurrentMethod = null ; <nl> <nl> / / Place us back in the pool for future use . <nl> s_readerPool . Free ( this ) ; <nl>\n", "msg": "Make sure to clear SymbolKeyReader . CurrentMethod before placing in pool\n", "score": 1}
{"diff_id": 25618, "repo": "QuantConnect/Lean\n", "sha": "c427902c369eefa6e744be638c2f0ae5ae4984da\n", "time": "2020-01-14T10:24:34Z\n", "diff": "mmm a / Brokerages / InteractiveBrokers / InteractiveBrokersBrokerage . cs <nl> ppp b / Brokerages / InteractiveBrokers / InteractiveBrokersBrokerage . cs <nl> public override void Connect ( ) <nl> { <nl> Log . Trace ( \" InteractiveBrokersBrokerage . Connect ( ) : Attempting to connect ( { 0 } / { 1 } ) . . . \" , attempt , maxAttempts ) ; <nl> <nl> + / / if we have errors from IBAutomater , exit immediately <nl> + if ( HasIbAutomaterErrors ( ) ) <nl> + { <nl> + attempt = maxAttempts ; <nl> + CheckIbAutomaterErrors ( ) ; <nl> + } <nl> + <nl> / / if message processing thread is still running , wait until it terminates <nl> Disconnect ( ) ; <nl> <nl> private void OnIbAutomaterExited ( object sender , ExitedEventArgs e ) <nl> Log . Trace ( $ \" InteractiveBrokersBrokerage . OnIbAutomaterExited ( ) : Exit code : { e . ExitCode } \" ) ; <nl> } <nl> <nl> + private bool HasIbAutomaterErrors ( ) <nl> + { <nl> + return _loginFailed | | _existingSessionDetected | | _securityDialogDetected ; <nl> + } <nl> + <nl> private void CheckIbAutomaterErrors ( ) <nl> { <nl> if ( _loginFailed ) <nl>\n", "msg": "Do not attempt to reconnect after IBAutomater errors\n", "score": 1}
{"diff_id": 26560, "repo": "bitwarden/server\n", "sha": "5a5b9163bfe9b4aab4519bc65ca890527be54fe9\n", "time": "2020-08-29T01:14:03Z\n", "diff": "mmm a / src / Identity / Startup . cs <nl> ppp b / src / Identity / Startup . cs <nl> public void ConfigureServices ( IServiceCollection services ) <nl> . AddOpenIdConnect ( \" sso \" , \" Single Sign On \" , options = > <nl> { <nl> options . Authority = globalSettings . BaseServiceUri . Sso ; <nl> + options . MetadataAddress = globalSettings . BaseServiceUri . InternalSso ; <nl> options . RequireHttpsMetadata = ! Environment . IsDevelopment ( ) & & <nl> globalSettings . BaseServiceUri . InternalIdentity . StartsWith ( \" https \" ) ; <nl> options . ClientId = \" oidc - identity \" ; <nl>\n", "msg": "use internal sso for metadata address\n", "score": 1}
{"diff_id": 26956, "repo": "ppy/osu\n", "sha": "55d076d6f359ed50edd3cf371195b656effd9929\n", "time": "2020-04-04T21:10:25Z\n", "diff": "mmm a / osu . Game . Rulesets . Catch / Skinning / CatchLegacySkinTransformer . cs <nl> ppp b / osu . Game . Rulesets . Catch / Skinning / CatchLegacySkinTransformer . cs <nl> public Drawable GetDrawableComponent ( ISkinComponent component ) <nl> <nl> public SampleChannel GetSample ( ISampleInfo sample ) = > source . GetSample ( sample ) ; <nl> <nl> - public IBindable < TValue > GetConfig < TLookup , TValue > ( TLookup lookup ) = > source . GetConfig < TLookup , TValue > ( lookup ) ; <nl> + public IBindable < TValue > GetConfig < TLookup , TValue > ( TLookup lookup ) <nl> + { <nl> + switch ( lookup ) <nl> + { <nl> + case CatchSkinColour colour : <nl> + return source . GetConfig < SkinCustomColourLookup , TValue > ( new SkinCustomColourLookup ( colour ) ) ; <nl> + } <nl> + <nl> + return source . GetConfig < TLookup , TValue > ( lookup ) ; <nl> + } <nl> } <nl> } <nl>\n", "msg": "Transform CatchSkinColour lookup to skin configuration custom colours lookup\n", "score": 1}
{"diff_id": 28092, "repo": "OpenRA/OpenRA\n", "sha": "02a8b05aff891ab8a12079349106f855c4679945\n", "time": "2013-05-31T06:12:30Z\n", "diff": "mmm a / OpenRA . Mods . RA / Guard . cs <nl> ppp b / OpenRA . Mods . RA / Guard . cs <nl> public IEnumerable < Order > Order ( World world , CPos xy , MouseInput mi ) <nl> if ( target = = null | | subjects . All ( s = > s . IsDead ( ) ) ) <nl> yield break ; <nl> <nl> - foreach ( var actor in subjects ) <nl> - yield return new Order ( \" Guard \" , actor , false ) { TargetActor = target } ; <nl> + foreach ( var subject in subjects ) <nl> + if ( subject ! = target ) <nl> + yield return new Order ( \" Guard \" , subject , false ) { TargetActor = target } ; <nl> } <nl> <nl> public void Tick ( World world ) <nl> public void Tick ( World world ) <nl> <nl> public string GetCursor ( World world , CPos xy , MouseInput mi ) <nl> { <nl> - return world . Map . IsInMap ( xy ) <nl> - & & FriendlyGuardableUnitsAtMouse ( world , mi ) . Any ( ) <nl> - ? \" guard \" <nl> - : \" move - blocked \" ; <nl> + if ( world . Map . IsInMap ( xy ) ) <nl> + { <nl> + var targets = FriendlyGuardableUnitsAtMouse ( world , mi ) ; <nl> + if ( targets . Any ( ) & & ( subjects . Count ( ) > 1 | | ( subjects . Count ( ) = = 1 & & subjects . First ( ) ! = targets . First ( ) ) ) ) <nl> + return \" guard \" ; <nl> + } <nl> + return \" move - blocked \" ; <nl> } <nl> <nl> static IEnumerable < Actor > FriendlyGuardableUnitsAtMouse ( World world , MouseInput mi ) <nl>\n", "msg": "Remove ability to have a single unit guard itself\n", "score": 1}
{"diff_id": 29043, "repo": "ppy/osu\n", "sha": "9036ea92ebc3146124348af74b3c490e6b6d51ac\n", "time": "2018-01-10T09:29:46Z\n", "diff": "mmm a / osu . Game / Rulesets / Objects / Drawables / DrawableHitObject . cs <nl> ppp b / osu . Game / Rulesets / Objects / Drawables / DrawableHitObject . cs <nl> public abstract class DrawableHitObject : Container , IHasAccentColour <nl> <nl> public override bool RemoveCompletedTransforms = > false ; <nl> public override bool RemoveWhenNotAlive = > false ; <nl> + protected override bool RequiresChildrenUpdate = > true ; <nl> <nl> protected DrawableHitObject ( HitObject hitObject ) <nl> { <nl>\n", "msg": "Run child updates for nested hitobjects when parent hitobjects are masked\n", "score": 1}
{"diff_id": 29058, "repo": "dotnet/runtime\n", "sha": "184e5aa16bcdef7bfb02a545cf92333337439db6\n", "time": "2020-11-17T12:56:18Z\n", "diff": "mmm a / src / libraries / System . Collections . Concurrent / src / System / Collections / Concurrent / ConcurrentDictionary . cs <nl> ppp b / src / libraries / System . Collections . Concurrent / src / System / Collections / Concurrent / ConcurrentDictionary . cs <nl> public void Clear ( ) <nl> { <nl> AcquireAllLocks ( ref locksAcquired ) ; <nl> <nl> + / / If the dictionary is already empty , then there ' s nothing to clear . <nl> + if ( AreAllBucketsEmpty ( ) ) <nl> + { <nl> + return ; <nl> + } <nl> + <nl> Tables tables = _tables ; <nl> var newTables = new Tables ( new Node [ DefaultCapacity ] , tables . _locks , new int [ tables . _countPerLock . Length ] ) ; <nl> _tables = newTables ; <nl> public bool IsEmpty <nl> ReleaseLocks ( 0 , acquiredLocks ) ; <nl> } <nl> <nl> - bool AreAllBucketsEmpty ( ) <nl> - { <nl> - int [ ] countPerLock = _tables . _countPerLock ; <nl> - <nl> - for ( int i = 0 ; i < countPerLock . Length ; i + + ) <nl> - { <nl> - if ( countPerLock [ i ] ! = 0 ) <nl> - { <nl> - return false ; <nl> - } <nl> - } <nl> <nl> - return true ; <nl> - } <nl> } <nl> } <nl> <nl> void ICollection . CopyTo ( Array array , int index ) <nl> <nl> # endregion <nl> <nl> + <nl> + private bool AreAllBucketsEmpty ( ) <nl> + { <nl> + int [ ] countPerLock = _tables . _countPerLock ; <nl> + <nl> + for ( int i = 0 ; i < countPerLock . Length ; i + + ) <nl> + { <nl> + if ( countPerLock [ i ] ! = 0 ) <nl> + { <nl> + return false ; <nl> + } <nl> + } <nl> + <nl> + return true ; <nl> + } <nl> + <nl> / / / < summary > <nl> / / / Replaces the bucket table with a larger one . To prevent multiple threads from resizing the <nl> / / / table as a result of races , the Tables instance that holds the table of buckets deemed too <nl>\n", "msg": "Added condition of empty for concurrent dictionary ( )\n", "score": 1}
{"diff_id": 29481, "repo": "QuantConnect/Lean\n", "sha": "b85a8ae94cc2716e8bbd25cc4466c41c9b136748\n", "time": "2015-06-18T02:34:04Z\n", "diff": "mmm a / Common / Data / Market / TradeBar . cs <nl> ppp b / Common / Data / Market / TradeBar . cs <nl> public TradeBar ( ) <nl> / / / Return a new instance with the same values as this original . <nl> / / / < / summary > <nl> / / / < param name = \" original \" > Original tradebar object we seek to clone < / param > <nl> - public TradeBar ( TradeBar original ) <nl> + public TradeBar ( TradeBar original ) <nl> { <nl> + DataType = MarketDataType . TradeBar ; <nl> Time = new DateTime ( original . Time . Ticks ) ; <nl> Symbol = original . Symbol ; <nl> Value = original . Close ; <nl> public TradeBar ( DateTime time , string symbol , decimal open , decimal high , decima <nl> Close = close ; <nl> Volume = volume ; <nl> Period = period ? ? TimeSpan . FromMinutes ( 1 ) ; <nl> + DataType = MarketDataType . TradeBar ; <nl> } <nl> <nl> / / / < summary > <nl>\n", "msg": "Require TradeBar ctors to set TradeBar data type\n", "score": 1}
{"diff_id": 30402, "repo": "NLog/NLog\n", "sha": "4d38f3a01e720fbc159dcd327d7a1378b13c0516\n", "time": "2018-09-01T14:34:12Z\n", "diff": "mmm a / src / NLog / LogFactory . cs <nl> ppp b / src / NLog / LogFactory . cs <nl> internal void ReloadConfigOnTimer ( object state ) <nl> } <nl> } <nl> # endif <nl> - private void GetTargetsByLevelForLogger ( string name , IEnumerable < LoggingRule > loggingRules , TargetWithFilterChain [ ] targetsByLevel , TargetWithFilterChain [ ] lastTargetsByLevel , bool [ ] suppressedLevels ) <nl> + <nl> + private bool GetTargetsByLevelForLogger ( string name , List < LoggingRule > loggingRules , TargetWithFilterChain [ ] targetsByLevel , TargetWithFilterChain [ ] lastTargetsByLevel , bool [ ] suppressedLevels ) <nl> { <nl> + bool targetsFound = false ; <nl> foreach ( LoggingRule rule in loggingRules ) <nl> { <nl> if ( ! rule . NameMatches ( name ) ) <nl> private void GetTargetsByLevelForLogger ( string name , IEnumerable < LoggingRule > lo <nl> <nl> foreach ( Target target in rule . GetTargetsThreadSafe ( ) ) <nl> { <nl> + targetsFound = true ; <nl> var awf = new TargetWithFilterChain ( target , rule . Filters , rule . DefaultFilterResult ) ; <nl> if ( lastTargetsByLevel [ i ] ! = null ) <nl> { <nl> private void GetTargetsByLevelForLogger ( string name , IEnumerable < LoggingRule > lo <nl> / / Recursively analyze the child rules . <nl> if ( rule . ChildRules . Count ! = 0 ) <nl> { <nl> - GetTargetsByLevelForLogger ( name , rule . GetChildRulesThreadSafe ( ) , targetsByLevel , lastTargetsByLevel , suppressedLevels ) ; <nl> + targetsFound = GetTargetsByLevelForLogger ( name , rule . GetChildRulesThreadSafe ( ) , targetsByLevel , lastTargetsByLevel , suppressedLevels ) | | targetsFound ; <nl> } <nl> } <nl> <nl> private void GetTargetsByLevelForLogger ( string name , IEnumerable < LoggingRule > lo <nl> tfc . PrecalculateStackTraceUsage ( ) ; <nl> } <nl> } <nl> + <nl> + return targetsFound ; <nl> } <nl> <nl> internal LoggerConfiguration GetConfigurationForLogger ( string name , LoggingConfiguration configuration ) <nl> internal LoggerConfiguration GetConfigurationForLogger ( string name , LoggingConfi <nl> TargetWithFilterChain [ ] lastTargetsByLevel = new TargetWithFilterChain [ LogLevel . MaxLevel . Ordinal + 1 ] ; <nl> bool [ ] suppressedLevels = new bool [ LogLevel . MaxLevel . Ordinal + 1 ] ; <nl> <nl> + bool targetsFound = false ; <nl> if ( configuration ! = null & & IsLoggingEnabled ( ) ) <nl> { <nl> / / no \" System . InvalidOperationException : Collection was modified \" <nl> var loggingRules = configuration . GetLoggingRulesThreadSafe ( ) ; <nl> - GetTargetsByLevelForLogger ( name , loggingRules , targetsByLevel , lastTargetsByLevel , suppressedLevels ) ; <nl> + targetsFound = GetTargetsByLevelForLogger ( name , loggingRules , targetsByLevel , lastTargetsByLevel , suppressedLevels ) ; <nl> } <nl> <nl> if ( InternalLogger . IsDebugEnabled ) <nl> { <nl> - InternalLogger . Debug ( \" Targets for { 0 } by level : \" , name ) ; <nl> - for ( int i = 0 ; i < = LogLevel . MaxLevel . Ordinal ; + + i ) <nl> + if ( targetsFound ) <nl> { <nl> - StringBuilder sb = new StringBuilder ( ) ; <nl> - sb . AppendFormat ( CultureInfo . InvariantCulture , \" { 0 } = > \" , LogLevel . FromOrdinal ( i ) ) ; <nl> - for ( TargetWithFilterChain afc = targetsByLevel [ i ] ; afc ! = null ; afc = afc . NextInChain ) <nl> + InternalLogger . Debug ( \" Targets for { 0 } by level : \" , name ) ; <nl> + for ( int i = 0 ; i < = LogLevel . MaxLevel . Ordinal ; + + i ) <nl> { <nl> - sb . AppendFormat ( CultureInfo . InvariantCulture , \" { 0 } \" , afc . Target . Name ) ; <nl> - if ( afc . FilterChain . Count > 0 ) <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + sb . AppendFormat ( CultureInfo . InvariantCulture , \" { 0 } = > \" , LogLevel . FromOrdinal ( i ) ) ; <nl> + for ( TargetWithFilterChain afc = targetsByLevel [ i ] ; afc ! = null ; afc = afc . NextInChain ) <nl> { <nl> - sb . AppendFormat ( CultureInfo . InvariantCulture , \" ( { 0 } filters ) \" , afc . FilterChain . Count ) ; <nl> + sb . AppendFormat ( CultureInfo . InvariantCulture , \" { 0 } \" , afc . Target . Name ) ; <nl> + if ( afc . FilterChain . Count > 0 ) <nl> + { <nl> + sb . AppendFormat ( CultureInfo . InvariantCulture , \" ( { 0 } filters ) \" , afc . FilterChain . Count ) ; <nl> + } <nl> } <nl> - } <nl> <nl> - InternalLogger . Debug ( sb . ToString ( ) ) ; <nl> + InternalLogger . Debug ( sb . ToString ( ) ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + InternalLogger . Debug ( \" Targets not configured for logger : { 0 } \" , name ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Compact logging of logging levels for loggers with no active targets ( )\n", "score": 1}
{"diff_id": 32030, "repo": "ppy/osu\n", "sha": "e4297ffeaded24ea61f8fd188e7fb92215d70674\n", "time": "2019-12-12T07:12:32Z\n", "diff": "mmm a / osu . Game / Rulesets / Mods / ModCinema . cs <nl> ppp b / osu . Game / Rulesets / Mods / ModCinema . cs <nl> public class ModCinema : ModAutoplay , IApplicableToHUD , IApplicableToPlayer <nl> <nl> public void ApplyToHUD ( HUDOverlay overlay ) <nl> { <nl> - overlay . AlwaysPresent = true ; <nl> - overlay . Hide ( ) ; <nl> + overlay . ShowHud . Value = false ; <nl> + overlay . ShowHud . Disabled = true ; <nl> } <nl> <nl> public void ApplyToPlayer ( Player player ) <nl>\n", "msg": "Hide HUD in a better way\n", "score": 1}
{"diff_id": 32919, "repo": "abpframework/abp\n", "sha": "e43603d155c8915c0f1ccd2875bb9fc578b84ea1\n", "time": "2019-04-03T15:05:26Z\n", "diff": "mmm a / modules / identityserver / src / Volo . Abp . IdentityServer . EntityFrameworkCore / Volo / Abp / IdentityServer / EntityFrameworkCore / IdentityServerDbContextModelCreatingExtensions . cs <nl> ppp b / modules / identityserver / src / Volo . Abp . IdentityServer . EntityFrameworkCore / Volo / Abp / IdentityServer / EntityFrameworkCore / IdentityServerDbContextModelCreatingExtensions . cs <nl> public static class IdentityServerDbContextModelCreatingExtensions <nl> { <nl> client . ToTable ( tablePrefix + \" Clients \" , schema ) ; <nl> <nl> + client . ConfigureFullAudited ( ) ; <nl> client . ConfigureExtraProperties ( ) ; <nl> <nl> client . Property ( x = > x . ClientId ) . HasMaxLength ( ClientConsts . ClientIdMaxLength ) . IsRequired ( ) ; <nl> public static class IdentityServerDbContextModelCreatingExtensions <nl> { <nl> identityResource . ToTable ( tablePrefix + \" IdentityResources \" , schema ) ; <nl> <nl> + identityResource . ConfigureFullAudited ( ) ; <nl> identityResource . ConfigureExtraProperties ( ) ; <nl> <nl> identityResource . Property ( x = > x . Name ) . HasMaxLength ( IdentityResourceConsts . NameMaxLength ) . IsRequired ( ) ; <nl> public static class IdentityServerDbContextModelCreatingExtensions <nl> { <nl> apiResource . ToTable ( tablePrefix + \" ApiResources \" , schema ) ; <nl> <nl> + apiResource . ConfigureFullAudited ( ) ; <nl> apiResource . ConfigureExtraProperties ( ) ; <nl> <nl> apiResource . Property ( x = > x . Name ) . HasMaxLength ( ApiResourceConsts . NameMaxLength ) . IsRequired ( ) ; <nl>\n", "msg": "Configure audit fields for aggregate roots .\n", "score": 1}
{"diff_id": 33765, "repo": "dnSpy/dnSpy\n", "sha": "8c273c6ab83f284f8530f0ebfb2eed67640a272b\n", "time": "2017-04-18T19:51:40Z\n", "diff": "mmm a / Extensions / dnSpy . Debugger / dnSpy . Debugger / Breakpoints / Code / CondChecker / TracepointMessageCreator . cs <nl> ppp b / Extensions / dnSpy . Debugger / dnSpy . Debugger / Breakpoints / Code / CondChecker / TracepointMessageCreator . cs <nl> struct KeywordInfo { <nl> textPos + = 2 ; <nl> break ; <nl> } <nl> + else { <nl> + bool ok = true ; <nl> + switch ( c ) { <nl> + case ' a ' : Write ( ' \\ a ' ) ; break ; <nl> + case ' b ' : Write ( ' \\ b ' ) ; break ; <nl> + case ' f ' : Write ( ' \\ f ' ) ; break ; <nl> + case ' n ' : Write ( ' \\ n ' ) ; break ; <nl> + case ' r ' : Write ( ' \\ r ' ) ; break ; <nl> + case ' t ' : Write ( ' \\ t ' ) ; break ; <nl> + case ' v ' : Write ( ' \\ v ' ) ; break ; <nl> + default : <nl> + ok = false ; <nl> + break ; <nl> + } <nl> + if ( ok ) { <nl> + textPos + = 2 ; <nl> + break ; <nl> + } <nl> + } <nl> } <nl> goto default ; <nl> <nl>\n", "msg": "Trace msg : allow more escape sequences\n", "score": 1}
{"diff_id": 33812, "repo": "ppy/osu\n", "sha": "f8eb07b21116e9ae3f01eba30cd626e50f097a32\n", "time": "2019-10-03T02:24:17Z\n", "diff": "mmm a / osu . Game / Database / ArchiveModelManager . cs <nl> ppp b / osu . Game / Database / ArchiveModelManager . cs <nl> public void Undelete ( List < TModel > items , bool silent = false ) <nl> <nl> int i = 0 ; <nl> <nl> - using ( ContextFactory . GetForWrite ( ) ) <nl> + foreach ( var item in items ) <nl> { <nl> - foreach ( var item in items ) <nl> - { <nl> - if ( notification . State = = ProgressNotificationState . Cancelled ) <nl> - / / user requested abort <nl> - return ; <nl> + if ( notification . State = = ProgressNotificationState . Cancelled ) <nl> + / / user requested abort <nl> + return ; <nl> <nl> - notification . Text = $ \" Restoring ( { + + i } of { items . Count } ) \" ; <nl> + notification . Text = $ \" Restoring ( { + + i } of { items . Count } ) \" ; <nl> <nl> - Undelete ( item ) ; <nl> + Undelete ( item ) ; <nl> <nl> - notification . Progress = ( float ) i / items . Count ; <nl> - } <nl> + notification . Progress = ( float ) i / items . Count ; <nl> } <nl> <nl> notification . State = ProgressNotificationState . Completed ; <nl>\n", "msg": "Only lock database for the duration of a model restoration\n", "score": 1}
{"diff_id": 35327, "repo": "mono/mono\n", "sha": "6d36b224565d54f6f0e5f98361b1f66fa43c1394\n", "time": "2008-10-16T20:43:53Z\n", "diff": "new file mode 100644 <nl> index 000000000000 . . c30021c17cdf <nl> mmm / dev / null <nl> ppp b / mcs / class / monodoc / addins - provider . cs <nl> <nl> + / / addins - provider . cs <nl> + / / <nl> + / / A provider to display Mono . Addins extension models <nl> + / / <nl> + / / Author : <nl> + / / Lluis Sanchez Gual < lluis @ novell . com > <nl> + / / <nl> + / / Copyright ( c ) 2007 Novell , Inc ( http : / / www . novell . com ) <nl> + / / <nl> + / / Permission is hereby granted , free of charge , to any person obtaining a copy <nl> + / / of this software and associated documentation files ( the \" Software \" ) , to deal <nl> + / / in the Software without restriction , including without limitation the rights <nl> + / / to use , copy , modify , merge , publish , distribute , sublicense , and / or sell <nl> + / / copies of the Software , and to permit persons to whom the Software is <nl> + / / furnished to do so , subject to the following conditions : <nl> + / / <nl> + / / The above copyright notice and this permission notice shall be included in <nl> + / / all copies or substantial portions of the Software . <nl> + / / <nl> + / / THE SOFTWARE IS PROVIDED \" AS IS \" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR <nl> + / / IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , <nl> + / / FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE <nl> + / / AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER <nl> + / / LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , <nl> + / / OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN <nl> + / / THE SOFTWARE . <nl> + / / <nl> + / / <nl> + <nl> + using System ; <nl> + using System . Text ; <nl> + using System . IO ; <nl> + using System . Xml ; <nl> + <nl> + namespace Monodoc <nl> + { <nl> + <nl> + / / <nl> + / / The simple provider generates the information source <nl> + / / <nl> + public class AddinsProvider : Provider <nl> + { <nl> + string file ; <nl> + <nl> + public AddinsProvider ( string xmlModelFile ) <nl> + { <nl> + file = xmlModelFile ; <nl> + <nl> + if ( ! File . Exists ( file ) ) <nl> + throw new FileNotFoundException ( String . Format ( \" The file ` { 0 } ' does not exist \" , file ) ) ; <nl> + } <nl> + <nl> + public override void PopulateTree ( Tree tree ) <nl> + { <nl> + string fileId = tree . tree . HelpSource . PackFile ( file ) ; <nl> + XmlDocument doc = new XmlDocument ( ) ; <nl> + doc . Load ( file ) ; <nl> + <nl> + foreach ( XmlElement addin in doc . SelectNodes ( \" Addins / Addin \" ) ) { <nl> + <nl> + string addinId = addin . GetAttribute ( \" fullId \" ) ; <nl> + Node newNode = tree . CreateNode ( addin . GetAttribute ( \" name \" ) , \" addin : \" + fileId + \" # \" + addinId ) ; <nl> + <nl> + foreach ( XmlElement node in addin . SelectNodes ( \" ExtensionPoint \" ) ) { <nl> + string target = \" extension - point : \" + fileId + \" # \" + addinId + \" # \" + node . GetAttribute ( \" path \" ) ; <nl> + Node newExt = newNode . CreateNode ( node . GetAttribute ( \" name \" ) , target ) ; <nl> + <nl> + foreach ( XmlElement en in node . SelectNodes ( \" ExtensionNode \" ) ) { <nl> + string nid = en . GetAttribute ( \" id \" ) ; <nl> + string nname = en . GetAttribute ( \" name \" ) ; <nl> + newExt . CreateNode ( nname , \" extension - node : \" + fileId + \" # \" + addinId + \" # \" + nid ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + <nl> + public override void CloseTree ( HelpSource hs , Tree tree ) <nl> + { <nl> + } <nl> + } <nl> + <nl> + / / <nl> + / / The HelpSource is used during the rendering phase . <nl> + / / <nl> + <nl> + public class AddinsHelpSource : HelpSource <nl> + { <nl> + public AddinsHelpSource ( string base_file , bool create ) : base ( base_file , create ) <nl> + { <nl> + } <nl> + <nl> + protected const string AddinPrefix = \" addin : \" ; <nl> + protected const string ExtensionPrefix = \" extension - point : \" ; <nl> + protected const string ExtensionNodePrefix = \" extension - node : \" ; <nl> + <nl> + public override string GetText ( string url , out Node match_node ) <nl> + { <nl> + match_node = null ; <nl> + if ( url . StartsWith ( AddinPrefix ) ) <nl> + return GetAddinTextFromUrl ( url ) ; <nl> + else if ( url . StartsWith ( ExtensionPrefix ) ) <nl> + return GetExtensionTextFromUrl ( url ) ; <nl> + else if ( url . StartsWith ( ExtensionNodePrefix ) ) <nl> + return GetExtensionNodeTextFromUrl ( url ) ; <nl> + <nl> + return null ; <nl> + } <nl> + <nl> + protected string GetAddinTextFromUrl ( string url ) <nl> + { <nl> + / / Remove \" addin : \" prefix including any help - source id on the front . <nl> + url = url . Substring ( AddinPrefix . Length ) ; <nl> + int i = url . IndexOf ( ' # ' ) ; <nl> + <nl> + if ( i = = - 1 ) { <nl> + Console . WriteLine ( \" Warning , NULL url ! \" ) ; <nl> + return \" < html > Invalid url < / html > \" ; <nl> + } <nl> + <nl> + string fileId = url . Substring ( 0 , i ) ; <nl> + string addinId = url . Substring ( i + 1 ) ; <nl> + <nl> + XmlElement addin = GetAddin ( fileId , addinId ) ; <nl> + if ( addin = = null ) <nl> + return \" < html > Add - in not found : \" + addinId + \" < / html > \" ; <nl> + <nl> + StringBuilder sb = new StringBuilder ( \" < html > \" ) ; <nl> + sb . Append ( \" < h1 > \" ) . Append ( addin . GetAttribute ( \" name \" ) ) . Append ( \" < / h1 > \" ) ; <nl> + XmlElement docs = ( XmlElement ) addin . SelectSingleNode ( \" Description \" ) ; <nl> + if ( docs ! = null ) <nl> + sb . Append ( docs . InnerText ) ; <nl> + <nl> + sb . Append ( \" < p > < table border = \\ \" 1 \\ \" cellpadding = \\ \" 4 \\ \" cellspacing = \\ \" 0 \\ \" > \" ) ; <nl> + sb . AppendFormat ( \" < tr > < td > < b > Id < / b > < / td > < td > { 0 } < / td > < / tr > \" , addin . GetAttribute ( \" addinId \" ) ) ; <nl> + sb . AppendFormat ( \" < tr > < td > < b > Namespace < / b > < / td > < td > { 0 } < / td > < / tr > \" , addin . GetAttribute ( \" namespace \" ) ) ; <nl> + sb . AppendFormat ( \" < tr > < td > < b > Version < / b > < / td > < td > { 0 } < / td > < / tr > \" , addin . GetAttribute ( \" version \" ) ) ; <nl> + sb . Append ( \" < / table > < / p > \" ) ; <nl> + sb . Append ( \" < p > < b > Extension Points < / b > : < / p > \" ) ; <nl> + sb . Append ( \" < ul > \" ) ; <nl> + <nl> + foreach ( XmlElement ep in addin . SelectNodes ( \" ExtensionPoint \" ) ) { <nl> + sb . AppendFormat ( \" < li > < a href = \\ \" extension - point : { 0 } # { 1 } # { 2 } \\ \" > { 3 } < / li > \" , fileId , addinId , ep . GetAttribute ( \" path \" ) , ep . GetAttribute ( \" name \" ) ) ; <nl> + } <nl> + sb . Append ( \" < / ul > \" ) ; <nl> + <nl> + sb . Append ( \" < / html > \" ) ; <nl> + return sb . ToString ( ) ; <nl> + } <nl> + <nl> + protected string GetExtensionTextFromUrl ( string url ) <nl> + { <nl> + / / Remove \" addin : \" prefix including any help - source id on the front . <nl> + url = url . Substring ( ExtensionPrefix . Length ) ; <nl> + int i = url . IndexOf ( ' # ' ) ; <nl> + <nl> + if ( i = = - 1 ) { <nl> + Console . WriteLine ( \" Warning , NULL url ! \" ) ; <nl> + return \" < html > Invalid url < / html > \" ; <nl> + } <nl> + <nl> + string fileId = url . Substring ( 0 , i ) ; <nl> + <nl> + int j = url . IndexOf ( ' # ' , i + 1 ) ; <nl> + string addinId = url . Substring ( i + 1 , j - i - 1 ) ; <nl> + string path = url . Substring ( j + 1 ) ; <nl> + <nl> + XmlElement addin = GetAddin ( fileId , addinId ) ; <nl> + if ( addin = = null ) <nl> + return \" < html > Add - in not found : \" + addinId + \" < / html > \" ; <nl> + <nl> + XmlElement ext = ( XmlElement ) addin . SelectSingleNode ( \" ExtensionPoint [ @ path = ' \" + path + \" ' ] \" ) ; <nl> + if ( ext = = null ) <nl> + return \" < html > Extension point not found : \" + path + \" < / html > \" ; <nl> + <nl> + StringBuilder sb = new StringBuilder ( \" < html > \" ) ; <nl> + sb . Append ( \" < h1 > \" ) . Append ( ext . GetAttribute ( \" name \" ) ) . Append ( \" < / h1 > \" ) ; <nl> + <nl> + path = path . Replace ( \" / \" , \" < b > / < / b > \" ) ; <nl> + sb . Append ( \" < p > < b > Path < / b > : \" ) . Append ( path ) . Append ( \" < / p > \" ) ; <nl> + XmlElement desc = ( XmlElement ) ext . SelectSingleNode ( \" Description \" ) ; <nl> + if ( desc ! = null ) <nl> + sb . Append ( desc . InnerText ) ; <nl> + <nl> + sb . Append ( \" < p > < b > Extension Nodes < / b > : < / p > \" ) ; <nl> + sb . Append ( \" < table border = \\ \" 1 \\ \" cellpadding = \\ \" 4 \\ \" cellspacing = \\ \" 0 \\ \" > \" ) ; <nl> + <nl> + foreach ( XmlElement en in ext . SelectNodes ( \" ExtensionNode \" ) ) { <nl> + string nid = en . GetAttribute ( \" id \" ) ; <nl> + string nname = en . GetAttribute ( \" name \" ) ; <nl> + string sdesc = \" \" ; <nl> + desc = ( XmlElement ) en . SelectSingleNode ( \" Description \" ) ; <nl> + if ( desc ! = null ) <nl> + sdesc = desc . InnerText ; <nl> + <nl> + sb . AppendFormat ( \" < tr > < td > < a href = \\ \" extension - node : { 0 } # { 1 } # { 2 } \\ \" > { 3 } < / td > < td > { 4 } < / td > < / tr > \" , fileId , addinId , nid , nname , sdesc ) ; <nl> + } <nl> + sb . Append ( \" < / table > \" ) ; <nl> + <nl> + sb . Append ( \" < / html > \" ) ; <nl> + return sb . ToString ( ) ; <nl> + } <nl> + <nl> + protected string GetExtensionNodeTextFromUrl ( string url ) <nl> + { <nl> + / / Remove \" addin : \" prefix including any help - source id on the front . <nl> + url = url . Substring ( ExtensionNodePrefix . Length ) ; <nl> + int i = url . IndexOf ( ' # ' ) ; <nl> + <nl> + if ( i = = - 1 ) { <nl> + Console . WriteLine ( \" Warning , NULL url ! \" ) ; <nl> + return \" < html > Invalid url < / html > \" ; <nl> + } <nl> + <nl> + string fileId = url . Substring ( 0 , i ) ; <nl> + <nl> + int j = url . IndexOf ( ' # ' , i + 1 ) ; <nl> + string addinId = url . Substring ( i + 1 , j - i - 1 ) ; <nl> + string nodeId = url . Substring ( j + 1 ) ; <nl> + <nl> + XmlElement addin = GetAddin ( fileId , addinId ) ; <nl> + if ( addin = = null ) <nl> + return \" < html > Add - in not found : \" + addinId + \" < / html > \" ; <nl> + <nl> + XmlElement node = ( XmlElement ) addin . SelectSingleNode ( \" ExtensionNodeType [ @ id = ' \" + nodeId + \" ' ] \" ) ; <nl> + if ( node = = null ) <nl> + return \" < html > Extension point not found : \" + nodeId + \" < / html > \" ; <nl> + <nl> + StringBuilder sb = new StringBuilder ( \" < html > \" ) ; <nl> + sb . Append ( \" < h1 > \" ) . Append ( node . GetAttribute ( \" name \" ) ) . Append ( \" < / h1 > \" ) ; <nl> + XmlElement desc = ( XmlElement ) node . SelectSingleNode ( \" Description \" ) ; <nl> + if ( desc ! = null ) <nl> + sb . Append ( desc . InnerText ) ; <nl> + <nl> + sb . Append ( \" < p > < b > Attributes < / b > : < / p > \" ) ; <nl> + sb . Append ( \" < table border = \\ \" 1 \\ \" cellpadding = \\ \" 4 \\ \" cellspacing = \\ \" 0 \\ \" > < tr > \" ) ; <nl> + sb . Append ( \" < td > < b > Name < / b > < / td > \" ) ; <nl> + sb . Append ( \" < td > < b > Type < / b > < / td > \" ) ; <nl> + sb . Append ( \" < td > < b > Required < / b > < / td > \" ) ; <nl> + sb . Append ( \" < td > < b > Localizable < / b > < / td > \" ) ; <nl> + sb . Append ( \" < td > < b > Description < / b > < / td > \" ) ; <nl> + sb . Append ( \" < tr > \" ) ; <nl> + sb . Append ( \" < td > id < / td > \" ) ; <nl> + sb . Append ( \" < td > System . String < / td > \" ) ; <nl> + sb . Append ( \" < td > < / td > \" ) ; <nl> + sb . Append ( \" < td > < / td > \" ) ; <nl> + sb . Append ( \" < td > Identifier of the node . < / td > \" ) ; <nl> + sb . Append ( \" < / tr > \" ) ; <nl> + <nl> + foreach ( XmlElement at in node . SelectNodes ( \" Attributes / Attribute \" ) ) { <nl> + sb . Append ( \" < tr > \" ) ; <nl> + sb . AppendFormat ( \" < td > { 0 } < / td > \" , at . GetAttribute ( \" name \" ) ) ; <nl> + sb . AppendFormat ( \" < td > { 0 } < / td > \" , at . GetAttribute ( \" type \" ) ) ; <nl> + if ( at . GetAttribute ( \" required \" ) = = \" True \" ) <nl> + sb . Append ( \" < td > Yes < / td > \" ) ; <nl> + else <nl> + sb . Append ( \" < td > < / td > \" ) ; <nl> + if ( at . GetAttribute ( \" localizable \" ) = = \" True \" ) <nl> + sb . Append ( \" < td > Yes < / td > \" ) ; <nl> + else <nl> + sb . Append ( \" < td > < / td > \" ) ; <nl> + string sdesc = \" \" ; <nl> + desc = ( XmlElement ) at . SelectSingleNode ( \" Description \" ) ; <nl> + if ( desc ! = null ) <nl> + sdesc = desc . InnerText ; <nl> + <nl> + sb . AppendFormat ( \" < td > { 0 } < / td > \" , sdesc ) ; <nl> + sb . Append ( \" < / tr > \" ) ; <nl> + } <nl> + sb . Append ( \" < / table > \" ) ; <nl> + <nl> + XmlNodeList children = node . SelectNodes ( \" ChildNodes / ExtensionNode \" ) ; <nl> + if ( children . Count > 0 ) { <nl> + sb . Append ( \" < p > < b > Child Nodes < / b > : < / p > \" ) ; <nl> + sb . Append ( \" < table border = \\ \" 1 \\ \" cellpadding = \\ \" 4 \\ \" cellspacing = \\ \" 0 \\ \" > \" ) ; <nl> + <nl> + foreach ( XmlElement en in children ) { <nl> + string nid = en . GetAttribute ( \" id \" ) ; <nl> + string nname = en . GetAttribute ( \" name \" ) ; <nl> + string sdesc = \" \" ; <nl> + desc = ( XmlElement ) en . SelectSingleNode ( \" Description \" ) ; <nl> + if ( desc ! = null ) <nl> + sdesc = desc . InnerText ; <nl> + <nl> + sb . AppendFormat ( \" < tr > < td > < a href = \\ \" extension - node : { 0 } # { 1 } # { 2 } \\ \" > { 3 } < / td > < td > { 4 } < / td > < / tr > \" , fileId , addinId , nid , nname , sdesc ) ; <nl> + } <nl> + sb . Append ( \" < / table > \" ) ; <nl> + } <nl> + <nl> + sb . Append ( \" < / html > \" ) ; <nl> + return sb . ToString ( ) ; <nl> + } <nl> + <nl> + XmlElement GetAddin ( string fileId , string addinId ) <nl> + { <nl> + Stream s = GetHelpStream ( fileId ) ; <nl> + StreamReader file ; <nl> + using ( file = new StreamReader ( s ) ) { <nl> + XmlDocument doc = new XmlDocument ( ) ; <nl> + doc . Load ( file ) ; <nl> + XmlElement addin = ( XmlElement ) doc . SelectSingleNode ( \" Addins / Addin [ @ fullId = ' \" + addinId + \" ' ] \" ) ; <nl> + if ( addin ! = null ) <nl> + return addin ; <nl> + else <nl> + return null ; <nl> + } <nl> + } <nl> + } <nl> + } <nl>\n", "msg": "Prepping for monodoc move from monodoc / engine to mcs / class / monodoc . . .\n", "score": 1}
{"diff_id": 35391, "repo": "dotnet/roslyn\n", "sha": "064585c0b871e204553c1425e7e3813daa9e2f48\n", "time": "2018-10-23T06:26:04Z\n", "diff": "mmm a / src / EditorFeatures / CSharpTest / FixInterpolatedVerbatimString / FixInterpolatedVerbatimStringCommandHandlerTests . cs <nl> ppp b / src / EditorFeatures / CSharpTest / FixInterpolatedVerbatimString / FixInterpolatedVerbatimStringCommandHandlerTests . cs <nl> private static TestWorkspace CreateTestWorkspace ( string inputMarkup ) <nl> return workspace ; <nl> } <nl> <nl> - private static ( string insertedCharSnapshotText , int insertedCharCaretPosition ) TypeChar ( TestWorkspace workspace , char ch ) <nl> + private static ( string quoteCharSnapshotText , int quoteCharCaretPosition ) TypeQuoteChar ( TestWorkspace workspace ) <nl> { <nl> var view = workspace . Documents . Single ( ) . GetTextView ( ) ; <nl> var commandHandler = new FixInterpolatedVerbatimStringCommandHandler ( ) ; <nl> <nl> - string insertedCharSnapshotText = default ; <nl> - int insertedCharCaretPosition = default ; <nl> + string quoteCharSnapshotText = default ; <nl> + int quoteCharCaretPosition = default ; <nl> <nl> - commandHandler . ExecuteCommand ( new TypeCharCommandArgs ( view , view . TextBuffer , ch ) , <nl> + commandHandler . ExecuteCommand ( new TypeCharCommandArgs ( view , view . TextBuffer , ' \" ' ) , <nl> ( ) = > <nl> { <nl> var editorOperations = workspace . GetService < IEditorOperationsFactoryService > ( ) . GetEditorOperations ( view ) ; <nl> - editorOperations . InsertText ( ch . ToString ( ) ) ; <nl> + editorOperations . InsertText ( \" \\ \" \" ) ; <nl> <nl> - / / We want to get the snapshot after the character was inserted , but before the command is executed <nl> - insertedCharSnapshotText = view . TextBuffer . CurrentSnapshot . GetText ( ) ; <nl> - insertedCharCaretPosition = view . Caret . Position . BufferPosition . Position ; <nl> + quoteCharSnapshotText = view . TextBuffer . CurrentSnapshot . GetText ( ) ; <nl> + quoteCharCaretPosition = view . Caret . Position . BufferPosition . Position ; <nl> <nl> } , TestCommandExecutionContext . Create ( ) ) ; <nl> <nl> - return ( insertedCharSnapshotText , insertedCharCaretPosition ) ; <nl> + return ( quoteCharSnapshotText , quoteCharCaretPosition ) ; <nl> } <nl> <nl> - private static void TestHandled ( char insertedChar , string inputMarkup , string expectedOutputMarkup ) <nl> + private static void TestHandled ( string inputMarkup , string expectedOutputMarkup ) <nl> { <nl> using ( var workspace = CreateTestWorkspace ( inputMarkup ) ) <nl> { <nl> - var ( insertedCharSnapshotText , insertedCharCaretPosition ) = TypeChar ( workspace , insertedChar ) ; <nl> + var ( quoteCharSnapshotText , quoteCharCaretPosition ) = TypeQuoteChar ( workspace ) ; <nl> var view = workspace . Documents . Single ( ) . GetTextView ( ) ; <nl> <nl> MarkupTestFile . GetSpans ( expectedOutputMarkup , <nl> private static void TestHandled ( char insertedChar , string inputMarkup , string ex <nl> var history = workspace . GetService < ITextUndoHistoryRegistry > ( ) . GetHistory ( view . TextBuffer ) ; <nl> history . Undo ( count : 1 ) ; <nl> <nl> - / / Ensure that after undo , the ordering fix is undone but the typed character remains inserted <nl> - Assert . Equal ( insertedCharSnapshotText , view . TextBuffer . CurrentSnapshot . GetText ( ) ) ; <nl> - Assert . Equal ( insertedCharCaretPosition , view . Caret . Position . BufferPosition . Position ) ; <nl> + / / Ensure that after undo , the ordering fix is undone but the quote remains inserted <nl> + Assert . Equal ( quoteCharSnapshotText , view . TextBuffer . CurrentSnapshot . GetText ( ) ) ; <nl> + Assert . Equal ( quoteCharCaretPosition , view . Caret . Position . BufferPosition . Position ) ; <nl> } <nl> } <nl> <nl> - private static void TestNotHandled ( char insertedChar , string inputMarkup ) <nl> + private static void TestNotHandled ( string inputMarkup ) <nl> { <nl> using ( var workspace = CreateTestWorkspace ( inputMarkup ) ) <nl> { <nl> private static void TestNotHandled ( char insertedChar , string inputMarkup ) <nl> var originalSnapshotText = originalView . TextBuffer . CurrentSnapshot . GetText ( ) ; <nl> var originalCaretPosition = originalView . Caret . Position . BufferPosition . Position ; <nl> <nl> - var ( insertedCharSnapshotText , insertedCharCaretPosition ) = TypeChar ( workspace , insertedChar ) ; <nl> + var ( quoteCharSnapshotText , quoteCharCaretPosition ) = TypeQuoteChar ( workspace ) ; <nl> var view = workspace . Documents . Single ( ) . GetTextView ( ) ; <nl> <nl> - Assert . Equal ( insertedCharSnapshotText , view . TextBuffer . CurrentSnapshot . GetText ( ) ) ; <nl> - Assert . Equal ( insertedCharCaretPosition , view . Caret . Position . BufferPosition . Position ) ; <nl> + Assert . Equal ( quoteCharSnapshotText , view . TextBuffer . CurrentSnapshot . GetText ( ) ) ; <nl> + Assert . Equal ( quoteCharCaretPosition , view . Caret . Position . BufferPosition . Position ) ; <nl> <nl> var history = workspace . GetService < ITextUndoHistoryRegistry > ( ) . GetHistory ( view . TextBuffer ) ; <nl> history . Undo ( count : 1 ) ; <nl> <nl> - / / Ensure that after undo , the typed character is removed because the command made no changes <nl> + / / Ensure that after undo , the quote is removed because the command made no changes <nl> Assert . Equal ( originalSnapshotText , view . TextBuffer . CurrentSnapshot . GetText ( ) ) ; <nl> Assert . Equal ( originalCaretPosition , view . Caret . Position . BufferPosition . Position ) ; <nl> } <nl> private static void TestNotHandled ( char insertedChar , string inputMarkup ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestAfterAtSignDollarSign ( ) <nl> { <nl> - TestHandled ( ' \" ' , <nl> + TestHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingAfterDollarSignAtSign ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingAfterAtSign ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingAfterDollarSign ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInEmptyFileAfterAtSignDollarSign ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , @ \" @ $ [ | | ] \" ) ; <nl> + TestNotHandled ( @ \" @ $ [ | | ] \" ) ; <nl> } <nl> <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInEmptyFileAfterDollarSign ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , @ \" $ [ | | ] \" ) ; <nl> + TestNotHandled ( @ \" $ [ | | ] \" ) ; <nl> } <nl> <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInEmptyFile ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , @ \" [ | | ] \" ) ; <nl> + TestNotHandled ( @ \" [ | | ] \" ) ; <nl> } <nl> <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestAfterAtSignDollarSignEndOfFile ( ) <nl> { <nl> - TestHandled ( ' \" ' , <nl> + TestHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInClassDeclaration ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> @ $ [ | | ] <nl> public void TestMissingInClassDeclaration ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInComment1 ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInComment2 ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInString ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInVerbatimString ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInInterpolatedString ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInInterpolatedVerbatimString1 ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestMissingInInterpolatedVerbatimString2 ( ) <nl> { <nl> - TestNotHandled ( ' \" ' , <nl> + TestNotHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl> void M ( ) <nl> [ WpfFact , Trait ( Traits . Feature , Traits . Features . FixInterpolatedVerbatimString ) ] <nl> public void TestTrivia ( ) <nl> { <nl> - TestHandled ( ' \" ' , <nl> + TestHandled ( <nl> @ \" class C <nl> { <nl> void M ( ) <nl>\n", "msg": "Revert \" Updating test infrastructure to support different insertion characters \"\n", "score": 1}
{"diff_id": 36854, "repo": "ppy/osu\n", "sha": "63edcddaf13453d66e86d4368e63ed90d2636962\n", "time": "2020-03-12T06:06:26Z\n", "diff": "mmm a / osu . Game / Screens / Select / Carousel / CarouselBeatmap . cs <nl> ppp b / osu . Game / Screens / Select / Carousel / CarouselBeatmap . cs <nl> public override void Filter ( FilterCriteria criteria ) <nl> { <nl> base . Filter ( criteria ) ; <nl> <nl> + bool match = <nl> + criteria . Ruleset = = null | | <nl> + Beatmap . RulesetID = = criteria . Ruleset . ID | | <nl> + ( Beatmap . RulesetID = = 0 & & criteria . Ruleset . ID > 0 & & criteria . AllowConvertedBeatmaps ) ; <nl> + <nl> if ( Beatmap . BeatmapSet ? . Equals ( criteria . SelectedBeatmapSet ) = = true ) <nl> { <nl> / / bypass filtering for selected beatmap <nl> - Filtered . Value = false ; <nl> + Filtered . Value = ! match ; <nl> return ; <nl> } <nl> <nl> - bool match = <nl> - criteria . Ruleset = = null | | <nl> - Beatmap . RulesetID = = criteria . Ruleset . ID | | <nl> - ( Beatmap . RulesetID = = 0 & & criteria . Ruleset . ID > 0 & & criteria . AllowConvertedBeatmaps ) ; <nl> - <nl> match & = ! criteria . StarDifficulty . HasFilter | | criteria . StarDifficulty . IsInRange ( Beatmap . StarDifficulty ) ; <nl> match & = ! criteria . ApproachRate . HasFilter | | criteria . ApproachRate . IsInRange ( Beatmap . BaseDifficulty . ApproachRate ) ; <nl> match & = ! criteria . DrainRate . HasFilter | | criteria . DrainRate . IsInRange ( Beatmap . BaseDifficulty . DrainRate ) ; <nl>\n", "msg": "Apply ruleset filter in all cases ( even when bypassing filter for selection purposes )\n", "score": 1}
{"diff_id": 36866, "repo": "ServiceStack/ServiceStack\n", "sha": "c6c23f95872f6814510231321c48d3acd2a95168\n", "time": "2015-10-03T23:45:13Z\n", "diff": "mmm a / src / ServiceStack / HttpError . cs <nl> ppp b / src / ServiceStack / HttpError . cs <nl> public HttpError ( string message ) <nl> : this ( HttpStatusCode . InternalServerError , message ) <nl> { } <nl> <nl> - public HttpError ( HttpStatusCode statusCode , string errorCode ) <nl> - : this ( statusCode , errorCode , null ) <nl> + public HttpError ( HttpStatusCode statusCode , string errorMessage ) <nl> + : this ( statusCode , statusCode . ToString ( ) , errorMessage ) <nl> { } <nl> <nl> public HttpError ( int statusCode , string errorCode ) <nl>\n", "msg": "Use the status code string as the error code in HttpError with HttpStatusCode + message\n", "score": 1}
{"diff_id": 37293, "repo": "QuantConnect/Lean\n", "sha": "a3be5716ef50143b4f1884802ab1f8d2f6021f9b\n", "time": "2015-05-12T18:57:11Z\n", "diff": "mmm a / Common / Data / Custom / Quandl . cs <nl> ppp b / Common / Data / Custom / Quandl . cs <nl> public class Quandl : DynamicData <nl> / / / < summary > <nl> / / / Is the auth <nl> / / / < / summary > <nl> - private static bool IsAuthCodeSet <nl> + public static bool IsAuthCodeSet <nl> { <nl> get ; <nl> - set ; <nl> + private set ; <nl> } <nl> <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * <nl> private static bool IsAuthCodeSet <nl> / / / < / summary > <nl> public Quandl ( ) <nl> { <nl> + base . EndTime = Time + TimeSpan . FromDays ( 1 ) ; <nl> _valueColumn = \" Close \" ; <nl> } <nl> <nl>\n", "msg": "Quandl update to have default time span of 1 day , closes\n", "score": 1}
{"diff_id": 38648, "repo": "mono/mono\n", "sha": "04bf64e3e720ed8379eec960430b461e468e5d9b\n", "time": "2003-11-15T04:06:55Z\n", "diff": "mmm a / mcs / class / System . Windows . Forms / System . Windows . Forms / ButtonBase . cs <nl> ppp b / mcs / class / System . Windows . Forms / System . Windows . Forms / ButtonBase . cs <nl> protected ButtonBase ( ) : base ( ) <nl> <nl> if ( flatStyle = = FlatStyle . System ) { <nl> Win32 . UpdateWindowStyle ( Handle , ( int ) ButtonStyles . BS_OWNERDRAW , 0 ) ; <nl> - } <nl> - else { <nl> + } else { <nl> Win32 . UpdateWindowStyle ( Handle , 0 , ( int ) ButtonStyles . BS_OWNERDRAW ) ; <nl> } <nl> Invalidate ( ) ; <nl> protected override void WndProc ( ref Message m ) <nl> switch ( m . Msg ) { <nl> case Msg . WM_COMMAND : { <nl> switch ( m . HiWordWParam ) { <nl> - case ( uint ) ButtonNotification . BN_CLICKED : <nl> + case ( uint ) ButtonNotification . BN_CLICKED : { <nl> OnClick ( new ControlEventArgs ( this ) ) ; <nl> + Win32 . SendMessage ( Handle , Msg . WM_SETFOCUS , ( int ) Handle , 0 ) ; <nl> CallControlWndProc ( ref m ) ; <nl> break ; <nl> - case ( uint ) ButtonNotification . BN_DOUBLECLICKED : <nl> + } <nl> + <nl> + case ( uint ) ButtonNotification . BN_DOUBLECLICKED : { <nl> OnClick ( new ControlEventArgs ( this ) ) ; <nl> CallControlWndProc ( ref m ) ; <nl> break ; <nl> + } <nl> + <nl> + case ( uint ) ButtonNotification . BN_SETFOCUS : { <nl> + OnGotFocus ( new ControlEventArgs ( this ) ) ; <nl> + break ; <nl> + } <nl> + <nl> + case ( uint ) ButtonNotification . BN_KILLFOCUS : { <nl> + OnLostFocus ( new ControlEventArgs ( this ) ) ; <nl> + break ; <nl> + } <nl> + <nl> default : <nl> CallControlWndProc ( ref m ) ; <nl> break ; <nl> } <nl> break ; <nl> } <nl> - case Msg . WM_DRAWITEM : <nl> + <nl> + case Msg . WM_DRAWITEM : { <nl> m . Result = ( IntPtr ) 1 ; <nl> break ; <nl> - case Msg . WM_PAINT : <nl> - PAINTSTRUCT ps = new PAINTSTRUCT ( ) ; <nl> - IntPtr hdc = Win32 . BeginPaint ( Handle , ref ps ) ; <nl> - Rectangle rc = new Rectangle ( ) ; <nl> + } <nl> + <nl> + case Msg . WM_PAINT : { <nl> + PAINTSTRUCT ps = new PAINTSTRUCT ( ) ; <nl> + IntPtr hdc = Win32 . BeginPaint ( Handle , ref ps ) ; <nl> + Rectangle rc = new Rectangle ( ) ; <nl> + <nl> rc . X = ps . rcPaint . left ; <nl> rc . Y = ps . rcPaint . top ; <nl> rc . Width = ps . rcPaint . right - ps . rcPaint . left ; <nl> protected override void WndProc ( ref Message m ) <nl> paintEventArgs . Dispose ( ) ; <nl> Win32 . EndPaint ( Handle , ref ps ) ; <nl> break ; <nl> - default : <nl> + } <nl> + <nl> + default : { <nl> base . WndProc ( ref m ) ; <nl> break ; <nl> + } <nl> } <nl> } <nl> <nl>\n", "msg": "Added ( rudimentary ) focus handling for button controls\n", "score": 1}
{"diff_id": 39734, "repo": "dotnet/aspnetcore\n", "sha": "753dad3e3fdc078a12543d52fb6b71348a4d092b\n", "time": "2020-10-15T16:23:18Z\n", "diff": "mmm a / src / Components / WebAssembly / Sdk / integrationtests / WasmPublishIntegrationTest . cs <nl> ppp b / src / Components / WebAssembly / Sdk / integrationtests / WasmPublishIntegrationTest . cs <nl> public async Task Publish_HostedApp_ProducesBootJsonDataWithExpectedContent ( ) <nl> Assert . Contains ( \" System . Text . Json . dll \" , assemblies ) ; <nl> <nl> / / No pdbs <nl> - / / Testing this requires an update to the SDK in this repo . Re - enabling tracked via https : / / github . com / dotnet / aspnetcore / issues / 25135 <nl> - / / Assert . Null ( bootJsonData . resources . pdb ) ; <nl> + Assert . Null ( bootJsonData . resources . pdb ) ; <nl> Assert . Null ( bootJsonData . resources . satelliteResources ) ; <nl> <nl> Assert . Contains ( \" appsettings . json \" , bootJsonData . config ) ; <nl>\n", "msg": "Re - enable assertion for pdbs during WASM publish ( )\n", "score": 1}
{"diff_id": 40125, "repo": "OpenRA/OpenRA\n", "sha": "e861e7c07ecc9029e375210d9f1af099c8d3b09b\n", "time": "2014-04-28T07:41:24Z\n", "diff": "mmm a / OpenRA . Mods . RA / Harvester . cs <nl> ppp b / OpenRA . Mods . RA / Harvester . cs <nl> <nl> using System . Collections . Generic ; <nl> using System . Drawing ; <nl> using System . Linq ; <nl> + using OpenRA . FileFormats ; <nl> using OpenRA . Mods . RA . Activities ; <nl> using OpenRA . Mods . RA . Move ; <nl> using OpenRA . Mods . RA . Orders ; <nl> namespace OpenRA . Mods . RA <nl> public class HarvesterInfo : ITraitInfo <nl> { <nl> public readonly string [ ] DeliveryBuildings = { } ; <nl> + [ Desc ( \" How much resources it can carry . \" ) ] <nl> public readonly int Capacity = 28 ; <nl> public readonly int LoadTicksPerBale = 4 ; <nl> + [ Desc ( \" How fast it can dump it ' s carryage . \" ) ] <nl> public readonly int UnloadTicksPerBale = 4 ; <nl> + [ Desc ( \" How many squares to show the fill level . \" ) ] <nl> public readonly int PipCount = 7 ; <nl> public readonly int HarvestFacings = 0 ; <nl> + [ Desc ( \" Which resources it can harvest . \" ) ] <nl> public readonly string [ ] Resources = { } ; <nl> + [ Desc ( \" How much it is slowed down when returning to the refinery . \" ) ] <nl> public readonly decimal FullyLoadedSpeed = . 85m ; <nl> - / / / < summary > <nl> - / / / Initial search radius ( in cells ) from the refinery ( proc ) that created us . <nl> - / / / < / summary > <nl> + [ Desc ( \" Initial search radius ( in cells ) from the refinery that created us . \" ) ] <nl> public readonly int SearchFromProcRadius = 24 ; <nl> - / / / < summary > <nl> - / / / Search radius ( in cells ) from the last harvest order location to find more resources . <nl> - / / / < / summary > <nl> + [ Desc ( \" Search radius ( in cells ) from the last harvest order location to find more resources . \" ) ] <nl> public readonly int SearchFromOrderRadius = 12 ; <nl> <nl> public object Create ( ActorInitializer init ) { return new Harvester ( init . self , this ) ; } <nl>\n", "msg": "port harvester documentation to the new inline Desc format\n", "score": 1}
{"diff_id": 40357, "repo": "ServiceStack/ServiceStack\n", "sha": "f70d07ef9853228d5f887155305bae860b1f55a0\n", "time": "2016-04-23T02:00:54Z\n", "diff": "mmm a / src / ServiceStack . RabbitMq / RabbitMqServer . cs <nl> ppp b / src / ServiceStack . RabbitMq / RabbitMqServer . cs <nl> private void RunLoop ( ) <nl> case WorkerOperation . Stop : <nl> Log . Debug ( \" Stop Command Issued \" ) ; <nl> <nl> + Interlocked . CompareExchange ( ref status , WorkerStatus . Stopping , WorkerStatus . Started ) ; <nl> try <nl> { <nl> StopWorkerThreads ( ) ; <nl> } <nl> finally <nl> { <nl> - if ( Interlocked . CompareExchange ( ref status , WorkerStatus . Stopped , WorkerStatus . Started ) ! = WorkerStatus . Started ) <nl> - Interlocked . CompareExchange ( ref status , WorkerStatus . Stopped , WorkerStatus . Stopping ) ; <nl> + Interlocked . CompareExchange ( ref status , WorkerStatus . Stopped , WorkerStatus . Stopping ) ; <nl> } <nl> return ; / / exits <nl> <nl> case WorkerOperation . Restart : <nl> Log . Debug ( \" Restart Command Issued \" ) ; <nl> <nl> - if ( Interlocked . CompareExchange ( ref status , WorkerStatus . Stopped , WorkerStatus . Started ) ! = WorkerStatus . Started ) <nl> + Interlocked . CompareExchange ( ref status , WorkerStatus . Stopping , WorkerStatus . Started ) ; <nl> + try <nl> + { <nl> + StopWorkerThreads ( ) ; <nl> + } <nl> + finally <nl> + { <nl> Interlocked . CompareExchange ( ref status , WorkerStatus . Stopped , WorkerStatus . Stopping ) ; <nl> + } <nl> <nl> - StopWorkerThreads ( ) ; <nl> StartWorkerThreads ( ) ; <nl> - <nl> Interlocked . CompareExchange ( ref status , WorkerStatus . Started , WorkerStatus . Stopped ) ; <nl> break ; / / continues <nl> } <nl>\n", "msg": "Change status to Stopping before stoping workers , Stopped after\n", "score": 1}
{"diff_id": 40911, "repo": "shadowsocks/shadowsocks-windows\n", "sha": "a0786a435fd729b9fb1d91c42577d670e0d5195b\n", "time": "2019-11-28T12:14:41Z\n", "diff": "mmm a / shadowsocks - csharp / Controller / Service / PACServer . cs <nl> ppp b / shadowsocks - csharp / Controller / Service / PACServer . cs <nl> public void UpdatePACURL ( Configuration config ) <nl> PacSecret = \" \" ; <nl> } <nl> <nl> - PacUrl = $ \" http : / / { config . localHost } : { config . localPort } / { RESOURCE_NAME } ? t = { GetTimestamp ( DateTime . Now ) } { PacSecret } \" ; <nl> + PacUrl = $ \" http : / / { config . localHost } : { config . localPort } / { RESOURCE_NAME } ? hash = { GetHash ( _pacDaemon . GetPACContent ( ) ) } { PacSecret } \" ; <nl> } <nl> <nl> <nl> - private static string GetTimestamp ( DateTime value ) <nl> + private static string GetHash ( string content ) <nl> { <nl> - return value . ToString ( \" yyyyMMddHHmmssfff \" ) ; <nl> + var contentBytes = Encoding . ASCII . GetBytes ( content ) ; <nl> + using ( var md5 = System . Security . Cryptography . MD5 . Create ( ) ) <nl> + { <nl> + var md5Bytes = md5 . ComputeHash ( contentBytes ) ; <nl> + return BitConverter . ToString ( md5Bytes ) . Replace ( \" - \" , \" \" ) ; <nl> + } ; <nl> } <nl> <nl> public override bool Handle ( byte [ ] firstPacket , int length , Socket socket , object state ) <nl> public void SendResponse ( Socket socket , bool useSocks ) <nl> string proxy = GetPACAddress ( localEndPoint , useSocks ) ; <nl> <nl> string pacContent = $ \" var __PROXY__ = ' { proxy } ' ; \\ n \" + _pacDaemon . GetPACContent ( ) ; <nl> - string responseHead = <nl> + string responseHead = <nl> $ @ \" HTTP / 1 . 1 200 OK <nl> Server : ShadowsocksWindows / { UpdateChecker . Version } <nl> Content - Type : application / x - ns - proxy - autoconfig <nl>\n", "msg": "Use MD5 hash instead of timestamp for PAC URL\n", "score": 1}
{"diff_id": 41252, "repo": "dotnet/runtime\n", "sha": "8d754cd638f8359cd0efb7991028288207455ba2\n", "time": "2017-05-09T19:09:41Z\n", "diff": "mmm a / src / libraries / System . Net . HttpListener / tests / HttpListenerPrefixCollectionTests . cs <nl> ppp b / src / libraries / System . Net . HttpListener / tests / HttpListenerPrefixCollectionTests . cs <nl> public void Contains_NullPrefix_ThrowsArgumentNullException ( ) <nl> Assert . Throws < ArgumentNullException > ( \" key \" , ( ) = > listener . Prefixes . Contains ( null ) ) ; <nl> } <nl> <nl> + [ ActiveIssue ( 19526 ) ] <nl> [ Fact ] <nl> public void Remove_PrefixExistsNotStarted_ReturnsTrue ( ) <nl> { <nl> public void Remove_PrefixExistsNotStarted_ReturnsTrue ( ) <nl> Assert . Equal ( 0 , listener . Prefixes . Count ) ; <nl> } <nl> <nl> + [ ActiveIssue ( 19526 ) ] <nl> [ Fact ] <nl> public async Task Remove_PrefixExistsStarted_ReturnsTrue ( ) <nl> { <nl>\n", "msg": "Disable more recently added HttpListener tests\n", "score": 1}
{"diff_id": 41479, "repo": "duplicati/duplicati\n", "sha": "fcedd9746d1ab264b9a0cba93c19a39fccc3579e\n", "time": "2018-01-28T00:41:15Z\n", "diff": "mmm a / Duplicati / Server / WebServer / RESTMethods / Backups . cs <nl> ppp b / Duplicati / Server / WebServer / RESTMethods / Backups . cs <nl> private void ImportBackup ( RequestInfo info ) <nl> { <nl> var input = info . Request . Form ; <nl> var cmdline = Library . Utility . Utility . ParseBool ( input [ \" cmdline \" ] . Value , false ) ; <nl> + var import_metadata = Library . Utility . Utility . ParseBool ( input [ \" import_metadata \" ] . Value , false ) ; <nl> var direct = Library . Utility . Utility . ParseBool ( input [ \" direct \" ] . Value , false ) ; <nl> output_template = output_template . Replace ( \" CBM \" , input [ \" callback \" ] . Value ) ; <nl> if ( cmdline ) <nl> private void ImportBackup ( RequestInfo info ) <nl> ipx = Serializer . Deserialize < Serializable . ImportExportStructure > ( sr ) ; <nl> } <nl> } <nl> + if ( ! import_metadata ) { <nl> + ipx . Backup . Metadata . Clear ( ) ; <nl> + } <nl> <nl> ipx . Backup . ID = null ; <nl> ( ( Database . Backup ) ipx . Backup ) . DBPath = null ; <nl>\n", "msg": "added backend code to support stripping metadata from imported backup configs\n", "score": 1}
{"diff_id": 41557, "repo": "dotnet/roslyn\n", "sha": "8a065053fb5aa26c62a81e5d90bd720dff96587f\n", "time": "2016-10-04T01:43:19Z\n", "diff": "mmm a / src / EditorFeatures / Next / Structure / BlockContextProvider . cs <nl> ppp b / src / EditorFeatures / Next / Structure / BlockContextProvider . cs <nl> private ITextBuffer CreateProjectionBufferForBlockHeaders ( ) <nl> <nl> var statementLine = textSnapshot . GetLineFromPosition ( blockTag . StatementSpan . Start ) ; <nl> <nl> - / / We want the span from the start of the line the statement is on , up <nl> - / / till the end of the line , or the beginning of the collapsed region <nl> - / / ( whichever is closer ) . <nl> - / / <nl> - / / The beginning of the line ensures that all the headers look properly <nl> - / / indented in the tooltip . <nl> var lineStart = statementLine . Start . Position ; <nl> - var lineEnd = Math . Min ( statementLine . End . Position , collapseSpan . Start ) ; <nl> + var lineEnd = statementLine . End . Position ; <nl> <nl> var headerSpan = new SnapshotSpan ( textSnapshot , Span . FromBounds ( lineStart , lineEnd ) ) ; <nl> var mappingSpan = headerSpan . CreateTrackingSpan ( SpanTrackingMode . EdgeExclusive ) ; <nl>\n", "msg": "Improve the display of the indent guides tooltips .\n", "score": 1}
{"diff_id": 42344, "repo": "ServiceStack/ServiceStack\n", "sha": "1994b05a7b01812317cd3e6dd044dd688da6e84f\n", "time": "2013-12-02T00:48:41Z\n", "diff": "mmm a / src / ServiceStack / Auth / UserAuth . cs <nl> ppp b / src / ServiceStack / Auth / UserAuth . cs <nl> public UserAuth ( ) <nl> public virtual int InvalidLoginAttempts { get ; set ; } <nl> public virtual DateTime ? LastLoginAttempt { get ; set ; } <nl> public virtual DateTime ? LockedDate { get ; set ; } <nl> + public virtual string RecoveryToken { get ; set ; } <nl> <nl> / / Custom Reference Data <nl> public virtual int ? RefId { get ; set ; } <nl>\n", "msg": "Add RecoveryToken to UserAuth for future password recovery functionality\n", "score": 1}
{"diff_id": 42445, "repo": "duplicati/duplicati\n", "sha": "7a106df094d95d81a24dc14b4ac0e2110bcfe3c5\n", "time": "2018-12-29T06:07:59Z\n", "diff": "mmm a / Duplicati / Library / Utility / FilterExpression . cs <nl> ppp b / Duplicati / Library / Utility / FilterExpression . cs <nl> private static IEnumerable < string > Expand ( string filter ) <nl> if ( string . IsNullOrWhiteSpace ( filter ) ) <nl> return null ; <nl> <nl> - if ( filter . Length < 2 | | <nl> - ( filter . StartsWith ( \" [ \" , StringComparison . Ordinal ) & & filter . EndsWith ( \" ] \" , StringComparison . Ordinal ) ) | | <nl> - ( filter . StartsWith ( \" { \" , StringComparison . Ordinal ) & & filter . EndsWith ( \" } \" , StringComparison . Ordinal ) ) ) <nl> + if ( filter . Length < 2 | | ( filter . StartsWith ( \" [ \" , StringComparison . Ordinal ) & & filter . EndsWith ( \" ] \" , StringComparison . Ordinal ) ) ) <nl> { <nl> return new string [ ] { filter } ; <nl> } <nl> - else <nl> + <nl> + if ( filter . StartsWith ( \" { \" , StringComparison . Ordinal ) & & filter . EndsWith ( \" } \" , StringComparison . Ordinal ) ) <nl> { <nl> - return filter . Split ( new char [ ] { System . IO . Path . PathSeparator } , StringSplitOptions . RemoveEmptyEntries ) ; <nl> + string groupName = filter . Substring ( 1 , filter . Length - 2 ) ; <nl> + FilterGroup filterGroup = FilterGroups . ParseFilterList ( groupName , FilterGroup . None ) ; <nl> + return ( filterGroup = = FilterGroup . None ) ? null : FilterGroups . GetFilterStrings ( filterGroup ) ; <nl> } <nl> + <nl> + return filter . Split ( new char [ ] { System . IO . Path . PathSeparator } , StringSplitOptions . RemoveEmptyEntries ) ; <nl> } <nl> <nl> private static List < FilterEntry > Compact ( IEnumerable < FilterEntry > items ) <nl>\n", "msg": "Improve performance of default excludes filters .\n", "score": 1}
{"diff_id": 42959, "repo": "SignalR/SignalR\n", "sha": "d39408b978ea3c3c97694fc176649d3a2181718c\n", "time": "2013-03-27T10:25:12Z\n", "diff": "mmm a / src / Microsoft . AspNet . SignalR . SqlServer / Properties / AssemblyInfo . cs <nl> ppp b / src / Microsoft . AspNet . SignalR . SqlServer / Properties / AssemblyInfo . cs <nl> <nl> <nl> [ assembly : AssemblyTitle ( \" Microsoft . AspNet . SignalR . SqlServer \" ) ] <nl> [ assembly : AssemblyDescription ( \" Assembly containing components for scaling - out SignalR applications using SQL Server . \" ) ] <nl> - [ assembly : InternalsVisibleTo ( \" Microsoft . AspNet . SignalR . SqlServer . Tests \" ) ] <nl> \\ No newline at end of file <nl> + # if SIGNED <nl> + [ assembly : InternalsVisibleTo ( \" Microsoft . AspNet . SignalR . SqlServer . Tests , PublicKey = 0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9 \" ) ] <nl> + # else <nl> + [ assembly : InternalsVisibleTo ( \" Microsoft . AspNet . SignalR . SqlServer . Tests \" ) ] <nl> + # endif <nl> \\ No newline at end of file <nl>\n", "msg": "Added public key to internals visible to for sql server .\n", "score": 1}
{"diff_id": 43372, "repo": "ppy/osu\n", "sha": "ad258e2e52ac387dd50b35f93022fd62217e6f30\n", "time": "2020-11-26T09:33:41Z\n", "diff": "mmm a / osu . Game / Screens / Select / BeatmapCarousel . cs <nl> ppp b / osu . Game / Screens / Select / BeatmapCarousel . cs <nl> protected override void Update ( ) <nl> if ( revalidateItems ) <nl> updateYPositions ( ) ; <nl> <nl> + if ( ! scrollPositionCache . IsValid ) <nl> + updateScrollPosition ( ) ; <nl> + <nl> / / This data is consumed to find the currently displayable range . <nl> / / This is the range we want to keep drawables for , and should exceed the visible range slightly to avoid drawable churn . <nl> var newDisplayRange = getDisplayRange ( ) ; <nl> protected override void Update ( ) <nl> return ( firstIndex , lastIndex ) ; <nl> } <nl> <nl> - protected override void UpdateAfterChildren ( ) <nl> - { <nl> - base . UpdateAfterChildren ( ) ; <nl> - <nl> - if ( ! scrollPositionCache . IsValid ) <nl> - updateScrollPosition ( ) ; <nl> - } <nl> - <nl> private void beatmapRemoved ( ValueChangedEvent < WeakReference < BeatmapSetInfo > > weakItem ) <nl> { <nl> if ( weakItem . NewValue . TryGetTarget ( out var item ) ) <nl>\n", "msg": "Update scroll position before applying any panel animations\n", "score": 1}
{"diff_id": 43406, "repo": "cefsharp/CefSharp\n", "sha": "fe026a8f9ef462aac000d0633aad9ed9f3bec7fa\n", "time": "2017-05-29T03:49:23Z\n", "diff": "mmm a / CefSharp / WebBrowserExtensions . cs <nl> ppp b / CefSharp / WebBrowserExtensions . cs <nl> public static void AddWordToDictionary ( this IBrowser cefBrowser , string word ) <nl> host . AddWordToDictionary ( word ) ; <nl> } <nl> <nl> + / / / < summary > <nl> + / / / Shortcut method to get the browser IBrowserHost <nl> + / / / < / summary > <nl> + / / / < param name = \" browser \" > The ChromiumWebBrowser instance this method extends < / param > <nl> + / / / < returns > browserHost or null < / returns > <nl> + public static IBrowserHost GetHost ( IWebBrowser browser ) <nl> + { <nl> + var cefBrowser = browser . GetBrowser ( ) ; <nl> + <nl> + return cefBrowser = = null ? null : cefBrowser . GetHost ( ) ; <nl> + } <nl> + <nl> / / / < summary > <nl> / / / Add the specified word to the spelling dictionary . <nl> / / / < / summary > <nl>\n", "msg": "Add IWebBrowser . GetHost ( ) extension method - make it easier to directly get the IBrowserHost reference\n", "score": 1}
{"diff_id": 43894, "repo": "dotnet/roslyn\n", "sha": "13c2e222b25567833dd368ffd012efc02c9b1086\n", "time": "2020-09-14T08:39:01Z\n", "diff": "mmm a / src / Analyzers / Core / Analyzers / RemoveRedundantEquality / AbstractRemoveRedundantEqualityDiagnosticAnalyzer . cs <nl> ppp b / src / Analyzers / Core / Analyzers / RemoveRedundantEquality / AbstractRemoveRedundantEqualityDiagnosticAnalyzer . cs <nl> private void AnalyzeBinaryOperator ( OperationAnalysisContext context ) <nl> return ; <nl> } <nl> <nl> + if ( ! _syntaxFacts . IsBinaryExpression ( operation . Syntax ) ) <nl> + { <nl> + return ; <nl> + } <nl> + <nl> var rightOperand = operation . RightOperand ; <nl> var leftOperand = operation . LeftOperand ; <nl> if ( rightOperand . Type . SpecialType is not SpecialType . System_Boolean | | <nl>\n", "msg": "Check IsBinaryExpression to avoid invalid cast\n", "score": 1}
{"diff_id": 44011, "repo": "mono/mono\n", "sha": "6ce8fd5bceb156432faa36a97c7ef797d6ec8ff1\n", "time": "2006-11-02T10:52:44Z\n", "diff": "mmm a / mcs / class / System . Web / Test / System . Web . UI . WebControls / UnitTest . cs <nl> ppp b / mcs / class / System . Web / Test / System . Web . UI . WebControls / UnitTest . cs <nl> public void IncorrectConstructor8 ( ) <nl> / / throws because there is stuff after cm ( a ) <nl> Unit a = new Unit ( \" - 45cm a \" ) ; <nl> } <nl> - <nl> - # if ! NET_2_0 <nl> - [ Test ] <nl> + <nl> + [ Test ] <nl> [ ExpectedException ( typeof ( FormatException ) ) ] <nl> - public void IncorrectConstructor9 ( ) <nl> - { <nl> - / / throws because floating point values are not valid for Pixel . <nl> - Unit a = new Unit ( \" 34 . 4px \" ) ; <nl> - <nl> - } <nl> - <nl> - [ Test ] <nl> + public void IncorrectConstructor9 ( ) <nl> + { <nl> + / / throws because floating point values are not valid for Pixel . <nl> + Unit a = new Unit ( \" 34 . 4px \" ) ; <nl> + <nl> + } <nl> + <nl> + [ Test ] <nl> [ ExpectedException ( typeof ( ArgumentOutOfRangeException ) ) ] <nl> public void IncorrectConstructor10 ( ) <nl> { <nl> public object GetFormat ( Type format_type ) <nl> } <nl> <nl> [ Test ] <nl> - [ Category ( \" NotWorking \" ) ] <nl> + [ Category ( \" NotWorking \" ) ] <nl> public void Unit_IFormatProviderToString ( ) <nl> { <nl> MyFormatProvider mfp = new MyFormatProvider ( ) ; <nl>\n", "msg": "Little format and directive changed for revision 67260\n", "score": 1}
{"diff_id": 44123, "repo": "JustArchiNET/ArchiSteamFarm\n", "sha": "06d9014ebe89519544788834b2ff26f09ac0b351\n", "time": "2020-04-18T12:15:20Z\n", "diff": "mmm a / ArchiSteamFarm / Bot . cs <nl> ppp b / ArchiSteamFarm / Bot . cs <nl> public sealed class Bot : IDisposable { <nl> SteamConfiguration = SteamConfiguration . Create ( builder = > builder . WithProtocolTypes ( ASF . GlobalConfig . SteamProtocols ) . WithCellID ( ASF . GlobalDatabase . CellID ) . WithServerListProvider ( ASF . GlobalDatabase . ServerListProvider ) . WithHttpClientFactory ( ArchiWebHandler . GenerateDisposableHttpClient ) ) ; <nl> <nl> / / Initialize <nl> - SteamClient = new SteamClient ( SteamConfiguration ) ; <nl> + SteamClient = new SteamClient ( SteamConfiguration , botName ) ; <nl> <nl> if ( Debugging . IsUserDebugging & & Directory . Exists ( SharedInfo . DebugDirectory ) ) { <nl> string debugListenerPath = Path . Combine ( SharedInfo . DebugDirectory , botName ) ; <nl>\n", "msg": "Use botName identifier for new SteamClient logging context\n", "score": 1}
{"diff_id": 44346, "repo": "mono/mono\n", "sha": "cafdbf84dc6cc674aaa995b9132082299444b234\n", "time": "2013-12-03T07:53:28Z\n", "diff": "mmm a / mcs / class / Microsoft . Build / Microsoft . Build . Internal / BuildEngine4 . cs <nl> ppp b / mcs / class / Microsoft . Build / Microsoft . Build . Internal / BuildEngine4 . cs <nl> void BuildProject ( InternalBuildArguments args ) <nl> <nl> var initialPropertiesFormatted = \" Initial Properties : \\ n \" + string . Join ( Environment . NewLine , project . Properties . OrderBy ( p = > p . Name ) . Select ( p = > string . Format ( \" { 0 } = { 1 } \" , p . Name , p . EvaluatedValue ) ) . ToArray ( ) ) ; <nl> LogMessageEvent ( new BuildMessageEventArgs ( initialPropertiesFormatted , null , null , MessageImportance . Low ) ) ; <nl> + var initialItemsFormatted = \" Initial Items : \\ n \" + string . Join ( Environment . NewLine , project . Items . OrderBy ( i = > i . ItemType ) . Select ( i = > string . Format ( \" { 0 } : { 1 } \" , i . ItemType , i . EvaluatedInclude ) ) . ToArray ( ) ) ; <nl> + LogMessageEvent ( new BuildMessageEventArgs ( initialItemsFormatted , null , null , MessageImportance . Low ) ) ; <nl> <nl> / / null targets - > success . empty targets - > success ( ! ) <nl> if ( request . TargetNames = = null ) <nl> args . Result . OverallResult = BuildResultCode . Success ; <nl> else { <nl> - foreach ( var targetName in request . TargetNames . Where ( t = > t ! = null ) ) <nl> + foreach ( var targetName in ( args . TargetNames ? ? request . TargetNames ) . Where ( t = > t ! = null ) ) <nl> BuildTargetByName ( targetName , args ) ; <nl> <nl> / / FIXME : check . NET behavior , whether cancellation always results in failure . <nl> bool DoBuildTarget ( ProjectTargetInstance target , TargetResult targetResult , Int <nl> if ( ! args . Project . EvaluateCondition ( c . Condition ) ) <nl> continue ; <nl> foreach ( var item in c . Items ) { <nl> + if ( ! args . Project . EvaluateCondition ( item . Condition ) ) <nl> + continue ; <nl> Func < string , ProjectItemInstance > creator = i = > new ProjectItemInstance ( project , item . ItemType , item . Metadata . Select ( m = > new KeyValuePair < string , string > ( m . Name , m . Value ) ) , i ) ; <nl> foreach ( var ti in project . GetAllItems ( item . Include , item . Exclude , creator , creator , s = > s = = item . ItemType , ( ti , s ) = > ti . SetMetadata ( \" RecurseDir \" , s ) ) ) <nl> itemsToRemove . Add ( ti ) ; <nl>\n", "msg": "Target items related fixes - give diagnostic outputs for initial items . Evaluate item condition .\n", "score": 1}
{"diff_id": 44525, "repo": "Sonarr/Sonarr\n", "sha": "7d23f24854854b41faaf3e7574dd64f89e3b1ad6\n", "time": "2015-05-21T19:54:08Z\n", "diff": "mmm a / src / NzbDrone . Update / UpdateEngine / InstallUpdateService . cs <nl> ppp b / src / NzbDrone . Update / UpdateEngine / InstallUpdateService . cs <nl> public void Start ( string installationFolder , int processId ) <nl> <nl> try <nl> { <nl> - _terminateNzbDrone . Terminate ( processId ) ; <nl> + if ( OsInfo . IsWindows ) <nl> + { <nl> + _terminateNzbDrone . Terminate ( processId ) ; <nl> + } <nl> <nl> _backupAndRestore . Backup ( installationFolder ) ; <nl> _backupAppData . Backup ( ) ; <nl> public void Start ( string installationFolder , int processId ) <nl> _logger . Info ( \" Copying new files to target folder \" ) ; <nl> _diskProvider . CopyFolder ( _appFolderInfo . GetUpdatePackageFolder ( ) , installationFolder ) ; <nl> <nl> - / / Set executable flag on SOnarr app <nl> + / / Set executable flag on Sonarr app <nl> if ( OsInfo . IsOsx ) <nl> { <nl> - _diskProvider . SetPermissions ( Path . Combine ( installationFolder , \" Sonarr \" ) , \" 0755 \" , null , null ) ; <nl> + _diskProvider . SetPermissions ( Path . Combine ( installationFolder , \" Sonarr \" ) , \" 0755 \" , null , null ) ; <nl> } <nl> } <nl> catch ( Exception e ) <nl> public void Start ( string installationFolder , int processId ) <nl> } <nl> finally <nl> { <nl> - _startNzbDrone . Start ( appType , installationFolder ) ; <nl> + if ( OsInfo . IsWindows ) <nl> + { <nl> + _startNzbDrone . Start ( appType , installationFolder ) ; <nl> + } <nl> + else <nl> + { <nl> + _terminateNzbDrone . Terminate ( processId ) ; <nl> + <nl> + _logger . Info ( \" Waiting for external auto - restart . \" ) ; <nl> + for ( int i = 0 ; i < 5 ; i + + ) <nl> + { <nl> + System . Threading . Thread . Sleep ( 1000 ) ; <nl> + <nl> + if ( _processProvider . Exists ( ProcessProvider . NZB_DRONE_PROCESS_NAME ) ) <nl> + { <nl> + _logger . Info ( \" Sonarr was restarted by external process . \" ) ; <nl> + break ; <nl> + } <nl> + } <nl> + <nl> + if ( ! _processProvider . Exists ( ProcessProvider . NZB_DRONE_PROCESS_NAME ) ) <nl> + { <nl> + _startNzbDrone . Start ( appType , installationFolder ) ; <nl> + } <nl> + } <nl> } <nl> <nl> } <nl>\n", "msg": "New : Hand - off update logic to handle upstart / systemd and other auto - restart mechanisms .\n", "score": 1}
{"diff_id": 44818, "repo": "jellyfin/jellyfin\n", "sha": "78c7e79b6176ebc939589cfb5affcde4551db1e1\n", "time": "2013-06-11T12:50:50Z\n", "diff": "mmm a / MediaBrowser . Server . Implementations / MediaEncoder / MediaEncoder . cs <nl> ppp b / MediaBrowser . Server . Implementations / MediaEncoder / MediaEncoder . cs <nl> public async Task ConvertTextSubtitleToAss ( string inputPath , string outputPath , <nl> throw new ArgumentNullException ( \" outputPath \" ) ; <nl> } <nl> <nl> - var offsetParam = offset . Ticks > 0 ? \" - ss \" + offset . TotalSeconds + \" \" : string . Empty ; <nl> + var fastSeekSeconds = offset . TotalSeconds > = 1 ? offset . TotalSeconds - 1 : 0 ; <nl> + var slowSeekSeconds = offset . TotalSeconds > = 1 ? 1 : 0 ; <nl> + <nl> + var fastSeekParam = fastSeekSeconds > 0 ? \" - ss \" + fastSeekSeconds + \" \" : string . Empty ; <nl> + var slowSeekParam = slowSeekSeconds > 0 ? \" - ss \" + slowSeekSeconds : string . Empty ; <nl> <nl> var process = new Process <nl> { <nl> public async Task ConvertTextSubtitleToAss ( string inputPath , string outputPath , <nl> CreateNoWindow = true , <nl> UseShellExecute = false , <nl> FileName = FFMpegPath , <nl> - Arguments = string . Format ( \" { 0 } - i \\ \" { 1 } \\ \" \\ \" { 2 } \\ \" \" , offsetParam , inputPath , outputPath ) , <nl> + Arguments = string . Format ( \" { 0 } - i \\ \" { 1 } \\ \" { 2 } \\ \" { 3 } \\ \" \" , fastSeekParam , inputPath , slowSeekParam , outputPath ) , <nl> WindowStyle = ProcessWindowStyle . Hidden , <nl> ErrorDialog = false <nl> } <nl> private async Task ExtractTextSubtitleInternal ( string inputPath , int subtitleStr <nl> throw new ArgumentNullException ( \" cancellationToken \" ) ; <nl> } <nl> <nl> - var offsetParam = offset . Ticks > 0 ? \" - ss \" + offset . TotalSeconds + \" \" : string . Empty ; <nl> + var fastSeekSeconds = offset . TotalSeconds > = 1 ? offset . TotalSeconds - 1 : 0 ; <nl> + var slowSeekSeconds = offset . TotalSeconds > = 1 ? 1 : 0 ; <nl> + <nl> + var fastSeekParam = fastSeekSeconds > 0 ? \" - ss \" + fastSeekSeconds + \" \" : string . Empty ; <nl> + var slowSeekParam = slowSeekSeconds > 0 ? \" - ss \" + slowSeekSeconds : string . Empty ; <nl> <nl> var process = new Process <nl> { <nl> private async Task ExtractTextSubtitleInternal ( string inputPath , int subtitleStr <nl> RedirectStandardError = true , <nl> <nl> FileName = FFMpegPath , <nl> - Arguments = string . Format ( \" { 0 } - i { 1 } - map 0 : { 2 } - an - vn - c : s ass \\ \" { 3 } \\ \" \" , offsetParam , inputPath , subtitleStreamIndex , outputPath ) , <nl> + Arguments = string . Format ( \" { 0 } - i { 1 } { 2 } - map 0 : { 3 } - an - vn - c : s ass \\ \" { 4 } \\ \" \" , fastSeekParam , inputPath , slowSeekParam , subtitleStreamIndex , outputPath ) , <nl> WindowStyle = ProcessWindowStyle . Hidden , <nl> ErrorDialog = false <nl> } <nl>\n", "msg": "use combination of fast and slow seek on subtitle conversions\n", "score": 1}
{"diff_id": 44858, "repo": "StackExchange/StackExchange.Redis\n", "sha": "0c2c50609ca005747e4261e031a57b955e4cbaa1\n", "time": "2016-09-26T20:59:10Z\n", "diff": "mmm a / StackExchange . Redis / StackExchange / Redis / ConnectionMultiplexer . cs <nl> ppp b / StackExchange . Redis / StackExchange / Redis / ConnectionMultiplexer . cs <nl> internal T ExecuteSyncImpl < T > ( Message message , ResultProcessor < T > processor , Ser <nl> add ( \" Active - Readers \" , \" ar \" , ar . ToString ( ) ) ; <nl> <nl> add ( \" Client - Name \" , \" clientName \" , ClientName ) ; <nl> + add ( \" Server - Endpoint \" , \" serverEndpoint \" , server . EndPoint . ToString ( ) ) ; <nl> + var hashSlot = message . GetHashSlot ( this . ServerSelectionStrategy ) ; <nl> + / / only add keyslot if its a valid cluster key slot <nl> + if ( hashSlot ! = ServerSelectionStrategy . NoSlot ) <nl> + { <nl> + add ( \" CommandKey - Slot \" , \" commandKeySlot \" , message . GetHashSlot ( this . ServerSelectionStrategy ) . ToString ( ) ) ; <nl> + } <nl> # if ! CORE_CLR <nl> string iocp , worker ; <nl> int busyWorkerCount = GetThreadPoolStats ( out iocp , out worker ) ; <nl>\n", "msg": "adding server info and slot information to debug info\n", "score": 1}
{"diff_id": 44915, "repo": "ShareX/ShareX\n", "sha": "bc044b3e270082655bea3b0de45de0fecd8bafae\n", "time": "2015-08-27T00:38:20Z\n", "diff": "mmm a / ShareX . UploadersLib / FileUploaders / Up1 . cs <nl> ppp b / ShareX . UploadersLib / FileUploaders / Up1 . cs <nl> private static MemoryStream Encrypt ( Stream source , string fileName , out string s <nl> aes . CngMode = CngChainingMode . Ccm ; <nl> aes . Key = key ; <nl> aes . IV = ccmIV ; <nl> + aes . TagSize = MacSize ; <nl> <nl> MemoryStream ms = new MemoryStream ( ) ; <nl> <nl> private static MemoryStream Encrypt ( Stream source , string fileName , out string s <nl> CryptoStream cs = new CryptoStream ( ms , encryptor , CryptoStreamMode . Write ) ; <nl> cs . Write ( data , 0 , data . Length ) ; <nl> cs . FlushFinalBlock ( ) ; <nl> - / / tag = encryptor . GetTag ( ) ; <nl> + byte [ ] tag = encryptor . GetTag ( ) ; <nl> + ms . Write ( tag , 0 , tag . Length ) ; <nl> return ms ; <nl> } <nl> } <nl>\n", "msg": "Set tag size , append tag to fix Up1 support using new library\n", "score": 1}
{"diff_id": 13, "repo": "mRemoteNG/mRemoteNG\n", "sha": "57dd93f1361e02297aaa5ceb9bfb562b880c3c8e\n", "time": "2016-07-26T18:39:37Z\n", "diff": "mmm a / mRemoteV1 / Config / Connections / XmlConnectionsLoader . cs <nl> ppp b / mRemoteV1 / Config / Connections / XmlConnectionsLoader . cs <nl> public void LoadFromXml ( bool import ) <nl> ValidateConnectionFileVersion ( ) ; <nl> <nl> / / SECTION 2 . Initialize the treeview control . <nl> - var rootNodeName = \" \" ; <nl> - if ( _xmlDocument . DocumentElement . HasAttribute ( \" Name \" ) ) <nl> - rootNodeName = Convert . ToString ( _xmlDocument . DocumentElement . Attributes [ \" Name \" ] . Value . Trim ( ) ) ; <nl> - RootTreeNode . Name = ! string . IsNullOrEmpty ( rootNodeName ) ? rootNodeName : _xmlDocument . DocumentElement . Name ; <nl> - RootTreeNode . Text = RootTreeNode . Name ; <nl> - <nl> - var rootInfo = new RootNodeInfo ( RootNodeType . Connection ) <nl> - { <nl> - Name = RootTreeNode . Name , <nl> - TreeNode = RootTreeNode <nl> - } ; <nl> - RootTreeNode . Tag = rootInfo ; <nl> + var rootInfo = InitializeRootNode ( ) ; <nl> <nl> if ( _confVersion > 1 . 3 ) / / 1 . 4 <nl> { <nl>\n", "msg": "Extracted method for initializing the root tree node\n", "score": 1}
{"diff_id": 208, "repo": "ppy/osu\n", "sha": "aead13628bbaa284b4dc1719c7c83e173f9e8565\n", "time": "2020-08-21T08:52:42Z\n", "diff": "mmm a / osu . Game . Rulesets . Mania / Objects / Drawables / DrawableHoldNote . cs <nl> ppp b / osu . Game . Rulesets . Mania / Objects / Drawables / DrawableHoldNote . cs <nl> <nl> using osu . Game . Rulesets . Scoring ; <nl> using osu . Game . Rulesets . UI . Scrolling ; <nl> using osu . Game . Skinning ; <nl> - using osuTK ; <nl> <nl> namespace osu . Game . Rulesets . Mania . Objects . Drawables <nl> { <nl> public class DrawableHoldNote : DrawableManiaHitObject < HoldNote > , IKeyBindingHan <nl> private readonly Container < DrawableHoldNoteTick > tickContainer ; <nl> <nl> / / / < summary > <nl> - / / / Contains the maximum size / position of the body prior to any offset or size adjustments . <nl> + / / / Contains the size of the hold note covering the whole head / tail bounds . The size of this container changes as the hold note is being pressed . <nl> / / / < / summary > <nl> - private readonly Container bodyContainer ; <nl> + private readonly Container sizingContainer ; <nl> <nl> / / / < summary > <nl> - / / / Contains the offset size / position of the body such that the body extends half - way between the head and tail pieces . <nl> + / / / Contains the contents of the hold note that should be masked as the hold note is being pressed . Follows changes in the size of < see cref = \" sizingContainer \" / > . <nl> / / / < / summary > <nl> - private readonly Container bodyOffsetContainer ; <nl> - <nl> - / / / < summary > <nl> - / / / Contains the masking area for the tail , which is resized along with < see cref = \" bodyContainer \" / > . <nl> - / / / < / summary > <nl> - private readonly Container tailMaskingContainer ; <nl> + private readonly Container maskingContainer ; <nl> <nl> private readonly SkinnableDrawable bodyPiece ; <nl> <nl> public DrawableHoldNote ( HoldNote hitObject ) <nl> { <nl> RelativeSizeAxes = Axes . X ; <nl> <nl> - AddRangeInternal ( new [ ] <nl> + Container maskedContents ; <nl> + <nl> + AddRangeInternal ( new Drawable [ ] <nl> { <nl> - bodyContainer = new Container <nl> + sizingContainer = new Container <nl> { <nl> RelativeSizeAxes = Axes . Both , <nl> Children = new Drawable [ ] <nl> { <nl> - bodyOffsetContainer = new Container <nl> + maskingContainer = new Container <nl> { <nl> - RelativeSizeAxes = Axes . X , <nl> - Child = bodyPiece = new SkinnableDrawable ( new ManiaSkinComponent ( ManiaSkinComponents . HoldNoteBody , hitObject . Column ) , _ = > new DefaultBodyPiece <nl> + RelativeSizeAxes = Axes . Both , <nl> + Child = maskedContents = new Container <nl> { <nl> - RelativeSizeAxes = Axes . Both <nl> - } ) <nl> + RelativeSizeAxes = Axes . Both , <nl> + Masking = true , <nl> + } <nl> } , <nl> - / / The head needs to move along with changes in the size of the body . <nl> headContainer = new Container < DrawableHoldNoteHead > { RelativeSizeAxes = Axes . Both } <nl> } <nl> } , <nl> - tickContainer = new Container < DrawableHoldNoteTick > { RelativeSizeAxes = Axes . Both } , <nl> - tailMaskingContainer = new Container <nl> + bodyPiece = new SkinnableDrawable ( new ManiaSkinComponent ( ManiaSkinComponents . HoldNoteBody , hitObject . Column ) , _ = > new DefaultBodyPiece <nl> { <nl> - RelativeSizeAxes = Axes . X , <nl> - Masking = true , <nl> - Child = tailContainer = new Container < DrawableHoldNoteTail > <nl> - { <nl> - RelativeSizeAxes = Axes . X , <nl> - } <nl> + RelativeSizeAxes = Axes . Both , <nl> + } ) <nl> + { <nl> + RelativeSizeAxes = Axes . X <nl> } , <nl> - headContainer . CreateProxy ( ) <nl> + tickContainer = new Container < DrawableHoldNoteTick > { RelativeSizeAxes = Axes . Both } , <nl> + tailContainer = new Container < DrawableHoldNoteTail > { RelativeSizeAxes = Axes . Both } , <nl> + } ) ; <nl> + <nl> + maskedContents . AddRange ( new [ ] <nl> + { <nl> + bodyPiece . CreateProxy ( ) , <nl> + tickContainer . CreateProxy ( ) , <nl> + tailContainer . CreateProxy ( ) , <nl> } ) ; <nl> } <nl> <nl> protected override void OnDirectionChanged ( ValueChangedEvent < ScrollingDirection > <nl> { <nl> base . OnDirectionChanged ( e ) ; <nl> <nl> - / / The body container is anchored from the position of the tail , since its height is changed when the hold note is being hit . <nl> - / / The body offset container is anchored from the position of the head ( inverse of the above ) . <nl> - / / The tail containers are both anchored from the position of the tail . <nl> if ( e . NewValue = = ScrollingDirection . Up ) <nl> { <nl> - bodyContainer . Anchor = bodyContainer . Origin = Anchor . BottomLeft ; <nl> - bodyOffsetContainer . Anchor = bodyOffsetContainer . Origin = Anchor . TopLeft ; <nl> - <nl> - tailMaskingContainer . Anchor = tailMaskingContainer . Origin = Anchor . BottomLeft ; <nl> - tailContainer . Anchor = tailContainer . Origin = Anchor . BottomLeft ; <nl> + bodyPiece . Anchor = bodyPiece . Origin = Anchor . TopLeft ; <nl> + sizingContainer . Anchor = sizingContainer . Origin = Anchor . BottomLeft ; <nl> } <nl> else <nl> { <nl> - bodyContainer . Anchor = bodyContainer . Origin = Anchor . TopLeft ; <nl> - bodyOffsetContainer . Anchor = bodyOffsetContainer . Origin = Anchor . BottomLeft ; <nl> - <nl> - tailMaskingContainer . Anchor = tailMaskingContainer . Origin = Anchor . TopLeft ; <nl> - tailContainer . Anchor = tailContainer . Origin = Anchor . TopLeft ; <nl> + bodyPiece . Anchor = bodyPiece . Origin = Anchor . BottomLeft ; <nl> + sizingContainer . Anchor = sizingContainer . Origin = Anchor . TopLeft ; <nl> } <nl> } <nl> <nl> protected override void Update ( ) <nl> if ( Time . Current < releaseTime ) <nl> releaseTime = null ; <nl> <nl> - / / Decrease the size of the body while the hold note is held and the head has been hit . This stops at the very first release point . <nl> - if ( Head . IsHit & & releaseTime = = null ) <nl> + / / Pad the full size container so its contents ( i . e . the masking container ) reach under the tail . <nl> + / / This is required for the tail to not be masked away , since it lies outside the bounds of the hold note . <nl> + sizingContainer . Padding = new MarginPadding <nl> { <nl> - float heightDecrease = ( float ) ( Math . Max ( 0 , Time . Current - HitObject . StartTime ) / HitObject . Duration ) ; <nl> - bodyContainer . Height = MathHelper . Clamp ( 1 - heightDecrease , 0 , 1 ) ; <nl> - } <nl> + Top = Direction . Value = = ScrollingDirection . Down ? - Tail . Height : 0 , <nl> + Bottom = Direction . Value = = ScrollingDirection . Up ? - Tail . Height : 0 , <nl> + } ; <nl> <nl> - / / Re - position the body half - way up the head , and extend the height until it ' s half - way under the tail . <nl> - bodyOffsetContainer . Y = ( Direction . Value = = ScrollingDirection . Up ? 1 : - 1 ) * Head . Height / 2 ; <nl> - bodyOffsetContainer . Height = bodyContainer . DrawHeight + Tail . Height / 2 - Head . Height / 2 ; <nl> + / / Pad the masking container to the starting position of the body piece ( half - way under the head ) . <nl> + / / This is required ot make the body start getting masked immediately as soon as the note is held . <nl> + maskingContainer . Padding = new MarginPadding <nl> + { <nl> + Top = Direction . Value = = ScrollingDirection . Up ? Head . Height / 2 : 0 , <nl> + Bottom = Direction . Value = = ScrollingDirection . Down ? Head . Height / 2 : 0 , <nl> + } ; <nl> <nl> - / / The tail is positioned to be \" outside \" the hold note , so re - position its masking container to fully cover the tail and extend the height until it ' s half - way under the head . <nl> - / / The masking height is determined by the size of the body so that the head and tail don ' t overlap as the body becomes shorter via hitting ( above ) . <nl> - tailMaskingContainer . Y = ( Direction . Value = = ScrollingDirection . Up ? 1 : - 1 ) * Tail . Height ; <nl> - tailMaskingContainer . Height = bodyContainer . DrawHeight + Tail . Height - Head . Height / 2 ; <nl> + / / Position and resize the body to lie half - way under the head and the tail notes . <nl> + bodyPiece . Y = ( Direction . Value = = ScrollingDirection . Up ? 1 : - 1 ) * Head . Height / 2 ; <nl> + bodyPiece . Height = DrawHeight - Head . Height / 2 + Tail . Height / 2 ; <nl> <nl> - / / The tail container needs the reverse of the above offset applied to bring the tail to its original position . <nl> - / / It also needs the full original height of the hold note to maintain positioning even as the height of the masking container changes . <nl> - tailContainer . Y = - tailMaskingContainer . Y ; <nl> - tailContainer . Height = DrawHeight ; <nl> + / / As the note is being held , adjust the size of the fullSizeContainer . This has two effects : <nl> + / / 1 . The contained masking container will mask the body and ticks . <nl> + / / 2 . The head note will move along with the new \" head position \" in the container . <nl> + if ( Head . IsHit & & releaseTime = = null ) <nl> + { <nl> + float heightDecrease = ( float ) ( Math . Max ( 0 , Time . Current - HitObject . StartTime ) / HitObject . Duration ) ; <nl> + sizingContainer . Height = Math . Clamp ( 1 - heightDecrease , 0 , 1 ) ; <nl> + } <nl> } <nl> <nl> protected override void UpdateStateTransforms ( ArmedState state ) <nl>\n", "msg": "Rework freezing to use masking\n", "score": 1}
{"diff_id": 298, "repo": "dotnet/runtime\n", "sha": "d1cef150d4d84dcdbe00fb507b9878fb7e538be2\n", "time": "2015-07-14T19:03:33Z\n", "diff": "mmm a / src / coreclr / src / mscorlib / src / System / Collections / Generic / List . cs <nl> ppp b / src / coreclr / src / mscorlib / src / System / Collections / Generic / List . cs <nl> void System . Collections . IList . Remove ( Object item ) <nl> / / which was previously located at index i will now be located at <nl> / / index index + ( index + count - i - 1 ) . <nl> / / <nl> - / / This method uses the Array . Reverse method to reverse the <nl> - / / elements . <nl> - / / <nl> public void Reverse ( int index , int count ) { <nl> if ( index < 0 ) { <nl> ThrowHelper . ThrowArgumentOutOfRangeException ( ExceptionArgument . index , ExceptionResource . ArgumentOutOfRange_NeedNonNegNum ) ; <nl> void System . Collections . IList . Remove ( Object item ) <nl> if ( _size - index < count ) <nl> ThrowHelper . ThrowArgumentException ( ExceptionResource . Argument_InvalidOffLen ) ; <nl> Contract . EndContractBlock ( ) ; <nl> - Array . Reverse ( _items , index , count ) ; <nl> + <nl> + / / The non - generic Array . Reverse is not used because it does not perform <nl> + / / well for non - primitive value types . <nl> + / / If / when a generic Array . Reverse < T > becomes available , the below code <nl> + / / can be deleted and replaced with a call to Array . Reverse < T > . <nl> + int i = index ; <nl> + int j = index + count - 1 ; <nl> + T [ ] array = _items ; <nl> + while ( i < j ) <nl> + { <nl> + T temp = array [ i ] ; <nl> + array [ i ] = array [ j ] ; <nl> + array [ j ] = temp ; <nl> + i + + ; <nl> + j - - ; <nl> + } <nl> + <nl> _version + + ; <nl> } <nl> <nl>\n", "msg": "Improve the performance of List < T > . Reverse\n", "score": 1}
{"diff_id": 845, "repo": "gitextensions/gitextensions\n", "sha": "b1b1cc163a7ac649b371eb89e75560498ed5d668\n", "time": "2011-10-13T22:45:07Z\n", "diff": "mmm a / GitUI / FormTranslate . cs <nl> ppp b / GitUI / FormTranslate . cs <nl> private void FillTranslateGrid ( string filter ) <nl> UpdateProgress ( ) ; <nl> } <nl> <nl> + private bool IsAssemblyTranslatable ( Assembly assembly ) <nl> + { <nl> + if ( ( assembly . FullName . StartsWith ( \" mscorlib \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> + ( assembly . FullName . StartsWith ( \" Microsoft \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> + ( assembly . FullName . StartsWith ( \" Presentation \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> + ( assembly . FullName . StartsWith ( \" WindowsBase \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> + ( assembly . FullName . StartsWith ( \" ICSharpCode \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> + ( assembly . FullName . StartsWith ( \" access \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> + ( assembly . FullName . StartsWith ( \" SMDiag \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> + ( assembly . FullName . StartsWith ( \" System \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> + ( assembly . FullName . StartsWith ( \" vshost \" , StringComparison . OrdinalIgnoreCase ) ) ) <nl> + { <nl> + return false ; <nl> + } <nl> + return true ; <nl> + } <nl> + <nl> + private bool IsTranslatableType ( Type type ) <nl> + { <nl> + if ( ( typeof ( GitExtensionsControl ) . IsAssignableFrom ( type ) ) | | <nl> + ( typeof ( GitExtensionsForm ) . IsAssignableFrom ( type ) ) | | <nl> + ( typeof ( ITranslate ) . IsAssignableFrom ( type ) ) ) <nl> + { <nl> + return true ; <nl> + } <nl> + return false ; <nl> + } <nl> + <nl> + private List < Type > GetTranslatableTypes ( ) <nl> + { <nl> + List < Type > translatableTypes = new List < Type > ( ) ; <nl> + foreach ( Assembly assembly in AppDomain . CurrentDomain . GetAssemblies ( ) ) <nl> + { <nl> + if ( IsAssemblyTranslatable ( assembly ) ) <nl> + { <nl> + foreach ( Type type in assembly . GetTypes ( ) ) <nl> + { <nl> + if ( IsTranslatableType ( type ) ) <nl> + { <nl> + translatableTypes . Add ( type ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + return translatableTypes ; <nl> + } <nl> + <nl> + private object CreateInstanceOfClass ( Type type ) <nl> + { <nl> + object obj = null ; <nl> + if ( type = = GetType ( ) ) <nl> + obj = this ; <nl> + else <nl> + { <nl> + / / try to find parameter less constructor first <nl> + foreach ( ConstructorInfo constructor in type . GetConstructors ( ) ) <nl> + { <nl> + if ( constructor . GetParameters ( ) . Length = = 0 ) <nl> + obj = Activator . CreateInstance ( type ) ; <nl> + } <nl> + } <nl> + if ( obj = = null & & type . GetConstructors ( ) . Length > 0 ) <nl> + { <nl> + ConstructorInfo parameterConstructor = type . GetConstructors ( ) [ 0 ] ; <nl> + var parameters = new List < object > ( parameterConstructor . GetParameters ( ) . Length ) ; <nl> + for ( int i = 0 ; i < parameterConstructor . GetParameters ( ) . Length ; i + + ) <nl> + parameters . Add ( null ) ; <nl> + obj = parameterConstructor . Invoke ( parameters . ToArray ( ) ) ; <nl> + } <nl> + <nl> + return obj ; <nl> + } <nl> + <nl> + private void GetTranslatableFromComponent ( string className , object obj , FieldInfo fieldInfo ) <nl> + { <nl> + if ( ! ( fieldInfo . GetValue ( obj ) is Component ) ) <nl> + { <nl> + return ; <nl> + } <nl> + Component component = fieldInfo . GetValue ( obj ) as Component ; <nl> + foreach ( PropertyInfo propertyInfo in fieldInfo . FieldType . GetProperties ( BindingFlags . Public | BindingFlags . Instance | BindingFlags . Static | BindingFlags . NonPublic ) ) <nl> + { <nl> + if ( IsTranslatableItemInComponent ( propertyInfo ) ) <nl> + { <nl> + var value = ( string ) propertyInfo . GetValue ( component , null ) ; <nl> + if ( ! string . IsNullOrEmpty ( value ) ) <nl> + { <nl> + AddTranslationItem ( className , fieldInfo . Name , propertyInfo . Name , value ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + private void GetTranslatableFromDataGridViewElement ( string className , object obj , FieldInfo fieldInfo ) <nl> + { <nl> + if ( ! ( fieldInfo . GetValue ( obj ) is DataGridViewElement ) ) <nl> + { <nl> + return ; <nl> + } <nl> + DataGridViewColumn dataGridViewColumn = fieldInfo . GetValue ( obj ) as DataGridViewColumn ; <nl> + foreach ( PropertyInfo propertyInfo in fieldInfo . FieldType . GetProperties ( BindingFlags . Public | BindingFlags . Instance | BindingFlags . Static | BindingFlags . NonPublic ) ) <nl> + { <nl> + if ( IsTranslatableItemInDataGridViewElement ( propertyInfo , fieldInfo , obj ) ) <nl> + { <nl> + var value = ( string ) propertyInfo . GetValue ( dataGridViewColumn , null ) ; <nl> + if ( ! string . IsNullOrEmpty ( value ) ) <nl> + { <nl> + AddTranslationItem ( className , fieldInfo . Name , propertyInfo . Name , value ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> public void GetPropertiesToTranslate ( ) <nl> { <nl> translateCategories . Items . Clear ( ) ; <nl> public void GetPropertiesToTranslate ( ) <nl> / / Set language to neutral to get neutral translations <nl> GitCommands . Settings . Translation = \" \" ; <nl> <nl> - foreach ( Assembly assembly in AppDomain . CurrentDomain . GetAssemblies ( ) ) <nl> + List < Type > translatableTypes = GetTranslatableTypes ( ) ; <nl> + <nl> + foreach ( Type type in translatableTypes ) <nl> { <nl> - if ( ( assembly . FullName . StartsWith ( \" mscorlib \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> - ( assembly . FullName . StartsWith ( \" Microsoft \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> - ( assembly . FullName . StartsWith ( \" ICSharpCode \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> - ( assembly . FullName . StartsWith ( \" System . \" , StringComparison . OrdinalIgnoreCase ) ) | | <nl> - ( assembly . FullName . StartsWith ( \" vshost \" , StringComparison . OrdinalIgnoreCase ) ) ) <nl> + string className = type . Name ; <nl> + if ( ! translateCategories . Items . Contains ( className ) ) <nl> + translateCategories . Items . Add ( className ) ; <nl> + <nl> + object obj = CreateInstanceOfClass ( type ) ; <nl> + if ( obj = = null ) <nl> { <nl> continue ; <nl> } <nl> - try <nl> + <nl> + if ( obj is Form ) <nl> { <nl> - foreach ( Type type in assembly . GetTypes ( ) ) <nl> + if ( ! string . IsNullOrEmpty ( ( ( Form ) obj ) . Text ) ) <nl> { <nl> - if ( typeof ( GitExtensionsControl ) . IsAssignableFrom ( type ) | | <nl> - typeof ( GitExtensionsForm ) . IsAssignableFrom ( type ) | | <nl> - typeof ( ITranslate ) . IsAssignableFrom ( type ) ) <nl> - { / / if ( typeof ) <nl> - object control = null ; <nl> - <nl> - <nl> - if ( type = = GetType ( ) ) <nl> - control = this ; <nl> - else <nl> - / / try to find parameter less constructor first <nl> - foreach ( ConstructorInfo constructor in type . GetConstructors ( ) ) <nl> - { <nl> - if ( constructor . GetParameters ( ) . Length = = 0 ) <nl> - control = Activator . CreateInstance ( type ) ; <nl> - } <nl> - <nl> - if ( control = = null & & type . GetConstructors ( ) . Length > 0 ) <nl> - { <nl> - ConstructorInfo parameterConstructor = type . GetConstructors ( ) [ 0 ] ; <nl> - var parameters = new List < object > ( parameterConstructor . GetParameters ( ) . Length ) ; <nl> - for ( int i = 0 ; i < parameterConstructor . GetParameters ( ) . Length ; i + + ) <nl> - parameters . Add ( null ) ; <nl> - control = parameterConstructor . Invoke ( parameters . ToArray ( ) ) ; <nl> - } <nl> - <nl> - if ( control = = null ) <nl> - continue ; <nl> - <nl> - string name ; <nl> - <nl> - if ( control is Control ) <nl> - name = ( ( Control ) control ) . Name ; <nl> - else <nl> - name = control . GetType ( ) . Name ; <nl> - <nl> - if ( control is Form & & ! string . IsNullOrEmpty ( name ) ) <nl> - { <nl> - if ( ! translateCategories . Items . Contains ( name ) ) <nl> - translateCategories . Items . Add ( name ) ; <nl> - <nl> - AddTranslationItem ( name , \" $ this \" , \" Text \" , ( ( Form ) control ) . Text ) ; <nl> - } <nl> - <nl> - foreach ( FieldInfo fieldInfo in control . GetType ( ) . GetFields ( BindingFlags . NonPublic | BindingFlags . Instance | BindingFlags . Static ) ) <nl> - { <nl> - / / Skip controls with a name started with \" _NO_TRANSLATE_ \" <nl> - / / this is a naming convention , these are not translated <nl> - if ( fieldInfo . Name . StartsWith ( \" _NO_TRANSLATE_ \" ) ) <nl> - continue ; <nl> - <nl> - var component = fieldInfo . GetValue ( control ) as Component ; <nl> - <nl> - if ( component ! = null ) <nl> - { <nl> - foreach ( PropertyInfo propertyInfo in fieldInfo . FieldType . GetProperties ( BindingFlags . Public | BindingFlags . Instance | BindingFlags . Static ) ) <nl> - { <nl> - if ( propertyInfo . PropertyType = = typeof ( string ) & & ShouldBeTranslated ( propertyInfo ) ) <nl> - { <nl> - var value = ( string ) propertyInfo . GetValue ( component , null ) ; <nl> - <nl> - / / Only translate properties that have a neutral value <nl> - if ( ! string . IsNullOrEmpty ( value ) ) <nl> - { <nl> - AddTranslationItem ( name , fieldInfo . Name , propertyInfo . Name , value ) ; <nl> - } <nl> - } <nl> - <nl> - / * <nl> - var t = propertyInfo . GetCustomAttributes ( true ) ; <nl> - if ( t . Length > 0 ) <nl> - { <nl> - <nl> - } <nl> - * / <nl> - } <nl> - } <nl> - } <nl> - } <nl> + AddTranslationItem ( className , \" $ this \" , \" Text \" , ( ( Form ) obj ) . Text ) ; <nl> } <nl> } <nl> - catch ( Exception ) <nl> + <nl> + foreach ( FieldInfo fieldInfo in obj . GetType ( ) . GetFields ( BindingFlags . NonPublic | BindingFlags . Instance | BindingFlags . Static ) ) <nl> { <nl> + / / Skip controls with a name started with \" _NO_TRANSLATE_ \" <nl> + / / this is a naming convention , these are not translated <nl> + if ( fieldInfo . Name . StartsWith ( \" _NO_TRANSLATE_ \" ) ) <nl> + continue ; <nl> + <nl> + GetTranslatableFromComponent ( className , obj , fieldInfo ) ; <nl> + GetTranslatableFromDataGridViewElement ( className , obj , fieldInfo ) ; <nl> } <nl> } <nl> - <nl> } <nl> finally <nl> { <nl> public void GetPropertiesToTranslate ( ) <nl> } <nl> } <nl> <nl> - private static bool ShouldBeTranslated ( PropertyInfo propertyInfo ) <nl> + private bool IsTranslatableItemInComponent ( PropertyInfo propertyInfo ) <nl> { <nl> + if ( propertyInfo . PropertyType ! = typeof ( string ) ) <nl> + return false ; <nl> if ( propertyInfo . Name . Equals ( \" Caption \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> return true ; <nl> if ( propertyInfo . Name . Equals ( \" Text \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> private static bool ShouldBeTranslated ( PropertyInfo propertyInfo ) <nl> return true ; <nl> if ( propertyInfo . Name . Equals ( \" Title \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> return true ; <nl> + return false ; <nl> + } <nl> <nl> + private bool IsTranslatableItemInDataGridViewElement ( PropertyInfo propertyInfo , FieldInfo fieldInfo , Object obj ) <nl> + { <nl> + if ( propertyInfo . Name . Equals ( \" HeaderText \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + DataGridViewColumn viewCol = fieldInfo . GetValue ( obj ) as DataGridViewColumn ; <nl> + if ( viewCol . Visible ) <nl> + return true ; <nl> + else <nl> + return false ; <nl> + } <nl> return false ; <nl> } <nl> <nl>\n", "msg": "Added support for DataGridViewElements ( e . g . FormRemotes ) and Refactoring\n", "score": 1}
{"diff_id": 973, "repo": "OpenRA/OpenRA\n", "sha": "aadfcdac66e33dd1bddf1478ac280dd69166bcf8\n", "time": "2017-10-25T23:28:42Z\n", "diff": "mmm a / OpenRA . Mods . Common / Traits / Buildings / RallyPoint . cs <nl> ppp b / OpenRA . Mods . Common / Traits / Buildings / RallyPoint . cs <nl> public class RallyPointInfo : ITraitInfo <nl> [ SequenceReference ( \" Image \" ) ] public readonly string FlagSequence = \" flag \" ; <nl> [ SequenceReference ( \" Image \" ) ] public readonly string CirclesSequence = \" circles \" ; <nl> <nl> + public readonly string Cursor = \" ability \" ; <nl> + <nl> [ Desc ( \" Custom indicator palette name \" ) ] <nl> [ PaletteReference ( \" IsPlayerPalette \" ) ] public readonly string Palette = \" player \" ; <nl> <nl> public void OnOwnerChanged ( Actor self , Player oldOwner , Player newOwner ) <nl> <nl> public IEnumerable < IOrderTargeter > Orders <nl> { <nl> - get { yield return new RallyPointOrderTargeter ( ) ; } <nl> + get { yield return new RallyPointOrderTargeter ( Info . Cursor ) ; } <nl> } <nl> <nl> public Order IssueOrder ( Actor self , IOrderTargeter order , Target target , bool queued ) <nl> public static bool IsForceSet ( Order order ) <nl> <nl> class RallyPointOrderTargeter : IOrderTargeter <nl> { <nl> + readonly string cursor ; <nl> + <nl> + public RallyPointOrderTargeter ( string cursor ) <nl> + { <nl> + this . cursor = cursor ; <nl> + } <nl> + <nl> public string OrderID { get { return \" SetRallyPoint \" ; } } <nl> public int OrderPriority { get { return 0 ; } } <nl> public bool TargetOverridesSelection ( TargetModifiers modifiers ) { return true ; } <nl> public bool CanTarget ( Actor self , Target target , List < Actor > othersAtTarget , ref <nl> var location = self . World . Map . CellContaining ( target . CenterPosition ) ; <nl> if ( self . World . Map . Contains ( location ) ) <nl> { <nl> - cursor = \" ability \" ; <nl> + cursor = this . cursor ; <nl> <nl> / / Notify force - set ' RallyPoint ' order watchers with Ctrl and only if this is the only building of its type selected <nl> if ( modifiers . HasModifier ( TargetModifiers . ForceAttack ) ) <nl>\n", "msg": "Allow RallyPoint cursor to be defined via Yaml\n", "score": 1}
{"diff_id": 1094, "repo": "Sonarr/Sonarr\n", "sha": "1f2a1e32066b276bcd62534682bcd9e8efe34f6d\n", "time": "2011-09-05T22:26:53Z\n", "diff": "mmm a / NzbDrone . Core / Providers / Jobs / SeasonSearchJob . cs <nl> ppp b / NzbDrone . Core / Providers / Jobs / SeasonSearchJob . cs <nl> public virtual void Start ( ProgressNotification notification , int targetId , int s <nl> var missingEpisodes = episodeNumbers . Except ( addedSeries ) . ToList ( ) ; <nl> <nl> / / Only process episodes that is in missing episodes ( To ensure we double check if the episode is available ) <nl> - foreach ( var episode in episodes . Where ( e = > ! e . Ignored & & missingEpisodes . Contains ( e . EpisodeNumber ) ) ) <nl> + foreach ( var episode in episodes . Where ( e = > ! e . Ignored & & missingEpisodes . Contains ( e . EpisodeNumber ) ) . OrderBy ( o = > o . EpisodeNumber ) ) <nl> { <nl> _episodeSearchJob . Start ( notification , episode . EpisodeId , 0 ) ; <nl> } <nl>\n", "msg": "Season searching fallback to individual episodes will done in order from 1 to n .\n", "score": 1}
{"diff_id": 1130, "repo": "AvaloniaUI/Avalonia\n", "sha": "cecbe8fefe4ea48e9dd92841eacb443dbac4bbe9\n", "time": "2016-08-04T19:48:39Z\n", "diff": "mmm a / tests / Avalonia . Base . UnitTests / AvaloniaObjectTests_Direct . cs <nl> ppp b / tests / Avalonia . Base . UnitTests / AvaloniaObjectTests_Direct . cs <nl> public void Binding_To_Direct_Property_Does_Not_Get_Collected ( ) <nl> public void Binding_To_Direct_Property_Gets_Collected_When_Completed ( ) <nl> { <nl> var target = new Class2 ( ) ; <nl> - <nl> - Func < WeakReference > setupBinding = ( ) = > <nl> - { <nl> - var source = new Subject < string > ( ) ; <nl> - var sub = target . Bind ( ( AvaloniaProperty ) Class1 . FooProperty , source ) ; <nl> - return new WeakReference ( source ) ; <nl> - } ; <nl> - <nl> - var weakSource = setupBinding ( ) ; <nl> + var weakSource = SetupDirectBinding ( target ) ; <nl> <nl> Action completeSource = ( ) = > <nl> { <nl> public void Binding_To_Direct_Property_Logs_BindingError ( ) <nl> Assert . True ( called ) ; <nl> } <nl> <nl> + private WeakReference SetupDirectBinding ( Class2 target ) <nl> + { <nl> + var source = new Subject < string > ( ) ; <nl> + var sub = target . Bind ( ( AvaloniaProperty ) Class1 . FooProperty , source ) ; <nl> + return new WeakReference ( source ) ; <nl> + } <nl> + <nl> private class Class1 : AvaloniaObject <nl> { <nl> public static readonly DirectProperty < Class1 , string > FooProperty = <nl>\n", "msg": "Move WeakReference setup to separate method .\n", "score": 1}
{"diff_id": 1435, "repo": "dotnet/aspnetcore\n", "sha": "c567a690bc4364c536a727dd3b64227bb574a0ec\n", "time": "2017-10-26T19:41:34Z\n", "diff": "mmm a / src / Microsoft . AspNetCore . Mvc . Core / ControllerBase . cs <nl> ppp b / src / Microsoft . AspNetCore . Mvc . Core / ControllerBase . cs <nl> <nl> using System ; <nl> using System . IO ; <nl> using System . Linq . Expressions ; <nl> + using System . Net ; <nl> using System . Security . Claims ; <nl> using System . Text ; <nl> using System . Threading . Tasks ; <nl> public IObjectModelValidator ObjectValidator <nl> [ NonAction ] <nl> public virtual StatusCodeResult StatusCode ( int statusCode ) <nl> = > new StatusCodeResult ( statusCode ) ; <nl> + <nl> + / / / < summary > <nl> + / / / Creates a < see cref = \" StatusCodeResult \" / > object by specifying a < paramref name = \" statusCode \" / > . <nl> + / / / < / summary > <nl> + / / / < param name = \" statusCode \" > The status code to set on the response . < / param > <nl> + / / / < returns > The created < see cref = \" StatusCodeResult \" / > object for the response . < / returns > <nl> + [ NonAction ] <nl> + public virtual StatusCodeResult StatusCode ( HttpStatusCode statusCode ) <nl> + = > StatusCode ( ( int ) statusCode ) ; <nl> <nl> / / / < summary > <nl> / / / Creates a < see cref = \" ObjectResult \" / > object by specifying a < paramref name = \" statusCode \" / > and < paramref name = \" value \" / > <nl>\n", "msg": "[ Fixes ] Added an overload for StatusCode that takes in System . Net . HttpStatusCode\n", "score": 1}
{"diff_id": 1646, "repo": "ppy/osu\n", "sha": "7d5f5d2fd9272e207bc26860e76f613ce01e38ec\n", "time": "2019-10-04T14:55:33Z\n", "diff": "mmm a / osu . Game / Overlays / BeatmapSet / Header . cs <nl> ppp b / osu . Game / Overlays / BeatmapSet / Header . cs <nl> <nl> <nl> using System . Linq ; <nl> using osu . Framework . Allocation ; <nl> + using osu . Framework . Bindables ; <nl> using osu . Framework . Extensions . Color4Extensions ; <nl> using osu . Framework . Graphics ; <nl> using osu . Framework . Graphics . Colour ; <nl> <nl> using osu . Game . Online ; <nl> using osu . Game . Overlays . BeatmapSet . Buttons ; <nl> using osu . Game . Overlays . Direct ; <nl> + using osu . Game . Rulesets ; <nl> using osuTK ; <nl> using osuTK . Graphics ; <nl> <nl> public class Header : BeatmapDownloadTrackingComposite <nl> <nl> public bool DownloadButtonsVisible = > downloadButtonsContainer . Any ( ) ; <nl> <nl> + public readonly BeatmapRulesetSelector RulesetSelector ; <nl> public readonly BeatmapPicker Picker ; <nl> <nl> private readonly FavouriteButton favouriteButton ; <nl> public Header ( ) <nl> { <nl> RelativeSizeAxes = Axes . X , <nl> Height = tabs_height , <nl> - Children = new [ ] <nl> + Children = new Drawable [ ] <nl> { <nl> tabsBg = new Box <nl> { <nl> RelativeSizeAxes = Axes . Both , <nl> } , <nl> + RulesetSelector = new BeatmapRulesetSelector <nl> + { <nl> + Anchor = Anchor . BottomCentre , <nl> + Origin = Anchor . BottomCentre , <nl> + } <nl> } , <nl> } , <nl> new Container <nl> public Header ( ) <nl> } ; <nl> } <nl> <nl> + protected override IReadOnlyDependencyContainer CreateChildDependencies ( IReadOnlyDependencyContainer parent ) <nl> + { <nl> + var dependencies = new DependencyContainer ( base . CreateChildDependencies ( parent ) ) ; <nl> + dependencies . CacheAs < IBindable < RulesetInfo > > ( RulesetSelector . Current ) ; <nl> + return dependencies ; <nl> + } <nl> + <nl> [ BackgroundDependencyLoader ] <nl> private void load ( OsuColour colours ) <nl> { <nl> private void load ( OsuColour colours ) <nl> <nl> BeatmapSet . BindValueChanged ( setInfo = > <nl> { <nl> - Picker . BeatmapSet = author . BeatmapSet = beatmapAvailability . BeatmapSet = Details . BeatmapSet = setInfo . NewValue ; <nl> + Picker . BeatmapSet = RulesetSelector . BeatmapSet = author . BeatmapSet = beatmapAvailability . BeatmapSet = Details . BeatmapSet = setInfo . NewValue ; <nl> cover . BeatmapSet = setInfo . NewValue ; <nl> <nl> if ( setInfo . NewValue = = null ) <nl>\n", "msg": "Add ruleset selector to the beatmap overlay header\n", "score": 1}
{"diff_id": 2094, "repo": "dotnet/roslyn\n", "sha": "a1dc6251cecbb0d7f936c8da274757e328b501e3\n", "time": "2016-06-04T02:04:44Z\n", "diff": "mmm a / src / Features / Core / Portable / ReplacePropertyWithMethods / AbstractReplacePropertyWithMethodsService . cs <nl> ppp b / src / Features / Core / Portable / ReplacePropertyWithMethods / AbstractReplacePropertyWithMethodsService . cs <nl> protected static SyntaxNode GetFieldReference ( SyntaxGenerator generator , IFieldS <nl> referenceReplacer . Do ( ) ; <nl> } <nl> <nl> + private delegate TExpressionSyntax GetWriteValue ( ReferenceReplacer replacer , SyntaxNode parent ) ; <nl> + <nl> private struct ReferenceReplacer <nl> { <nl> private readonly AbstractReplacePropertyWithMethodsService < TIdentifierNameSyntax , TExpressionSyntax , TStatementSyntax > _service ; <nl> private struct ReferenceReplacer <nl> private readonly TExpressionSyntax _expression ; <nl> private readonly CancellationToken _cancellationToken ; <nl> <nl> - private readonly Func < ReferenceReplacer , SyntaxNode , TExpressionSyntax > getRightHandSideOfParent ; <nl> - <nl> public ReferenceReplacer ( <nl> AbstractReplacePropertyWithMethodsService < TIdentifierNameSyntax , TExpressionSyntax , TStatementSyntax > service , <nl> SemanticModel semanticModel , <nl> private struct ReferenceReplacer <nl> { <nl> _expression = _expression . Parent as TExpressionSyntax ; <nl> } <nl> - <nl> - getRightHandSideOfParent = ( replacer , parent ) = > ( TExpressionSyntax ) replacer . _syntaxFacts . GetRightHandSideOfAssignment ( parent ) ; <nl> } <nl> <nl> + private static readonly GetWriteValue getWriteValueForLeftSideOfAssignment = <nl> + ( replacer , parent ) = > <nl> + { <nl> + return ( TExpressionSyntax ) replacer . _syntaxFacts . GetRightHandSideOfAssignment ( parent ) ; <nl> + } ; <nl> + <nl> + private static readonly GetWriteValue getWriteValueForIncrementOrDecrement = <nl> + ( replacer , parent ) = > <nl> + { <nl> + / / We ' re being read from and written to ( i . e . Prop + + ) , we need to replace with a <nl> + / / Get and a Set call . <nl> + var readExpression = replacer . GetReadExpression ( keepTrivia : false , conflictMessage : null ) ; <nl> + var literalOne = replacer . Generator . LiteralExpression ( 1 ) ; <nl> + <nl> + var writeValue = replacer . _syntaxFacts . IsOperandOfIncrementExpression ( replacer . _expression ) <nl> + ? replacer . Generator . AddExpression ( readExpression , literalOne ) <nl> + : replacer . Generator . SubtractExpression ( readExpression , literalOne ) ; <nl> + <nl> + return ( TExpressionSyntax ) writeValue ; <nl> + } ; <nl> + <nl> + private static GetWriteValue getWriteValueForCompoundAssignment = <nl> + ( replacer , parent ) = > <nl> + { <nl> + var readExpression = replacer . GetReadExpression ( keepTrivia : false , conflictMessage : null ) ; <nl> + <nl> + / / Convert \" Prop * = X \" into \" Prop * X \" . <nl> + return replacer . _service . UnwrapCompoundAssignment ( parent , readExpression ) ; <nl> + } ; <nl> + <nl> private SyntaxGenerator Generator = > _editor . Generator ; <nl> <nl> public void Do ( ) <nl> public void Do ( ) <nl> { <nl> / / We ' re only being written to here . This is safe to replace with a call to the <nl> / / setter . <nl> - var replacer = this ; <nl> ReplaceWrite ( <nl> - getWriteValue : getRightHandSideOfParent , <nl> + getWriteValueForLeftSideOfAssignment , <nl> keepTrivia : true , <nl> conflictMessage : null ) ; <nl> } <nl> public void Do ( ) <nl> } <nl> else if ( _syntaxFacts . IsOperandOfIncrementOrDecrementExpression ( _expression ) ) <nl> { <nl> - / / We ' re being read from and written to ( i . e . Prop + + ) , we need to replace with a <nl> - / / Get and a Set call . <nl> - var readExpression = GetReadExpression ( keepTrivia : false , conflictMessage : null ) ; <nl> - var literalOne = Generator . LiteralExpression ( 1 ) ; <nl> - <nl> - var writeValue = _syntaxFacts . IsOperandOfIncrementExpression ( _expression ) <nl> - ? Generator . AddExpression ( readExpression , literalOne ) <nl> - : Generator . SubtractExpression ( readExpression , literalOne ) ; <nl> - <nl> - ReplaceWrite ( ( TExpressionSyntax ) writeValue , keepTrivia : true , conflictMessage : null ) ; <nl> + ReplaceWrite ( <nl> + getWriteValueForIncrementOrDecrement , <nl> + keepTrivia : true , <nl> + conflictMessage : null ) ; <nl> } <nl> else if ( _syntaxFacts . IsInferredAnonymousObjectMemberDeclarator ( _expression . Parent ) ) / / . IsParentKind ( SyntaxKind . AnonymousObjectMemberDeclarator ) ) <nl> { <nl> private void ReplaceRead ( bool keepTrivia , string conflictMessage ) <nl> } <nl> <nl> private void ReplaceWrite ( <nl> - TExpressionSyntax writeValue , <nl> - bool keepTrivia , <nl> - string conflictMessage ) <nl> - { <nl> - ReplaceWrite ( ( _1 , _2 ) = > writeValue , keepTrivia , conflictMessage ) ; <nl> - } <nl> - <nl> - private void ReplaceWrite ( <nl> - Func < ReferenceReplacer , SyntaxNode , TExpressionSyntax > getWriteValue , <nl> + GetWriteValue getWriteValue , <nl> bool keepTrivia , <nl> string conflictMessage ) <nl> { <nl> private void HandleCompoundAssignExpression ( ) <nl> { <nl> / / We ' re being read from and written to from a compound assignment <nl> / / ( i . e . Prop * = X ) , we need to replace with a Get and a Set call . <nl> - <nl> ReplaceWrite ( <nl> - getWriteValue : ( replacer , parent ) = > <nl> - { <nl> - var readExpression = replacer . GetReadExpression ( keepTrivia : false , conflictMessage : null ) ; <nl> - <nl> - / / Convert \" Prop * = X \" into \" Prop * X \" . <nl> - return replacer . _service . UnwrapCompoundAssignment ( parent , readExpression ) ; <nl> - } , <nl> - keepTrivia : true , conflictMessage : null ) ; <nl> + getWriteValueForCompoundAssignment , <nl> + keepTrivia : true , <nl> + conflictMessage : null ) ; <nl> } <nl> <nl> private static TIdentifierNameSyntax AddConflictAnnotation ( TIdentifierNameSyntax name , string conflictMessage ) <nl>\n", "msg": "Extract out statics to prevent allocations .\n", "score": 1}
{"diff_id": 2593, "repo": "OpenRA/OpenRA\n", "sha": "c42a6f8386bf716634d458474839a58317bf5381\n", "time": "2013-12-26T04:23:13Z\n", "diff": "mmm a / OpenRA . Game / Graphics / TerrainRenderer . cs <nl> ppp b / OpenRA . Game / Graphics / TerrainRenderer . cs <nl> public TerrainRenderer ( World world , WorldRenderer wr ) <nl> int nv = 0 ; <nl> <nl> for ( var j = map . Bounds . Top ; j < map . Bounds . Bottom ; j + + ) <nl> + { <nl> for ( var i = map . Bounds . Left ; i < map . Bounds . Right ; i + + ) <nl> { <nl> var tile = wr . Theater . TileSprite ( map . MapTiles . Value [ i , j ] ) ; <nl> - Util . FastCreateQuad ( vertices , Game . CellSize * new float2 ( i , j ) , tile , terrainPalette , nv , tile . size ) ; <nl> + var pos = wr . ScreenPosition ( new CPos ( i , j ) . CenterPosition ) - 0 . 5f * tile . size ; <nl> + Util . FastCreateQuad ( vertices , pos , tile , terrainPalette , nv , tile . size ) ; <nl> nv + = 4 ; <nl> } <nl> + } <nl> <nl> vertexBuffer = Game . Renderer . Device . CreateVertexBuffer ( vertices . Length ) ; <nl> vertexBuffer . SetData ( vertices , nv ) ; <nl>\n", "msg": "Convert terrain rendering to world coords .\n", "score": 1}
{"diff_id": 3325, "repo": "mRemoteNG/mRemoteNG\n", "sha": "c57bd386f2ae3d788d33c7e4722a7a1da1171a9c\n", "time": "2018-05-19T21:57:34Z\n", "diff": "mmm a / mRemoteV1 / UI / Controls / QuickConnectToolStrip . cs <nl> ppp b / mRemoteV1 / UI / Controls / QuickConnectToolStrip . cs <nl> <nl> using mRemoteNG . App ; <nl> using mRemoteNG . Connection ; <nl> using mRemoteNG . Connection . Protocol ; <nl> + using mRemoteNG . Container ; <nl> using mRemoteNG . Themes ; <nl> using mRemoteNG . Tools ; <nl> <nl> private void btnConnections_DropDownOpening ( object sender , EventArgs e ) <nl> private void ConnectionsMenuItem_MouseUp ( object sender , MouseEventArgs e ) <nl> { <nl> if ( e . Button ! = MouseButtons . Left ) return ; <nl> - var tag = ( ( ToolStripMenuItem ) sender ) . Tag as ConnectionInfo ; <nl> - if ( tag ! = null ) <nl> + var menuItem = ( ToolStripMenuItem ) sender ; <nl> + <nl> + / / While we can connect to a whole folder at once , it is <nl> + / / probably not the expected behavior when navigating through <nl> + / / a nested menu . Just return <nl> + var containerInfo = menuItem . Tag as ContainerInfo ; <nl> + if ( containerInfo ! = null ) <nl> + return ; <nl> + <nl> + var connectionInfo = menuItem . Tag as ConnectionInfo ; <nl> + if ( connectionInfo ! = null ) <nl> { <nl> - ConnectionInitiator . OpenConnection ( tag ) ; <nl> + ConnectionInitiator . OpenConnection ( connectionInfo ) ; <nl> } <nl> } <nl> # endregion <nl>\n", "msg": "dont try to connect to folders in quick connect menu . resolves\n", "score": 1}
{"diff_id": 3910, "repo": "AvaloniaUI/Avalonia\n", "sha": "c52804cc0f8c3b0833a1d4bbb37d8a2252824b4b\n", "time": "2020-11-08T21:17:11Z\n", "diff": "mmm a / src / Avalonia . Visuals / Media / FontFamily . cs <nl> ppp b / src / Avalonia . Visuals / Media / FontFamily . cs <nl> private static FontFamilyIdentifier GetFontFamilyIdentifier ( string name ) <nl> } <nl> } <nl> <nl> + / / / < summary > <nl> + / / / Parses a < see cref = \" T : Avalonia . Media . FontFamily \" / > string . <nl> + / / / < / summary > <nl> + / / / < param name = \" s \" > The < see cref = \" T : Avalonia . Media . FontFamily \" / > string . < / param > <nl> + / / / < returns > < / returns > <nl> + / / / < exception cref = \" ArgumentException \" > <nl> + / / / Specified family is not supported . <nl> + / / / < / exception > <nl> + public static FontFamily Parse ( string s ) = > Parse ( s , null ) ; <nl> + <nl> / / / < summary > <nl> / / / Parses a < see cref = \" T : Avalonia . Media . FontFamily \" / > string . <nl> / / / < / summary > <nl> private static FontFamilyIdentifier GetFontFamilyIdentifier ( string name ) <nl> / / / < exception cref = \" ArgumentException \" > <nl> / / / Specified family is not supported . <nl> / / / < / exception > <nl> - public static FontFamily Parse ( string s , Uri baseUri = null ) <nl> + public static FontFamily Parse ( string s , Uri baseUri ) <nl> { <nl> if ( string . IsNullOrEmpty ( s ) ) <nl> { <nl>\n", "msg": "Add a single argument Parse function for FontFamily .\n", "score": 1}
{"diff_id": 3921, "repo": "aspnetboilerplate/aspnetboilerplate\n", "sha": "d8157b81813104a8488f4cdf7c9ad4cb12815a53\n", "time": "2020-04-30T05:54:02Z\n", "diff": "mmm a / src / Abp . ZeroCore / Authorization / Roles / AbpRoleManager . cs <nl> ppp b / src / Abp . ZeroCore / Authorization / Roles / AbpRoleManager . cs <nl> public virtual async Task < IReadOnlyList < Permission > > GetGrantedPermissionsAsync ( <nl> / / / < returns > List of granted permissions < / returns > <nl> public virtual async Task < IReadOnlyList < Permission > > GetGrantedPermissionsAsync ( TRole role ) <nl> { <nl> - var permissionList = new List < Permission > ( ) ; <nl> - <nl> - foreach ( var permission in _permissionManager . GetAllPermissions ( ) ) <nl> - { <nl> - if ( await IsGrantedAsync ( role . Id , permission ) ) <nl> - { <nl> - permissionList . Add ( permission ) ; <nl> - } <nl> - } <nl> - <nl> - return permissionList ; <nl> + var cacheItem = await GetRolePermissionCacheItemAsync ( role . Id ) ; <nl> + var allPermissions = _permissionManager . GetAllPermissions ( ) ; <nl> + var grantedPermissions = allPermissions . Select ( x = > x . Name ) . Intersect ( cacheItem . GrantedPermissions ) ; <nl> + return allPermissions . Where ( x = > grantedPermissions . Contains ( x . Name ) ) . ToList ( ) ; <nl> } <nl> <nl> / / / < summary > <nl>\n", "msg": "Enhance the performance of GetGrantedPermissionsAsync .\n", "score": 1}
{"diff_id": 4052, "repo": "abpframework/abp\n", "sha": "0df437d876b3758d10d7d4f3dc83887edd5c0126\n", "time": "2020-05-18T23:12:17Z\n", "diff": "mmm a / framework / src / Volo . Abp . AspNetCore . Mvc . UI / Volo / Abp / ObjectExtending / MvcUiObjectExtensionPropertyInfoExtensions . cs <nl> ppp b / framework / src / Volo . Abp . AspNetCore . Mvc . UI / Volo / Abp / ObjectExtending / MvcUiObjectExtensionPropertyInfoExtensions . cs <nl> public static class MvcUiObjectExtensionPropertyInfoExtensions <nl> typeof ( ulong ) , <nl> typeof ( float ) , <nl> typeof ( double ) , <nl> + typeof ( decimal ) , <nl> typeof ( int ? ) , <nl> typeof ( long ? ) , <nl> typeof ( byte ? ) , <nl> public static class MvcUiObjectExtensionPropertyInfoExtensions <nl> typeof ( ulong ? ) , <nl> typeof ( float ? ) , <nl> typeof ( double ? ) , <nl> + typeof ( decimal ? ) <nl> } ; <nl> <nl> public static string GetInputFormatOrNull ( this IBasicObjectExtensionPropertyInfo property ) <nl>\n", "msg": "Add decimal to NumberTypes for extension properties\n", "score": 1}
{"diff_id": 4110, "repo": "HangfireIO/Hangfire\n", "sha": "b374633caf69f8cf262a88b954614a30785ad95b\n", "time": "2016-07-05T09:34:54Z\n", "diff": "mmm a / src / Hangfire . Core / Server / BackgroundProcessingServer . cs <nl> ppp b / src / Hangfire . Core / Server / BackgroundProcessingServer . cs <nl> private static IServerProcess WrapProcess ( IServerProcess process ) <nl> <nl> private static string GetGloballyUniqueServerId ( ) <nl> { <nl> - return $ \" { Environment . GetEnvironmentVariable ( \" COMPUTERNAME \" ) . ToLowerInvariant ( ) } : { Process . GetCurrentProcess ( ) . Id } : { Guid . NewGuid ( ) } \" ; <nl> + var hostName = Environment . GetEnvironmentVariable ( \" COMPUTERNAME \" ) <nl> + ? ? Environment . GetEnvironmentVariable ( \" HOSTNAME \" ) ; <nl> + <nl> + return $ \" { hostName . ToLowerInvariant ( ) } : { Process . GetCurrentProcess ( ) . Id } : { Guid . NewGuid ( ) } \" ; <nl> } <nl> <nl> private static ServerContext GetServerContext ( IReadOnlyDictionary < string , object > properties ) <nl>\n", "msg": "Use HOSTNAME environment variable for unix\n", "score": 1}
{"diff_id": 4655, "repo": "OpenRA/OpenRA\n", "sha": "112034a41d59099f7d8d49e35a8f9764974eac70\n", "time": "2013-05-17T15:59:46Z\n", "diff": "mmm a / OpenRA . FileFormats / Filesystem / MixFile . cs <nl> ppp b / OpenRA . FileFormats / Filesystem / MixFile . cs <nl> <nl> <nl> using System ; <nl> using System . Collections . Generic ; <nl> + using System . Globalization ; <nl> using System . IO ; <nl> using System . Linq ; <nl> <nl> uint [ ] ReadBlocks ( Stream s , long offset , int count ) <nl> return ret ; <nl> } <nl> <nl> + uint ? FindMatchingHash ( string filename ) <nl> + { <nl> + / / Try first as a TD / RA hash <nl> + var hash = PackageEntry . HashFilename ( filename ) ; <nl> + if ( index . ContainsKey ( hash ) ) <nl> + return hash ; <nl> + <nl> + / / Fall back to TS / RA2 hash style <nl> + var crc = PackageEntry . CrcHashFilename ( filename ) ; <nl> + if ( index . ContainsKey ( crc ) ) <nl> + return hash ; <nl> + <nl> + / / Test for a raw hash before giving up <nl> + uint raw ; <nl> + if ( ! uint . TryParse ( filename , NumberStyles . AllowHexSpecifier , CultureInfo . InvariantCulture , out raw ) ) <nl> + return null ; <nl> + <nl> + if ( \" { 0 : X } \" . F ( raw ) = = filename & & index . ContainsKey ( raw ) ) <nl> + return raw ; <nl> + <nl> + return null ; <nl> + } <nl> + <nl> public Stream GetContent ( uint hash ) <nl> { <nl> PackageEntry e ; <nl> public Stream GetContent ( uint hash ) <nl> <nl> public Stream GetContent ( string filename ) <nl> { <nl> - var content = GetContent ( PackageEntry . HashFilename ( filename ) ) ; / / RA1 and TD <nl> - if ( content ! = null ) <nl> - return content ; <nl> - else <nl> - return GetContent ( PackageEntry . CrcHashFilename ( filename ) ) ; / / TS <nl> + var hash = FindMatchingHash ( filename ) ; <nl> + return hash . HasValue ? GetContent ( hash . Value ) : null ; <nl> } <nl> <nl> public IEnumerable < uint > AllFileHashes ( ) <nl> public IEnumerable < string > AllFileNames ( ) <nl> } <nl> } <nl> <nl> - return index . Keys . Select ( k = > lookup . ContainsKey ( k ) ? lookup [ k ] : \" Unknown File [ { 0 } ] \" . F ( k ) ) ; <nl> + return index . Keys . Select ( k = > lookup . ContainsKey ( k ) ? lookup [ k ] : \" { 0 : X } \" . F ( k ) ) ; <nl> } <nl> <nl> public bool Exists ( string filename ) <nl> { <nl> - return ( index . ContainsKey ( PackageEntry . HashFilename ( filename ) ) | | index . ContainsKey ( PackageEntry . CrcHashFilename ( filename ) ) ) ; <nl> + return FindMatchingHash ( filename ) . HasValue ; <nl> } <nl> <nl> - <nl> public int Priority <nl> { <nl> get { return 1000 + priority ; } <nl>\n", "msg": "Allow hashes to be accepted as valid mix filenames .\n", "score": 1}
{"diff_id": 4918, "repo": "QuantConnect/Lean\n", "sha": "794c71bb553274bc8016318b268f948649094269\n", "time": "2018-03-23T21:07:37Z\n", "diff": "mmm a / Algorithm . Framework / Selection / ManualPortfolioSelectionModel . cs <nl> ppp b / Algorithm . Framework / Selection / ManualPortfolioSelectionModel . cs <nl> public ManualPortfolioSelectionModel ( IEnumerable < Symbol > symbols ) <nl> / / / < / summary > <nl> / / / < param name = \" symbols \" > The symbols to subscribe to < / param > <nl> public ManualPortfolioSelectionModel ( params Symbol [ ] symbols ) <nl> + : this ( symbols ? . AsEnumerable ( ) , null , null ) <nl> { <nl> - if ( symbols = = null ) <nl> - { <nl> - throw new ArgumentNullException ( nameof ( symbols ) ) ; <nl> - } <nl> - <nl> - _symbols = symbols . ToList ( ) ; <nl> } <nl> <nl> / / / < summary > <nl> public ManualPortfolioSelectionModel ( params Symbol [ ] symbols ) <nl> / / / < param name = \" securityInitializer \" > Optional security initializer invoked when creating new securities , specify null to use algorithm . SecurityInitializer < / param > <nl> public ManualPortfolioSelectionModel ( IEnumerable < Symbol > symbols , UniverseSettings universeSettings , ISecurityInitializer securityInitializer ) <nl> { <nl> + if ( symbols = = null ) <nl> + { <nl> + throw new ArgumentNullException ( nameof ( symbols ) ) ; <nl> + } <nl> + <nl> _symbols = symbols . ToList ( ) ; <nl> _universeSettings = universeSettings ; <nl> _securityInitializer = securityInitializer ; <nl> + <nl> + foreach ( var symbol in _symbols ) <nl> + { <nl> + SymbolCache . Set ( symbol . Value , symbol ) ; <nl> + } <nl> } <nl> <nl> / / / < summary > <nl>\n", "msg": "Add entries to SymbolCache for ManualPortoflioSelectionModel symbols\n", "score": 1}
{"diff_id": 6221, "repo": "jellyfin/jellyfin\n", "sha": "7668ecf9c95fe7deb8211704c24266d5b17f6c8c\n", "time": "2019-02-27T18:20:48Z\n", "diff": "mmm a / MediaBrowser . MediaEncoding / Encoder / EncoderValidator . cs <nl> ppp b / MediaBrowser . MediaEncoding / Encoder / EncoderValidator . cs <nl> <nl> <nl> namespace MediaBrowser . MediaEncoding . Encoder <nl> { <nl> - public class FFmpegVersion <nl> - { <nl> - private readonly int _major ; <nl> - private readonly int _minor ; <nl> - <nl> - private const int _unknown = 0 ; <nl> - <nl> - public FFmpegVersion ( string p1 ) <nl> - { <nl> - var match = Regex . Match ( p1 , @ \" ( ? < major > \\ d + ) \\ . ( ? < minor > \\ d + ) \" ) ; <nl> - <nl> - if ( match . Groups [ \" major \" ] . Success & & match . Groups [ \" minor \" ] . Success ) <nl> - { <nl> - _major = int . Parse ( match . Groups [ \" major \" ] . Value ) ; <nl> - _minor = int . Parse ( match . Groups [ \" minor \" ] . Value ) ; <nl> - } <nl> - else <nl> - { <nl> - _major = _unknown ; <nl> - _minor = _unknown ; <nl> - } <nl> - } <nl> - <nl> - public override string ToString ( ) <nl> - { <nl> - switch ( _major ) <nl> - { <nl> - case _unknown : <nl> - return \" Unknown \" ; <nl> - default : <nl> - return $ \" { _major } . { _minor } \" ; <nl> - } <nl> - } <nl> - <nl> - public bool Unknown ( ) <nl> - { <nl> - return _major = = _unknown ; <nl> - } <nl> - <nl> - public bool Below ( FFmpegVersion checkAgainst ) <nl> - { <nl> - return ToScalar ( ) < checkAgainst . ToScalar ( ) ; <nl> - } <nl> - <nl> - public bool Above ( FFmpegVersion checkAgainst ) <nl> - { <nl> - return ToScalar ( ) > checkAgainst . ToScalar ( ) ; <nl> - } <nl> - <nl> - public bool Same ( FFmpegVersion checkAgainst ) <nl> - { <nl> - return ToScalar ( ) = = checkAgainst . ToScalar ( ) ; <nl> - } <nl> - <nl> - private int ToScalar ( ) <nl> - { <nl> - return ( _major * 1000 ) + _minor ; <nl> - } <nl> - } <nl> - <nl> public class EncoderValidator <nl> { <nl> private readonly ILogger _logger ; <nl> public bool ValidateVersion ( string encoderAppPath , bool logOutput ) <nl> } <nl> <nl> / / The min and max FFmpeg versions required to run jellyfin successfully <nl> - FFmpegVersion minRequired = new FFmpegVersion ( \" 4 . 0 \" ) ; <nl> - FFmpegVersion maxRequired = new FFmpegVersion ( \" 4 . 0 \" ) ; <nl> + var minRequired = new Version ( 4 , 0 ) ; <nl> + var maxRequired = new Version ( 4 , 0 ) ; <nl> <nl> / / Work out what the version under test is <nl> - FFmpegVersion underTest = GetFFmpegVersion ( output ) ; <nl> + var underTest = GetFFmpegVersion ( output ) ; <nl> <nl> if ( logOutput ) <nl> { <nl> - _logger . LogInformation ( \" FFmpeg validation : Found ffmpeg version { 0 } \" , underTest . ToString ( ) ) ; <nl> + _logger . LogInformation ( \" FFmpeg validation : Found ffmpeg version { 0 } \" , underTest ! = null ? underTest . ToString ( ) : \" unknown \" ) ; <nl> <nl> - if ( underTest . Unknown ( ) ) <nl> + if ( underTest = = null ) / / Version is unknown <nl> { <nl> - if ( minRequired . Same ( maxRequired ) ) <nl> + if ( minRequired . Equals ( maxRequired ) ) <nl> { <nl> _logger . LogWarning ( \" FFmpeg validation : We recommend ffmpeg version { 0 } \" , minRequired . ToString ( ) ) ; <nl> } <nl> public bool ValidateVersion ( string encoderAppPath , bool logOutput ) <nl> _logger . LogWarning ( \" FFmpeg validation : We recommend a minimum of { 0 } and maximum of { 1 } \" , minRequired . ToString ( ) , maxRequired . ToString ( ) ) ; <nl> } <nl> } <nl> - else if ( underTest . Below ( minRequired ) ) <nl> + else if ( underTest . CompareTo ( minRequired ) < 0 ) / / Version is below what we recommend <nl> { <nl> _logger . LogWarning ( \" FFmpeg validation : The minimum recommended ffmpeg version is { 0 } \" , minRequired . ToString ( ) ) ; <nl> } <nl> - else if ( underTest . Above ( maxRequired ) ) <nl> + else if ( underTest . CompareTo ( maxRequired ) > 0 ) / / Version is above what we recommend <nl> { <nl> _logger . LogWarning ( \" FFmpeg validation : The maximum recommended ffmpeg version is { 0 } \" , maxRequired . ToString ( ) ) ; <nl> } <nl> - else <nl> + else / / Version is ok <nl> { <nl> _logger . LogInformation ( \" FFmpeg validation : Found suitable ffmpeg version \" ) ; <nl> } <nl> } <nl> <nl> - return ! underTest . Below ( minRequired ) & & ! underTest . Above ( maxRequired ) ; <nl> + / / underTest shall be null if versions is unknown <nl> + return ( underTest = = null ) ? false : ! ( underTest . CompareTo ( minRequired ) < 0 ) & & ! ( underTest . CompareTo ( maxRequired ) > 0 ) ; <nl> } <nl> <nl> / / / < summary > <nl> public bool ValidateVersion ( string encoderAppPath , bool logOutput ) <nl> / / / < / summary > <nl> / / / < param name = \" output \" > < / param > <nl> / / / < returns > < / returns > <nl> - static private FFmpegVersion GetFFmpegVersion ( string output ) <nl> + static private Version GetFFmpegVersion ( string output ) <nl> { <nl> / / For pre - built binaries the FFmpeg version should be mentioned at the very start of the output <nl> var match = Regex . Match ( output , @ \" ffmpeg version ( \\ d + \\ . \\ d + ) \" ) ; <nl> <nl> if ( match . Success ) <nl> { <nl> - return new FFmpegVersion ( match . Groups [ 1 ] . Value ) ; <nl> + return new Version ( match . Groups [ 1 ] . Value ) ; <nl> } <nl> else <nl> { <nl> / / Try and use the individual library versions to determine a FFmpeg version <nl> / / This lookup table is to be maintained with the following command line : <nl> / / $ . / ffmpeg . exe - version | perl - ne ' print \" $ 1 = $ 2 . $ 3 , \" if / ^ ( lib \\ w + ) \\ s + ( \\ d + ) \\ . \\ s * ( \\ d + ) / ' <nl> - var lut = new ReadOnlyDictionary < FFmpegVersion , string > <nl> - ( new Dictionary < FFmpegVersion , string > <nl> + var lut = new ReadOnlyDictionary < Version , string > <nl> + ( new Dictionary < Version , string > <nl> { <nl> - { new FFmpegVersion ( \" 4 . 1 \" ) , \" libavutil = 56 . 22 , libavcodec = 58 . 35 , libavformat = 58 . 20 , libavdevice = 58 . 5 , libavfilter = 7 . 40 , libswscale = 5 . 3 , libswresample = 3 . 3 , libpostproc = 55 . 3 , \" } , <nl> - { new FFmpegVersion ( \" 4 . 0 \" ) , \" libavutil = 56 . 14 , libavcodec = 58 . 18 , libavformat = 58 . 12 , libavdevice = 58 . 3 , libavfilter = 7 . 16 , libswscale = 5 . 1 , libswresample = 3 . 1 , libpostproc = 55 . 1 , \" } , <nl> - { new FFmpegVersion ( \" 3 . 4 \" ) , \" libavutil = 55 . 78 , libavcodec = 57 . 107 , libavformat = 57 . 83 , libavdevice = 57 . 10 , libavfilter = 6 . 107 , libswscale = 4 . 8 , libswresample = 2 . 9 , libpostproc = 54 . 7 , \" } , <nl> - { new FFmpegVersion ( \" 3 . 3 \" ) , \" libavutil = 55 . 58 , libavcodec = 57 . 89 , libavformat = 57 . 71 , libavdevice = 57 . 6 , libavfilter = 6 . 82 , libswscale = 4 . 6 , libswresample = 2 . 7 , libpostproc = 54 . 5 , \" } , <nl> - { new FFmpegVersion ( \" 3 . 2 \" ) , \" libavutil = 55 . 34 , libavcodec = 57 . 64 , libavformat = 57 . 56 , libavdevice = 57 . 1 , libavfilter = 6 . 65 , libswscale = 4 . 2 , libswresample = 2 . 3 , libpostproc = 54 . 1 , \" } , <nl> - { new FFmpegVersion ( \" 2 . 8 \" ) , \" libavutil = 54 . 31 , libavcodec = 56 . 60 , libavformat = 56 . 40 , libavdevice = 56 . 4 , libavfilter = 5 . 40 , libswscale = 3 . 1 , libswresample = 1 . 2 , libpostproc = 53 . 3 , \" } <nl> + { new Version ( \" 4 . 1 \" ) , \" libavutil = 56 . 22 , libavcodec = 58 . 35 , libavformat = 58 . 20 , libavdevice = 58 . 5 , libavfilter = 7 . 40 , libswscale = 5 . 3 , libswresample = 3 . 3 , libpostproc = 55 . 3 , \" } , <nl> + { new Version ( \" 4 . 0 \" ) , \" libavutil = 56 . 14 , libavcodec = 58 . 18 , libavformat = 58 . 12 , libavdevice = 58 . 3 , libavfilter = 7 . 16 , libswscale = 5 . 1 , libswresample = 3 . 1 , libpostproc = 55 . 1 , \" } , <nl> + { new Version ( \" 3 . 4 \" ) , \" libavutil = 55 . 78 , libavcodec = 57 . 107 , libavformat = 57 . 83 , libavdevice = 57 . 10 , libavfilter = 6 . 107 , libswscale = 4 . 8 , libswresample = 2 . 9 , libpostproc = 54 . 7 , \" } , <nl> + { new Version ( \" 3 . 3 \" ) , \" libavutil = 55 . 58 , libavcodec = 57 . 89 , libavformat = 57 . 71 , libavdevice = 57 . 6 , libavfilter = 6 . 82 , libswscale = 4 . 6 , libswresample = 2 . 7 , libpostproc = 54 . 5 , \" } , <nl> + { new Version ( \" 3 . 2 \" ) , \" libavutil = 55 . 34 , libavcodec = 57 . 64 , libavformat = 57 . 56 , libavdevice = 57 . 1 , libavfilter = 6 . 65 , libswscale = 4 . 2 , libswresample = 2 . 3 , libpostproc = 54 . 1 , \" } , <nl> + { new Version ( \" 2 . 8 \" ) , \" libavutil = 54 . 31 , libavcodec = 56 . 60 , libavformat = 56 . 40 , libavdevice = 56 . 4 , libavfilter = 5 . 40 , libswscale = 3 . 1 , libswresample = 1 . 2 , libpostproc = 53 . 3 , \" } <nl> } ) ; <nl> <nl> / / Create a reduced version string and lookup key from dictionary <nl> var reducedVersion = GetVersionString ( output ) ; <nl> - var found = lut . FirstOrDefault ( x = > x . Value = = reducedVersion ) . Key ; <nl> <nl> - return found ? ? new FFmpegVersion ( \" Unknown \" ) ; <nl> + / / Try to lookup the string and return Key , otherwise if not found returns null <nl> + return lut . FirstOrDefault ( x = > x . Value = = reducedVersion ) . Key ; <nl> } <nl> } <nl> <nl>\n", "msg": "Use Version Class to ease comparisons\n", "score": 1}
{"diff_id": 6317, "repo": "aspnetboilerplate/aspnetboilerplate\n", "sha": "7e9113b64f7dca514c463fb0ec6bb076200ad919\n", "time": "2018-06-11T22:54:48Z\n", "diff": "mmm a / src / Abp . AspNetCore / AspNetCore / EntityHistory / HttpRequestEntityChangeSetReasonProvider . cs <nl> ppp b / src / Abp . AspNetCore / AspNetCore / EntityHistory / HttpRequestEntityChangeSetReasonProvider . cs <nl> <nl> using JetBrains . Annotations ; <nl> using Microsoft . AspNetCore . Http ; <nl> using Microsoft . AspNetCore . Http . Extensions ; <nl> + using System ; <nl> <nl> namespace Abp . AspNetCore . EntityHistory <nl> { <nl> public override string Reason <nl> return OverridedValue . Reason ; <nl> } <nl> <nl> - return HttpContextAccessor . HttpContext ? . Request . GetDisplayUrl ( ) ; <nl> + try <nl> + { <nl> + return HttpContextAccessor . HttpContext ? . Request . GetDisplayUrl ( ) ; <nl> + } <nl> + catch ( NullReferenceException ) <nl> + { <nl> + / / Workaround : https : / / github . com / aspnet / Home / issues / 2718 <nl> + return null ; <nl> + } <nl> } <nl> } <nl> <nl>\n", "msg": "Add workaround for exception from GetDisplayUrl\n", "score": 1}
{"diff_id": 6963, "repo": "mono/mono\n", "sha": "bd1c57e389635de87325331581924c9a0bc4492d\n", "time": "2008-10-16T21:01:46Z\n", "diff": "new file mode 100644 <nl> index 000000000000 . . d0debceb6af4 <nl> mmm / dev / null <nl> ppp b / mcs / class / monodoc / monohb - provider . cs <nl> <nl> + / / <nl> + / / monohb - provider . cs : Handbook provider for Monodoc <nl> + / / <nl> + / / Authors : <nl> + / / Copyright 2003 Lee Mallabone < gnome @ fonicmonkey . net > <nl> + / / Johannes Roith < johannes @ jroith . de > <nl> + / / Miguel de Icaza < miguel @ ximian . com > <nl> + / / <nl> + namespace Monodoc { <nl> + using System . Xml ; <nl> + using System ; <nl> + <nl> + / * * <nl> + * Processes the mono handbook to remove extra web - specific div sections . <nl> + * / <nl> + public class MonoHBHelpSource : XhtmlHelpSource <nl> + <nl> + { <nl> + public MonoHBHelpSource ( string base_file , bool create ) : base ( base_file , create ) <nl> + { <nl> + } <nl> + <nl> + public override XmlDocument ProcessContent ( XmlDocument docToProcess ) <nl> + { <nl> + <nl> + Console . WriteLine ( \" x1 \" ) ; <nl> + XmlNamespaceManager nsmgr = new XmlNamespaceManager ( docToProcess . NameTable ) ; <nl> + nsmgr . AddNamespace ( \" default \" , \" http : / / www . w3 . org / 1999 / xhtml \" ) ; <nl> + nsmgr . AddNamespace ( \" monodoc \" , \" http : / / www . go - mono . org / xml / monodoc \" ) ; <nl> + nsmgr . PushScope ( ) ; <nl> + <nl> + Console . WriteLine ( \" x2 \" ) ; <nl> + XmlElement root = docToProcess . DocumentElement ; <nl> + XmlNode body = root . SelectSingleNode ( \" / default : html / default : body \" , nsmgr ) ; <nl> + <nl> + / / Use the DC . Description meta tag as sign , that the file is in the new format <nl> + <nl> + Console . WriteLine ( \" x3 \" ) ; <nl> + if ( root . SelectNodes ( \" / default : html / default : head / default : meta [ @ name = ' DC . Description ' ] \" , nsmgr ) . Count ! = 0 ) <nl> + <nl> + { <nl> + <nl> + <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + / / Start of temporary code , until the tutorial is converted completely <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + <nl> + XmlNodeList nodeList = docToProcess . GetElementsByTagName ( \" div \" ) ; <nl> + <nl> + / * Remove the mono handbook specific decorations * / <nl> + foreach ( XmlNode node in nodeList ) <nl> + { <nl> + string cssClass = ( ( XmlElement ) node ) . GetAttribute ( \" class \" ) ; <nl> + if ( cssClass ! = null & & ( cssClass = = \" topframe \" | | cssClass = = \" navbar \" | | cssClass = = \" copyright \" ) ) <nl> + { <nl> + node . RemoveAll ( ) ; <nl> + } <nl> + <nl> + } <nl> + <nl> + <nl> + string headinginner = \" Mono Handbook \" ; <nl> + XmlNode firstheading = docToProcess . GetElementsByTagName ( \" title \" ) [ 0 ] ; <nl> + headinginner = firstheading . InnerXml ; <nl> + <nl> + <nl> + try { <nl> + <nl> + XmlNode bodynode = docToProcess . GetElementsByTagName ( \" body \" ) [ 0 ] ; <nl> + bodynode . InnerXml = \" < table width = \\ \" 100 % \\ \" > \" + <nl> + \" < tr bgcolor = \\ \" # b0c4de \\ \" > < td > < i > < / i > Mono Handbook < h3 > \" + headinginner + \" < / h3 > < / td > < / tr > < / table > < p / > \" + <nl> + bodynode . InnerXml ; <nl> + } <nl> + catch { <nl> + } <nl> + <nl> + Console . WriteLine ( \" x5 \" ) ; <nl> + <nl> + <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + / / End of temporary code , until the tutorial is converted completely <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + <nl> + XmlNodeList nodeList2 = docToProcess . GetElementsByTagName ( \" pre \" ) ; <nl> + foreach ( XmlNode node in nodeList2 ) <nl> + { <nl> + string cssClass = ( ( XmlElement ) node ) . GetAttribute ( \" class \" ) ; <nl> + <nl> + if ( cssClass ! = null ) { <nl> + <nl> + switch ( cssClass ) <nl> + { <nl> + <nl> + case \" code \" : <nl> + <nl> + node . InnerXml = \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 3 ' > < tr > < td > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 0 ' height = ' 100 % ' > \" + <nl> + \" < tr > < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < tr > < td bgcolor = ' # c0c0c0 ' > < / td > < td width = ' 100 % ' bgcolor = ' # efefef ' > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 0 ' > < tr > < td bgcolor = ' # ffffff ' > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 2 ' > < tr > < td bgcolor = ' # efefef ' > < pre > \" + <nl> + <nl> + node . InnerXml + <nl> + <nl> + \" < / pre > < / td > < / tr > < / table > < / td > < / tr > < / table > < / td > < td bgcolor = ' # 999999 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < tr > < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < / table > < / td > < / tr > < / table > \" ; <nl> + <nl> + break ; <nl> + case \" console \" : <nl> + <nl> + node . InnerXml = \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 3 ' > < tr > < td > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 0 ' height = ' 100 % ' > \" + <nl> + \" < tr > < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < tr > < td bgcolor = ' # c0c0c0 ' > < / td > < td width = ' 100 % ' bgcolor = ' # efefef ' > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 0 ' > < tr > < td bgcolor = ' # ffffff ' > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 2 ' > < tr > < td bgcolor = ' # 999999 ' > < pre > \" + <nl> + <nl> + node . InnerXml + <nl> + <nl> + \" < / pre > < / td > < / tr > < / table > < / td > < / tr > < / table > < / td > < td bgcolor = ' # 999999 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < tr > < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < / table > < / td > < / tr > < / table > \" ; <nl> + break ; <nl> + <nl> + default : <nl> + break ; <nl> + } <nl> + <nl> + <nl> + } <nl> + <nl> + } <nl> + <nl> + nodeList = root . SelectNodes ( \" / / monodoc : example \" , nsmgr ) ; <nl> + foreach ( XmlNode node in nodeList ) { <nl> + / / XmlNode csnode = root . SelectSingleNode ( \" / monodoc : source [ @ lang = ' CS ' ] \" , nsmgr ) ; <nl> + body . RemoveChild ( node ) ; <nl> + <nl> + } <nl> + <nl> + / / string copyright_string = \" \" ; / / no string for now <nl> + <nl> + nodeList = root . SelectNodes ( \" / / default : link [ @ type = ' text / css ' ] \" , nsmgr ) ; <nl> + if ( nodeList . Count = = 0 ) { <nl> + <nl> + / / TODO : Stylesheet path maybe variable <nl> + root . SelectSingleNode ( \" / default : html / default : head \" , nsmgr ) . InnerXml + = \" \\ n < link rel = \\ \" stylesheet \\ \" type = \\ \" text / css \\ \" href = \\ \" style . css \\ \" / > \" ; <nl> + } <nl> + <nl> + string contributor_string = \" < a id = \\ \" credits \\ \" > < h2 > Credits < / h2 > < / a > \" ; <nl> + <nl> + nodeList = root . SelectNodes ( \" / / default : meta [ @ name = ' DC . Contributor ' ] \" , nsmgr ) ; <nl> + foreach ( XmlNode node in nodeList ) { <nl> + <nl> + contributor_string + = node . Attributes . GetNamedItem ( \" content \" ) . Value + \" < br / > \\ n \" ; <nl> + <nl> + } <nl> + <nl> + / / body . InnerXml + = contributor_string + copyright_string ; <nl> + <nl> + } <nl> + else { <nl> + Console . WriteLine ( \" x4 \" ) ; <nl> + <nl> + XmlNodeList nodeList = docToProcess . GetElementsByTagName ( \" div \" ) ; <nl> + <nl> + if ( nodeList ! = null ) { <nl> + / * Remove the mono handbook specific decorations * / <nl> + foreach ( XmlNode node in nodeList ) { <nl> + string cssClass = ( ( XmlElement ) node ) . GetAttribute ( \" class \" ) ; <nl> + if ( cssClass ! = null & & ( cssClass = = \" topframe \" | | cssClass = = \" navbar \" | | cssClass = = \" copyright \" ) ) { <nl> + node . RemoveAll ( ) ; <nl> + } <nl> + <nl> + } <nl> + } <nl> + <nl> + Console . WriteLine ( \" x6 \" ) ; <nl> + <nl> + string headinginner = \" Mono Handbook \" ; <nl> + XmlNode firstheading = null ; <nl> + <nl> + try { <nl> + firstheading = docToProcess . GetElementsByTagName ( \" h1 \" ) [ 0 ] ; <nl> + headinginner = firstheading . InnerXml ; <nl> + } <nl> + <nl> + catch { <nl> + <nl> + try { <nl> + <nl> + firstheading = docToProcess . GetElementsByTagName ( \" h2 \" ) [ 0 ] ; <nl> + headinginner = firstheading . InnerXml ; <nl> + <nl> + } <nl> + catch { } <nl> + } <nl> + <nl> + Console . WriteLine ( \" x8 \" ) ; <nl> + <nl> + try { <nl> + <nl> + XmlNode bodynode = docToProcess . GetElementsByTagName ( \" body \" ) [ 0 ] ; <nl> + if ( firstheading ! = null ) <nl> + bodynode . RemoveChild ( firstheading ) ; <nl> + <nl> + bodynode . InnerXml = \" < table width = \\ \" 100 % \\ \" > \" + <nl> + \" < tr bgcolor = \\ \" # b0c4de \\ \" > < td > < i > < / i > Mono Handbook < h3 > \" + headinginner + \" < / h3 > < / td > < / tr > < / table > < p / > \" + <nl> + bodynode . InnerXml ; <nl> + } <nl> + catch { <nl> + } <nl> + <nl> + Console . WriteLine ( \" x9 \" ) ; <nl> + XmlNodeList nodeList2 = docToProcess . GetElementsByTagName ( \" pre \" ) ; <nl> + foreach ( XmlNode node in nodeList2 ) { <nl> + string cssClass = ( ( XmlElement ) node ) . GetAttribute ( \" class \" ) ; <nl> + <nl> + if ( cssClass ! = null ) { <nl> + switch ( cssClass ) { <nl> + <nl> + case \" code \" : <nl> + <nl> + node . InnerXml = \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 3 ' > < tr > < td > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 0 ' height = ' 100 % ' > \" + <nl> + \" < tr > < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < tr > < td bgcolor = ' # c0c0c0 ' > < / td > < td width = ' 100 % ' bgcolor = ' # efefef ' > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 0 ' > < tr > < td bgcolor = ' # ffffff ' > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 2 ' > < tr > < td bgcolor = ' # efefef ' > \" + <nl> + \" < pre > \" + <nl> + <nl> + node . InnerXml + <nl> + <nl> + \" < / pre > \" + <nl> + \" < / td > < / tr > < / table > < / td > < / tr > < / table > < / td > < td bgcolor = ' # 999999 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < tr > < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # c0c0c0 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < / table > < / td > < / tr > < / table > \" ; <nl> + <nl> + break ; <nl> + case \" console \" : <nl> + <nl> + node . InnerXml = \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 3 ' > < tr > < td > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 0 ' height = ' 100 % ' > \" + <nl> + \" < tr > < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < tr > < td bgcolor = ' # c0c0c0 ' > < / td > < td width = ' 100 % ' bgcolor = ' # efefef ' > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 0 ' > < tr > < td bgcolor = ' # ffffff ' > \" + <nl> + \" < table width = ' 100 % ' border = ' 0 ' cellspacing = ' 0 ' cellpadding = ' 2 ' > < tr > < td bgcolor = ' # 999999 ' > \" + <nl> + \" < pre > \" + <nl> + <nl> + node . InnerXml + <nl> + <nl> + \" < / pre > \" + <nl> + \" < / td > < / tr > < / table > < / td > < / tr > < / table > < / td > < td bgcolor = ' # 999999 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < tr > < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < td bgcolor = ' # 555555 ' > < img src = ' / html / en / images / empty . png ' width = ' 1 ' height = ' 1 ' / > < / td > \" + <nl> + \" < / tr > < / table > < / td > < / tr > < / table > \" ; <nl> + break ; <nl> + <nl> + default : <nl> + break ; <nl> + } <nl> + <nl> + <nl> + } <nl> + } <nl> + <nl> + } <nl> + return docToProcess ; <nl> + } <nl> + } <nl> + } <nl>\n", "msg": "Prepping for monodoc move from monodoc / engine to mcs / class / monodoc . . .\n", "score": 1}
{"diff_id": 7051, "repo": "migueldeicaza/gui.cs\n", "sha": "f1c7880e75395b7450bb6aac7c313fdcef46ce27\n", "time": "2020-05-21T21:51:24Z\n", "diff": "mmm a / UICatalog / Scenarios / Progress . cs <nl> ppp b / UICatalog / Scenarios / Progress . cs <nl> namespace UICatalog { <nl> [ ScenarioCategory ( \" Controls \" ) ] <nl> class Progress : Scenario { <nl> <nl> - private ProgressBar _progressBar ; <nl> + private ProgressBar _activityProgressBar ; <nl> + private ProgressBar _pulseProgressBar ; <nl> public override void Setup ( ) <nl> { <nl> Win . Add ( new Button ( \" Start \" ) { <nl> X = Pos . Center ( ) - 20 , <nl> Y = Pos . Center ( ) - 5 , <nl> Clicked = ( ) = > Start ( ) <nl> - } ) ; ; <nl> + } ) ; <nl> + <nl> + Win . Add ( new Button ( \" Pulse \" ) { <nl> + X = Pos . Center ( ) - 5 , <nl> + Y = Pos . Center ( ) - 5 , <nl> + Clicked = ( ) = > Pulse ( ) <nl> + } ) ; <nl> + <nl> <nl> Win . Add ( new Button ( \" Stop \" ) { <nl> X = Pos . Center ( ) + 10 , <nl> public override void Setup ( ) <nl> Clicked = ( ) = > Stop ( ) <nl> } ) ; <nl> <nl> - _progressBar = new ProgressBar ( ) { <nl> + _activityProgressBar = new ProgressBar ( ) { <nl> X = Pos . Center ( ) , <nl> / / BUGBUG : If you remove the + 1 below the control is drawn at top ? ! ? ! <nl> Y = Pos . Center ( ) + 1 , <nl> Width = 30 , <nl> Fraction = 0 . 25F , <nl> } ; <nl> - Win . Add ( _progressBar ) ; <nl> + Win . Add ( _activityProgressBar ) ; <nl> + <nl> + _pulseProgressBar = new ProgressBar ( ) { <nl> + X = Pos . Center ( ) , <nl> + / / BUGBUG : If you remove the + 1 below the control is drawn at top ? ! ? ! <nl> + Y = Pos . Center ( ) + 3 , <nl> + Width = 30 , <nl> + } ; <nl> + Win . Add ( _pulseProgressBar ) ; <nl> + } <nl> + <nl> + private void Pulse ( ) <nl> + { <nl> + if ( _activityProgressBar . Fraction + 0 . 1F > = 1 ) { <nl> + _activityProgressBar . Fraction = 0F ; <nl> + } else { <nl> + _activityProgressBar . Fraction + = 0 . 1F ; <nl> + } <nl> + _pulseProgressBar . Pulse ( ) ; <nl> } <nl> <nl> private void Start ( ) <nl> { <nl> - _progressBar . Fraction = 0F ; <nl> + _activityProgressBar . Fraction = 0F ; <nl> + _pulseProgressBar . Fraction = 0F ; <nl> } <nl> <nl> private void Stop ( ) <nl> { <nl> - _progressBar . Fraction = 1F ; <nl> + _activityProgressBar . Fraction = 1F ; <nl> + _pulseProgressBar . Fraction = 1F ; <nl> } <nl> } <nl> } <nl> \\ No newline at end of file <nl>\n", "msg": "updated to also demo Activity mode\n", "score": 1}
{"diff_id": 7245, "repo": "dotnet/roslyn\n", "sha": "ad2f7b81d0c22143b1e02a7759c09fcb84982cf2\n", "time": "2019-07-18T00:33:39Z\n", "diff": "mmm a / src / Features / LanguageServer / Protocol / Handler / Initialize / InitializeHandler . cs <nl> ppp b / src / Features / LanguageServer / Protocol / Handler / Initialize / InitializeHandler . cs <nl> internal class InitializeHandler : IRequestHandler < InitializeParams , InitializeR <nl> } <nl> } ; <nl> <nl> - public Task < InitializeResult > HandleRequestAsync ( Solution solution , InitializeParams request , ClientCapabilities clientCapabilities , CancellationToken cancellationToken ) <nl> + public Task < InitializeResult > HandleRequestAsync ( Solution solution , InitializeParams request , ClientCapabilities clientCapabilities , CancellationToken cancellationToken , bool keepThreadContext = false ) <nl> = > Task . FromResult ( s_initializeResult ) ; <nl> } <nl> } <nl>\n", "msg": "Use thread context parameter for initialize .\n", "score": 1}
{"diff_id": 7659, "repo": "nopSolutions/nopCommerce\n", "sha": "b182c45098a20b7ad40ebbbc781ac8fb9eb5c4c3\n", "time": "2017-12-18T11:39:35Z\n", "diff": "mmm a / src / Tests / Nop . Services . Tests / Payments / TestPaymentMethod . cs <nl> ppp b / src / Tests / Nop . Services . Tests / Payments / TestPaymentMethod . cs <nl> public ProcessPaymentRequest GetPaymentInfo ( IFormCollection form ) <nl> } <nl> <nl> / / / < summary > <nl> - / / / Gets a view component for displaying plugin in public store ( \" payment info \" checkout step ) <nl> + / / / Gets a name of a view component for displaying plugin in public store ( \" payment info \" checkout step ) <nl> / / / < / summary > <nl> - / / / < param name = \" viewComponentName \" > View component name < / param > <nl> - public void GetPublicViewComponent ( out string viewComponentName ) <nl> + / / / < returns > View component name < / returns > <nl> + public string GetPublicViewComponentName ( ) <nl> { <nl> - viewComponentName = null ; <nl> + return null ; <nl> } <nl> <nl> <nl>\n", "msg": "Minor addition to the previous commit\n", "score": 1}
{"diff_id": 7660, "repo": "dotnet/roslyn\n", "sha": "ae0f7edbc18713ae7a99d0808b9ecffe45950ff6\n", "time": "2019-04-17T13:41:08Z\n", "diff": "mmm a / src / VisualStudio / IntegrationTest / TestUtilities / VisualStudioInstanceFactory . cs <nl> ppp b / src / VisualStudio / IntegrationTest / TestUtilities / VisualStudioInstanceFactory . cs <nl> private static Process StartNewVisualStudioProcess ( string installationPath , int <nl> / / Disable roaming settings to avoid interference from the online user profile <nl> Process . Start ( vsRegEditExeFile , $ \" set \\ \" { installationPath } \\ \" { Settings . Default . VsRootSuffix } HKCU \\ \" ApplicationPrivateSettings \\ \\ Microsoft \\ \\ VisualStudio \\ \" RoamingEnabled string \\ \" 1 * System . Boolean * False \\ \" \" ) . WaitForExit ( ) ; <nl> <nl> + / / Disable background download UI to avoid toasts <nl> + Process . Start ( vsRegEditExeFile , $ \" set \\ \" { installationPath } \\ \" { Settings . Default . VsRootSuffix } HKCU \\ \" FeatureFlags \\ \\ Setup \\ \\ BackgroundDownload \\ \" Value dword 0 \" ) . WaitForExit ( ) ; <nl> + <nl> / / Enable or disable async completion as necessary for integration testing <nl> var usingAsyncCompletion = LegacyCompletionCondition . Instance . ShouldSkip ; <nl> var useAsyncCompletionSetting = usingAsyncCompletion ? 1 : - 1 ; <nl>\n", "msg": "Disable background download UI to avoid toasts\n", "score": 1}
{"diff_id": 8166, "repo": "SignalR/SignalR\n", "sha": "05d3f97d51b8bd931806c84577ce4b287605fd9f\n", "time": "2012-08-28T10:22:45Z\n", "diff": "mmm a / SignalR / MessageBus / MessageBus . cs <nl> ppp b / SignalR / MessageBus / MessageBus . cs <nl> public void AddOrUpdateCursor ( string key , ulong id , Topic topic ) <nl> { <nl> / / O ( n ) , but small n and it ' s not common <nl> var index = _cursors . FindIndex ( c = > c . Key = = key ) ; <nl> - if ( index ! = - 1 ) <nl> - { <nl> - Cursor cursor = _cursors [ index ] ; <nl> - cursor . Id = id ; <nl> - cursor . Topic = topic ; <nl> - } <nl> - else <nl> + if ( index = = - 1 ) <nl> { <nl> _cursors . Add ( new Cursor <nl> { <nl> public void PumpImpl ( TaskCompletionSource < object > taskCompletionSource ) <nl> { <nl> while ( _queue . Count = = 0 ) <nl> { <nl> - Monitor . Wait ( _queue ) ; <nl> + if ( ! Monitor . Wait ( _queue , TimeSpan . FromSeconds ( 5 ) ) ) <nl> + { <nl> + taskCompletionSource . TrySetResult ( null ) ; <nl> + return ; <nl> + } <nl> } <nl> <nl> subscription = _queue . Dequeue ( ) ; <nl>\n", "msg": "Don ' t modify the group cursor if subscriber is already part of the group .\n", "score": 1}
{"diff_id": 8372, "repo": "dotnet/roslyn\n", "sha": "f1c77e707f24e21811d71435684af0e620d9066c\n", "time": "2015-08-25T17:35:14Z\n", "diff": "mmm a / src / Features / Core / Portable / Diagnostics / HostAnalyzerManager . cs <nl> ppp b / src / Features / Core / Portable / Diagnostics / HostAnalyzerManager . cs <nl> <nl> using System . Reflection ; <nl> using Microsoft . CodeAnalysis . Diagnostics . Log ; <nl> using Roslyn . Utilities ; <nl> - using Microsoft . CodeAnalysis . ErrorReporting ; <nl> using System . Runtime . CompilerServices ; <nl> + using System . Reflection . Metadata ; <nl> + using System . Reflection . PortableExecutable ; <nl> <nl> namespace Microsoft . CodeAnalysis . Diagnostics <nl> { <nl> public Assembly LoadFromPath ( string fullPath ) <nl> { <nl> / / We want to load the analyzer assembly assets in default context . <nl> / / Use Assembly . Load instead of Assembly . LoadFrom to ensure that if the assembly is ngen ' ed , then the native image gets loaded . <nl> - return Assembly . Load ( AssemblyName . GetAssemblyName ( fullPath ) ) ; <nl> + return Assembly . Load ( GetAssemblyName ( fullPath ) ) ; <nl> + } <nl> + <nl> + private AssemblyName GetAssemblyName ( string fullPath ) <nl> + { <nl> + using ( var stream = PortableShim . File . OpenRead ( fullPath ) ) <nl> + { <nl> + using ( var peReader = new PEReader ( stream ) ) <nl> + { <nl> + var reader = peReader . GetMetadataReader ( ) ; <nl> + var assemblyDef = reader . GetAssemblyDefinition ( ) ; <nl> + <nl> + var name = reader . GetString ( assemblyDef . Name ) ; <nl> + <nl> + var cultureName = assemblyDef . Culture . IsNil <nl> + ? null <nl> + : reader . GetString ( assemblyDef . Culture ) ; <nl> + <nl> + var publicKeyOrToken = reader . GetBlobContent ( assemblyDef . PublicKey ) ; <nl> + var hasPublicKey = ! publicKeyOrToken . IsEmpty ; <nl> + <nl> + if ( publicKeyOrToken . IsEmpty ) <nl> + { <nl> + publicKeyOrToken = default ( ImmutableArray < byte > ) ; <nl> + } <nl> + <nl> + var identity = new AssemblyIdentity ( <nl> + name : name , <nl> + version : assemblyDef . Version , <nl> + cultureName : cultureName , <nl> + publicKeyOrToken : publicKeyOrToken , <nl> + hasPublicKey : hasPublicKey , <nl> + isRetargetable : ( assemblyDef . Flags & AssemblyFlags . Retargetable ) ! = 0 , <nl> + contentType : ( AssemblyContentType ) ( ( int ) ( assemblyDef . Flags & AssemblyFlags . ContentTypeMask ) > > 9 ) ) ; <nl> + <nl> + return new AssemblyName ( identity . GetDisplayName ( ) ) ; <nl> + } <nl> + } <nl> } <nl> } <nl> } <nl>\n", "msg": "Add GetAssemblyName helper using MetadataReader for analyzer framework\n", "score": 1}
{"diff_id": 8448, "repo": "ppy/osu\n", "sha": "759c5b3db94ff9e2457aac2e6bb6f9f8a857a173\n", "time": "2019-03-29T01:52:26Z\n", "diff": "mmm a / osu . Game / Screens / Select / SongSelect . cs <nl> ppp b / osu . Game / Screens / Select / SongSelect . cs <nl> public override void OnResuming ( IScreen last ) <nl> if ( Beatmap ! = null & & ! Beatmap . Value . BeatmapSetInfo . DeletePending ) <nl> { <nl> UpdateBeatmap ( Beatmap . Value ) ; <nl> - ensurePlayingSelected ( true ) ; <nl> + ensurePlayingSelected ( ) ; <nl> } <nl> <nl> base . OnResuming ( last ) ; <nl>\n", "msg": "Restore previous resume behaviour for the time being\n", "score": 1}
{"diff_id": 8725, "repo": "nopSolutions/nopCommerce\n", "sha": "81b27d577c28b57ec5cde80f0d092467215e6c00\n", "time": "2018-10-15T11:46:43Z\n", "diff": "mmm a / src / Presentation / Nop . Web / Areas / Admin / Infrastructure / Mapper / AdminMapperConfiguration . cs <nl> ppp b / src / Presentation / Nop . Web / Areas / Admin / Infrastructure / Mapper / AdminMapperConfiguration . cs <nl> protected virtual void CreateTasksMaps ( ) <nl> { <nl> CreateMap < ScheduleTask , ScheduleTaskModel > ( ) ; <nl> CreateMap < ScheduleTaskModel , ScheduleTask > ( ) <nl> - . ForMember ( entity = > entity . Type , options = > options . Ignore ( ) ) ; <nl> + . ForMember ( entity = > entity . Type , options = > options . Ignore ( ) ) <nl> + . ForMember ( entity = > entity . LastStartUtc , options = > options . Ignore ( ) ) <nl> + . ForMember ( entity = > entity . LastEndUtc , options = > options . Ignore ( ) ) <nl> + . ForMember ( entity = > entity . LastSuccessUtc , options = > options . Ignore ( ) ) ; <nl> } <nl> <nl> / / / < summary > <nl>\n", "msg": "Fixed automapper settings for schedule models\n", "score": 1}
{"diff_id": 8789, "repo": "OpenRA/OpenRA\n", "sha": "220579ff859af7290366822b41405af27ecfb9d4\n", "time": "2010-12-06T07:43:09Z\n", "diff": "mmm a / OpenRA . Mods . RA / Widgets / WorldCommandWidget . cs <nl> ppp b / OpenRA . Mods . RA / Widgets / WorldCommandWidget . cs <nl> public class WorldCommandWidget : Widget <nl> public World World { get { return OrderManager . world ; } } <nl> <nl> public char AttackMoveKey = ' a ' ; <nl> + public char StopKey = ' s ' ; <nl> public char HoldGroundKey = ' g ' ; / / Hold ( G ) round <nl> public char DefensiveKey = ' d ' ; / / ( D ) efensive <nl> public char AggressiveKey = ' a ' ; / / ( A ) ggressive <nl> public WorldCommandWidget ( [ ObjectCreator . Param ] OrderManager orderManager ) <nl> OrderManager = orderManager ; <nl> } <nl> <nl> - public override void DrawInner ( WorldRenderer wr ) <nl> - { <nl> - <nl> - } <nl> + public override void DrawInner ( WorldRenderer wr ) { } <nl> <nl> - public override string GetCursor ( int2 pos ) <nl> - { <nl> - return null ; <nl> - } <nl> + public override string GetCursor ( int2 pos ) { return null ; } <nl> <nl> public override bool HandleKeyPressInner ( KeyInput e ) <nl> { <nl> public override bool HandleKeyPressInner ( KeyInput e ) <nl> <nl> bool ProcessInput ( KeyInput e ) <nl> { <nl> - / / command : AttackMove <nl> - if ( e . KeyChar = = AttackMoveKey & & e . Modifiers = = Modifiers . None ) <nl> + if ( ! World . Selection . Actors . Any ( ) ) <nl> + return false ; <nl> + <nl> + if ( e . Modifiers = = Modifiers . None ) <nl> { <nl> - return PerformAttackMove ( ) ; <nl> + if ( e . KeyChar = = AttackMoveKey ) <nl> + return PerformAttackMove ( ) ; <nl> + <nl> + if ( e . KeyChar = = StopKey ) <nl> + return PerformStop ( ) ; <nl> } <nl> <nl> / * / / command : GuardStance <nl> bool ProcessInput ( KeyInput e ) <nl> <nl> bool PerformAttackMove ( ) <nl> { <nl> - if ( World . Selection . Actors . Count ( ) > 0 ) <nl> - { <nl> - World . OrderGenerator = new GenericSelectTarget ( World . Selection . Actors , \" AttackMove \" , \" attackmove \" , MouseButton . Right ) ; <nl> + World . OrderGenerator = new GenericSelectTarget ( World . Selection . Actors , \" AttackMove \" , <nl> + \" attackmove \" , MouseButton . Right ) ; <nl> <nl> - return true ; <nl> - } <nl> + return true ; <nl> + } <nl> <nl> - return false ; <nl> + bool PerformStop ( ) <nl> + { <nl> + / * issue a stop order to everyone . * / <nl> + foreach ( var a in World . Selection . Actors ) <nl> + World . IssueOrder ( new Order ( \" Stop \" , a , false ) ) ; <nl> + <nl> + return true ; <nl> } <nl> } <nl> } <nl> \\ No newline at end of file <nl>\n", "msg": "wire ' s ' ( default binding ) to issue ' Stop ' order to each selected actor\n", "score": 1}
{"diff_id": 8807, "repo": "OpenRA/OpenRA\n", "sha": "b58988c6236c134f532f6229b5810e58b77dc1f0\n", "time": "2015-06-13T09:01:55Z\n", "diff": "mmm a / OpenRA . Game / Settings . cs <nl> ppp b / OpenRA . Game / Settings . cs <nl> public static string SanitizedPlayerName ( string dirty ) <nl> <nl> var clean = SanitizedName ( dirty ) ; <nl> <nl> + if ( string . IsNullOrWhiteSpace ( clean ) | | forbiddenNames . Contains ( clean ) | | botNames . Contains ( clean ) ) <nl> + clean = new PlayerSettings ( ) . Name ; <nl> + <nl> / / avoid UI glitches <nl> if ( clean . Length > 16 ) <nl> clean = clean . Substring ( 0 , 16 ) ; <nl> <nl> - if ( string . IsNullOrWhiteSpace ( clean ) | | forbiddenNames . Contains ( clean ) | | botNames . Contains ( clean ) ) <nl> - clean = new PlayerSettings ( ) . Name ; <nl> - <nl> return clean ; <nl> } <nl> <nl>\n", "msg": "move the null check to avoid a crash\n", "score": 1}
{"diff_id": 8923, "repo": "HangfireIO/Hangfire\n", "sha": "df5dfa7f51adc4306025be09ab38d67cc9d25538\n", "time": "2014-05-16T20:08:34Z\n", "diff": "mmm a / src / HangFire . SqlServer . Msmq / MsmqSqlServerStorageExtensions . cs <nl> ppp b / src / HangFire . SqlServer . Msmq / MsmqSqlServerStorageExtensions . cs <nl> namespace HangFire . SqlServer . Msmq <nl> { <nl> public static class MsmqSqlServerStorageExtensions <nl> { <nl> - public static void UseMsmqQueues ( this SqlServerStorage storage , string pathPattern ) <nl> + public static SqlServerStorage UseMsmqQueues ( this SqlServerStorage storage , string pathPattern ) <nl> { <nl> - UseMsmqQueues ( storage , pathPattern , new [ ] { EnqueuedState . DefaultQueue } ) ; <nl> + return UseMsmqQueues ( storage , pathPattern , new [ ] { EnqueuedState . DefaultQueue } ) ; <nl> } <nl> <nl> - public static void UseMsmqQueues ( this SqlServerStorage storage , string pathPattern , params string [ ] queues ) <nl> + public static SqlServerStorage UseMsmqQueues ( this SqlServerStorage storage , string pathPattern , params string [ ] queues ) <nl> { <nl> if ( storage = = null ) throw new ArgumentNullException ( \" storage \" ) ; <nl> <nl> var provider = new MsmqJobQueueProvider ( pathPattern , queues ) ; <nl> storage . QueueProviders . Add ( provider , queues ) ; <nl> + <nl> + return storage ; <nl> } <nl> } <nl> } <nl> \\ No newline at end of file <nl>\n", "msg": "Return storage instance from UseMsmqQueues method for chaining\n", "score": 1}
{"diff_id": 9588, "repo": "NLog/NLog\n", "sha": "dcca205e26a6b0b84e11543ac45d4a875960d217\n", "time": "2015-12-28T18:34:08Z\n", "diff": "mmm a / src / NLog / Config / XmlLoggingConfiguration . cs <nl> ppp b / src / NLog / Config / XmlLoggingConfiguration . cs <nl> private void Initialize ( XmlReader reader , string fileName , bool ignoreErrors ) <nl> if ( fileName ! = null ) <nl> { <nl> this . originalFileName = fileName ; <nl> - this . ParseTopLevel ( content , fileName ) ; <nl> + this . ParseTopLevel ( content , fileName , autoReloadDefault : false ) ; <nl> <nl> InternalLogger . Info ( \" Configured from an XML element in { 0 } . . . \" , fileName ) ; <nl> } <nl> else <nl> { <nl> - this . ParseTopLevel ( content , null ) ; <nl> + this . ParseTopLevel ( content , null , autoReloadDefault : false ) ; <nl> } <nl> InitializeSucceeded = true ; <nl> <nl> private void CheckUnusedTargets ( ) <nl> InternalLogger . Debug ( \" Unused target checking is completed . Total Rule Count : { 0 } , Total Target Count : { 1 } , Unused Target Count : { 2 } \" , this . LoggingRules . Count , configuredNamedTargets . Count , unusedCount ) ; <nl> } <nl> <nl> - private void ConfigureFromFile ( string fileName , bool autoReloadDefault = false ) <nl> + private void ConfigureFromFile ( string fileName , bool autoReloadDefault ) <nl> { <nl> if ( ! this . fileMustAutoReloadLookup . ContainsKey ( GetFileLookupKey ( fileName ) ) ) <nl> this . ParseTopLevel ( new NLogXmlElement ( fileName ) , fileName , autoReloadDefault ) ; <nl> private void ConfigureFromFile ( string fileName , bool autoReloadDefault = false ) <nl> / / / < param name = \" content \" > < / param > <nl> / / / < param name = \" filePath \" > path to config file . < / param > <nl> / / / < param name = \" autoReloadDefault \" > The default value for the autoReload option . < / param > <nl> - private void ParseTopLevel ( NLogXmlElement content , string filePath , bool autoReloadDefault = false ) <nl> + private void ParseTopLevel ( NLogXmlElement content , string filePath , bool autoReloadDefault ) <nl> { <nl> content . AssertName ( \" nlog \" , \" configuration \" ) ; <nl> <nl> private void ParseTopLevel ( NLogXmlElement content , string filePath , bool autoRel <nl> / / / < param name = \" configurationElement \" > < / param > <nl> / / / < param name = \" filePath \" > path to config file . < / param > <nl> / / / < param name = \" autoReloadDefault \" > The default value for the autoReload option . < / param > <nl> - private void ParseConfigurationElement ( NLogXmlElement configurationElement , string filePath , bool autoReloadDefault = false ) <nl> + private void ParseConfigurationElement ( NLogXmlElement configurationElement , string filePath , bool autoReloadDefault ) <nl> { <nl> InternalLogger . Trace ( \" ParseConfigurationElement \" ) ; <nl> configurationElement . AssertName ( \" configuration \" ) ; <nl> private void ParseConfigurationElement ( NLogXmlElement configurationElement , stri <nl> / / / < param name = \" nlogElement \" > < / param > <nl> / / / < param name = \" filePath \" > path to config file . < / param > <nl> / / / < param name = \" autoReloadDefault \" > The default value for the autoReload option . < / param > <nl> - private void ParseNLogElement ( NLogXmlElement nlogElement , string filePath , bool autoReloadDefault = false ) <nl> + private void ParseNLogElement ( NLogXmlElement nlogElement , string filePath , bool autoReloadDefault ) <nl> { <nl> InternalLogger . Trace ( \" ParseNLogElement \" ) ; <nl> nlogElement . AssertName ( \" nlog \" ) ; <nl>\n", "msg": "Config : Implemented inheritance policy for autoReload in included config files .\n", "score": 1}
{"diff_id": 9629, "repo": "Wox-launcher/Wox\n", "sha": "196cf1cd1855819b9526221ecf0b8540d38400d9\n", "time": "2017-01-13T14:15:48Z\n", "diff": "mmm a / Plugins / Wox . Plugin . ControlPanel / Main . cs <nl> ppp b / Plugins / Wox . Plugin . ControlPanel / Main . cs <nl> public void Init ( PluginInitContext context ) <nl> } <nl> } <nl> <nl> - var characters = controlPanelItems . Select ( i = > i . LocalizedString ) <nl> - . Concat ( controlPanelItems . Select ( i = > i . InfoTip ) ) ; <nl> - <nl> - Parallel . ForEach ( characters , c = > <nl> + Task . Run ( ( ) = > <nl> { <nl> - if ( ! string . IsNullOrWhiteSpace ( c ) & & Alphabet . ContainsChinese ( c ) ) <nl> + var characters = controlPanelItems . Select ( i = > i . LocalizedString ) <nl> + . Concat ( controlPanelItems . Select ( i = > i . InfoTip ) ) ; <nl> + <nl> + Parallel . ForEach ( characters , c = > <nl> { <nl> - Alphabet . PinyinComination ( c ) ; <nl> - } <nl> + if ( ! string . IsNullOrWhiteSpace ( c ) & & Alphabet . ContainsChinese ( c ) ) <nl> + { <nl> + Alphabet . PinyinComination ( c ) ; <nl> + } <nl> + } ) ; <nl> } ) ; <nl> } <nl> <nl>\n", "msg": "faster startup time for control panel plugin\n", "score": 1}
{"diff_id": 10147, "repo": "MonoGame/MonoGame\n", "sha": "9370c3651eaf0e064545037c687bc38a68b7296e\n", "time": "2013-05-21T06:58:23Z\n", "diff": "mmm a / MonoGame . Framework / GraphicsDeviceManager . cs <nl> ppp b / MonoGame . Framework / GraphicsDeviceManager . cs <nl> public GraphicsDeviceManager ( Game game ) <nl> <nl> public void CreateDevice ( ) <nl> { <nl> - if ( PreparingDeviceSettings ! = null ) <nl> - { <nl> - GraphicsDeviceInformation gdi = new GraphicsDeviceInformation ( ) ; <nl> - gdi . DeviceType = DeviceType . Hardware ; <nl> - gdi . Adapter = GraphicsAdapter . DefaultAdapter ; <nl> - gdi . PresentationParameters = new PresentationParameters ( ) ; <nl> - PreparingDeviceSettingsEventArgs pe = new PreparingDeviceSettingsEventArgs ( gdi ) ; <nl> - PreparingDeviceSettings ( this , pe ) ; <nl> - _graphicsDevice = new GraphicsDevice ( gdi ) ; <nl> - } <nl> - else <nl> - { <nl> - _graphicsDevice = new GraphicsDevice ( ) ; <nl> - } <nl> - <nl> Initialize ( ) ; <nl> <nl> OnDeviceCreated ( EventArgs . Empty ) ; <nl> private void Initialize ( ) <nl> # endif / / MONOMAC <nl> <nl> / / TODO : Implement multisampling ( aka anti - alising ) for all platforms ! <nl> + if ( PreparingDeviceSettings ! = null ) <nl> + { <nl> + GraphicsDeviceInformation gdi = new GraphicsDeviceInformation ( ) ; <nl> + gdi . DeviceType = DeviceType . Hardware ; <nl> + gdi . Adapter = GraphicsAdapter . DefaultAdapter ; <nl> + gdi . PresentationParameters = presentationParameters ; <nl> + PreparingDeviceSettingsEventArgs pe = new PreparingDeviceSettingsEventArgs ( gdi ) ; <nl> + PreparingDeviceSettings ( this , pe ) ; <nl> + presentationParameters = pe . GraphicsDeviceInformation . PresentationParameters ; <nl> + } <nl> <nl> _graphicsDevice = new GraphicsDevice ( GraphicsProfile , presentationParameters ) ; <nl> <nl>\n", "msg": "moved invocation of the PrepareDeviceSettings event to the initialize method .\n", "score": 1}
{"diff_id": 10237, "repo": "QuantConnect/Lean\n", "sha": "835658ec3ed599831b439e80d729dff62709c436\n", "time": "2020-07-28T21:34:08Z\n", "diff": "mmm a / Tests / Indicators / SchaffTrendCycleTests . cs <nl> ppp b / Tests / Indicators / SchaffTrendCycleTests . cs <nl> protected override string TestColumnName <nl> get { return \" STC \" ; } <nl> } <nl> <nl> - [ Test ] <nl> - public virtual void RunningTest ( ) <nl> + / / / < summary > <nl> + / / / Returns a custom assertion function , parameters are the indicator and the expected value from the file <nl> + / / / This overwrites the virtual function to allow a + / - 1 variance since this indicator is highly sensitive with <nl> + / / / a chain of EMAs and Stochastics calculation . <nl> + / / / < / summary > <nl> + protected override Action < IndicatorBase < IndicatorDataPoint > , double > Assertion <nl> { <nl> - var indicator = CreateIndicator ( ) ; <nl> - var startDate = new DateTime ( 2019 , 1 , 1 ) ; <nl> - <nl> - for ( var i = 0 ; i < 30 ; i + + ) <nl> - { <nl> - var input = new IndicatorDataPoint ( startDate . AddDays ( i ) , 100m + i ) ; <nl> - indicator . Update ( input ) ; <nl> - } <nl> + get { return ( indicator , expected ) = > Assert . AreEqual ( expected , ( double ) indicator . Current . Value , 1 ) ; } <nl> } <nl> } <nl> } <nl>\n", "msg": "Overwriting assertion to allow a greater variance\n", "score": 1}
{"diff_id": 10900, "repo": "aspnetboilerplate/aspnetboilerplate\n", "sha": "d0cdbfd4ad985de9f2d81cf50b5cd4b741f619ff\n", "time": "2015-08-07T06:57:10Z\n", "diff": "mmm a / src / Abp / Application / Services / Dto / NullableIdInput . cs <nl> ppp b / src / Abp / Application / Services / Dto / NullableIdInput . cs <nl> public NullableIdInput ( ) <nl> <nl> } <nl> <nl> - public NullableIdInput ( TId id ) <nl> + public NullableIdInput ( TId ? id ) <nl> { <nl> Id = id ; <nl> } <nl> public NullableIdInput ( ) <nl> <nl> } <nl> <nl> - public NullableIdInput ( int id ) <nl> + public NullableIdInput ( int ? id ) <nl> : base ( id ) <nl> { <nl> <nl>\n", "msg": "Changed constructor signature for NullableIdInput to nullable .\n", "score": 1}
{"diff_id": 11452, "repo": "OpenRA/OpenRA\n", "sha": "4f9f258413ebde7c80666097435964c2cdc4b7ac\n", "time": "2014-04-03T05:22:39Z\n", "diff": "mmm a / OpenRA . Utility / UpgradeRules . cs <nl> ppp b / OpenRA . Utility / UpgradeRules . cs <nl> static void UpgradeActorRules ( int engineVersion , ref List < MiniYamlNode > nodes , M <nl> } <nl> } <nl> <nl> + / / \" disabled \" palette overlay has been moved into it ' s own DisabledOverlay trait <nl> + if ( engineVersion < 20140305 ) <nl> + { <nl> + if ( node . Value . Nodes . Any ( n = > n . Key . StartsWith ( \" RequiresPower \" ) ) <nl> + & & ! node . Value . Nodes . Any ( n = > n . Key . StartsWith ( \" DisabledOverlay \" ) ) ) <nl> + { <nl> + node . Value . Nodes . Add ( new MiniYamlNode ( \" DisabledOverlay \" , new MiniYaml ( \" \" ) ) ) ; <nl> + } <nl> + } <nl> + <nl> / / ChronoshiftDeploy was replaced with PortableChrono <nl> if ( engineVersion < 20140321 ) <nl> { <nl>\n", "msg": "automatic upgrade rules for new DisabledOverlay\n", "score": 1}
{"diff_id": 11590, "repo": "App-vNext/Polly\n", "sha": "577d322529812f27ba774b410e20f8a1864836b0\n", "time": "2015-06-26T12:51:04Z\n", "diff": "mmm a / src / Polly . Net35 / HandledPolicySyntax . cs <nl> ppp b / src / Polly . Net35 / HandledPolicySyntax . cs <nl> public static HandledPolicy RollbackWith ( this HandledPolicy policy , Action actio <nl> throw policy . InnerException ; <nl> } <nl> <nl> + / / / < summary > <nl> + / / / <nl> + / / / < / summary > <nl> + / / / < param name = \" policy \" > < / param > <nl> + / / / < param name = \" action \" > < / param > <nl> + / / / < returns > < / returns > <nl> + public static HandledPolicy FollowedBy ( this HandledPolicy policy , Action < HandledPolicy > action ) <nl> + { <nl> + if ( ! policy . HasException ) return policy ; <nl> + <nl> + action ( policy ) ; <nl> + <nl> + return policy ; <nl> + } <nl> } <nl> } <nl> \\ No newline at end of file <nl>\n", "msg": "FollowedBy added to easily add methods to the method chain .\n", "score": 1}
{"diff_id": 11605, "repo": "IdentityServer/IdentityServer4\n", "sha": "42b117b9d3804249a39ae1e191e7db2615122d72\n", "time": "2016-10-05T17:43:31Z\n", "diff": "mmm a / src / IdentityServer4 / Validation / Models / ValidatedEndSessionRequest . cs <nl> ppp b / src / IdentityServer4 / Validation / Models / ValidatedEndSessionRequest . cs <nl> namespace IdentityServer4 . Validation <nl> / / / < / summary > <nl> public class ValidatedEndSessionRequest : ValidatedRequest <nl> { <nl> + / / / < summary > <nl> + / / / Gets a value indicating whether this instance is authenticated . <nl> + / / / < / summary > <nl> + / / / < value > <nl> + / / / < c > true < / c > if this instance is authenticated ; otherwise , < c > false < / c > . <nl> + / / / < / value > <nl> + public bool IsAuthenticated = > Client ! = null ; <nl> + <nl> / / / < summary > <nl> / / / Gets or sets the client . <nl> / / / < / summary > <nl>\n", "msg": "add property for authenticated request\n", "score": 1}
{"diff_id": 11695, "repo": "mono/mono\n", "sha": "9fb28e2d618ec40b7af412f3a0bcad847b9b3e10\n", "time": "2007-05-20T15:32:26Z\n", "diff": "mmm a / mcs / class / Mainsoft . Web / Mainsoft . Web . Hosting / ServletWorkerRequest . jvm . cs <nl> ppp b / mcs / class / Mainsoft . Web / Mainsoft . Web . Hosting / ServletWorkerRequest . jvm . cs <nl> enum KnownServerVariable { <nl> / / the one containing more information wins . <nl> if ( contextPath . Length + servletPath . Length > requestURI . Length ) <nl> requestURI = contextPath + servletPath ; <nl> - <nl> + else { <nl> + int contextPos = requestURI . IndexOf ( contextPath , StringComparison . Ordinal ) ; <nl> + if ( contextPos > 0 ) <nl> + requestURI = requestURI . Substring ( contextPos ) ; <nl> + } <nl> + <nl> _requestUri = Uri . UnescapeDataString ( requestURI ) ; <nl> const int dotInvokeLength = 7 ; / / \" . invoke \" . Length <nl> if ( _requestUri . Length > dotInvokeLength & & <nl>\n", "msg": "Request Uri fixing to context root path\n", "score": 1}
{"diff_id": 11861, "repo": "dotnet/roslyn\n", "sha": "bdcf468e928f8e1d5ee857f5d5288f4e2be7226e\n", "time": "2015-02-25T00:39:13Z\n", "diff": "mmm a / src / VisualStudio / Core / Def / Implementation / Preview / PreviewUpdater . PreviewDialogWorkspace . cs <nl> ppp b / src / VisualStudio / Core / Def / Implementation / Preview / PreviewUpdater . PreviewDialogWorkspace . cs <nl> <nl> using System . Threading . Tasks ; <nl> using Microsoft . CodeAnalysis ; <nl> using Microsoft . CodeAnalysis . Editor . Shared . Preview ; <nl> - using Microsoft . CodeAnalysis . Shared . Extensions ; <nl> using Microsoft . CodeAnalysis . Text ; <nl> <nl> namespace Microsoft . VisualStudio . LanguageServices . Implementation . Preview <nl> { <nl> internal partial class PreviewUpdater <nl> { <nl> - private class PreviewDialogWorkspace : PreviewWorkspace <nl> + internal class PreviewDialogWorkspace : PreviewWorkspace <nl> { <nl> public PreviewDialogWorkspace ( Solution solution ) : base ( solution ) <nl> { <nl>\n", "msg": "make PreviewDialogWorkspace internal to facilitate other testing\n", "score": 1}
{"diff_id": 12109, "repo": "ppy/osu\n", "sha": "6a67ffa5b3e5ffb9be3c5a790dc184aec1e67bed\n", "time": "2017-02-25T07:31:29Z\n", "diff": "mmm a / osu . Game . Tests / Beatmaps / IO / ImportBeatmapTest . cs <nl> ppp b / osu . Game . Tests / Beatmaps / IO / ImportBeatmapTest . cs <nl> public void TestImportOverIPC ( ) <nl> if ( ! importer . ImportAsync ( osz_path ) . Wait ( 1000 ) ) <nl> Assert . Fail ( @ \" IPC took too long to send \" ) ; <nl> <nl> - ensureLoaded ( osu , 10000 ) ; <nl> + ensureLoaded ( osu ) ; <nl> } <nl> } <nl> <nl> private OsuGameBase loadOsu ( GameHost host ) <nl> return osu ; <nl> } <nl> <nl> - private void ensureLoaded ( OsuGameBase osu , int timeout = 100 ) <nl> + private void ensureLoaded ( OsuGameBase osu , int timeout = 10000 ) <nl> { <nl> IEnumerable < BeatmapSetInfo > resultSets = null ; <nl> <nl>\n", "msg": "Attempt to fix failing beatmap import test case\n", "score": 1}
{"diff_id": 13107, "repo": "ppy/osu\n", "sha": "9373520bca1ebc0f38d16bca5163eb9ed2e28a5c\n", "time": "2020-04-21T02:59:37Z\n", "diff": "mmm a / osu . Game . Rulesets . Catch / UI / Catcher . cs <nl> ppp b / osu . Game . Rulesets . Catch / UI / Catcher . cs <nl> public class Catcher : SkinReloadableDrawable , IKeyBindingHandler < CatchAction > <nl> { <nl> public static readonly Color4 DEFAULT_HYPER_DASH_COLOUR = Color4 . Red ; <nl> <nl> + / / / < summary > <nl> + / / / The default colour used directly for < see cref = \" Catcher . Colour \" / > . <nl> + / / / < / summary > <nl> + / / / < remarks > <nl> + / / / This colour is only used when no skin overrides < see cref = \" CatchSkinColour . HyperDash \" / > . <nl> + / / / < / remarks > <nl> + public static readonly Color4 DEFAULT_CATCHER_HYPER_DASH_COLOUR = Color4 . OrangeRed ; <nl> + <nl> / / / < summary > <nl> / / / Whether we are hyper - dashing or not . <nl> / / / < / summary > <nl> private void updateCatcherColour ( bool hyperDashing ) <nl> <nl> if ( hyperDashing ) <nl> { <nl> - this . FadeColour ( hyperDashColour = = DefaultHyperDashColour ? Color4 . OrangeRed : hyperDashColour , hyper_dash_transition_length , Easing . OutQuint ) ; <nl> + / / special behaviour for catcher colour if no skin overrides . <nl> + var catcherColour = <nl> + hyperDashColour = = DEFAULT_HYPER_DASH_COLOUR <nl> + ? DEFAULT_CATCHER_HYPER_DASH_COLOUR <nl> + : hyperDashColour ; <nl> + <nl> + this . FadeColour ( catcherColour , hyper_dash_transition_length , Easing . OutQuint ) ; <nl> this . FadeTo ( 0 . 2f , hyper_dash_transition_length , Easing . OutQuint ) ; <nl> } <nl> else <nl>\n", "msg": "Add constant for special colour of catcher on default skin\n", "score": 1}
{"diff_id": 13377, "repo": "jellyfin/jellyfin\n", "sha": "b501d66fa8b57eefd1c61e8388d5f0b91b34fe92\n", "time": "2016-01-12T20:12:50Z\n", "diff": "mmm a / MediaBrowser . Common . Implementations / Updates / InstallationManager . cs <nl> ppp b / MediaBrowser . Common . Implementations / Updates / InstallationManager . cs <nl> private static string ValueOrDefault ( string str , string def ) <nl> / / / < returns > Task { List { PackageInfo } } . < / returns > <nl> public async Task < IEnumerable < PackageInfo > > GetAvailablePackagesWithoutRegistrationInfo ( CancellationToken cancellationToken ) <nl> { <nl> - using ( var stream = await GetCachedPackages ( cancellationToken ) . ConfigureAwait ( false ) ) <nl> + try <nl> { <nl> - var packages = _jsonSerializer . DeserializeFromStream < List < PackageInfo > > ( stream ) . ToList ( ) ; <nl> - <nl> - if ( ( DateTime . UtcNow - _lastPackageUpdateTime ) > GetCacheLength ( ) ) <nl> + using ( var stream = _fileSystem . OpenRead ( PackageCachePath ) ) <nl> { <nl> - UpdateCachedPackages ( CancellationToken . None , false ) ; <nl> - } <nl> - <nl> - return packages ; <nl> - } <nl> - } <nl> + var packages = _jsonSerializer . DeserializeFromStream < List < PackageInfo > > ( stream ) . ToList ( ) ; <nl> <nl> - private string PackageCachePath <nl> - { <nl> - get { return Path . Combine ( _appPaths . CachePath , \" serverpackages . json \" ) ; } <nl> - } <nl> + if ( ( DateTime . UtcNow - _lastPackageUpdateTime ) > GetCacheLength ( ) ) <nl> + { <nl> + UpdateCachedPackages ( CancellationToken . None , false ) ; <nl> + } <nl> <nl> - private async Task < Stream > GetCachedPackages ( CancellationToken cancellationToken ) <nl> - { <nl> - try <nl> - { <nl> - return _fileSystem . OpenRead ( PackageCachePath ) ; <nl> + return packages ; <nl> + } <nl> } <nl> catch ( Exception ) <nl> { <nl> <nl> } <nl> <nl> + _lastPackageUpdateTime = DateTime . MinValue ; <nl> await UpdateCachedPackages ( cancellationToken , true ) . ConfigureAwait ( false ) ; <nl> - return _fileSystem . OpenRead ( PackageCachePath ) ; <nl> + using ( var stream = _fileSystem . OpenRead ( PackageCachePath ) ) <nl> + { <nl> + return _jsonSerializer . DeserializeFromStream < List < PackageInfo > > ( stream ) . ToList ( ) ; <nl> + } <nl> + } <nl> + <nl> + private string PackageCachePath <nl> + { <nl> + get { return Path . Combine ( _appPaths . CachePath , \" serverpackages . json \" ) ; } <nl> } <nl> <nl> private readonly SemaphoreSlim _updateSemaphore = new SemaphoreSlim ( 1 , 1 ) ; <nl>\n", "msg": "add error handling to package retrieval\n", "score": 1}
{"diff_id": 13832, "repo": "MonoGame/MonoGame\n", "sha": "59eba4d1b09bef1cefcc5e7c92031810bf32cac7\n", "time": "2011-07-22T22:53:54Z\n", "diff": "mmm a / MonoGame . Framework / Net / MonoGamerPeer . cs <nl> ppp b / MonoGame . Framework / Net / MonoGamerPeer . cs <nl> private void MGServer_DoWork ( object sender , DoWorkEventArgs e ) <nl> om . Write ( session . PrivateGamerSlots ) ; <nl> om . Write ( session . MaxGamers ) ; <nl> om . Write ( localMe . IsHost ) ; <nl> - IPAddress adr = IPAddress . Parse ( GetMyLocalIpAddress ( ) ) ; <nl> - om . Write ( new IPEndPoint ( adr , port ) ) ; <nl> + / / IPAddress adr = IPAddress . Parse ( GetMyLocalIpAddress ( ) ) ; <nl> + / / om . Write ( new IPEndPoint ( adr , port ) ) ; <nl> + om . Write ( myLocalEndPoint ) ; <nl> om . Write ( peer . Configuration . AppIdentifier ) ; <nl> peer . SendUnconnectedMessage ( om , m_masterServer ) ; / / send message to peer <nl> } <nl>\n", "msg": "Modify to not use unsupported call on mac and iOS\n", "score": 1}
{"diff_id": 13871, "repo": "gitextensions/gitextensions\n", "sha": "6cff88aab53f489f72694095eb8fd0de5267b138\n", "time": "2010-07-20T08:55:08Z\n", "diff": "mmm a / GitUI / FormSettings . cs <nl> ppp b / GitUI / FormSettings . cs <nl> <nl> -  using System ; <nl> - using System . Collections . Generic ; <nl> - using System . ComponentModel ; <nl> - using System . Data ; <nl> +  using System ; <nl> using System . Drawing ; <nl> - <nl> using System . Text ; <nl> using System . Windows . Forms ; <nl> using Gravatar ; <nl> <nl> using System . Reflection ; <nl> using System . IO ; <nl> using GitCommands ; <nl> - using ResourceManager . Translation ; <nl> - <nl> - namespace GitUI <nl> - { <nl> - public partial class FormSettings : GitExtensionsForm <nl> - { <nl> - public FormSettings ( ) <nl> - { <nl> - InitializeComponent ( ) ; Translate ( ) ; <nl> - <nl> - <nl> - } <nl> - <nl> - public static bool AutoSolveAllSettings ( ) <nl> - { <nl> - return SolveGitCmdDir ( ) & & <nl> - SolveGitBinDir ( ) & & <nl> - SolveKDiff ( ) & & <nl> - SolveKDiffTool2 ( ) & & <nl> - SolveGitExtensionsDir ( ) ; <nl> - } <nl> - <nl> - private void SetCheckboxFromString ( CheckBox checkBox , string str ) <nl> - { <nl> - str = str . Trim ( ) . ToLower ( ) ; <nl> - <nl> - if ( str = = \" true \" ) <nl> - checkBox . CheckState = CheckState . Checked ; <nl> - else <nl> - if ( str = = \" false \" ) <nl> - checkBox . CheckState = CheckState . Unchecked ; <nl> - else <nl> - checkBox . CheckState = CheckState . Indeterminate ; <nl> - } <nl> - <nl> - private static void SetComboBoxFromString ( ComboBox comboBox , string option ) <nl> - { <nl> - option = option . Trim ( ) . ToLower ( ) ; <nl> - <nl> - switch ( option ) <nl> - { <nl> - case \" true \" : <nl> - comboBox . SelectedItem = option ; <nl> - break ; <nl> - <nl> - case \" false \" : <nl> - comboBox . SelectedItem = option ; <nl> - break ; <nl> - <nl> - case \" input \" : <nl> - comboBox . SelectedItem = option ; <nl> - break ; <nl> - <nl> - default : <nl> - comboBox . SelectedItem = \" \" ; <nl> - break ; <nl> - } <nl> - } <nl> - <nl> - private static string GetGlobalDiffToolFromConfig ( ) <nl> - { <nl> - if ( GitCommands . GitCommands . VersionInUse . GuiDiffToolExist ) <nl> - return GitCommands . GitCommands . GetGlobalConfig ( ) . GetValue ( \" diff . guitool \" ) ; <nl> - else <nl> - return GitCommands . GitCommands . GetGlobalConfig ( ) . GetValue ( \" diff . tool \" ) ; <nl> - } <nl> - <nl> - private static void SetGlobalDiffToolToConfig ( ConfigFile configFile , string diffTool ) <nl> - { <nl> - if ( GitCommands . GitCommands . VersionInUse . GuiDiffToolExist ) <nl> - configFile . SetValue ( \" diff . guitool \" , diffTool ) ; <nl> - else <nl> - configFile . SetValue ( \" diff . tool \" , diffTool ) ; <nl> - } <nl> - <nl> - private void LoadSettings ( ) <nl> - { <nl> - try <nl> - { <nl> - if ( GitCommands . Settings . Encoding . GetType ( ) = = typeof ( ASCIIEncoding ) ) <nl> - _Encoding . Text = \" ASCII \" ; <nl> - else if ( GitCommands . Settings . Encoding . GetType ( ) = = typeof ( UnicodeEncoding ) ) <nl> - _Encoding . Text = \" Unicode \" ; <nl> - else if ( GitCommands . Settings . Encoding . GetType ( ) = = typeof ( UTF7Encoding ) ) <nl> - _Encoding . Text = \" UTF7 \" ; <nl> - else if ( GitCommands . Settings . Encoding . GetType ( ) = = typeof ( UTF8Encoding ) ) <nl> - _Encoding . Text = \" UTF8 \" ; <nl> - else if ( GitCommands . Settings . Encoding . GetType ( ) = = typeof ( UTF32Encoding ) ) <nl> - _Encoding . Text = \" UTF32 \" ; <nl> - else if ( GitCommands . Settings . Encoding = = System . Text . Encoding . Default ) <nl> - _Encoding . Text = \" Default \" ; <nl> - <nl> - FollowRenamesInFileHistory . Checked = Settings . FollowRenamesInFileHistory ; <nl> - <nl> - _DaysToCacheImages . Value = GitCommands . Settings . AuthorImageCacheDays ; <nl> - <nl> - _authorImageSize . Value = Settings . AuthorImageSize ; <nl> - ShowAuthorGravatar . Checked = Settings . ShowAuthorGravatar ; <nl> - <nl> - Language . Items . Clear ( ) ; <nl> - Language . Items . Add ( \" English \" ) ; <nl> - Language . Items . AddRange ( Translator . GetAllTranslations ( ) ) ; <nl> - Language . Text = Settings . Translation ; <nl> - <nl> - MulticolorBranches . Checked = Settings . MulticolorBranches ; <nl> - MulticolorBranches_CheckedChanged ( null , null ) ; <nl> - <nl> - BranchBorders . Checked = Settings . BranchBorders ; <nl> - StripedBanchChange . Checked = Settings . StripedBranchChange ; <nl> - <nl> - _ColorGraphLabel . BackColor = Settings . GraphColor ; <nl> - _ColorGraphLabel . Text = Settings . GraphColor . Name ; <nl> - _ColorGraphLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorGraphLabel . BackColor ) ; <nl> - _ColorTagLabel . BackColor = Settings . TagColor ; <nl> - _ColorTagLabel . Text = Settings . TagColor . Name ; <nl> - _ColorTagLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorTagLabel . BackColor ) ; <nl> - _ColorBranchLabel . BackColor = Settings . BranchColor ; <nl> - _ColorBranchLabel . Text = Settings . BranchColor . Name ; <nl> - _ColorBranchLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorBranchLabel . BackColor ) ; <nl> - _ColorRemoteBranchLabel . BackColor = Settings . RemoteBranchColor ; <nl> - _ColorRemoteBranchLabel . Text = Settings . RemoteBranchColor . Name ; <nl> - _ColorRemoteBranchLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemoteBranchLabel . BackColor ) ; <nl> - _ColorOtherLabel . BackColor = Settings . OtherTagColor ; <nl> - _ColorOtherLabel . Text = Settings . OtherTagColor . Name ; <nl> - _ColorOtherLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorOtherLabel . BackColor ) ; <nl> - <nl> - <nl> - _ColorAddedLineLabel . BackColor = Settings . DiffAddedColor ; <nl> - _ColorAddedLineLabel . Text = Settings . DiffAddedColor . Name ; <nl> - _ColorAddedLineLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorAddedLineLabel . BackColor ) ; <nl> - _ColorAddedLineDiffLabel . BackColor = Settings . DiffAddedExtraColor ; <nl> - _ColorAddedLineDiffLabel . Text = Settings . DiffAddedExtraColor . Name ; <nl> - _ColorAddedLineDiffLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorAddedLineDiffLabel . BackColor ) ; <nl> - <nl> - _ColorRemovedLine . BackColor = Settings . DiffRemovedColor ; <nl> - _ColorRemovedLine . Text = Settings . DiffRemovedColor . Name ; <nl> - _ColorRemovedLine . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemovedLine . BackColor ) ; <nl> - _ColorRemovedLineDiffLabel . BackColor = Settings . DiffRemovedExtraColor ; <nl> - _ColorRemovedLineDiffLabel . Text = Settings . DiffRemovedExtraColor . Name ; <nl> - _ColorRemovedLineDiffLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemovedLineDiffLabel . BackColor ) ; <nl> - _ColorSectionLabel . BackColor = Settings . DiffSectionColor ; <nl> - _ColorSectionLabel . Text = Settings . DiffSectionColor . Name ; <nl> - _ColorSectionLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorSectionLabel . BackColor ) ; <nl> - <nl> - if ( ! string . IsNullOrEmpty ( Settings . CustomHomeDir ) ) <nl> - { <nl> - defaultHome . Checked = userprofileHome . Checked = false ; <nl> - otherHome . Checked = true ; <nl> - otherHomeDir . Text = Settings . CustomHomeDir ; <nl> - } <nl> - else if ( Settings . UserProfileHomeDir ) <nl> - { <nl> - defaultHome . Checked = otherHome . Checked = false ; <nl> - userprofileHome . Checked = true ; <nl> - } <nl> - else <nl> - { <nl> - userprofileHome . Checked = otherHome . Checked = false ; <nl> - defaultHome . Checked = true ; <nl> - } <nl> - <nl> - SmtpServer . Text = GitCommands . Settings . Smtp ; <nl> - <nl> - _MaxCommits . Value = GitCommands . Settings . MaxCommits ; <nl> - <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - <nl> - GitPath . Text = GitCommands . Settings . GitCommand ; <nl> - GitBinPath . Text = GitCommands . Settings . GitBinDir ; <nl> - <nl> - ConfigFile localConfig = GitCommands . GitCommands . GetLocalConfig ( ) ; <nl> - ConfigFile globalConfig = GitCommands . GitCommands . GetGlobalConfig ( ) ; <nl> - <nl> - UserName . Text = localConfig . GetValue ( \" user . name \" ) ; <nl> - UserEmail . Text = localConfig . GetValue ( \" user . email \" ) ; <nl> - Editor . Text = localConfig . GetValue ( \" core . editor \" ) ; <nl> - MergeTool . Text = localConfig . GetValue ( \" merge . tool \" ) ; <nl> - <nl> - Dictionary . Text = GitCommands . Settings . Dictionary ; <nl> - <nl> - GlobalUserName . Text = globalConfig . GetValue ( \" user . name \" ) ; <nl> - GlobalUserEmail . Text = globalConfig . GetValue ( \" user . email \" ) ; <nl> - GlobalEditor . Text = globalConfig . GetValue ( \" core . editor \" ) ; <nl> - GlobalMergeTool . Text = globalConfig . GetValue ( \" merge . tool \" ) ; <nl> - <nl> - SetCheckboxFromString ( KeepMergeBackup , localConfig . GetValue ( \" mergetool . keepBackup \" ) ) ; <nl> - SetComboBoxFromString ( LocalAutoCRLF , localConfig . GetValue ( \" core . autocrlf \" ) ) ; <nl> - <nl> - if ( ! string . IsNullOrEmpty ( GlobalMergeTool . Text ) ) <nl> - MergetoolPath . Text = globalConfig . GetValue ( \" mergetool . \" + GlobalMergeTool . Text + \" . path \" ) ; <nl> - if ( ! string . IsNullOrEmpty ( GlobalMergeTool . Text ) ) <nl> - MergeToolCmd . Text = globalConfig . GetValue ( \" mergetool . \" + GlobalMergeTool . Text + \" . cmd \" ) ; <nl> - <nl> - DefaultIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" default \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> - BlueIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" blue \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> - GreenIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" green \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> - PurpleIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" purple \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> - RedIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" red \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> - YellowIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" yellow \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> - RandomIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" random \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> - <nl> - GlobalDiffTool . Text = FormSettings . GetGlobalDiffToolFromConfig ( ) ; <nl> - <nl> - if ( ! string . IsNullOrEmpty ( GlobalDiffTool . Text ) ) <nl> - DifftoolPath . Text = globalConfig . GetValue ( \" difftool . \" + GlobalDiffTool . Text + \" . path \" ) ; <nl> - if ( ! string . IsNullOrEmpty ( GlobalDiffTool . Text ) ) <nl> - DifftoolCmd . Text = globalConfig . GetValue ( \" difftool . \" + GlobalDiffTool . Text + \" . cmd \" ) ; <nl> - <nl> - SetCheckboxFromString ( GlobalKeepMergeBackup , globalConfig . GetValue ( \" mergetool . keepBackup \" ) ) ; <nl> - SetComboBoxFromString ( GlobalAutoCRLF , globalConfig . GetValue ( \" core . autocrlf \" ) ) ; <nl> - <nl> - PlinkPath . Text = GitCommands . Settings . Plink ; <nl> - PuttygenPath . Text = GitCommands . Settings . Puttygen ; <nl> - PageantPath . Text = GitCommands . Settings . Pageant ; <nl> - AutostartPageant . Checked = GitCommands . Settings . AutoStartPageant ; <nl> - <nl> - CloseProcessDialog . Checked = GitCommands . Settings . CloseProcessDialog ; <nl> - ShowRevisionGraph . Checked = GitCommands . Settings . ShowRevisionGraph ; <nl> - ShowGitCommandLine . Checked = GitCommands . Settings . ShowGitCommandLine ; <nl> - <nl> - UseFastChecks . Checked = GitCommands . Settings . UseFastChecks ; <nl> - ShowRelativeDate . Checked = GitCommands . Settings . RelativeDate ; <nl> - <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . GetSsh ( ) ) ) <nl> - OpenSSH . Checked = true ; <nl> - else <nl> - if ( GitCommands . GitCommands . Plink ( ) ) <nl> - Putty . Checked = true ; <nl> - else <nl> - { <nl> - OtherSsh . Text = GitCommands . GitCommands . GetSsh ( ) ; <nl> - Other . Checked = true ; <nl> - } <nl> - <nl> - EnableSshOptions ( ) ; <nl> - } <nl> - catch ( Exception ex ) <nl> - { <nl> - MessageBox . Show ( \" Could not load settings . \\ n \\ n \" + ex . Message ) ; <nl> - <nl> - / / Bail out before the user saves the incompletely loaded settings <nl> - / / and has their day ruined . <nl> - DialogResult = DialogResult . Abort ; <nl> - } <nl> - } <nl> - <nl> - private void UserName_TextChanged ( object sender , EventArgs e ) <nl> - { <nl> - } <nl> - <nl> - private void UserEmail_TextChanged ( object sender , EventArgs e ) <nl> - { <nl> - } <nl> - <nl> - private void Ok_Click ( object sender , EventArgs e ) <nl> - { <nl> - Close ( ) ; <nl> - } <nl> - <nl> - private bool Save ( ) <nl> - { <nl> - if ( otherHome . Checked ) <nl> - { <nl> - Settings . UserProfileHomeDir = false ; <nl> - if ( string . IsNullOrEmpty ( otherHomeDir . Text ) ) <nl> - { <nl> - MessageBox . Show ( \" Please enter a valid HOME directory . \" ) ; <nl> - new FormFixHome ( ) . ShowDialog ( ) ; <nl> - } <nl> - else <nl> - Settings . CustomHomeDir = otherHomeDir . Text ; <nl> - } <nl> - else <nl> - { <nl> - Settings . CustomHomeDir = \" \" ; <nl> - Settings . UserProfileHomeDir = userprofileHome . Checked ; <nl> - } <nl> - <nl> - FormFixHome . CheckHomePath ( ) ; <nl> - <nl> - GitCommands . GitCommands . SetEnvironmentVariable ( true ) ; <nl> - <nl> - <nl> - GitCommands . Settings . FollowRenamesInFileHistory = FollowRenamesInFileHistory . Checked ; <nl> - <nl> - if ( ( int ) _authorImageSize . Value ! = GitCommands . Settings . AuthorImageSize ) <nl> - { <nl> - GitCommands . Settings . AuthorImageSize = ( int ) _authorImageSize . Value ; <nl> - GravatarService . ClearImageCache ( ) ; <nl> - } <nl> - GitCommands . Settings . Translation = Language . Text ; <nl> - <nl> - GitCommands . Settings . AuthorImageCacheDays = ( int ) _DaysToCacheImages . Value ; <nl> - <nl> - GitCommands . Settings . Smtp = SmtpServer . Text ; <nl> - <nl> - GitCommands . Settings . GitCommand = GitPath . Text ; <nl> - GitCommands . Settings . GitBinDir = GitBinPath . Text ; <nl> - <nl> - GitCommands . Settings . ShowAuthorGravatar = ShowAuthorGravatar . Checked ; <nl> - <nl> - GitCommands . Settings . CloseProcessDialog = CloseProcessDialog . Checked ; <nl> - GitCommands . Settings . ShowRevisionGraph = ShowRevisionGraph . Checked ; <nl> - GitCommands . Settings . ShowGitCommandLine = ShowGitCommandLine . Checked ; <nl> - <nl> - GitCommands . Settings . UseFastChecks = UseFastChecks . Checked ; <nl> - GitCommands . Settings . RelativeDate = ShowRelativeDate . Checked ; <nl> - <nl> - GitCommands . Settings . Dictionary = Dictionary . Text ; <nl> - <nl> - GitCommands . Settings . MaxCommits = ( int ) _MaxCommits . Value ; <nl> - <nl> - GitCommands . Settings . Plink = PlinkPath . Text ; <nl> - GitCommands . Settings . Puttygen = PuttygenPath . Text ; <nl> - GitCommands . Settings . Pageant = PageantPath . Text ; <nl> - GitCommands . Settings . AutoStartPageant = AutostartPageant . Checked ; <nl> - <nl> - if ( string . IsNullOrEmpty ( _Encoding . Text ) | | _Encoding . Text . Equals ( \" Default \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - GitCommands . Settings . Encoding = System . Text . Encoding . Default ; <nl> - else <nl> - if ( _Encoding . Text . Equals ( \" ASCII \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - GitCommands . Settings . Encoding = new ASCIIEncoding ( ) ; <nl> - else <nl> - if ( _Encoding . Text . Equals ( \" Unicode \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - GitCommands . Settings . Encoding = new UnicodeEncoding ( ) ; <nl> - else <nl> - if ( _Encoding . Text . Equals ( \" UTF7 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - GitCommands . Settings . Encoding = new UTF7Encoding ( ) ; <nl> - else <nl> - if ( _Encoding . Text . Equals ( \" UTF8 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - GitCommands . Settings . Encoding = new UTF8Encoding ( false ) ; <nl> - else <nl> - if ( _Encoding . Text . Equals ( \" UTF32 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - GitCommands . Settings . Encoding = new UTF32Encoding ( true , false ) ; <nl> - else <nl> - GitCommands . Settings . Encoding = System . Text . Encoding . Default ; <nl> - <nl> - <nl> - Settings . MulticolorBranches = MulticolorBranches . Checked ; <nl> - Settings . BranchBorders = BranchBorders . Checked ; <nl> - Settings . StripedBranchChange = StripedBanchChange . Checked ; <nl> - Settings . GraphColor = _ColorGraphLabel . BackColor ; <nl> - Settings . TagColor = _ColorTagLabel . BackColor ; <nl> - Settings . BranchColor = _ColorBranchLabel . BackColor ; <nl> - Settings . RemoteBranchColor = _ColorRemoteBranchLabel . BackColor ; <nl> - Settings . OtherTagColor = _ColorOtherLabel . BackColor ; <nl> - <nl> - Settings . DiffAddedColor = _ColorAddedLineLabel . BackColor ; <nl> - Settings . DiffRemovedColor = _ColorRemovedLine . BackColor ; <nl> - Settings . DiffAddedExtraColor = _ColorAddedLineDiffLabel . BackColor ; <nl> - Settings . DiffRemovedExtraColor = _ColorRemovedLineDiffLabel . BackColor ; <nl> - <nl> - Settings . DiffSectionColor = _ColorSectionLabel . BackColor ; <nl> - <nl> - if ( DefaultIcon . Checked ) <nl> - GitCommands . Settings . IconColor = \" default \" ; <nl> - if ( BlueIcon . Checked ) <nl> - GitCommands . Settings . IconColor = \" blue \" ; <nl> - if ( GreenIcon . Checked ) <nl> - GitCommands . Settings . IconColor = \" green \" ; <nl> - if ( PurpleIcon . Checked ) <nl> - GitCommands . Settings . IconColor = \" purple \" ; <nl> - if ( RedIcon . Checked ) <nl> - GitCommands . Settings . IconColor = \" red \" ; <nl> - if ( YellowIcon . Checked ) <nl> - GitCommands . Settings . IconColor = \" yellow \" ; <nl> - if ( RandomIcon . Checked ) <nl> - GitCommands . Settings . IconColor = \" random \" ; <nl> - <nl> - EnableSettings ( ) ; <nl> - <nl> - if ( ! CanFindGitCmd ( ) ) <nl> - { <nl> - if ( MessageBox . Show ( \" The path to git . cmd is not configured correct . \" + Environment . NewLine + \" You need to set the correct path to be able to use GitExtensions . \" + Environment . NewLine + Environment . NewLine + \" Do you want to set the correct path now ? \" , \" Incorrect path \" , MessageBoxButtons . YesNo ) = = DialogResult . Yes ) <nl> - return false ; <nl> - } <nl> - else <nl> - { <nl> + using ResourceManager . Translation ; <nl> + <nl> + namespace GitUI <nl> + { <nl> + public partial class FormSettings : GitExtensionsForm <nl> + { <nl> + public FormSettings ( ) <nl> + { <nl> + InitializeComponent ( ) ; Translate ( ) ; <nl> + } <nl> + <nl> + public static bool AutoSolveAllSettings ( ) <nl> + { <nl> + return SolveGitCmdDir ( ) & & <nl> + SolveGitBinDir ( ) & & <nl> + SolveKDiff ( ) & & <nl> + SolveKDiffTool2 ( ) & & <nl> + SolveGitExtensionsDir ( ) ; <nl> + } <nl> + <nl> + private void SetCheckboxFromString ( CheckBox checkBox , string str ) <nl> + { <nl> + str = str . Trim ( ) . ToLower ( ) ; <nl> + <nl> + switch ( str ) <nl> + { <nl> + case \" true \" : <nl> + { <nl> + checkBox . CheckState = CheckState . Checked ; <nl> + return ; <nl> + } <nl> + case \" false \" : <nl> + { <nl> + checkBox . CheckState = CheckState . Unchecked ; <nl> + return ; <nl> + } <nl> + default : <nl> + checkBox . CheckState = CheckState . Indeterminate ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + private static void SetComboBoxFromString ( ComboBox comboBox , string option ) <nl> + { <nl> + option = option . Trim ( ) . ToLower ( ) ; <nl> + <nl> + switch ( option ) <nl> + { <nl> + case \" true \" : <nl> + comboBox . SelectedItem = option ; <nl> + break ; <nl> + <nl> + case \" false \" : <nl> + comboBox . SelectedItem = option ; <nl> + break ; <nl> + <nl> + case \" input \" : <nl> + comboBox . SelectedItem = option ; <nl> + break ; <nl> + <nl> + default : <nl> + comboBox . SelectedItem = \" \" ; <nl> + break ; <nl> + } <nl> + } <nl> + <nl> + private static string GetGlobalDiffToolFromConfig ( ) <nl> + { <nl> + if ( GitCommands . GitCommands . VersionInUse . GuiDiffToolExist ) <nl> + return GitCommands . GitCommands . GetGlobalConfig ( ) . GetValue ( \" diff . guitool \" ) ; <nl> + return GitCommands . GitCommands . GetGlobalConfig ( ) . GetValue ( \" diff . tool \" ) ; <nl> + } <nl> + <nl> + private static void SetGlobalDiffToolToConfig ( ConfigFile configFile , string diffTool ) <nl> + { <nl> + if ( GitCommands . GitCommands . VersionInUse . GuiDiffToolExist ) <nl> + { <nl> + configFile . SetValue ( \" diff . guitool \" , diffTool ) ; <nl> + return ; <nl> + } <nl> + configFile . SetValue ( \" diff . tool \" , diffTool ) ; <nl> + } <nl> + <nl> + private void LoadSettings ( ) <nl> + { <nl> + try <nl> + { <nl> + if ( GitCommands . Settings . Encoding . GetType ( ) = = typeof ( ASCIIEncoding ) ) <nl> + _Encoding . Text = \" ASCII \" ; <nl> + else if ( GitCommands . Settings . Encoding . GetType ( ) = = typeof ( UnicodeEncoding ) ) <nl> + _Encoding . Text = \" Unicode \" ; <nl> + else if ( GitCommands . Settings . Encoding . GetType ( ) = = typeof ( UTF7Encoding ) ) <nl> + _Encoding . Text = \" UTF7 \" ; <nl> + else if ( GitCommands . Settings . Encoding . GetType ( ) = = typeof ( UTF8Encoding ) ) <nl> + _Encoding . Text = \" UTF8 \" ; <nl> + else if ( GitCommands . Settings . Encoding . GetType ( ) = = typeof ( UTF32Encoding ) ) <nl> + _Encoding . Text = \" UTF32 \" ; <nl> + else if ( GitCommands . Settings . Encoding = = System . Text . Encoding . Default ) <nl> + _Encoding . Text = \" Default \" ; <nl> + <nl> + FollowRenamesInFileHistory . Checked = Settings . FollowRenamesInFileHistory ; <nl> + <nl> + _DaysToCacheImages . Value = GitCommands . Settings . AuthorImageCacheDays ; <nl> + <nl> + _authorImageSize . Value = Settings . AuthorImageSize ; <nl> + ShowAuthorGravatar . Checked = Settings . ShowAuthorGravatar ; <nl> + <nl> + Language . Items . Clear ( ) ; <nl> + Language . Items . Add ( \" English \" ) ; <nl> + Language . Items . AddRange ( Translator . GetAllTranslations ( ) ) ; <nl> + Language . Text = Settings . Translation ; <nl> + <nl> + MulticolorBranches . Checked = Settings . MulticolorBranches ; <nl> + MulticolorBranches_CheckedChanged ( null , null ) ; <nl> + <nl> + BranchBorders . Checked = Settings . BranchBorders ; <nl> + StripedBanchChange . Checked = Settings . StripedBranchChange ; <nl> + <nl> + _ColorGraphLabel . BackColor = Settings . GraphColor ; <nl> + _ColorGraphLabel . Text = Settings . GraphColor . Name ; <nl> + _ColorGraphLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorGraphLabel . BackColor ) ; <nl> + _ColorTagLabel . BackColor = Settings . TagColor ; <nl> + _ColorTagLabel . Text = Settings . TagColor . Name ; <nl> + _ColorTagLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorTagLabel . BackColor ) ; <nl> + _ColorBranchLabel . BackColor = Settings . BranchColor ; <nl> + _ColorBranchLabel . Text = Settings . BranchColor . Name ; <nl> + _ColorBranchLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorBranchLabel . BackColor ) ; <nl> + _ColorRemoteBranchLabel . BackColor = Settings . RemoteBranchColor ; <nl> + _ColorRemoteBranchLabel . Text = Settings . RemoteBranchColor . Name ; <nl> + _ColorRemoteBranchLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemoteBranchLabel . BackColor ) ; <nl> + _ColorOtherLabel . BackColor = Settings . OtherTagColor ; <nl> + _ColorOtherLabel . Text = Settings . OtherTagColor . Name ; <nl> + _ColorOtherLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorOtherLabel . BackColor ) ; <nl> + <nl> + <nl> + _ColorAddedLineLabel . BackColor = Settings . DiffAddedColor ; <nl> + _ColorAddedLineLabel . Text = Settings . DiffAddedColor . Name ; <nl> + _ColorAddedLineLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorAddedLineLabel . BackColor ) ; <nl> + _ColorAddedLineDiffLabel . BackColor = Settings . DiffAddedExtraColor ; <nl> + _ColorAddedLineDiffLabel . Text = Settings . DiffAddedExtraColor . Name ; <nl> + _ColorAddedLineDiffLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorAddedLineDiffLabel . BackColor ) ; <nl> + <nl> + _ColorRemovedLine . BackColor = Settings . DiffRemovedColor ; <nl> + _ColorRemovedLine . Text = Settings . DiffRemovedColor . Name ; <nl> + _ColorRemovedLine . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemovedLine . BackColor ) ; <nl> + _ColorRemovedLineDiffLabel . BackColor = Settings . DiffRemovedExtraColor ; <nl> + _ColorRemovedLineDiffLabel . Text = Settings . DiffRemovedExtraColor . Name ; <nl> + _ColorRemovedLineDiffLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemovedLineDiffLabel . BackColor ) ; <nl> + _ColorSectionLabel . BackColor = Settings . DiffSectionColor ; <nl> + _ColorSectionLabel . Text = Settings . DiffSectionColor . Name ; <nl> + _ColorSectionLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorSectionLabel . BackColor ) ; <nl> + <nl> + if ( ! string . IsNullOrEmpty ( Settings . CustomHomeDir ) ) <nl> + { <nl> + defaultHome . Checked = userprofileHome . Checked = false ; <nl> + otherHome . Checked = true ; <nl> + otherHomeDir . Text = Settings . CustomHomeDir ; <nl> + } <nl> + else if ( Settings . UserProfileHomeDir ) <nl> + { <nl> + defaultHome . Checked = otherHome . Checked = false ; <nl> + userprofileHome . Checked = true ; <nl> + } <nl> + else <nl> + { <nl> + userprofileHome . Checked = otherHome . Checked = false ; <nl> + defaultHome . Checked = true ; <nl> + } <nl> + <nl> + SmtpServer . Text = GitCommands . Settings . Smtp ; <nl> + <nl> + _MaxCommits . Value = GitCommands . Settings . MaxCommits ; <nl> + <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + <nl> + GitPath . Text = GitCommands . Settings . GitCommand ; <nl> + GitBinPath . Text = GitCommands . Settings . GitBinDir ; <nl> + <nl> + ConfigFile localConfig = GitCommands . GitCommands . GetLocalConfig ( ) ; <nl> + ConfigFile globalConfig = GitCommands . GitCommands . GetGlobalConfig ( ) ; <nl> + <nl> + UserName . Text = localConfig . GetValue ( \" user . name \" ) ; <nl> + UserEmail . Text = localConfig . GetValue ( \" user . email \" ) ; <nl> + Editor . Text = localConfig . GetValue ( \" core . editor \" ) ; <nl> + MergeTool . Text = localConfig . GetValue ( \" merge . tool \" ) ; <nl> + <nl> + Dictionary . Text = GitCommands . Settings . Dictionary ; <nl> + <nl> + GlobalUserName . Text = globalConfig . GetValue ( \" user . name \" ) ; <nl> + GlobalUserEmail . Text = globalConfig . GetValue ( \" user . email \" ) ; <nl> + GlobalEditor . Text = globalConfig . GetValue ( \" core . editor \" ) ; <nl> + GlobalMergeTool . Text = globalConfig . GetValue ( \" merge . tool \" ) ; <nl> + <nl> + SetCheckboxFromString ( KeepMergeBackup , localConfig . GetValue ( \" mergetool . keepBackup \" ) ) ; <nl> + SetComboBoxFromString ( LocalAutoCRLF , localConfig . GetValue ( \" core . autocrlf \" ) ) ; <nl> + <nl> + if ( ! string . IsNullOrEmpty ( GlobalMergeTool . Text ) ) <nl> + MergetoolPath . Text = globalConfig . GetValue ( \" mergetool . \" + GlobalMergeTool . Text + \" . path \" ) ; <nl> + if ( ! string . IsNullOrEmpty ( GlobalMergeTool . Text ) ) <nl> + MergeToolCmd . Text = globalConfig . GetValue ( \" mergetool . \" + GlobalMergeTool . Text + \" . cmd \" ) ; <nl> + <nl> + DefaultIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" default \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> + BlueIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" blue \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> + GreenIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" green \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> + PurpleIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" purple \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> + RedIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" red \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> + YellowIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" yellow \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> + RandomIcon . Checked = GitCommands . Settings . IconColor . Equals ( \" random \" , StringComparison . CurrentCultureIgnoreCase ) ; <nl> + <nl> + GlobalDiffTool . Text = FormSettings . GetGlobalDiffToolFromConfig ( ) ; <nl> + <nl> + if ( ! string . IsNullOrEmpty ( GlobalDiffTool . Text ) ) <nl> + DifftoolPath . Text = globalConfig . GetValue ( \" difftool . \" + GlobalDiffTool . Text + \" . path \" ) ; <nl> + if ( ! string . IsNullOrEmpty ( GlobalDiffTool . Text ) ) <nl> + DifftoolCmd . Text = globalConfig . GetValue ( \" difftool . \" + GlobalDiffTool . Text + \" . cmd \" ) ; <nl> + <nl> + SetCheckboxFromString ( GlobalKeepMergeBackup , globalConfig . GetValue ( \" mergetool . keepBackup \" ) ) ; <nl> + SetComboBoxFromString ( GlobalAutoCRLF , globalConfig . GetValue ( \" core . autocrlf \" ) ) ; <nl> + <nl> + PlinkPath . Text = GitCommands . Settings . Plink ; <nl> + PuttygenPath . Text = GitCommands . Settings . Puttygen ; <nl> + PageantPath . Text = GitCommands . Settings . Pageant ; <nl> + AutostartPageant . Checked = GitCommands . Settings . AutoStartPageant ; <nl> + <nl> + CloseProcessDialog . Checked = GitCommands . Settings . CloseProcessDialog ; <nl> + ShowRevisionGraph . Checked = GitCommands . Settings . ShowRevisionGraph ; <nl> + ShowGitCommandLine . Checked = GitCommands . Settings . ShowGitCommandLine ; <nl> + <nl> + UseFastChecks . Checked = GitCommands . Settings . UseFastChecks ; <nl> + ShowRelativeDate . Checked = GitCommands . Settings . RelativeDate ; <nl> + <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . GetSsh ( ) ) ) <nl> + OpenSSH . Checked = true ; <nl> + else <nl> + if ( GitCommands . GitCommands . Plink ( ) ) <nl> + Putty . Checked = true ; <nl> + else <nl> + { <nl> + OtherSsh . Text = GitCommands . GitCommands . GetSsh ( ) ; <nl> + Other . Checked = true ; <nl> + } <nl> + <nl> + EnableSshOptions ( ) ; <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + MessageBox . Show ( \" Could not load settings . \\ n \\ n \" + ex . Message ) ; <nl> + <nl> + / / Bail out before the user saves the incompletely loaded settings <nl> + / / and has their day ruined . <nl> + DialogResult = DialogResult . Abort ; <nl> + } <nl> + } <nl> + <nl> + private void UserName_TextChanged ( object sender , EventArgs e ) <nl> + { <nl> + } <nl> + <nl> + private void UserEmail_TextChanged ( object sender , EventArgs e ) <nl> + { <nl> + } <nl> + <nl> + private void Ok_Click ( object sender , EventArgs e ) <nl> + { <nl> + Close ( ) ; <nl> + } <nl> + <nl> + private bool Save ( ) <nl> + { <nl> + if ( otherHome . Checked ) <nl> + { <nl> + Settings . UserProfileHomeDir = false ; <nl> + if ( string . IsNullOrEmpty ( otherHomeDir . Text ) ) <nl> + { <nl> + MessageBox . Show ( \" Please enter a valid HOME directory . \" ) ; <nl> + new FormFixHome ( ) . ShowDialog ( ) ; <nl> + } <nl> + else <nl> + Settings . CustomHomeDir = otherHomeDir . Text ; <nl> + } <nl> + else <nl> + { <nl> + Settings . CustomHomeDir = \" \" ; <nl> + Settings . UserProfileHomeDir = userprofileHome . Checked ; <nl> + } <nl> + <nl> + FormFixHome . CheckHomePath ( ) ; <nl> + <nl> + GitCommands . GitCommands . SetEnvironmentVariable ( true ) ; <nl> + <nl> + <nl> + GitCommands . Settings . FollowRenamesInFileHistory = FollowRenamesInFileHistory . Checked ; <nl> + <nl> + if ( ( int ) _authorImageSize . Value ! = GitCommands . Settings . AuthorImageSize ) <nl> + { <nl> + GitCommands . Settings . AuthorImageSize = ( int ) _authorImageSize . Value ; <nl> + GravatarService . ClearImageCache ( ) ; <nl> + } <nl> + GitCommands . Settings . Translation = Language . Text ; <nl> + <nl> + GitCommands . Settings . AuthorImageCacheDays = ( int ) _DaysToCacheImages . Value ; <nl> + <nl> + GitCommands . Settings . Smtp = SmtpServer . Text ; <nl> + <nl> + GitCommands . Settings . GitCommand = GitPath . Text ; <nl> + GitCommands . Settings . GitBinDir = GitBinPath . Text ; <nl> + <nl> + GitCommands . Settings . ShowAuthorGravatar = ShowAuthorGravatar . Checked ; <nl> + <nl> + GitCommands . Settings . CloseProcessDialog = CloseProcessDialog . Checked ; <nl> + GitCommands . Settings . ShowRevisionGraph = ShowRevisionGraph . Checked ; <nl> + GitCommands . Settings . ShowGitCommandLine = ShowGitCommandLine . Checked ; <nl> + <nl> + GitCommands . Settings . UseFastChecks = UseFastChecks . Checked ; <nl> + GitCommands . Settings . RelativeDate = ShowRelativeDate . Checked ; <nl> + <nl> + GitCommands . Settings . Dictionary = Dictionary . Text ; <nl> + <nl> + GitCommands . Settings . MaxCommits = ( int ) _MaxCommits . Value ; <nl> + <nl> + GitCommands . Settings . Plink = PlinkPath . Text ; <nl> + GitCommands . Settings . Puttygen = PuttygenPath . Text ; <nl> + GitCommands . Settings . Pageant = PageantPath . Text ; <nl> + GitCommands . Settings . AutoStartPageant = AutostartPageant . Checked ; <nl> + <nl> + if ( string . IsNullOrEmpty ( _Encoding . Text ) | | _Encoding . Text . Equals ( \" Default \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + GitCommands . Settings . Encoding = System . Text . Encoding . Default ; <nl> + else <nl> + if ( _Encoding . Text . Equals ( \" ASCII \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + GitCommands . Settings . Encoding = new ASCIIEncoding ( ) ; <nl> + else <nl> + if ( _Encoding . Text . Equals ( \" Unicode \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + GitCommands . Settings . Encoding = new UnicodeEncoding ( ) ; <nl> + else <nl> + if ( _Encoding . Text . Equals ( \" UTF7 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + GitCommands . Settings . Encoding = new UTF7Encoding ( ) ; <nl> + else <nl> + if ( _Encoding . Text . Equals ( \" UTF8 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + GitCommands . Settings . Encoding = new UTF8Encoding ( false ) ; <nl> + else <nl> + if ( _Encoding . Text . Equals ( \" UTF32 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + GitCommands . Settings . Encoding = new UTF32Encoding ( true , false ) ; <nl> + else <nl> + GitCommands . Settings . Encoding = System . Text . Encoding . Default ; <nl> + <nl> + <nl> + Settings . MulticolorBranches = MulticolorBranches . Checked ; <nl> + Settings . BranchBorders = BranchBorders . Checked ; <nl> + Settings . StripedBranchChange = StripedBanchChange . Checked ; <nl> + Settings . GraphColor = _ColorGraphLabel . BackColor ; <nl> + Settings . TagColor = _ColorTagLabel . BackColor ; <nl> + Settings . BranchColor = _ColorBranchLabel . BackColor ; <nl> + Settings . RemoteBranchColor = _ColorRemoteBranchLabel . BackColor ; <nl> + Settings . OtherTagColor = _ColorOtherLabel . BackColor ; <nl> + <nl> + Settings . DiffAddedColor = _ColorAddedLineLabel . BackColor ; <nl> + Settings . DiffRemovedColor = _ColorRemovedLine . BackColor ; <nl> + Settings . DiffAddedExtraColor = _ColorAddedLineDiffLabel . BackColor ; <nl> + Settings . DiffRemovedExtraColor = _ColorRemovedLineDiffLabel . BackColor ; <nl> + <nl> + Settings . DiffSectionColor = _ColorSectionLabel . BackColor ; <nl> + <nl> + if ( DefaultIcon . Checked ) <nl> + GitCommands . Settings . IconColor = \" default \" ; <nl> + if ( BlueIcon . Checked ) <nl> + GitCommands . Settings . IconColor = \" blue \" ; <nl> + if ( GreenIcon . Checked ) <nl> + GitCommands . Settings . IconColor = \" green \" ; <nl> + if ( PurpleIcon . Checked ) <nl> + GitCommands . Settings . IconColor = \" purple \" ; <nl> + if ( RedIcon . Checked ) <nl> + GitCommands . Settings . IconColor = \" red \" ; <nl> + if ( YellowIcon . Checked ) <nl> + GitCommands . Settings . IconColor = \" yellow \" ; <nl> + if ( RandomIcon . Checked ) <nl> + GitCommands . Settings . IconColor = \" random \" ; <nl> + <nl> + EnableSettings ( ) ; <nl> + <nl> + if ( ! CanFindGitCmd ( ) ) <nl> + { <nl> + if ( MessageBox . Show ( \" The path to git . cmd is not configured correct . \" + Environment . NewLine + \" You need to set the correct path to be able to use GitExtensions . \" + Environment . NewLine + Environment . NewLine + \" Do you want to set the correct path now ? \" , \" Incorrect path \" , MessageBoxButtons . YesNo ) = = DialogResult . Yes ) <nl> + return false ; <nl> + } <nl> + else <nl> + { <nl> handleCanFindGitCommand ( ) ; <nl> - } <nl> - <nl> - if ( OpenSSH . Checked ) <nl> - GitCommands . GitCommands . UnSetSsh ( ) ; <nl> - <nl> - if ( Putty . Checked ) <nl> - GitCommands . GitCommands . SetSsh ( PlinkPath . Text ) ; <nl> - <nl> - if ( Other . Checked ) <nl> - GitCommands . GitCommands . SetSsh ( OtherSsh . Text ) ; <nl> - <nl> - GitCommands . Settings . SaveSettings ( ) ; <nl> - <nl> - return true ; <nl> + } <nl> + <nl> + if ( OpenSSH . Checked ) <nl> + GitCommands . GitCommands . UnSetSsh ( ) ; <nl> + <nl> + if ( Putty . Checked ) <nl> + GitCommands . GitCommands . SetSsh ( PlinkPath . Text ) ; <nl> + <nl> + if ( Other . Checked ) <nl> + GitCommands . GitCommands . SetSsh ( OtherSsh . Text ) ; <nl> + <nl> + GitCommands . Settings . SaveSettings ( ) ; <nl> + <nl> + return true ; <nl> } <nl> <nl> private void handleCanFindGitCommand ( ) <nl> { <nl> - ConfigFile localConfig = GitCommands . GitCommands . GetLocalConfig ( ) ; <nl> - ConfigFile globalConfig = GitCommands . GitCommands . GetGlobalConfig ( ) ; <nl> - <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - <nl> - if ( string . IsNullOrEmpty ( UserName . Text ) | | ! UserName . Text . Equals ( localConfig . GetValue ( \" user . name \" ) ) ) <nl> - localConfig . SetValue ( \" user . name \" , UserName . Text ) ; <nl> - if ( string . IsNullOrEmpty ( UserEmail . Text ) | | ! UserEmail . Text . Equals ( localConfig . GetValue ( \" user . email \" ) ) ) <nl> - localConfig . SetValue ( \" user . email \" , UserEmail . Text ) ; <nl> - localConfig . SetValue ( \" core . editor \" , Editor . Text ) ; <nl> - localConfig . SetValue ( \" merge . tool \" , MergeTool . Text ) ; <nl> - <nl> - <nl> - if ( KeepMergeBackup . CheckState = = CheckState . Checked ) <nl> - localConfig . SetValue ( \" mergetool . keepBackup \" , \" true \" ) ; <nl> - else <nl> - if ( KeepMergeBackup . CheckState = = CheckState . Unchecked ) <nl> - localConfig . SetValue ( \" mergetool . keepBackup \" , \" false \" ) ; <nl> - <nl> - localConfig . SetValue ( \" core . autocrlf \" , LocalAutoCRLF . SelectedItem as string ) ; <nl> - <nl> - if ( string . IsNullOrEmpty ( GlobalUserName . Text ) | | ! GlobalUserName . Text . Equals ( globalConfig . GetValue ( \" user . name \" ) ) ) <nl> - globalConfig . SetValue ( \" user . name \" , GlobalUserName . Text ) ; <nl> - if ( string . IsNullOrEmpty ( GlobalUserEmail . Text ) | | ! GlobalUserEmail . Text . Equals ( globalConfig . GetValue ( \" user . email \" ) ) ) <nl> - globalConfig . SetValue ( \" user . email \" , GlobalUserEmail . Text ) ; <nl> - globalConfig . SetValue ( \" core . editor \" , GlobalEditor . Text ) ; <nl> - <nl> - FormSettings . SetGlobalDiffToolToConfig ( globalConfig , GlobalDiffTool . Text ) ; <nl> - <nl> - if ( ! string . IsNullOrEmpty ( GlobalDiffTool . Text ) ) <nl> - globalConfig . SetValue ( \" difftool . \" + GlobalDiffTool . Text + \" . path \" , DifftoolPath . Text ) ; <nl> - if ( ! string . IsNullOrEmpty ( GlobalDiffTool . Text ) ) <nl> - globalConfig . SetValue ( \" difftool . \" + GlobalDiffTool . Text + \" . cmd \" , DifftoolCmd . Text ) ; <nl> - <nl> - globalConfig . SetValue ( \" merge . tool \" , GlobalMergeTool . Text ) ; <nl> - <nl> - if ( ! string . IsNullOrEmpty ( GlobalMergeTool . Text ) ) <nl> - globalConfig . SetValue ( \" mergetool . \" + GlobalMergeTool . Text + \" . path \" , MergetoolPath . Text ) ; <nl> - if ( ! string . IsNullOrEmpty ( GlobalMergeTool . Text ) ) <nl> - globalConfig . SetValue ( \" mergetool . \" + GlobalMergeTool . Text + \" . cmd \" , MergeToolCmd . Text ) ; <nl> - <nl> - if ( GlobalKeepMergeBackup . CheckState = = CheckState . Checked ) <nl> - globalConfig . SetValue ( \" mergetool . keepBackup \" , \" true \" ) ; <nl> - else <nl> - if ( GlobalKeepMergeBackup . CheckState = = CheckState . Unchecked ) <nl> - globalConfig . SetValue ( \" mergetool . keepBackup \" , \" false \" ) ; <nl> - <nl> - globalConfig . SetValue ( \" core . autocrlf \" , GlobalAutoCRLF . SelectedItem as string ) ; <nl> - globalConfig . Save ( ) ; <nl> - <nl> - / / Only save local settings when we are inside a valid working dir <nl> - if ( Settings . ValidWorkingDir ( ) ) <nl> + ConfigFile localConfig = GitCommands . GitCommands . GetLocalConfig ( ) ; <nl> + ConfigFile globalConfig = GitCommands . GitCommands . GetGlobalConfig ( ) ; <nl> + <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + <nl> + if ( string . IsNullOrEmpty ( UserName . Text ) | | ! UserName . Text . Equals ( localConfig . GetValue ( \" user . name \" ) ) ) <nl> + localConfig . SetValue ( \" user . name \" , UserName . Text ) ; <nl> + if ( string . IsNullOrEmpty ( UserEmail . Text ) | | ! UserEmail . Text . Equals ( localConfig . GetValue ( \" user . email \" ) ) ) <nl> + localConfig . SetValue ( \" user . email \" , UserEmail . Text ) ; <nl> + localConfig . SetValue ( \" core . editor \" , Editor . Text ) ; <nl> + localConfig . SetValue ( \" merge . tool \" , MergeTool . Text ) ; <nl> + <nl> + <nl> + if ( KeepMergeBackup . CheckState = = CheckState . Checked ) <nl> + localConfig . SetValue ( \" mergetool . keepBackup \" , \" true \" ) ; <nl> + else <nl> + if ( KeepMergeBackup . CheckState = = CheckState . Unchecked ) <nl> + localConfig . SetValue ( \" mergetool . keepBackup \" , \" false \" ) ; <nl> + <nl> + localConfig . SetValue ( \" core . autocrlf \" , LocalAutoCRLF . SelectedItem as string ) ; <nl> + <nl> + if ( string . IsNullOrEmpty ( GlobalUserName . Text ) | | ! GlobalUserName . Text . Equals ( globalConfig . GetValue ( \" user . name \" ) ) ) <nl> + globalConfig . SetValue ( \" user . name \" , GlobalUserName . Text ) ; <nl> + if ( string . IsNullOrEmpty ( GlobalUserEmail . Text ) | | ! GlobalUserEmail . Text . Equals ( globalConfig . GetValue ( \" user . email \" ) ) ) <nl> + globalConfig . SetValue ( \" user . email \" , GlobalUserEmail . Text ) ; <nl> + globalConfig . SetValue ( \" core . editor \" , GlobalEditor . Text ) ; <nl> + <nl> + FormSettings . SetGlobalDiffToolToConfig ( globalConfig , GlobalDiffTool . Text ) ; <nl> + <nl> + if ( ! string . IsNullOrEmpty ( GlobalDiffTool . Text ) ) <nl> + globalConfig . SetValue ( \" difftool . \" + GlobalDiffTool . Text + \" . path \" , DifftoolPath . Text ) ; <nl> + if ( ! string . IsNullOrEmpty ( GlobalDiffTool . Text ) ) <nl> + globalConfig . SetValue ( \" difftool . \" + GlobalDiffTool . Text + \" . cmd \" , DifftoolCmd . Text ) ; <nl> + <nl> + globalConfig . SetValue ( \" merge . tool \" , GlobalMergeTool . Text ) ; <nl> + <nl> + if ( ! string . IsNullOrEmpty ( GlobalMergeTool . Text ) ) <nl> + globalConfig . SetValue ( \" mergetool . \" + GlobalMergeTool . Text + \" . path \" , MergetoolPath . Text ) ; <nl> + if ( ! string . IsNullOrEmpty ( GlobalMergeTool . Text ) ) <nl> + globalConfig . SetValue ( \" mergetool . \" + GlobalMergeTool . Text + \" . cmd \" , MergeToolCmd . Text ) ; <nl> + <nl> + if ( GlobalKeepMergeBackup . CheckState = = CheckState . Checked ) <nl> + globalConfig . SetValue ( \" mergetool . keepBackup \" , \" true \" ) ; <nl> + else <nl> + if ( GlobalKeepMergeBackup . CheckState = = CheckState . Unchecked ) <nl> + globalConfig . SetValue ( \" mergetool . keepBackup \" , \" false \" ) ; <nl> + <nl> + globalConfig . SetValue ( \" core . autocrlf \" , GlobalAutoCRLF . SelectedItem as string ) ; <nl> + globalConfig . Save ( ) ; <nl> + <nl> + / / Only save local settings when we are inside a valid working dir <nl> + if ( Settings . ValidWorkingDir ( ) ) <nl> localConfig . Save ( ) ; <nl> } <nl> <nl> - private void label3_Click ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - } <nl> - <nl> - private void textBox1_TextChanged ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - } <nl> - <nl> - protected static string GetRegistryValue ( RegistryKey root , string subkey , string key ) <nl> - { <nl> - try <nl> - { <nl> - RegistryKey rk ; <nl> - rk = root . OpenSubKey ( subkey , false ) ; <nl> - <nl> - string value = \" \" ; <nl> - <nl> - if ( rk ! = null & & rk . GetValue ( key ) is string ) <nl> - { <nl> - value = rk . GetValue ( key ) . ToString ( ) ; <nl> - rk . Flush ( ) ; <nl> - rk . Close ( ) ; <nl> - } <nl> - <nl> - return value ; <nl> - } <nl> - catch ( UnauthorizedAccessException ) <nl> - { <nl> - MessageBox . Show ( \" GitExtensions has insufficient permisions to check the registry . \" ) ; <nl> - } <nl> - return \" \" ; <nl> - } <nl> - <nl> - <nl> - protected void SetRegistryValue ( RegistryKey root , string subkey , string key , string value ) <nl> - { <nl> - try <nl> - { <nl> - string reg ; <nl> - value = value . Replace ( \" \\ \\ \" , \" \\ \\ \\ \\ \" ) ; <nl> - reg = \" Windows Registry Editor Version 5 . 00 \" + Environment . NewLine + Environment . NewLine + \" [ \" + root . ToString ( ) + \" \\ \\ \" + subkey + \" ] \" + Environment . NewLine + \" \\ \" \" + key + \" \\ \" = \\ \" \" + value + \" \\ \" \" ; <nl> - <nl> - TextWriter tw = new StreamWriter ( System . IO . Path . GetTempPath ( ) + \" GitExtensions . reg \" , false ) ; <nl> - tw . Write ( reg ) ; <nl> - tw . Close ( ) ; <nl> - GitCommands . GitCommands . RunCmd ( \" regedit \" , \" \\ \" \" + System . IO . Path . GetTempPath ( ) + \" GitExtensions . reg \" + \" \\ \" \" ) ; <nl> - } <nl> - catch ( UnauthorizedAccessException ) <nl> - { <nl> - MessageBox . Show ( \" GitExtensions has insufficient permisions to modify the registry . \" + Environment . NewLine + \" Please add this key to the registry manually . \" + Environment . NewLine + \" Path : \" + root . ToString ( ) + \" \\ \\ \" + subkey + Environment . NewLine + \" Value : \" + key + \" = \" + value ) ; <nl> - } <nl> - } <nl> - <nl> - public bool CheckSettings ( ) <nl> - { <nl> - bool bValid = true ; <nl> - try <nl> - { <nl> - if ( string . IsNullOrEmpty ( GitCommands . Settings . GetInstallDir ( ) ) ) <nl> - { <nl> - GitExtensionsInstall . BackColor = Color . LightSalmon ; <nl> - GitExtensionsInstall . Text = \" Registry entry missing [ Software \\ \\ GitExtensions \\ \\ GitExtensions \\ \\ 1 . 0 . 0 . 0 \\ \\ InstallDir ] . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - GitExtensionsInstall . BackColor = Color . LightGreen ; <nl> - GitExtensionsInstall . Text = \" GitExtensions is properly registered . \" ; <nl> - } <nl> - <nl> - if ( string . IsNullOrEmpty ( GetRegistryValue ( Registry . LocalMachine , \" Software \\ \\ Microsoft \\ \\ Windows \\ \\ CurrentVersion \\ \\ Shell Extensions \\ \\ Approved \" , \" { 3C16B20A - BA16 - 4156 - 916F - 0A375ECFFE24 } \" ) ) | | <nl> - string . IsNullOrEmpty ( GetRegistryValue ( Registry . ClassesRoot , \" * \\ \\ shellex \\ \\ ContextMenuHandlers \\ \\ GitExtensions2 \" , null ) ) | | <nl> - string . IsNullOrEmpty ( GetRegistryValue ( Registry . ClassesRoot , \" Directory \\ \\ shellex \\ \\ ContextMenuHandlers \\ \\ GitExtensions2 \" , null ) ) | | <nl> - string . IsNullOrEmpty ( GetRegistryValue ( Registry . ClassesRoot , \" Directory \\ \\ Background \\ \\ shellex \\ \\ ContextMenuHandlers \\ \\ GitExtensions2 \" , null ) ) ) <nl> - { <nl> - ShellExtensionsRegistered . BackColor = Color . LightSalmon ; <nl> - ShellExtensionsRegistered . Text = \" GitExtensionsShellEx . dll needs to be registered in order to use the shell extensions . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - ShellExtensionsRegistered . BackColor = Color . LightGreen ; <nl> - ShellExtensionsRegistered . Text = \" Shell extensions registered properly . \" ; <nl> - } <nl> - <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - if ( string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" user . name \" ) ) | | <nl> - string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" user . email \" ) ) ) <nl> - { <nl> - UserNameSet . BackColor = Color . LightSalmon ; <nl> - UserNameSet . Text = \" You need to configure a user name and an email address . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - UserNameSet . BackColor = Color . LightGreen ; <nl> - UserNameSet . Text = \" There is a user name and an email address configured . \" ; <nl> - } <nl> - <nl> - if ( string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) ) ) <nl> - { <nl> - DiffTool . BackColor = Color . LightSalmon ; <nl> - DiffTool . Text = \" You need to configure merge tool in order to solve mergeconflicts ( kdiff3 for example ) . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - if ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - string p = gitCommands . GetGlobalSetting ( \" mergetool . kdiff3 . path \" ) ; <nl> - if ( string . IsNullOrEmpty ( p ) | | ! File . Exists ( p ) ) <nl> - { <nl> - DiffTool . BackColor = Color . LightSalmon ; <nl> - DiffTool . Text = \" KDiff3 is configured as mergetool , but the path to kdiff . exe is not configured . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - DiffTool . BackColor = Color . LightGreen ; <nl> - DiffTool . Text = \" KDiff3 is configured as mergetool . \" ; <nl> - } <nl> - } <nl> - else <nl> - { <nl> - string mergetool = gitCommands . GetGlobalSetting ( \" merge . tool \" ) ; <nl> - if ( mergetool . Equals ( \" p4merge \" , StringComparison . CurrentCultureIgnoreCase ) | | <nl> - mergetool . Equals ( \" TortoiseMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - string p = gitCommands . GetGlobalSetting ( \" mergetool . \" + mergetool + \" . cmd \" ) ; <nl> - if ( string . IsNullOrEmpty ( p ) ) <nl> - { <nl> - DiffTool . BackColor = Color . LightSalmon ; <nl> - DiffTool . Text = mergetool + \" is configured as mergetool , this is a custom mergetool and needs a custom cmd to be configured . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - DiffTool . BackColor = Color . LightGreen ; <nl> - DiffTool . Text = \" There is a custom mergetool configured : \" + mergetool ; <nl> - } <nl> - } <nl> - else <nl> - { <nl> - DiffTool . BackColor = Color . LightGreen ; <nl> - DiffTool . Text = \" There is a mergetool configured . \" ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - if ( string . IsNullOrEmpty ( FormSettings . GetGlobalDiffToolFromConfig ( ) ) ) <nl> - { <nl> - DiffTool2 . BackColor = Color . LightSalmon ; <nl> - DiffTool2 . Text = \" You should configure a diff tool to show file diff in external program ( kdiff3 for example ) . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - if ( FormSettings . GetGlobalDiffToolFromConfig ( ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - string p = gitCommands . GetGlobalSetting ( \" difftool . kdiff3 . path \" ) ; <nl> - if ( string . IsNullOrEmpty ( p ) | | ! File . Exists ( p ) ) <nl> - { <nl> - DiffTool2 . BackColor = Color . LightSalmon ; <nl> - DiffTool2 . Text = \" KDiff3 is configured as difftool , but the path to kdiff . exe is not configured . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - DiffTool2 . BackColor = Color . LightGreen ; <nl> - DiffTool2 . Text = \" KDiff3 is configured as difftool . \" ; <nl> - } <nl> - } <nl> - else <nl> - { <nl> - string difftool = FormSettings . GetGlobalDiffToolFromConfig ( ) ; <nl> - DiffTool2 . BackColor = Color . LightGreen ; <nl> - DiffTool2 . Text = \" There is a difftool configured : \" + difftool ; <nl> - } <nl> - } <nl> - <nl> - if ( ! CanFindGitCmd ( ) ) <nl> - { <nl> - GitFound . BackColor = Color . LightSalmon ; <nl> - GitFound . Text = \" git . cmd not found . To solve this problem you can set the correct path in settings . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - GitFound . BackColor = Color . LightGreen ; <nl> - GitFound . Text = \" git . cmd is found on your computer . \" ; <nl> - } <nl> - <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitBinDir + \" git . exe \" , \" \" ) ) ) <nl> - { <nl> - GitBinFound . BackColor = Color . LightSalmon ; <nl> - GitBinFound . Text = \" git . exe not found . To solve this problem you can set the correct path in settings . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - GitBinFound . BackColor = Color . LightGreen ; <nl> - GitBinFound . Text = \" git . exe is found on your computer . \" ; <nl> - } <nl> - if ( GitCommands . GitCommands . Plink ( ) ) <nl> - { <nl> - if ( ! File . Exists ( GitCommands . Settings . Plink ) | | ! File . Exists ( GitCommands . Settings . Puttygen ) | | ! File . Exists ( GitCommands . Settings . Pageant ) ) <nl> - { <nl> - SshConfig . BackColor = Color . LightSalmon ; <nl> - SshConfig . Text = \" PuTTY is configured as SSH client but cannot find plink . exe , puttygen . exe or pageant . exe . \" ; <nl> - bValid = false ; <nl> - } <nl> - else <nl> - { <nl> - SshConfig . BackColor = Color . LightGreen ; <nl> - SshConfig . Text = \" SSH client PuTTY is configured properly \" ; <nl> - } <nl> - } <nl> - else <nl> - { <nl> - SshConfig . BackColor = Color . LightGreen ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . GetSsh ( ) ) ) <nl> - SshConfig . Text = \" Default SSH client , OpenSSH , will be used . ( commandline window will appear on pull , push and clone operations ) \" ; <nl> - else <nl> - SshConfig . Text = \" Unknown SSH client configured : \" + GitCommands . GitCommands . GetSsh ( ) ; <nl> - } <nl> - <nl> - } <nl> - catch <nl> - { <nl> - } <nl> - <nl> - if ( ( Application . UserAppDataRegistry . GetValue ( \" checksettings \" ) = = null | | <nl> - Application . UserAppDataRegistry . GetValue ( \" checksettings \" ) . ToString ( ) = = \" true \" ) ) <nl> - { <nl> - CheckAtStartup . Checked = true ; <nl> - } <nl> - else <nl> - { <nl> - CheckAtStartup . Checked = false ; <nl> - } <nl> - <nl> - <nl> - if ( bValid & & CheckAtStartup . Checked ) <nl> - { <nl> - Application . UserAppDataRegistry . SetValue ( \" checksettings \" , false ) ; <nl> - CheckAtStartup . Checked = false ; <nl> - } <nl> - <nl> - return bValid ; <nl> - } <nl> - <nl> - private static bool CanFindGitCmd ( ) <nl> - { <nl> - return ! string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ; <nl> - } <nl> - <nl> - private void GitExtensionsInstall_Click ( object sender , EventArgs e ) <nl> - { <nl> - SolveGitExtensionsDir ( ) ; <nl> - <nl> - CheckSettings ( ) ; <nl> - } <nl> - <nl> - public static bool SolveGitExtensionsDir ( ) <nl> - { <nl> - string fileName = Assembly . GetAssembly ( typeof ( FormSettings ) ) . Location ; <nl> - fileName = fileName . Substring ( 0 , fileName . LastIndexOfAny ( new char [ ] { ' \\ \\ ' , ' / ' } ) ) ; <nl> - <nl> - if ( File . Exists ( fileName + \" \\ \\ GitExtensions . exe \" ) ) <nl> - { <nl> - GitCommands . Settings . SetInstallDir ( fileName ) ; <nl> - return true ; <nl> - } <nl> - <nl> - return false ; <nl> - } <nl> - <nl> - private void ShellExtensionsRegistered_Click ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - if ( File . Exists ( GitCommands . Settings . GetInstallDir ( ) + \" \\ \\ GitExtensionsShellEx . dll \" ) ) <nl> - GitCommands . GitCommands . RunCmd ( \" regsvr32 \" , \" \\ \" \" + GitCommands . Settings . GetInstallDir ( ) + \" \\ \\ GitExtensionsShellEx . dll \\ \" \" ) ; <nl> - else <nl> - { <nl> - string fileName = Assembly . GetAssembly ( GetType ( ) ) . Location ; <nl> - fileName = fileName . Substring ( 0 , fileName . LastIndexOfAny ( new char [ ] { ' \\ \\ ' , ' / ' } ) ) + \" \\ \\ GitExtensionsShellEx . dll \" ; <nl> - <nl> - if ( File . Exists ( fileName ) ) <nl> - GitCommands . GitCommands . RunCmd ( \" regsvr32 \" , \" \\ \" \" + fileName + \" \\ \" \" ) ; <nl> - } <nl> - <nl> - CheckSettings ( ) ; <nl> - } <nl> - <nl> - private void UserNameSet_Click ( object sender , EventArgs e ) <nl> - { <nl> - tabControl1 . SelectTab ( \" GlobalSettingsPage \" ) ; <nl> - } <nl> - <nl> - private void DiffTool2_Click ( object sender , EventArgs e ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - <nl> - if ( string . IsNullOrEmpty ( FormSettings . GetGlobalDiffToolFromConfig ( ) ) ) <nl> - { <nl> - if ( MessageBox . Show ( \" There is no difftool configured . Do you want to configure kdiff3 as your difftool ? \" + Environment . NewLine + \" Select no if you want to configure a different difftool yourself . \" , \" Mergetool \" , MessageBoxButtons . YesNo ) = = DialogResult . Yes ) <nl> - { <nl> - SolveKDiffTool2 ( ) ; <nl> - GlobalDiffTool . Text = \" kdiff3 \" ; <nl> - } <nl> - else <nl> - { <nl> - tabControl1 . SelectTab ( \" GlobalSettingsPage \" ) ; <nl> - return ; <nl> - } <nl> - } <nl> - <nl> - if ( FormSettings . GetGlobalDiffToolFromConfig ( ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - SolveKDiffTool2Path ( gitCommands ) ; <nl> - } <nl> - <nl> - if ( FormSettings . GetGlobalDiffToolFromConfig ( ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) & & string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" difftool . kdiff3 . path \" ) ) ) <nl> - { <nl> - MessageBox . Show ( \" Path to kdiff3 could not be found automatically . \" + Environment . NewLine + \" Please make sure KDiff3 is installed or set path manually . \" ) ; <nl> - tabControl1 . SelectTab ( \" GlobalSettingsPage \" ) ; <nl> - return ; <nl> - } <nl> - <nl> - Rescan_Click ( null , null ) ; <nl> - } <nl> - <nl> - private void DiffTool_Click ( object sender , EventArgs e ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - <nl> - if ( string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) ) ) <nl> - { <nl> - if ( MessageBox . Show ( \" There is no mergetool configured . Do you want to configure kdiff3 as your mergetool ? \" + Environment . NewLine + \" Select no if you want to configure a different mergetool yourself . \" , \" Mergetool \" , MessageBoxButtons . YesNo ) = = DialogResult . Yes ) <nl> - { <nl> - SolveKDiff ( ) ; <nl> - GlobalDiffTool . Text = \" kdiff3 \" ; <nl> - } <nl> - else <nl> - { <nl> - tabControl1 . SelectTab ( \" GlobalSettingsPage \" ) ; <nl> - return ; <nl> - } <nl> - } <nl> - <nl> - if ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - SolveKDiffPath ( gitCommands ) ; <nl> - } <nl> - else <nl> - if ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) . Equals ( \" p4merge \" , StringComparison . CurrentCultureIgnoreCase ) | | <nl> - gitCommands . GetGlobalSetting ( \" merge . tool \" ) . Equals ( \" TortoiseMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - AutoConfigMergeToolcmd ( ) ; <nl> - gitCommands . SetGlobalSetting ( \" mergetool . \" + gitCommands . GetGlobalSetting ( \" merge . tool \" ) + \" . cmd \" , MergeToolCmd . Text ) ; <nl> - } <nl> - <nl> - <nl> - if ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) & & string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" mergetool . kdiff3 . path \" ) ) ) <nl> - { <nl> - MessageBox . Show ( \" Path to kdiff3 could not be found automatically . \" + Environment . NewLine + \" Please make sure KDiff3 is installed or set path manually . \" ) ; <nl> - tabControl1 . SelectTab ( \" GlobalSettingsPage \" ) ; <nl> - return ; <nl> - } <nl> - <nl> - Rescan_Click ( null , null ) ; <nl> - } <nl> - <nl> - public static bool SolveKDiff ( ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - string mergeTool = gitCommands . GetGlobalSetting ( \" merge . tool \" ) ; <nl> - if ( string . IsNullOrEmpty ( mergeTool ) ) <nl> - { <nl> - mergeTool = \" kdiff3 \" ; <nl> - gitCommands . SetGlobalSetting ( \" merge . tool \" , mergeTool ) ; <nl> - } <nl> - <nl> - if ( mergeTool . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - return SolveKDiffPath ( gitCommands ) ; <nl> - <nl> - return true ; <nl> - } <nl> - <nl> - public static bool SolveKDiffTool2 ( ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - string diffTool = GetGlobalDiffToolFromConfig ( ) ; <nl> - if ( string . IsNullOrEmpty ( diffTool ) ) <nl> - { <nl> - diffTool = \" kdiff3 \" ; <nl> - ConfigFile globalConfig = GitCommands . GitCommands . GetGlobalConfig ( ) ; <nl> - SetGlobalDiffToolToConfig ( globalConfig , diffTool ) ; <nl> - globalConfig . Save ( ) ; <nl> - } <nl> - <nl> - if ( diffTool . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - return SolveKDiffTool2Path ( gitCommands ) ; <nl> - <nl> - return true ; <nl> - } <nl> - <nl> - public static bool SolveKDiffPath ( GitCommands . GitCommands gitCommands ) <nl> - { <nl> - string kdiff3path = gitCommands . GetGlobalSetting ( \" mergetool . kdiff3 . path \" ) ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = @ \" c : \\ Program Files \\ KDiff3 \\ kdiff3 . exe \" ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = @ \" c : \\ Program Files ( x86 ) \\ KDiff3 \\ kdiff3 . exe \" ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ KDiff3 \" , \" \" ) + \" \\ \\ kdiff3 . exe \" ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = \" \" ; <nl> - return false ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - gitCommands . SetGlobalSetting ( \" mergetool . kdiff3 . path \" , kdiff3path ) ; <nl> - <nl> - return true ; <nl> - } <nl> - <nl> - public static bool SolveKDiffTool2Path ( GitCommands . GitCommands gitCommands ) <nl> - { <nl> - string kdiff3path = gitCommands . GetGlobalSetting ( \" difftool . kdiff3 . path \" ) ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = @ \" c : \\ Program Files \\ KDiff3 \\ kdiff3 . exe \" ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = @ \" c : \\ Program Files ( x86 ) \\ KDiff3 \\ kdiff3 . exe \" ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ KDiff3 \" , \" \" ) + \" \\ \\ kdiff3 . exe \" ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = \" \" ; <nl> - return false ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - gitCommands . SetGlobalSetting ( \" difftool . kdiff3 . path \" , kdiff3path ) ; <nl> - <nl> - return true ; <nl> - } <nl> - <nl> - private void GitFound_Click ( object sender , EventArgs e ) <nl> - { <nl> - SolveGitCmdDir ( ) ; <nl> - <nl> - if ( string . IsNullOrEmpty ( GitCommands . Settings . GitCommand ) ) <nl> - { <nl> - MessageBox . Show ( \" The command to run git could not be determined automatically . \" + Environment . NewLine + \" Please make sure git ( msysgit ) is installed or set the correct path manually . \" , \" Locate git . cmd \" ) ; <nl> - <nl> - tabControl1 . SelectTab ( \" TabPageGitExtensions \" ) ; <nl> - return ; <nl> - } <nl> - <nl> - MessageBox . Show ( \" Command git . cmd can be runned using : \" + GitCommands . Settings . GitCommand , \" Locate git . cmd \" ) ; <nl> - GitPath . Text = GitCommands . Settings . GitCommand ; <nl> - Rescan_Click ( null , null ) ; <nl> - } <nl> - <nl> - public static bool SolveGitCmdDir ( ) <nl> - { <nl> - GitCommands . Settings . GitCommand = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ Microsoft \\ \\ Windows \\ \\ CurrentVersion \\ \\ Uninstall \\ \\ Git_is1 \" , \" InstallLocation \" ) + \" cmd \\ \\ git . cmd \" ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> - { <nl> - GitCommands . Settings . GitCommand = @ \" c : \\ Program Files ( x86 ) \\ Git \\ cmd \\ git . cmd \" ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> - { <nl> - GitCommands . Settings . GitCommand = @ \" c : \\ Program Files \\ Git \\ cmd \\ git . cmd \" ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> - { <nl> - GitCommands . Settings . GitCommand = @ \" C : \\ cygwin \\ bin \\ git \" ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> - { <nl> - GitCommands . Settings . GitCommand = \" git . cmd \" ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> - { <nl> - GitCommands . Settings . GitCommand = \" git \" ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> - { <nl> - return false ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - } <nl> - } <nl> - <nl> - return true ; <nl> - } <nl> - <nl> - private void FormSettigns_Load ( object sender , EventArgs e ) <nl> - { <nl> - EnableSettings ( ) ; <nl> - <nl> - this . WindowState = FormWindowState . Normal ; <nl> - } <nl> - <nl> - private void EnableSettings ( ) <nl> - { <nl> - bool canFindGitCmd = CanFindGitCmd ( ) ; <nl> - GlobalUserName . Enabled = canFindGitCmd ; <nl> - GlobalUserEmail . Enabled = canFindGitCmd ; <nl> - GlobalEditor . Enabled = canFindGitCmd ; <nl> - GlobalMergeTool . Enabled = canFindGitCmd ; <nl> - MergetoolPath . Enabled = canFindGitCmd ; <nl> - MergeToolCmd . Enabled = canFindGitCmd ; <nl> - GlobalKeepMergeBackup . Enabled = canFindGitCmd ; <nl> - <nl> - InvalidGitPathGlobal . Visible = ! canFindGitCmd ; <nl> - InvalidGitPathLocal . Visible = ! canFindGitCmd ; <nl> - <nl> - bool valid = GitCommands . Settings . ValidWorkingDir ( ) & & canFindGitCmd ; <nl> - UserName . Enabled = valid ; <nl> - UserEmail . Enabled = valid ; <nl> - Editor . Enabled = valid ; <nl> - MergeTool . Enabled = valid ; <nl> - KeepMergeBackup . Enabled = valid ; <nl> - LocalAutoCRLF . Enabled = valid ; <nl> - NoGitRepo . Visible = ! valid ; <nl> - <nl> - } <nl> - <nl> - private void CheckAtStartup_CheckedChanged ( object sender , EventArgs e ) <nl> - { <nl> - if ( CheckAtStartup . Checked ) <nl> - Application . UserAppDataRegistry . SetValue ( \" checksettings \" , \" true \" ) ; <nl> - else <nl> - Application . UserAppDataRegistry . SetValue ( \" checksettings \" , \" false \" ) ; <nl> - } <nl> - <nl> - private void Rescan_Click ( object sender , EventArgs e ) <nl> - { <nl> - Cursor . Current = Cursors . WaitCursor ; <nl> - Save ( ) ; <nl> - LoadSettings ( ) ; <nl> - CheckSettings ( ) ; <nl> - } <nl> - <nl> - private void BrowseGitPath_Click ( object sender , EventArgs e ) <nl> - { <nl> - SolveGitCmdDir ( ) ; <nl> - <nl> - OpenFileDialog browseDialog = new OpenFileDialog ( ) ; <nl> - browseDialog . FileName = GitCommands . Settings . GitCommand ; <nl> - browseDialog . Filter = \" Git . cmd ( git . cmd ) | git . cmd | Git . exe ( git . exe ) | git . exe | Git ( git ) | git \" ; <nl> - <nl> - if ( browseDialog . ShowDialog ( ) = = DialogResult . OK ) <nl> - { <nl> - GitPath . Text = browseDialog . FileName ; <nl> - } <nl> - } <nl> - <nl> - private void TabPageGitExtensions_Click ( object sender , EventArgs e ) <nl> - { <nl> - GitPath . Text = GitCommands . Settings . GitCommand ; <nl> - } <nl> - <nl> - private void GitPath_TextChanged ( object sender , EventArgs e ) <nl> - { <nl> - GitCommands . Settings . GitCommand = GitPath . Text ; <nl> - LoadSettings ( ) ; <nl> - } <nl> - <nl> - private void GitBinFound_Click ( object sender , EventArgs e ) <nl> - { <nl> - SolveGitBinDir ( ) ; <nl> - <nl> - if ( string . IsNullOrEmpty ( GitCommands . Settings . GitBinDir ) ) <nl> - { <nl> - MessageBox . Show ( \" The path to git . exe could not be found automatically . \" + Environment . NewLine + \" Please make sure git ( msysgit ) is installed or set the correct path manually . \" , \" Locate git . exe \" ) ; <nl> - tabControl1 . SelectTab ( \" TabPageGitExtensions \" ) ; <nl> - return ; <nl> - } <nl> - <nl> - MessageBox . Show ( \" Command git . exe can be runned using : \" + GitCommands . Settings . GitBinDir + \" git . exe \" , \" Locate git . exe \" ) ; <nl> - GitBinPath . Text = GitCommands . Settings . GitBinDir ; <nl> - Rescan_Click ( null , null ) ; <nl> - } <nl> - <nl> - public static bool SolveGitBinDir ( ) <nl> - { <nl> - GitCommands . Settings . GitBinDir = @ \" c : \\ Program Files \\ Git \\ bin \\ \" ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitBinDir + \" git . exe \" , \" \" ) ) ) <nl> - { <nl> - GitCommands . Settings . GitBinDir = @ \" c : \\ Program Files ( x86 ) \\ Git \\ bin \\ \" ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitBinDir + \" git . exe \" , \" \" ) ) ) <nl> - { <nl> - GitCommands . Settings . GitBinDir = \" C : \\ \\ cygwin \\ \\ bin \" ; <nl> - if ( ! Directory . Exists ( GitCommands . Settings . GitBinDir ) ) <nl> - { <nl> - GitCommands . Settings . GitBinDir = GitCommands . Settings . GitCommand ; <nl> - GitCommands . Settings . GitBinDir = GitCommands . Settings . GitBinDir . Replace ( \" \\ \\ cmd \\ \\ git . cmd \" , \" \\ \\ bin \\ \\ \" ) ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitBinDir + \" git . exe \" , \" \" ) ) ) <nl> - { <nl> - GitCommands . Settings . GitBinDir = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ Microsoft \\ \\ Windows \\ \\ CurrentVersion \\ \\ Uninstall \\ \\ Git_is1 \" , \" InstallLocation \" ) + \" \\ \\ bin \\ \\ \" ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitBinDir + \" git . exe \" , \" \" ) ) ) <nl> - { <nl> - GitCommands . Settings . GitBinDir = \" \" ; <nl> - if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand . Replace ( \" git . cmd \" , \" git . exe \" ) ) ) ) <nl> - { <nl> - return false ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - } <nl> - } <nl> - return true ; <nl> - } <nl> - <nl> - private void OpenSSH_CheckedChanged ( object sender , EventArgs e ) <nl> - { <nl> - EnableSshOptions ( ) ; <nl> - } <nl> - <nl> - private void Putty_CheckedChanged ( object sender , EventArgs e ) <nl> - { <nl> - if ( Putty . Checked ) <nl> - { <nl> - AutoFindPuttyPaths ( ) ; <nl> - } <nl> - EnableSshOptions ( ) ; <nl> - } <nl> - <nl> - private bool AutoFindPuttyPaths ( ) <nl> - { <nl> - if ( AutoFindPuttyPathsInDir ( \" c : \\ \\ Program Files \\ \\ PuTTY \\ \\ \" ) ) return true ; <nl> - if ( AutoFindPuttyPathsInDir ( \" c : \\ \\ Program Files ( x86 ) \\ \\ PuTTY \\ \\ \" ) ) return true ; <nl> - if ( AutoFindPuttyPathsInDir ( \" C : \\ \\ Program Files \\ \\ TortoiseGit \\ \\ bin \" ) ) return true ; <nl> - if ( AutoFindPuttyPathsInDir ( \" C : \\ \\ Program Files ( x86 ) \\ \\ TortoiseGit \\ \\ bin \" ) ) return true ; <nl> - if ( AutoFindPuttyPathsInDir ( \" C : \\ \\ Program Files \\ \\ TortoiseSvn \\ \\ bin \" ) ) return true ; <nl> - if ( AutoFindPuttyPathsInDir ( \" C : \\ \\ Program Files ( x86 ) \\ \\ TortoiseSvn \\ \\ bin \" ) ) return true ; <nl> - if ( AutoFindPuttyPathsInDir ( GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ Microsoft \\ \\ Windows \\ \\ CurrentVersion \\ \\ Uninstall \\ \\ PuTTY_is1 \" , \" InstallLocation \" ) ) ) return true ; <nl> - if ( AutoFindPuttyPathsInDir ( GitCommands . Settings . GetInstallDir ( ) + \" \\ \\ PuTTY \\ \\ \" ) ) return true ; <nl> - <nl> - return false ; <nl> - } <nl> - <nl> - private bool AutoFindPuttyPathsInDir ( string installdir ) <nl> - { <nl> - if ( ! installdir . EndsWith ( \" \\ \\ \" ) ) <nl> - installdir + = \" \\ \\ \" ; <nl> - <nl> - if ( ! File . Exists ( PlinkPath . Text ) ) <nl> - { <nl> - if ( File . Exists ( installdir + \" plink . exe \" ) ) <nl> - PlinkPath . Text = installdir + \" plink . exe \" ; <nl> - } <nl> - <nl> - if ( ! File . Exists ( PlinkPath . Text ) ) <nl> - { <nl> - if ( File . Exists ( installdir + \" TortoisePlink . exe \" ) ) <nl> - PlinkPath . Text = installdir + \" TortoisePlink . exe \" ; <nl> - } <nl> - <nl> - if ( ! File . Exists ( PuttygenPath . Text ) ) <nl> - { <nl> - if ( File . Exists ( installdir + \" puttygen . exe \" ) ) <nl> - PuttygenPath . Text = installdir + \" puttygen . exe \" ; <nl> - } <nl> - <nl> - if ( ! File . Exists ( PageantPath . Text ) ) <nl> - { <nl> - if ( File . Exists ( installdir + \" pageant . exe \" ) ) <nl> - PageantPath . Text = installdir + \" pageant . exe \" ; <nl> - } <nl> - <nl> - if ( File . Exists ( PlinkPath . Text ) & & File . Exists ( PuttygenPath . Text ) & & File . Exists ( PageantPath . Text ) ) <nl> - return true ; <nl> - else <nl> - return false ; <nl> - } <nl> - <nl> - private string SelectFile ( string initialDirectory , string filter , string prev ) <nl> - { <nl> - OpenFileDialog dialog = new OpenFileDialog ( ) ; <nl> - dialog . Filter = filter ; <nl> - dialog . InitialDirectory = initialDirectory ; <nl> - dialog . Title = \" Select file \" ; <nl> - return ( dialog . ShowDialog ( ) = = DialogResult . OK ) ? dialog . FileName : prev ; <nl> - } <nl> - <nl> - private void button1_Click ( object sender , EventArgs e ) <nl> - { <nl> - OtherSsh . Text = SelectFile ( \" . \" , \" Executable file ( * . exe ) | * . exe \" , OtherSsh . Text ) ; <nl> - } <nl> - <nl> - private void Other_CheckedChanged ( object sender , EventArgs e ) <nl> - { <nl> - EnableSshOptions ( ) ; <nl> - } <nl> - <nl> - private void EnableSshOptions ( ) <nl> - { <nl> - OtherSsh . Enabled = Other . Checked ; <nl> - OtherSshBrowse . Enabled = Other . Checked ; <nl> - <nl> - PlinkPath . Enabled = Putty . Checked ; <nl> - PuttygenPath . Enabled = Putty . Checked ; <nl> - PageantPath . Enabled = Putty . Checked ; <nl> - PlinkBrowse . Enabled = Putty . Checked ; <nl> - PuttygenBrowse . Enabled = Putty . Checked ; <nl> - PageantBrowse . Enabled = Putty . Checked ; <nl> - AutostartPageant . Enabled = Putty . Checked ; <nl> - } <nl> - <nl> - private void PuttyBrowse_Click ( object sender , EventArgs e ) <nl> - { <nl> - PlinkPath . Text = SelectFile ( \" . \" , \" Plink . exe ( plink . exe ) | plink . exe | TortoisePlink . exe ( tortoiseplink . exe ) | tortoiseplink . exe \" , PlinkPath . Text ) ; <nl> - } <nl> - <nl> - private void PuttygenBrowse_Click ( object sender , EventArgs e ) <nl> - { <nl> - PuttygenPath . Text = SelectFile ( \" . \" , \" puttygen . exe ( puttygen . exe ) | puttygen . exe \" , PuttygenPath . Text ) ; <nl> - } <nl> - <nl> - private void PageantBrowse_Click ( object sender , EventArgs e ) <nl> - { <nl> - PageantPath . Text = SelectFile ( \" . \" , \" pageant . exe ( pageant . exe ) | pageant . exe \" , PageantPath . Text ) ; <nl> - } <nl> - <nl> - private void SshConfig_Click ( object sender , EventArgs e ) <nl> - { <nl> - if ( Putty . Checked ) <nl> - { <nl> - if ( AutoFindPuttyPaths ( ) ) <nl> - MessageBox . Show ( \" All paths needed for PuTTY could be automaticly found and are set . \" , \" PuTTY \" ) ; <nl> - else <nl> - tabControl1 . SelectTab ( \" ssh \" ) ; <nl> - } <nl> - } <nl> - <nl> - private void BrowseGitBinPath_Click ( object sender , EventArgs e ) <nl> - { <nl> - SolveGitBinDir ( ) ; <nl> - <nl> - FolderBrowserDialog browseDialog = new FolderBrowserDialog ( ) ; <nl> - browseDialog . SelectedPath = GitCommands . Settings . GitBinDir ; <nl> - <nl> - if ( browseDialog . ShowDialog ( ) = = DialogResult . OK ) <nl> - { <nl> - GitBinPath . Text = browseDialog . SelectedPath ; <nl> - } <nl> - } <nl> - <nl> - private void BrowseMergeTool_Click ( object sender , EventArgs e ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - <nl> - if ( GlobalMergeTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - MergetoolPath . Text = SelectFile ( \" . \" , \" kdiff3 . exe ( kdiff3 . exe ) | kdiff3 . exe \" , MergetoolPath . Text ) ; <nl> - } <nl> - else <nl> - if ( GlobalMergeTool . Text . Equals ( \" p4merge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - MergetoolPath . Text = SelectFile ( \" . \" , \" p4merge . exe ( p4merge . exe ) | p4merge . exe \" , MergetoolPath . Text ) ; <nl> - else <nl> - if ( GlobalMergeTool . Text . Equals ( \" TortoiseMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - MergetoolPath . Text = SelectFile ( \" . \" , \" TortoiseMerge . exe ( TortoiseMerge . exe ) | TortoiseMerge . exe \" , MergetoolPath . Text ) ; <nl> - else <nl> - MergetoolPath . Text = SelectFile ( \" . \" , \" * . exe ( * . exe ) | * . exe \" , MergetoolPath . Text ) ; <nl> - <nl> - } <nl> - <nl> - private void button1_Click_1 ( object sender , EventArgs e ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - <nl> - if ( GlobalMergeTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - string kdiff3path = gitCommands . GetGlobalSetting ( \" mergetool . kdiff3 . path \" ) ; <nl> - string regkdiff3path = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ KDiff3 \" , \" \" ) + \" \\ \\ kdiff3 . exe \" ; <nl> - <nl> - MergetoolPath . Text = FindFileInFolders ( \" kdiff3 . exe \" , kdiff3path , <nl> - @ \" c : \\ Program Files \\ KDiff3 \\ \" , <nl> - @ \" c : \\ Program Files ( x86 ) \\ KDiff3 \\ \" , <nl> - regkdiff3path ) ; <nl> - } <nl> - if ( GlobalMergeTool . Text . Equals ( \" winmerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - string winmergepath = gitCommands . GetGlobalSetting ( \" mergetool . winmerge . path \" ) ; <nl> - <nl> - MergetoolPath . Text = FindFileInFolders ( \" winmergeu . exe \" , winmergepath , <nl> - @ \" c : \\ Program Files \\ winmerge \\ \" , <nl> - @ \" c : \\ Program Files ( x86 ) \\ winmerge \\ \" ) ; <nl> - } <nl> - AutoConfigMergeToolcmd ( ) ; <nl> - } <nl> - <nl> - private string FindFileInFolders ( string fileName , params string [ ] locations ) <nl> - { <nl> - foreach ( string location in locations ) <nl> - { <nl> - if ( ! string . IsNullOrEmpty ( location ) & & File . Exists ( location ) ) <nl> - return location ; <nl> - if ( ! string . IsNullOrEmpty ( location ) & & File . Exists ( location + fileName ) ) <nl> - return location + fileName ; <nl> - if ( ! string . IsNullOrEmpty ( location ) & & File . Exists ( location + \" \\ \\ \" + fileName ) ) <nl> - return location + \" \\ \\ \" + fileName ; <nl> - } <nl> - <nl> - return \" \" ; <nl> - } <nl> - <nl> - private void AutoConfigMergeToolcmd ( ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - if ( GlobalMergeTool . Text . Equals ( \" p4merge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - if ( MergetoolPath . Text . Contains ( \" kdiff3 \" ) | | MergetoolPath . Text . Contains ( \" TortoiseMerge \" ) ) <nl> - MergetoolPath . Text = \" \" ; <nl> - if ( string . IsNullOrEmpty ( MergetoolPath . Text ) | | ! File . Exists ( MergetoolPath . Text ) ) <nl> - { <nl> - MergetoolPath . Text = @ \" c : \\ Program Files \\ Perforce \\ p4merge . exe \" ; <nl> - <nl> - MergetoolPath . Text = FindFileInFolders ( \" p4merge . exe \" , <nl> - @ \" c : \\ Program Files ( x86 ) \\ Perforce \\ \" , <nl> - @ \" c : \\ Program Files \\ Perforce \\ \" ) ; <nl> - <nl> - if ( ! File . Exists ( MergetoolPath . Text ) ) <nl> - { <nl> - MergetoolPath . Text = \" \" ; <nl> - MessageBox . Show ( \" Please enter the path to p4merge . exe and press suggest . \" , \" Suggest mergetool cmd \" ) ; <nl> - return ; <nl> - } <nl> - } <nl> - <nl> - MergeToolCmd . Text = \" \\ \" \" + MergetoolPath . Text + \" \\ \" \\ \" $ BASE \\ \" \\ \" $ LOCAL \\ \" \\ \" $ REMOTE \\ \" \\ \" $ MERGED \\ \" \" ; <nl> - return ; <nl> - } <nl> - <nl> - if ( GlobalMergeTool . Text . Equals ( \" Araxis \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - if ( MergetoolPath . Text . Contains ( \" kdiff3 \" ) | | MergetoolPath . Text . Contains ( \" TortoiseMerge \" ) ) <nl> - MergetoolPath . Text = \" \" ; <nl> - if ( string . IsNullOrEmpty ( MergetoolPath . Text ) | | ! File . Exists ( MergetoolPath . Text ) ) <nl> - { <nl> - MergetoolPath . Text = FindFileInFolders ( \" Compare . exe \" , <nl> - @ \" C : \\ Program Files ( x86 ) \\ Araxis \\ Araxis Merge \\ \" , <nl> - @ \" C : \\ Program Files \\ Araxis \\ Araxis Merge \\ \" , <nl> - @ \" C : \\ Program Files \\ Araxis 6 . 5 \\ Araxis Merge \\ \" ) ; <nl> - <nl> - if ( ! File . Exists ( MergetoolPath . Text ) ) <nl> - { <nl> - MergetoolPath . Text = \" \" ; <nl> - MessageBox . Show ( \" Please enter the path to Compare . exe and press suggest . \" , \" Suggest mergetool cmd \" ) ; <nl> - return ; <nl> - } <nl> - } <nl> - <nl> - MergeToolCmd . Text = \" \\ \" \" + MergetoolPath . Text + \" \\ \" - wait - merge - 3 - a1 \\ \" $ BASE \\ \" \\ \" $ LOCAL \\ \" \\ \" $ REMOTE \\ \" \\ \" $ MERGED \\ \" \" ; <nl> - return ; <nl> - } <nl> - <nl> - if ( GlobalMergeTool . Text . Equals ( \" TortoiseMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - if ( MergetoolPath . Text . ToLower ( ) . Contains ( \" kdiff3 \" ) | | MergetoolPath . Text . ToLower ( ) . Contains ( \" p4merge \" ) ) <nl> - MergetoolPath . Text = \" \" ; <nl> - if ( string . IsNullOrEmpty ( MergetoolPath . Text ) | | ! File . Exists ( MergetoolPath . Text ) ) <nl> - { <nl> - MergetoolPath . Text = FindFileInFolders ( \" TortoiseMerge . exe \" , <nl> - @ \" c : \\ Program Files ( x86 ) \\ TortoiseSVN \\ bin \\ \" , <nl> - @ \" c : \\ Program Files \\ TortoiseSVN \\ bin \\ \" , <nl> - @ \" c : \\ Program Files ( x86 ) \\ TortoiseGit \\ bin \\ \" , <nl> - @ \" c : \\ Program Files \\ TortoiseGit \\ bin \\ \" ) ; <nl> - <nl> - if ( ! File . Exists ( MergetoolPath . Text ) ) <nl> - { <nl> - MergetoolPath . Text = \" \" ; <nl> - MessageBox . Show ( \" Please enter the path to TortoiseMerge . exe and press suggest . \" , \" Suggest mergetool cmd \" ) ; <nl> - return ; <nl> - } <nl> - } <nl> - <nl> - MergeToolCmd . Text = \" \\ \" TortoiseMerge . exe \\ \" / base : \\ \" $ BASE \\ \" / mine : \\ \" $ LOCAL \\ \" / theirs : \\ \" $ REMOTE \\ \" / merged : \\ \" $ MERGED \\ \" \" ; <nl> - return ; <nl> - } <nl> - <nl> - if ( GlobalMergeTool . Text . Equals ( \" DiffMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - if ( MergetoolPath . Text . ToLower ( ) . Contains ( \" kdiff3 \" ) | | MergetoolPath . Text . ToLower ( ) . Contains ( \" p4merge \" ) ) <nl> - MergetoolPath . Text = \" \" ; <nl> - if ( string . IsNullOrEmpty ( MergetoolPath . Text ) | | ! File . Exists ( MergetoolPath . Text ) ) <nl> - { <nl> - MergetoolPath . Text = FindFileInFolders ( \" DiffMerge . exe \" , <nl> - @ \" C : \\ Program Files ( x86 ) \\ SourceGear \\ DiffMerge \\ \" , <nl> - @ \" C : \\ Program Files \\ SourceGear \\ DiffMerge \\ \" ) ; <nl> - <nl> - if ( ! File . Exists ( MergetoolPath . Text ) ) <nl> - { <nl> - MergetoolPath . Text = \" \" ; <nl> - MessageBox . Show ( \" Please enter the path to DiffMerge . exe and press suggest . \" , \" Suggest mergetool cmd \" ) ; <nl> - return ; <nl> - } <nl> - } <nl> - <nl> - / / / m / r = % merged / t1 = % yname / t2 = % bname / t3 = % tname / c = % mname % mine % base % theirs <nl> - MergeToolCmd . Text = \" \\ \" \" + MergetoolPath . Text + \" \\ \" / m / r = \\ \" $ MERGED \\ \" \\ \" $ LOCAL \\ \" \\ \" $ BASE \\ \" \\ \" $ REMOTE \\ \" \" ; <nl> - return ; <nl> - } <nl> - } <nl> - <nl> - private void GlobalMergeTool_SelectedIndexChanged ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - } <nl> - <nl> - private void ShowRevisionGraph_CheckedChanged ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - } <nl> - <nl> - private void FormSettigns_Shown ( object sender , EventArgs e ) <nl> - { <nl> - Cursor . Current = Cursors . WaitCursor ; <nl> - this . WindowState = FormWindowState . Normal ; <nl> - LoadSettings ( ) ; <nl> - CheckSettings ( ) ; <nl> - this . WindowState = FormWindowState . Normal ; <nl> - } <nl> - <nl> - private void FormSettigns_FormClosing ( object sender , FormClosingEventArgs e ) <nl> - { <nl> - Cursor . Current = Cursors . WaitCursor ; <nl> - if ( DialogResult ! = DialogResult . Abort & & ! Save ( ) ) <nl> - e . Cancel = true ; <nl> - } <nl> - <nl> - private void Dictionary_DropDown ( object sender , EventArgs e ) <nl> - { <nl> - try <nl> - { <nl> - Dictionary . Items . Clear ( ) ; <nl> - Dictionary . Items . Add ( \" None \" ) ; <nl> - foreach ( string fileName in Directory . GetFiles ( GitCommands . Settings . GetDictionaryDir ( ) , \" * . dic \" , SearchOption . TopDirectoryOnly ) ) <nl> - { <nl> - FileInfo file = new FileInfo ( fileName ) ; <nl> - Dictionary . Items . Add ( file . Name . Replace ( \" . dic \" , \" \" ) ) ; <nl> - } <nl> - } <nl> - catch <nl> - { <nl> - MessageBox . Show ( \" No dictionary files found in : \" + GitCommands . Settings . GetDictionaryDir ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - private void Dictionary_SelectedIndexChanged ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - } <nl> - <nl> - private void ExternalDiffTool_TextChanged ( object sender , EventArgs e ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - DifftoolPath . Text = gitCommands . GetGlobalSetting ( \" difftool . \" + GlobalDiffTool . Text . Trim ( ) + \" . path \" ) ; <nl> - DifftoolCmd . Text = gitCommands . GetGlobalSetting ( \" difftool . \" + GlobalDiffTool . Text . Trim ( ) + \" . cmd \" ) ; <nl> - <nl> - if ( GlobalDiffTool . Text . Trim ( ) . Equals ( \" winmerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - DiffToolCmdSuggest_Click ( null , null ) ; <nl> - <nl> - ResolveDiffToolPath ( ) ; <nl> - } <nl> - <nl> - private void ResolveDiffToolPath ( ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - <nl> - if ( GlobalDiffTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - string kdiff3path = gitCommands . GetGlobalSetting ( \" difftool . kdiff3 . path \" ) ; <nl> - if ( ! kdiff3path . ToLower ( ) . Contains ( \" kdiff3 . exe \" ) ) <nl> - kdiff3path = \" \" ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = @ \" c : \\ Program Files \\ KDiff3 \\ kdiff3 . exe \" ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = @ \" c : \\ Program Files ( x86 ) \\ KDiff3 \\ kdiff3 . exe \" ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ KDiff3 \" , \" \" ) + \" \\ \\ kdiff3 . exe \" ; <nl> - if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> - { <nl> - kdiff3path = MergetoolPath . Text ; <nl> - if ( ! kdiff3path . ToLower ( ) . Contains ( \" kdiff3 . exe \" ) ) <nl> - kdiff3path = \" \" ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - } <nl> - DifftoolPath . Text = kdiff3path ; <nl> - } <nl> - } <nl> - <nl> - private void BrowseDiffTool_Click ( object sender , EventArgs e ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - <nl> - if ( GlobalDiffTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - DifftoolPath . Text = SelectFile ( \" . \" , \" kdiff3 . exe ( kdiff3 . exe ) | kdiff3 . exe \" , DifftoolPath . Text ) ; <nl> - } <nl> - else <nl> - if ( GlobalDiffTool . Text . Equals ( \" p4merge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - DifftoolPath . Text = SelectFile ( \" . \" , \" p4merge . exe ( p4merge . exe ) | p4merge . exe \" , DifftoolPath . Text ) ; <nl> - else <nl> - if ( GlobalDiffTool . Text . Equals ( \" TortoiseMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - DifftoolPath . Text = SelectFile ( \" . \" , \" TortoiseMerge . exe ( TortoiseMerge . exe ) | TortoiseMerge . exe \" , DifftoolPath . Text ) ; <nl> - else <nl> - DifftoolPath . Text = SelectFile ( \" . \" , \" * . exe ( * . exe ) | * . exe \" , DifftoolPath . Text ) ; <nl> - } <nl> - <nl> - private void GlobalMergeTool_TextChanged ( object sender , EventArgs e ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - MergetoolPath . Text = gitCommands . GetGlobalSetting ( \" mergetool . \" + GlobalMergeTool . Text . Trim ( ) + \" . path \" ) ; <nl> - MergeToolCmd . Text = gitCommands . GetGlobalSetting ( \" mergetool . \" + GlobalMergeTool . Text . Trim ( ) + \" . cmd \" ) ; <nl> - <nl> - if ( GlobalMergeTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) & & string . IsNullOrEmpty ( MergeToolCmd . Text ) ) <nl> - MergeToolCmd . Enabled = false ; <nl> - else <nl> - MergeToolCmd . Enabled = true ; <nl> - <nl> - button1_Click_1 ( null , null ) ; <nl> - } <nl> - <nl> - private void ColorAddedLineDiffLabel_Click ( object sender , EventArgs e ) <nl> - { <nl> - ColorDialog colorDialog = new ColorDialog ( ) ; <nl> - colorDialog . Color = _ColorAddedLineDiffLabel . BackColor ; <nl> - colorDialog . ShowDialog ( ) ; <nl> - _ColorAddedLineDiffLabel . BackColor = colorDialog . Color ; <nl> - _ColorAddedLineDiffLabel . Text = colorDialog . Color . Name ; <nl> - _ColorAddedLineDiffLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorAddedLineDiffLabel . BackColor ) ; <nl> - } <nl> - <nl> - private void _ColorGraphLabel_Click ( object sender , EventArgs e ) <nl> - { <nl> - ColorDialog colorDialog = new ColorDialog ( ) ; <nl> - colorDialog . Color = _ColorGraphLabel . BackColor ; <nl> - colorDialog . ShowDialog ( ) ; <nl> - _ColorGraphLabel . BackColor = colorDialog . Color ; <nl> - _ColorGraphLabel . Text = colorDialog . Color . Name ; <nl> - _ColorGraphLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorAddedLineDiffLabel . BackColor ) ; <nl> - } <nl> - <nl> - private void label28_Click ( object sender , EventArgs e ) <nl> - { <nl> - ColorDialog colorDialog = new ColorDialog ( ) ; <nl> - colorDialog . Color = _ColorAddedLineLabel . BackColor ; <nl> - colorDialog . ShowDialog ( ) ; <nl> - _ColorAddedLineLabel . BackColor = colorDialog . Color ; <nl> - _ColorAddedLineLabel . Text = colorDialog . Color . Name ; <nl> - _ColorAddedLineLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorAddedLineLabel . BackColor ) ; <nl> - } <nl> - <nl> - private void ColorRemovedLineDiffLabel_Click ( object sender , EventArgs e ) <nl> - { <nl> - ColorDialog colorDialog = new ColorDialog ( ) ; <nl> - colorDialog . Color = _ColorRemovedLineDiffLabel . BackColor ; <nl> - colorDialog . ShowDialog ( ) ; <nl> - _ColorRemovedLineDiffLabel . BackColor = colorDialog . Color ; <nl> - _ColorRemovedLineDiffLabel . Text = colorDialog . Color . Name ; <nl> - _ColorRemovedLineDiffLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemovedLineDiffLabel . BackColor ) ; <nl> - <nl> - } <nl> - <nl> - private void ColorRemovedLine_Click ( object sender , EventArgs e ) <nl> - { <nl> - ColorDialog colorDialog = new ColorDialog ( ) ; <nl> - colorDialog . Color = _ColorRemovedLine . BackColor ; <nl> - colorDialog . ShowDialog ( ) ; <nl> - _ColorRemovedLine . BackColor = colorDialog . Color ; <nl> - _ColorRemovedLine . Text = colorDialog . Color . Name ; <nl> - _ColorRemovedLine . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemovedLine . BackColor ) ; <nl> - } <nl> - <nl> - private void ColorSectionLabel_Click ( object sender , EventArgs e ) <nl> - { <nl> - ColorDialog colorDialog = new ColorDialog ( ) ; <nl> - colorDialog . Color = _ColorSectionLabel . BackColor ; <nl> - colorDialog . ShowDialog ( ) ; <nl> - _ColorSectionLabel . BackColor = colorDialog . Color ; <nl> - _ColorSectionLabel . Text = colorDialog . Color . Name ; <nl> - _ColorSectionLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorSectionLabel . BackColor ) ; <nl> - } <nl> - <nl> - private void ColorTagLabel_Click ( object sender , EventArgs e ) <nl> - { <nl> - ColorDialog colorDialog = new ColorDialog ( ) ; <nl> - colorDialog . Color = _ColorTagLabel . BackColor ; <nl> - colorDialog . ShowDialog ( ) ; <nl> - _ColorTagLabel . BackColor = colorDialog . Color ; <nl> - _ColorTagLabel . Text = colorDialog . Color . Name ; <nl> - _ColorTagLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorTagLabel . BackColor ) ; <nl> - } <nl> - <nl> - private void ColorBranchLabel_Click ( object sender , EventArgs e ) <nl> - { <nl> - ColorDialog colorDialog = new ColorDialog ( ) ; <nl> - colorDialog . Color = _ColorBranchLabel . BackColor ; <nl> - colorDialog . ShowDialog ( ) ; <nl> - _ColorBranchLabel . BackColor = colorDialog . Color ; <nl> - _ColorBranchLabel . Text = colorDialog . Color . Name ; <nl> - _ColorBranchLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorBranchLabel . BackColor ) ; <nl> - } <nl> - <nl> - private void ColorRemoteBranchLabel_Click ( object sender , EventArgs e ) <nl> - { <nl> - ColorDialog colorDialog = new ColorDialog ( ) ; <nl> - colorDialog . Color = _ColorRemoteBranchLabel . BackColor ; <nl> - colorDialog . ShowDialog ( ) ; <nl> - _ColorRemoteBranchLabel . BackColor = colorDialog . Color ; <nl> - _ColorRemoteBranchLabel . Text = colorDialog . Color . Name ; <nl> - _ColorRemoteBranchLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemoteBranchLabel . BackColor ) ; <nl> - } <nl> - <nl> - private void ColorOtherLabel_Click ( object sender , EventArgs e ) <nl> - { <nl> - ColorDialog colorDialog = new ColorDialog ( ) ; <nl> - colorDialog . Color = _ColorOtherLabel . BackColor ; <nl> - colorDialog . ShowDialog ( ) ; <nl> - _ColorOtherLabel . BackColor = colorDialog . Color ; <nl> - _ColorOtherLabel . Text = colorDialog . Color . Name ; <nl> - _ColorOtherLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorOtherLabel . BackColor ) ; <nl> - } <nl> - <nl> - private void tabControl1_SelectedIndexChanged ( object sender , EventArgs e ) <nl> - { <nl> - if ( GlobalMergeTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) & & string . IsNullOrEmpty ( MergeToolCmd . Text ) ) <nl> - MergeToolCmd . Enabled = false ; <nl> - else <nl> - MergeToolCmd . Enabled = true ; <nl> - } <nl> - <nl> - private void radioButton1_CheckedChanged ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - } <nl> - <nl> - private void groupBox5_Enter ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - } <nl> - <nl> - private void ClearImageCache_Click ( object sender , EventArgs e ) <nl> - { <nl> - GravatarService . ClearImageCache ( ) ; <nl> - } <nl> - <nl> - private void DiffToolCmdSuggest_Click ( object sender , EventArgs e ) <nl> - { <nl> - GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> - <nl> - if ( GlobalDiffTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - string kdiff3path = gitCommands . GetGlobalSetting ( \" difftool . kdiff3 . path \" ) ; <nl> - string regkdiff3path = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ KDiff3 \" , \" \" ) + \" \\ \\ kdiff3 . exe \" ; <nl> - <nl> - DifftoolPath . Text = FindFileInFolders ( \" kdiff3 . exe \" , kdiff3path , <nl> - @ \" c : \\ Program Files \\ KDiff3 \\ \" , <nl> - @ \" c : \\ Program Files ( x86 ) \\ KDiff3 \\ \" , <nl> - regkdiff3path ) ; <nl> - } <nl> - if ( GlobalDiffTool . Text . Equals ( \" winmerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> - { <nl> - string winmergepath = gitCommands . GetGlobalSetting ( \" difftool . winmerge . path \" ) ; <nl> - <nl> - DifftoolPath . Text = FindFileInFolders ( \" winmergeu . exe \" , winmergepath , <nl> - @ \" c : \\ Program Files \\ winmerge \\ \" , <nl> - @ \" c : \\ Program Files ( x86 ) \\ winmerge \\ \" ) ; <nl> - } <nl> - if ( File . Exists ( DifftoolPath . Text ) ) <nl> - DifftoolCmd . Text = \" \\ \" \" + DifftoolPath . Text + \" \\ \" \\ \" $ LOCAL \\ \" \\ \" $ REMOTE \\ \" \" ; <nl> - } <nl> - <nl> - private void GlobalDiffTool_SelectedIndexChanged ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - } <nl> - <nl> - private void helpTranslate_LinkClicked ( object sender , LinkLabelLinkClickedEventArgs e ) <nl> - { <nl> - new FormTranslate ( ) . ShowDialog ( ) ; <nl> - } <nl> - <nl> - private void TabPageGit_Click ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - } <nl> - <nl> - private void groupBox7_Enter ( object sender , EventArgs e ) <nl> - { <nl> - <nl> - } <nl> - <nl> - private void otherHomeBrowse_Click ( object sender , EventArgs e ) <nl> - { <nl> - FolderBrowserDialog browseDialog = new FolderBrowserDialog ( ) ; <nl> - browseDialog . SelectedPath = Environment . GetEnvironmentVariable ( \" USERPROFILE \" ) ; <nl> - <nl> - if ( browseDialog . ShowDialog ( ) = = DialogResult . OK ) <nl> - { <nl> - otherHomeDir . Text = browseDialog . SelectedPath ; <nl> - } <nl> - <nl> - } <nl> - <nl> - private void otherHome_CheckedChanged ( object sender , EventArgs e ) <nl> - { <nl> - otherHomeDir . ReadOnly = ! otherHome . Checked ; <nl> - } <nl> - <nl> - private void MulticolorBranches_CheckedChanged ( object sender , EventArgs e ) <nl> - { <nl> - if ( MulticolorBranches . Checked ) <nl> - { <nl> - _ColorGraphLabel . Visible = false ; <nl> - StripedBanchChange . Enabled = true ; <nl> - } <nl> - else <nl> - { <nl> - _ColorGraphLabel . Visible = true ; <nl> - StripedBanchChange . Enabled = false ; <nl> - } <nl> - } <nl> - <nl> - <nl> - <nl> - } <nl> + private void label3_Click ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + } <nl> + <nl> + private void textBox1_TextChanged ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + } <nl> + <nl> + protected static string GetRegistryValue ( RegistryKey root , string subkey , string key ) <nl> + { <nl> + try <nl> + { <nl> + RegistryKey rk ; <nl> + rk = root . OpenSubKey ( subkey , false ) ; <nl> + <nl> + string value = \" \" ; <nl> + <nl> + if ( rk ! = null & & rk . GetValue ( key ) is string ) <nl> + { <nl> + value = rk . GetValue ( key ) . ToString ( ) ; <nl> + rk . Flush ( ) ; <nl> + rk . Close ( ) ; <nl> + } <nl> + <nl> + return value ; <nl> + } <nl> + catch ( UnauthorizedAccessException ) <nl> + { <nl> + MessageBox . Show ( \" GitExtensions has insufficient permisions to check the registry . \" ) ; <nl> + } <nl> + return \" \" ; <nl> + } <nl> + <nl> + <nl> + protected void SetRegistryValue ( RegistryKey root , string subkey , string key , string value ) <nl> + { <nl> + try <nl> + { <nl> + string reg ; <nl> + value = value . Replace ( \" \\ \\ \" , \" \\ \\ \\ \\ \" ) ; <nl> + reg = \" Windows Registry Editor Version 5 . 00 \" + Environment . NewLine + Environment . NewLine + \" [ \" + root . ToString ( ) + \" \\ \\ \" + subkey + \" ] \" + Environment . NewLine + \" \\ \" \" + key + \" \\ \" = \\ \" \" + value + \" \\ \" \" ; <nl> + <nl> + TextWriter tw = new StreamWriter ( System . IO . Path . GetTempPath ( ) + \" GitExtensions . reg \" , false ) ; <nl> + tw . Write ( reg ) ; <nl> + tw . Close ( ) ; <nl> + GitCommands . GitCommands . RunCmd ( \" regedit \" , \" \\ \" \" + System . IO . Path . GetTempPath ( ) + \" GitExtensions . reg \" + \" \\ \" \" ) ; <nl> + } <nl> + catch ( UnauthorizedAccessException ) <nl> + { <nl> + MessageBox . Show ( \" GitExtensions has insufficient permisions to modify the registry . \" + Environment . NewLine + \" Please add this key to the registry manually . \" + Environment . NewLine + \" Path : \" + root . ToString ( ) + \" \\ \\ \" + subkey + Environment . NewLine + \" Value : \" + key + \" = \" + value ) ; <nl> + } <nl> + } <nl> + <nl> + public bool CheckSettings ( ) <nl> + { <nl> + bool bValid = true ; <nl> + try <nl> + { <nl> + if ( string . IsNullOrEmpty ( GitCommands . Settings . GetInstallDir ( ) ) ) <nl> + { <nl> + GitExtensionsInstall . BackColor = Color . LightSalmon ; <nl> + GitExtensionsInstall . Text = \" Registry entry missing [ Software \\ \\ GitExtensions \\ \\ GitExtensions \\ \\ 1 . 0 . 0 . 0 \\ \\ InstallDir ] . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + GitExtensionsInstall . BackColor = Color . LightGreen ; <nl> + GitExtensionsInstall . Text = \" GitExtensions is properly registered . \" ; <nl> + } <nl> + <nl> + if ( string . IsNullOrEmpty ( GetRegistryValue ( Registry . LocalMachine , \" Software \\ \\ Microsoft \\ \\ Windows \\ \\ CurrentVersion \\ \\ Shell Extensions \\ \\ Approved \" , \" { 3C16B20A - BA16 - 4156 - 916F - 0A375ECFFE24 } \" ) ) | | <nl> + string . IsNullOrEmpty ( GetRegistryValue ( Registry . ClassesRoot , \" * \\ \\ shellex \\ \\ ContextMenuHandlers \\ \\ GitExtensions2 \" , null ) ) | | <nl> + string . IsNullOrEmpty ( GetRegistryValue ( Registry . ClassesRoot , \" Directory \\ \\ shellex \\ \\ ContextMenuHandlers \\ \\ GitExtensions2 \" , null ) ) | | <nl> + string . IsNullOrEmpty ( GetRegistryValue ( Registry . ClassesRoot , \" Directory \\ \\ Background \\ \\ shellex \\ \\ ContextMenuHandlers \\ \\ GitExtensions2 \" , null ) ) ) <nl> + { <nl> + ShellExtensionsRegistered . BackColor = Color . LightSalmon ; <nl> + ShellExtensionsRegistered . Text = \" GitExtensionsShellEx . dll needs to be registered in order to use the shell extensions . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + ShellExtensionsRegistered . BackColor = Color . LightGreen ; <nl> + ShellExtensionsRegistered . Text = \" Shell extensions registered properly . \" ; <nl> + } <nl> + <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + if ( string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" user . name \" ) ) | | <nl> + string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" user . email \" ) ) ) <nl> + { <nl> + UserNameSet . BackColor = Color . LightSalmon ; <nl> + UserNameSet . Text = \" You need to configure a user name and an email address . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + UserNameSet . BackColor = Color . LightGreen ; <nl> + UserNameSet . Text = \" There is a user name and an email address configured . \" ; <nl> + } <nl> + <nl> + if ( string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) ) ) <nl> + { <nl> + DiffTool . BackColor = Color . LightSalmon ; <nl> + DiffTool . Text = \" You need to configure merge tool in order to solve mergeconflicts ( kdiff3 for example ) . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + if ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + string p = gitCommands . GetGlobalSetting ( \" mergetool . kdiff3 . path \" ) ; <nl> + if ( string . IsNullOrEmpty ( p ) | | ! File . Exists ( p ) ) <nl> + { <nl> + DiffTool . BackColor = Color . LightSalmon ; <nl> + DiffTool . Text = \" KDiff3 is configured as mergetool , but the path to kdiff . exe is not configured . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + DiffTool . BackColor = Color . LightGreen ; <nl> + DiffTool . Text = \" KDiff3 is configured as mergetool . \" ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + string mergetool = gitCommands . GetGlobalSetting ( \" merge . tool \" ) ; <nl> + if ( mergetool . Equals ( \" p4merge \" , StringComparison . CurrentCultureIgnoreCase ) | | <nl> + mergetool . Equals ( \" TortoiseMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + string p = gitCommands . GetGlobalSetting ( \" mergetool . \" + mergetool + \" . cmd \" ) ; <nl> + if ( string . IsNullOrEmpty ( p ) ) <nl> + { <nl> + DiffTool . BackColor = Color . LightSalmon ; <nl> + DiffTool . Text = mergetool + \" is configured as mergetool , this is a custom mergetool and needs a custom cmd to be configured . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + DiffTool . BackColor = Color . LightGreen ; <nl> + DiffTool . Text = \" There is a custom mergetool configured : \" + mergetool ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + DiffTool . BackColor = Color . LightGreen ; <nl> + DiffTool . Text = \" There is a mergetool configured . \" ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + if ( string . IsNullOrEmpty ( FormSettings . GetGlobalDiffToolFromConfig ( ) ) ) <nl> + { <nl> + DiffTool2 . BackColor = Color . LightSalmon ; <nl> + DiffTool2 . Text = \" You should configure a diff tool to show file diff in external program ( kdiff3 for example ) . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + if ( FormSettings . GetGlobalDiffToolFromConfig ( ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + string p = gitCommands . GetGlobalSetting ( \" difftool . kdiff3 . path \" ) ; <nl> + if ( string . IsNullOrEmpty ( p ) | | ! File . Exists ( p ) ) <nl> + { <nl> + DiffTool2 . BackColor = Color . LightSalmon ; <nl> + DiffTool2 . Text = \" KDiff3 is configured as difftool , but the path to kdiff . exe is not configured . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + DiffTool2 . BackColor = Color . LightGreen ; <nl> + DiffTool2 . Text = \" KDiff3 is configured as difftool . \" ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + string difftool = FormSettings . GetGlobalDiffToolFromConfig ( ) ; <nl> + DiffTool2 . BackColor = Color . LightGreen ; <nl> + DiffTool2 . Text = \" There is a difftool configured : \" + difftool ; <nl> + } <nl> + } <nl> + <nl> + if ( ! CanFindGitCmd ( ) ) <nl> + { <nl> + GitFound . BackColor = Color . LightSalmon ; <nl> + GitFound . Text = \" git . cmd not found . To solve this problem you can set the correct path in settings . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + GitFound . BackColor = Color . LightGreen ; <nl> + GitFound . Text = \" git . cmd is found on your computer . \" ; <nl> + } <nl> + <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitBinDir + \" git . exe \" , \" \" ) ) ) <nl> + { <nl> + GitBinFound . BackColor = Color . LightSalmon ; <nl> + GitBinFound . Text = \" git . exe not found . To solve this problem you can set the correct path in settings . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + GitBinFound . BackColor = Color . LightGreen ; <nl> + GitBinFound . Text = \" git . exe is found on your computer . \" ; <nl> + } <nl> + if ( GitCommands . GitCommands . Plink ( ) ) <nl> + { <nl> + if ( ! File . Exists ( GitCommands . Settings . Plink ) | | ! File . Exists ( GitCommands . Settings . Puttygen ) | | ! File . Exists ( GitCommands . Settings . Pageant ) ) <nl> + { <nl> + SshConfig . BackColor = Color . LightSalmon ; <nl> + SshConfig . Text = \" PuTTY is configured as SSH client but cannot find plink . exe , puttygen . exe or pageant . exe . \" ; <nl> + bValid = false ; <nl> + } <nl> + else <nl> + { <nl> + SshConfig . BackColor = Color . LightGreen ; <nl> + SshConfig . Text = \" SSH client PuTTY is configured properly \" ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + SshConfig . BackColor = Color . LightGreen ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . GetSsh ( ) ) ) <nl> + SshConfig . Text = \" Default SSH client , OpenSSH , will be used . ( commandline window will appear on pull , push and clone operations ) \" ; <nl> + else <nl> + SshConfig . Text = \" Unknown SSH client configured : \" + GitCommands . GitCommands . GetSsh ( ) ; <nl> + } <nl> + <nl> + } <nl> + catch <nl> + { <nl> + } <nl> + <nl> + if ( ( Application . UserAppDataRegistry . GetValue ( \" checksettings \" ) = = null | | <nl> + Application . UserAppDataRegistry . GetValue ( \" checksettings \" ) . ToString ( ) = = \" true \" ) ) <nl> + { <nl> + CheckAtStartup . Checked = true ; <nl> + } <nl> + else <nl> + { <nl> + CheckAtStartup . Checked = false ; <nl> + } <nl> + <nl> + <nl> + if ( bValid & & CheckAtStartup . Checked ) <nl> + { <nl> + Application . UserAppDataRegistry . SetValue ( \" checksettings \" , false ) ; <nl> + CheckAtStartup . Checked = false ; <nl> + } <nl> + <nl> + return bValid ; <nl> + } <nl> + <nl> + private static bool CanFindGitCmd ( ) <nl> + { <nl> + return ! string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ; <nl> + } <nl> + <nl> + private void GitExtensionsInstall_Click ( object sender , EventArgs e ) <nl> + { <nl> + SolveGitExtensionsDir ( ) ; <nl> + <nl> + CheckSettings ( ) ; <nl> + } <nl> + <nl> + public static bool SolveGitExtensionsDir ( ) <nl> + { <nl> + string fileName = Assembly . GetAssembly ( typeof ( FormSettings ) ) . Location ; <nl> + fileName = fileName . Substring ( 0 , fileName . LastIndexOfAny ( new char [ ] { ' \\ \\ ' , ' / ' } ) ) ; <nl> + <nl> + if ( File . Exists ( fileName + \" \\ \\ GitExtensions . exe \" ) ) <nl> + { <nl> + GitCommands . Settings . SetInstallDir ( fileName ) ; <nl> + return true ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + <nl> + private void ShellExtensionsRegistered_Click ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + if ( File . Exists ( GitCommands . Settings . GetInstallDir ( ) + \" \\ \\ GitExtensionsShellEx . dll \" ) ) <nl> + GitCommands . GitCommands . RunCmd ( \" regsvr32 \" , \" \\ \" \" + GitCommands . Settings . GetInstallDir ( ) + \" \\ \\ GitExtensionsShellEx . dll \\ \" \" ) ; <nl> + else <nl> + { <nl> + string fileName = Assembly . GetAssembly ( GetType ( ) ) . Location ; <nl> + fileName = fileName . Substring ( 0 , fileName . LastIndexOfAny ( new char [ ] { ' \\ \\ ' , ' / ' } ) ) + \" \\ \\ GitExtensionsShellEx . dll \" ; <nl> + <nl> + if ( File . Exists ( fileName ) ) <nl> + GitCommands . GitCommands . RunCmd ( \" regsvr32 \" , \" \\ \" \" + fileName + \" \\ \" \" ) ; <nl> + } <nl> + <nl> + CheckSettings ( ) ; <nl> + } <nl> + <nl> + private void UserNameSet_Click ( object sender , EventArgs e ) <nl> + { <nl> + tabControl1 . SelectTab ( \" GlobalSettingsPage \" ) ; <nl> + } <nl> + <nl> + private void DiffTool2_Click ( object sender , EventArgs e ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + <nl> + if ( string . IsNullOrEmpty ( FormSettings . GetGlobalDiffToolFromConfig ( ) ) ) <nl> + { <nl> + if ( MessageBox . Show ( \" There is no difftool configured . Do you want to configure kdiff3 as your difftool ? \" + Environment . NewLine + \" Select no if you want to configure a different difftool yourself . \" , \" Mergetool \" , MessageBoxButtons . YesNo ) = = DialogResult . Yes ) <nl> + { <nl> + SolveKDiffTool2 ( ) ; <nl> + GlobalDiffTool . Text = \" kdiff3 \" ; <nl> + } <nl> + else <nl> + { <nl> + tabControl1 . SelectTab ( \" GlobalSettingsPage \" ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + if ( FormSettings . GetGlobalDiffToolFromConfig ( ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + SolveKDiffTool2Path ( gitCommands ) ; <nl> + } <nl> + <nl> + if ( FormSettings . GetGlobalDiffToolFromConfig ( ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) & & string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" difftool . kdiff3 . path \" ) ) ) <nl> + { <nl> + MessageBox . Show ( \" Path to kdiff3 could not be found automatically . \" + Environment . NewLine + \" Please make sure KDiff3 is installed or set path manually . \" ) ; <nl> + tabControl1 . SelectTab ( \" GlobalSettingsPage \" ) ; <nl> + return ; <nl> + } <nl> + <nl> + Rescan_Click ( null , null ) ; <nl> + } <nl> + <nl> + private void DiffTool_Click ( object sender , EventArgs e ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + <nl> + if ( string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) ) ) <nl> + { <nl> + if ( MessageBox . Show ( \" There is no mergetool configured . Do you want to configure kdiff3 as your mergetool ? \" + Environment . NewLine + \" Select no if you want to configure a different mergetool yourself . \" , \" Mergetool \" , MessageBoxButtons . YesNo ) = = DialogResult . Yes ) <nl> + { <nl> + SolveKDiff ( ) ; <nl> + GlobalDiffTool . Text = \" kdiff3 \" ; <nl> + } <nl> + else <nl> + { <nl> + tabControl1 . SelectTab ( \" GlobalSettingsPage \" ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + if ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + SolveKDiffPath ( gitCommands ) ; <nl> + } <nl> + else <nl> + if ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) . Equals ( \" p4merge \" , StringComparison . CurrentCultureIgnoreCase ) | | <nl> + gitCommands . GetGlobalSetting ( \" merge . tool \" ) . Equals ( \" TortoiseMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + AutoConfigMergeToolcmd ( ) ; <nl> + gitCommands . SetGlobalSetting ( \" mergetool . \" + gitCommands . GetGlobalSetting ( \" merge . tool \" ) + \" . cmd \" , MergeToolCmd . Text ) ; <nl> + } <nl> + <nl> + <nl> + if ( gitCommands . GetGlobalSetting ( \" merge . tool \" ) . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) & & string . IsNullOrEmpty ( gitCommands . GetGlobalSetting ( \" mergetool . kdiff3 . path \" ) ) ) <nl> + { <nl> + MessageBox . Show ( \" Path to kdiff3 could not be found automatically . \" + Environment . NewLine + \" Please make sure KDiff3 is installed or set path manually . \" ) ; <nl> + tabControl1 . SelectTab ( \" GlobalSettingsPage \" ) ; <nl> + return ; <nl> + } <nl> + <nl> + Rescan_Click ( null , null ) ; <nl> + } <nl> + <nl> + public static bool SolveKDiff ( ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + string mergeTool = gitCommands . GetGlobalSetting ( \" merge . tool \" ) ; <nl> + if ( string . IsNullOrEmpty ( mergeTool ) ) <nl> + { <nl> + mergeTool = \" kdiff3 \" ; <nl> + gitCommands . SetGlobalSetting ( \" merge . tool \" , mergeTool ) ; <nl> + } <nl> + <nl> + if ( mergeTool . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + return SolveKDiffPath ( gitCommands ) ; <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + public static bool SolveKDiffTool2 ( ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + string diffTool = GetGlobalDiffToolFromConfig ( ) ; <nl> + if ( string . IsNullOrEmpty ( diffTool ) ) <nl> + { <nl> + diffTool = \" kdiff3 \" ; <nl> + ConfigFile globalConfig = GitCommands . GitCommands . GetGlobalConfig ( ) ; <nl> + SetGlobalDiffToolToConfig ( globalConfig , diffTool ) ; <nl> + globalConfig . Save ( ) ; <nl> + } <nl> + <nl> + if ( diffTool . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + return SolveKDiffTool2Path ( gitCommands ) ; <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + public static bool SolveKDiffPath ( GitCommands . GitCommands gitCommands ) <nl> + { <nl> + string kdiff3path = gitCommands . GetGlobalSetting ( \" mergetool . kdiff3 . path \" ) ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = @ \" c : \\ Program Files \\ KDiff3 \\ kdiff3 . exe \" ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = @ \" c : \\ Program Files ( x86 ) \\ KDiff3 \\ kdiff3 . exe \" ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ KDiff3 \" , \" \" ) + \" \\ \\ kdiff3 . exe \" ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = \" \" ; <nl> + return false ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + gitCommands . SetGlobalSetting ( \" mergetool . kdiff3 . path \" , kdiff3path ) ; <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + public static bool SolveKDiffTool2Path ( GitCommands . GitCommands gitCommands ) <nl> + { <nl> + string kdiff3path = gitCommands . GetGlobalSetting ( \" difftool . kdiff3 . path \" ) ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = @ \" c : \\ Program Files \\ KDiff3 \\ kdiff3 . exe \" ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = @ \" c : \\ Program Files ( x86 ) \\ KDiff3 \\ kdiff3 . exe \" ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ KDiff3 \" , \" \" ) + \" \\ \\ kdiff3 . exe \" ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = \" \" ; <nl> + return false ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + gitCommands . SetGlobalSetting ( \" difftool . kdiff3 . path \" , kdiff3path ) ; <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + private void GitFound_Click ( object sender , EventArgs e ) <nl> + { <nl> + SolveGitCmdDir ( ) ; <nl> + <nl> + if ( string . IsNullOrEmpty ( GitCommands . Settings . GitCommand ) ) <nl> + { <nl> + MessageBox . Show ( \" The command to run git could not be determined automatically . \" + Environment . NewLine + \" Please make sure git ( msysgit ) is installed or set the correct path manually . \" , \" Locate git . cmd \" ) ; <nl> + <nl> + tabControl1 . SelectTab ( \" TabPageGitExtensions \" ) ; <nl> + return ; <nl> + } <nl> + <nl> + MessageBox . Show ( \" Command git . cmd can be runned using : \" + GitCommands . Settings . GitCommand , \" Locate git . cmd \" ) ; <nl> + GitPath . Text = GitCommands . Settings . GitCommand ; <nl> + Rescan_Click ( null , null ) ; <nl> + } <nl> + <nl> + public static bool SolveGitCmdDir ( ) <nl> + { <nl> + GitCommands . Settings . GitCommand = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ Microsoft \\ \\ Windows \\ \\ CurrentVersion \\ \\ Uninstall \\ \\ Git_is1 \" , \" InstallLocation \" ) + \" cmd \\ \\ git . cmd \" ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> + { <nl> + GitCommands . Settings . GitCommand = @ \" c : \\ Program Files ( x86 ) \\ Git \\ cmd \\ git . cmd \" ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> + { <nl> + GitCommands . Settings . GitCommand = @ \" c : \\ Program Files \\ Git \\ cmd \\ git . cmd \" ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> + { <nl> + GitCommands . Settings . GitCommand = @ \" C : \\ cygwin \\ bin \\ git \" ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> + { <nl> + GitCommands . Settings . GitCommand = \" git . cmd \" ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> + { <nl> + GitCommands . Settings . GitCommand = \" git \" ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand , \" \" ) ) ) <nl> + { <nl> + return false ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + private void FormSettigns_Load ( object sender , EventArgs e ) <nl> + { <nl> + EnableSettings ( ) ; <nl> + <nl> + this . WindowState = FormWindowState . Normal ; <nl> + } <nl> + <nl> + private void EnableSettings ( ) <nl> + { <nl> + bool canFindGitCmd = CanFindGitCmd ( ) ; <nl> + GlobalUserName . Enabled = canFindGitCmd ; <nl> + GlobalUserEmail . Enabled = canFindGitCmd ; <nl> + GlobalEditor . Enabled = canFindGitCmd ; <nl> + GlobalMergeTool . Enabled = canFindGitCmd ; <nl> + MergetoolPath . Enabled = canFindGitCmd ; <nl> + MergeToolCmd . Enabled = canFindGitCmd ; <nl> + GlobalKeepMergeBackup . Enabled = canFindGitCmd ; <nl> + <nl> + InvalidGitPathGlobal . Visible = ! canFindGitCmd ; <nl> + InvalidGitPathLocal . Visible = ! canFindGitCmd ; <nl> + <nl> + bool valid = GitCommands . Settings . ValidWorkingDir ( ) & & canFindGitCmd ; <nl> + UserName . Enabled = valid ; <nl> + UserEmail . Enabled = valid ; <nl> + Editor . Enabled = valid ; <nl> + MergeTool . Enabled = valid ; <nl> + KeepMergeBackup . Enabled = valid ; <nl> + LocalAutoCRLF . Enabled = valid ; <nl> + NoGitRepo . Visible = ! valid ; <nl> + <nl> + } <nl> + <nl> + private void CheckAtStartup_CheckedChanged ( object sender , EventArgs e ) <nl> + { <nl> + if ( CheckAtStartup . Checked ) <nl> + Application . UserAppDataRegistry . SetValue ( \" checksettings \" , \" true \" ) ; <nl> + else <nl> + Application . UserAppDataRegistry . SetValue ( \" checksettings \" , \" false \" ) ; <nl> + } <nl> + <nl> + private void Rescan_Click ( object sender , EventArgs e ) <nl> + { <nl> + Cursor . Current = Cursors . WaitCursor ; <nl> + Save ( ) ; <nl> + LoadSettings ( ) ; <nl> + CheckSettings ( ) ; <nl> + } <nl> + <nl> + private void BrowseGitPath_Click ( object sender , EventArgs e ) <nl> + { <nl> + SolveGitCmdDir ( ) ; <nl> + <nl> + OpenFileDialog browseDialog = new OpenFileDialog ( ) ; <nl> + browseDialog . FileName = GitCommands . Settings . GitCommand ; <nl> + browseDialog . Filter = \" Git . cmd ( git . cmd ) | git . cmd | Git . exe ( git . exe ) | git . exe | Git ( git ) | git \" ; <nl> + <nl> + if ( browseDialog . ShowDialog ( ) = = DialogResult . OK ) <nl> + { <nl> + GitPath . Text = browseDialog . FileName ; <nl> + } <nl> + } <nl> + <nl> + private void TabPageGitExtensions_Click ( object sender , EventArgs e ) <nl> + { <nl> + GitPath . Text = GitCommands . Settings . GitCommand ; <nl> + } <nl> + <nl> + private void GitPath_TextChanged ( object sender , EventArgs e ) <nl> + { <nl> + GitCommands . Settings . GitCommand = GitPath . Text ; <nl> + LoadSettings ( ) ; <nl> + } <nl> + <nl> + private void GitBinFound_Click ( object sender , EventArgs e ) <nl> + { <nl> + SolveGitBinDir ( ) ; <nl> + <nl> + if ( string . IsNullOrEmpty ( GitCommands . Settings . GitBinDir ) ) <nl> + { <nl> + MessageBox . Show ( \" The path to git . exe could not be found automatically . \" + Environment . NewLine + \" Please make sure git ( msysgit ) is installed or set the correct path manually . \" , \" Locate git . exe \" ) ; <nl> + tabControl1 . SelectTab ( \" TabPageGitExtensions \" ) ; <nl> + return ; <nl> + } <nl> + <nl> + MessageBox . Show ( \" Command git . exe can be runned using : \" + GitCommands . Settings . GitBinDir + \" git . exe \" , \" Locate git . exe \" ) ; <nl> + GitBinPath . Text = GitCommands . Settings . GitBinDir ; <nl> + Rescan_Click ( null , null ) ; <nl> + } <nl> + <nl> + public static bool SolveGitBinDir ( ) <nl> + { <nl> + GitCommands . Settings . GitBinDir = @ \" c : \\ Program Files \\ Git \\ bin \\ \" ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitBinDir + \" git . exe \" , \" \" ) ) ) <nl> + { <nl> + GitCommands . Settings . GitBinDir = @ \" c : \\ Program Files ( x86 ) \\ Git \\ bin \\ \" ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitBinDir + \" git . exe \" , \" \" ) ) ) <nl> + { <nl> + GitCommands . Settings . GitBinDir = \" C : \\ \\ cygwin \\ \\ bin \" ; <nl> + if ( ! Directory . Exists ( GitCommands . Settings . GitBinDir ) ) <nl> + { <nl> + GitCommands . Settings . GitBinDir = GitCommands . Settings . GitCommand ; <nl> + GitCommands . Settings . GitBinDir = GitCommands . Settings . GitBinDir . Replace ( \" \\ \\ cmd \\ \\ git . cmd \" , \" \\ \\ bin \\ \\ \" ) ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitBinDir + \" git . exe \" , \" \" ) ) ) <nl> + { <nl> + GitCommands . Settings . GitBinDir = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ Microsoft \\ \\ Windows \\ \\ CurrentVersion \\ \\ Uninstall \\ \\ Git_is1 \" , \" InstallLocation \" ) + \" \\ \\ bin \\ \\ \" ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitBinDir + \" git . exe \" , \" \" ) ) ) <nl> + { <nl> + GitCommands . Settings . GitBinDir = \" \" ; <nl> + if ( string . IsNullOrEmpty ( GitCommands . GitCommands . RunCmd ( GitCommands . Settings . GitCommand . Replace ( \" git . cmd \" , \" git . exe \" ) ) ) ) <nl> + { <nl> + return false ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> + } <nl> + return true ; <nl> + } <nl> + <nl> + private void OpenSSH_CheckedChanged ( object sender , EventArgs e ) <nl> + { <nl> + EnableSshOptions ( ) ; <nl> + } <nl> + <nl> + private void Putty_CheckedChanged ( object sender , EventArgs e ) <nl> + { <nl> + if ( Putty . Checked ) <nl> + { <nl> + AutoFindPuttyPaths ( ) ; <nl> + } <nl> + EnableSshOptions ( ) ; <nl> + } <nl> + <nl> + private bool AutoFindPuttyPaths ( ) <nl> + { <nl> + if ( AutoFindPuttyPathsInDir ( \" c : \\ \\ Program Files \\ \\ PuTTY \\ \\ \" ) ) return true ; <nl> + if ( AutoFindPuttyPathsInDir ( \" c : \\ \\ Program Files ( x86 ) \\ \\ PuTTY \\ \\ \" ) ) return true ; <nl> + if ( AutoFindPuttyPathsInDir ( \" C : \\ \\ Program Files \\ \\ TortoiseGit \\ \\ bin \" ) ) return true ; <nl> + if ( AutoFindPuttyPathsInDir ( \" C : \\ \\ Program Files ( x86 ) \\ \\ TortoiseGit \\ \\ bin \" ) ) return true ; <nl> + if ( AutoFindPuttyPathsInDir ( \" C : \\ \\ Program Files \\ \\ TortoiseSvn \\ \\ bin \" ) ) return true ; <nl> + if ( AutoFindPuttyPathsInDir ( \" C : \\ \\ Program Files ( x86 ) \\ \\ TortoiseSvn \\ \\ bin \" ) ) return true ; <nl> + if ( AutoFindPuttyPathsInDir ( GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ Microsoft \\ \\ Windows \\ \\ CurrentVersion \\ \\ Uninstall \\ \\ PuTTY_is1 \" , \" InstallLocation \" ) ) ) return true ; <nl> + if ( AutoFindPuttyPathsInDir ( GitCommands . Settings . GetInstallDir ( ) + \" \\ \\ PuTTY \\ \\ \" ) ) return true ; <nl> + <nl> + return false ; <nl> + } <nl> + <nl> + private bool AutoFindPuttyPathsInDir ( string installdir ) <nl> + { <nl> + if ( ! installdir . EndsWith ( \" \\ \\ \" ) ) <nl> + installdir + = \" \\ \\ \" ; <nl> + <nl> + if ( ! File . Exists ( PlinkPath . Text ) ) <nl> + { <nl> + if ( File . Exists ( installdir + \" plink . exe \" ) ) <nl> + PlinkPath . Text = installdir + \" plink . exe \" ; <nl> + } <nl> + <nl> + if ( ! File . Exists ( PlinkPath . Text ) ) <nl> + { <nl> + if ( File . Exists ( installdir + \" TortoisePlink . exe \" ) ) <nl> + PlinkPath . Text = installdir + \" TortoisePlink . exe \" ; <nl> + } <nl> + <nl> + if ( ! File . Exists ( PuttygenPath . Text ) ) <nl> + { <nl> + if ( File . Exists ( installdir + \" puttygen . exe \" ) ) <nl> + PuttygenPath . Text = installdir + \" puttygen . exe \" ; <nl> + } <nl> + <nl> + if ( ! File . Exists ( PageantPath . Text ) ) <nl> + { <nl> + if ( File . Exists ( installdir + \" pageant . exe \" ) ) <nl> + PageantPath . Text = installdir + \" pageant . exe \" ; <nl> + } <nl> + <nl> + if ( File . Exists ( PlinkPath . Text ) & & File . Exists ( PuttygenPath . Text ) & & File . Exists ( PageantPath . Text ) ) <nl> + return true ; <nl> + else <nl> + return false ; <nl> + } <nl> + <nl> + private string SelectFile ( string initialDirectory , string filter , string prev ) <nl> + { <nl> + OpenFileDialog dialog = new OpenFileDialog ( ) ; <nl> + dialog . Filter = filter ; <nl> + dialog . InitialDirectory = initialDirectory ; <nl> + dialog . Title = \" Select file \" ; <nl> + return ( dialog . ShowDialog ( ) = = DialogResult . OK ) ? dialog . FileName : prev ; <nl> + } <nl> + <nl> + private void button1_Click ( object sender , EventArgs e ) <nl> + { <nl> + OtherSsh . Text = SelectFile ( \" . \" , \" Executable file ( * . exe ) | * . exe \" , OtherSsh . Text ) ; <nl> + } <nl> + <nl> + private void Other_CheckedChanged ( object sender , EventArgs e ) <nl> + { <nl> + EnableSshOptions ( ) ; <nl> + } <nl> + <nl> + private void EnableSshOptions ( ) <nl> + { <nl> + OtherSsh . Enabled = Other . Checked ; <nl> + OtherSshBrowse . Enabled = Other . Checked ; <nl> + <nl> + PlinkPath . Enabled = Putty . Checked ; <nl> + PuttygenPath . Enabled = Putty . Checked ; <nl> + PageantPath . Enabled = Putty . Checked ; <nl> + PlinkBrowse . Enabled = Putty . Checked ; <nl> + PuttygenBrowse . Enabled = Putty . Checked ; <nl> + PageantBrowse . Enabled = Putty . Checked ; <nl> + AutostartPageant . Enabled = Putty . Checked ; <nl> + } <nl> + <nl> + private void PuttyBrowse_Click ( object sender , EventArgs e ) <nl> + { <nl> + PlinkPath . Text = SelectFile ( \" . \" , \" Plink . exe ( plink . exe ) | plink . exe | TortoisePlink . exe ( tortoiseplink . exe ) | tortoiseplink . exe \" , PlinkPath . Text ) ; <nl> + } <nl> + <nl> + private void PuttygenBrowse_Click ( object sender , EventArgs e ) <nl> + { <nl> + PuttygenPath . Text = SelectFile ( \" . \" , \" puttygen . exe ( puttygen . exe ) | puttygen . exe \" , PuttygenPath . Text ) ; <nl> + } <nl> + <nl> + private void PageantBrowse_Click ( object sender , EventArgs e ) <nl> + { <nl> + PageantPath . Text = SelectFile ( \" . \" , \" pageant . exe ( pageant . exe ) | pageant . exe \" , PageantPath . Text ) ; <nl> + } <nl> + <nl> + private void SshConfig_Click ( object sender , EventArgs e ) <nl> + { <nl> + if ( Putty . Checked ) <nl> + { <nl> + if ( AutoFindPuttyPaths ( ) ) <nl> + MessageBox . Show ( \" All paths needed for PuTTY could be automaticly found and are set . \" , \" PuTTY \" ) ; <nl> + else <nl> + tabControl1 . SelectTab ( \" ssh \" ) ; <nl> + } <nl> + } <nl> + <nl> + private void BrowseGitBinPath_Click ( object sender , EventArgs e ) <nl> + { <nl> + SolveGitBinDir ( ) ; <nl> + <nl> + FolderBrowserDialog browseDialog = new FolderBrowserDialog ( ) ; <nl> + browseDialog . SelectedPath = GitCommands . Settings . GitBinDir ; <nl> + <nl> + if ( browseDialog . ShowDialog ( ) = = DialogResult . OK ) <nl> + { <nl> + GitBinPath . Text = browseDialog . SelectedPath ; <nl> + } <nl> + } <nl> + <nl> + private void BrowseMergeTool_Click ( object sender , EventArgs e ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + <nl> + if ( GlobalMergeTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + MergetoolPath . Text = SelectFile ( \" . \" , \" kdiff3 . exe ( kdiff3 . exe ) | kdiff3 . exe \" , MergetoolPath . Text ) ; <nl> + } <nl> + else <nl> + if ( GlobalMergeTool . Text . Equals ( \" p4merge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + MergetoolPath . Text = SelectFile ( \" . \" , \" p4merge . exe ( p4merge . exe ) | p4merge . exe \" , MergetoolPath . Text ) ; <nl> + else <nl> + if ( GlobalMergeTool . Text . Equals ( \" TortoiseMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + MergetoolPath . Text = SelectFile ( \" . \" , \" TortoiseMerge . exe ( TortoiseMerge . exe ) | TortoiseMerge . exe \" , MergetoolPath . Text ) ; <nl> + else <nl> + MergetoolPath . Text = SelectFile ( \" . \" , \" * . exe ( * . exe ) | * . exe \" , MergetoolPath . Text ) ; <nl> + <nl> + } <nl> + <nl> + private void button1_Click_1 ( object sender , EventArgs e ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + <nl> + if ( GlobalMergeTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + string kdiff3path = gitCommands . GetGlobalSetting ( \" mergetool . kdiff3 . path \" ) ; <nl> + string regkdiff3path = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ KDiff3 \" , \" \" ) + \" \\ \\ kdiff3 . exe \" ; <nl> + <nl> + MergetoolPath . Text = FindFileInFolders ( \" kdiff3 . exe \" , kdiff3path , <nl> + @ \" c : \\ Program Files \\ KDiff3 \\ \" , <nl> + @ \" c : \\ Program Files ( x86 ) \\ KDiff3 \\ \" , <nl> + regkdiff3path ) ; <nl> + } <nl> + if ( GlobalMergeTool . Text . Equals ( \" winmerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + string winmergepath = gitCommands . GetGlobalSetting ( \" mergetool . winmerge . path \" ) ; <nl> + <nl> + MergetoolPath . Text = FindFileInFolders ( \" winmergeu . exe \" , winmergepath , <nl> + @ \" c : \\ Program Files \\ winmerge \\ \" , <nl> + @ \" c : \\ Program Files ( x86 ) \\ winmerge \\ \" ) ; <nl> + } <nl> + AutoConfigMergeToolcmd ( ) ; <nl> + } <nl> + <nl> + private string FindFileInFolders ( string fileName , params string [ ] locations ) <nl> + { <nl> + foreach ( string location in locations ) <nl> + { <nl> + if ( ! string . IsNullOrEmpty ( location ) & & File . Exists ( location ) ) <nl> + return location ; <nl> + if ( ! string . IsNullOrEmpty ( location ) & & File . Exists ( location + fileName ) ) <nl> + return location + fileName ; <nl> + if ( ! string . IsNullOrEmpty ( location ) & & File . Exists ( location + \" \\ \\ \" + fileName ) ) <nl> + return location + \" \\ \\ \" + fileName ; <nl> + } <nl> + <nl> + return \" \" ; <nl> + } <nl> + <nl> + private void AutoConfigMergeToolcmd ( ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + if ( GlobalMergeTool . Text . Equals ( \" p4merge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + if ( MergetoolPath . Text . Contains ( \" kdiff3 \" ) | | MergetoolPath . Text . Contains ( \" TortoiseMerge \" ) ) <nl> + MergetoolPath . Text = \" \" ; <nl> + if ( string . IsNullOrEmpty ( MergetoolPath . Text ) | | ! File . Exists ( MergetoolPath . Text ) ) <nl> + { <nl> + MergetoolPath . Text = @ \" c : \\ Program Files \\ Perforce \\ p4merge . exe \" ; <nl> + <nl> + MergetoolPath . Text = FindFileInFolders ( \" p4merge . exe \" , <nl> + @ \" c : \\ Program Files ( x86 ) \\ Perforce \\ \" , <nl> + @ \" c : \\ Program Files \\ Perforce \\ \" ) ; <nl> + <nl> + if ( ! File . Exists ( MergetoolPath . Text ) ) <nl> + { <nl> + MergetoolPath . Text = \" \" ; <nl> + MessageBox . Show ( \" Please enter the path to p4merge . exe and press suggest . \" , \" Suggest mergetool cmd \" ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + MergeToolCmd . Text = \" \\ \" \" + MergetoolPath . Text + \" \\ \" \\ \" $ BASE \\ \" \\ \" $ LOCAL \\ \" \\ \" $ REMOTE \\ \" \\ \" $ MERGED \\ \" \" ; <nl> + return ; <nl> + } <nl> + <nl> + if ( GlobalMergeTool . Text . Equals ( \" Araxis \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + if ( MergetoolPath . Text . Contains ( \" kdiff3 \" ) | | MergetoolPath . Text . Contains ( \" TortoiseMerge \" ) ) <nl> + MergetoolPath . Text = \" \" ; <nl> + if ( string . IsNullOrEmpty ( MergetoolPath . Text ) | | ! File . Exists ( MergetoolPath . Text ) ) <nl> + { <nl> + MergetoolPath . Text = FindFileInFolders ( \" Compare . exe \" , <nl> + @ \" C : \\ Program Files ( x86 ) \\ Araxis \\ Araxis Merge \\ \" , <nl> + @ \" C : \\ Program Files \\ Araxis \\ Araxis Merge \\ \" , <nl> + @ \" C : \\ Program Files \\ Araxis 6 . 5 \\ Araxis Merge \\ \" ) ; <nl> + <nl> + if ( ! File . Exists ( MergetoolPath . Text ) ) <nl> + { <nl> + MergetoolPath . Text = \" \" ; <nl> + MessageBox . Show ( \" Please enter the path to Compare . exe and press suggest . \" , \" Suggest mergetool cmd \" ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + MergeToolCmd . Text = \" \\ \" \" + MergetoolPath . Text + \" \\ \" - wait - merge - 3 - a1 \\ \" $ BASE \\ \" \\ \" $ LOCAL \\ \" \\ \" $ REMOTE \\ \" \\ \" $ MERGED \\ \" \" ; <nl> + return ; <nl> + } <nl> + <nl> + if ( GlobalMergeTool . Text . Equals ( \" TortoiseMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + if ( MergetoolPath . Text . ToLower ( ) . Contains ( \" kdiff3 \" ) | | MergetoolPath . Text . ToLower ( ) . Contains ( \" p4merge \" ) ) <nl> + MergetoolPath . Text = \" \" ; <nl> + if ( string . IsNullOrEmpty ( MergetoolPath . Text ) | | ! File . Exists ( MergetoolPath . Text ) ) <nl> + { <nl> + MergetoolPath . Text = FindFileInFolders ( \" TortoiseMerge . exe \" , <nl> + @ \" c : \\ Program Files ( x86 ) \\ TortoiseSVN \\ bin \\ \" , <nl> + @ \" c : \\ Program Files \\ TortoiseSVN \\ bin \\ \" , <nl> + @ \" c : \\ Program Files ( x86 ) \\ TortoiseGit \\ bin \\ \" , <nl> + @ \" c : \\ Program Files \\ TortoiseGit \\ bin \\ \" ) ; <nl> + <nl> + if ( ! File . Exists ( MergetoolPath . Text ) ) <nl> + { <nl> + MergetoolPath . Text = \" \" ; <nl> + MessageBox . Show ( \" Please enter the path to TortoiseMerge . exe and press suggest . \" , \" Suggest mergetool cmd \" ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + MergeToolCmd . Text = \" \\ \" TortoiseMerge . exe \\ \" / base : \\ \" $ BASE \\ \" / mine : \\ \" $ LOCAL \\ \" / theirs : \\ \" $ REMOTE \\ \" / merged : \\ \" $ MERGED \\ \" \" ; <nl> + return ; <nl> + } <nl> + <nl> + if ( GlobalMergeTool . Text . Equals ( \" DiffMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + if ( MergetoolPath . Text . ToLower ( ) . Contains ( \" kdiff3 \" ) | | MergetoolPath . Text . ToLower ( ) . Contains ( \" p4merge \" ) ) <nl> + MergetoolPath . Text = \" \" ; <nl> + if ( string . IsNullOrEmpty ( MergetoolPath . Text ) | | ! File . Exists ( MergetoolPath . Text ) ) <nl> + { <nl> + MergetoolPath . Text = FindFileInFolders ( \" DiffMerge . exe \" , <nl> + @ \" C : \\ Program Files ( x86 ) \\ SourceGear \\ DiffMerge \\ \" , <nl> + @ \" C : \\ Program Files \\ SourceGear \\ DiffMerge \\ \" ) ; <nl> + <nl> + if ( ! File . Exists ( MergetoolPath . Text ) ) <nl> + { <nl> + MergetoolPath . Text = \" \" ; <nl> + MessageBox . Show ( \" Please enter the path to DiffMerge . exe and press suggest . \" , \" Suggest mergetool cmd \" ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + / / / m / r = % merged / t1 = % yname / t2 = % bname / t3 = % tname / c = % mname % mine % base % theirs <nl> + MergeToolCmd . Text = \" \\ \" \" + MergetoolPath . Text + \" \\ \" / m / r = \\ \" $ MERGED \\ \" \\ \" $ LOCAL \\ \" \\ \" $ BASE \\ \" \\ \" $ REMOTE \\ \" \" ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + private void GlobalMergeTool_SelectedIndexChanged ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + } <nl> + <nl> + private void ShowRevisionGraph_CheckedChanged ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + } <nl> + <nl> + private void FormSettigns_Shown ( object sender , EventArgs e ) <nl> + { <nl> + Cursor . Current = Cursors . WaitCursor ; <nl> + this . WindowState = FormWindowState . Normal ; <nl> + LoadSettings ( ) ; <nl> + CheckSettings ( ) ; <nl> + this . WindowState = FormWindowState . Normal ; <nl> + } <nl> + <nl> + private void FormSettigns_FormClosing ( object sender , FormClosingEventArgs e ) <nl> + { <nl> + Cursor . Current = Cursors . WaitCursor ; <nl> + if ( DialogResult ! = DialogResult . Abort & & ! Save ( ) ) <nl> + e . Cancel = true ; <nl> + } <nl> + <nl> + private void Dictionary_DropDown ( object sender , EventArgs e ) <nl> + { <nl> + try <nl> + { <nl> + Dictionary . Items . Clear ( ) ; <nl> + Dictionary . Items . Add ( \" None \" ) ; <nl> + foreach ( string fileName in Directory . GetFiles ( GitCommands . Settings . GetDictionaryDir ( ) , \" * . dic \" , SearchOption . TopDirectoryOnly ) ) <nl> + { <nl> + FileInfo file = new FileInfo ( fileName ) ; <nl> + Dictionary . Items . Add ( file . Name . Replace ( \" . dic \" , \" \" ) ) ; <nl> + } <nl> + } <nl> + catch <nl> + { <nl> + MessageBox . Show ( \" No dictionary files found in : \" + GitCommands . Settings . GetDictionaryDir ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void Dictionary_SelectedIndexChanged ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + } <nl> + <nl> + private void ExternalDiffTool_TextChanged ( object sender , EventArgs e ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + DifftoolPath . Text = gitCommands . GetGlobalSetting ( \" difftool . \" + GlobalDiffTool . Text . Trim ( ) + \" . path \" ) ; <nl> + DifftoolCmd . Text = gitCommands . GetGlobalSetting ( \" difftool . \" + GlobalDiffTool . Text . Trim ( ) + \" . cmd \" ) ; <nl> + <nl> + if ( GlobalDiffTool . Text . Trim ( ) . Equals ( \" winmerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + DiffToolCmdSuggest_Click ( null , null ) ; <nl> + <nl> + ResolveDiffToolPath ( ) ; <nl> + } <nl> + <nl> + private void ResolveDiffToolPath ( ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + <nl> + if ( GlobalDiffTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + string kdiff3path = gitCommands . GetGlobalSetting ( \" difftool . kdiff3 . path \" ) ; <nl> + if ( ! kdiff3path . ToLower ( ) . Contains ( \" kdiff3 . exe \" ) ) <nl> + kdiff3path = \" \" ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = @ \" c : \\ Program Files \\ KDiff3 \\ kdiff3 . exe \" ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = @ \" c : \\ Program Files ( x86 ) \\ KDiff3 \\ kdiff3 . exe \" ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ KDiff3 \" , \" \" ) + \" \\ \\ kdiff3 . exe \" ; <nl> + if ( string . IsNullOrEmpty ( kdiff3path ) | | ! File . Exists ( kdiff3path ) ) <nl> + { <nl> + kdiff3path = MergetoolPath . Text ; <nl> + if ( ! kdiff3path . ToLower ( ) . Contains ( \" kdiff3 . exe \" ) ) <nl> + kdiff3path = \" \" ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + } <nl> + DifftoolPath . Text = kdiff3path ; <nl> + } <nl> + } <nl> + <nl> + private void BrowseDiffTool_Click ( object sender , EventArgs e ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + <nl> + if ( GlobalDiffTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + DifftoolPath . Text = SelectFile ( \" . \" , \" kdiff3 . exe ( kdiff3 . exe ) | kdiff3 . exe \" , DifftoolPath . Text ) ; <nl> + } <nl> + else <nl> + if ( GlobalDiffTool . Text . Equals ( \" p4merge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + DifftoolPath . Text = SelectFile ( \" . \" , \" p4merge . exe ( p4merge . exe ) | p4merge . exe \" , DifftoolPath . Text ) ; <nl> + else <nl> + if ( GlobalDiffTool . Text . Equals ( \" TortoiseMerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + DifftoolPath . Text = SelectFile ( \" . \" , \" TortoiseMerge . exe ( TortoiseMerge . exe ) | TortoiseMerge . exe \" , DifftoolPath . Text ) ; <nl> + else <nl> + DifftoolPath . Text = SelectFile ( \" . \" , \" * . exe ( * . exe ) | * . exe \" , DifftoolPath . Text ) ; <nl> + } <nl> + <nl> + private void GlobalMergeTool_TextChanged ( object sender , EventArgs e ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + MergetoolPath . Text = gitCommands . GetGlobalSetting ( \" mergetool . \" + GlobalMergeTool . Text . Trim ( ) + \" . path \" ) ; <nl> + MergeToolCmd . Text = gitCommands . GetGlobalSetting ( \" mergetool . \" + GlobalMergeTool . Text . Trim ( ) + \" . cmd \" ) ; <nl> + <nl> + if ( GlobalMergeTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) & & string . IsNullOrEmpty ( MergeToolCmd . Text ) ) <nl> + MergeToolCmd . Enabled = false ; <nl> + else <nl> + MergeToolCmd . Enabled = true ; <nl> + <nl> + button1_Click_1 ( null , null ) ; <nl> + } <nl> + <nl> + private void ColorAddedLineDiffLabel_Click ( object sender , EventArgs e ) <nl> + { <nl> + ColorDialog colorDialog = new ColorDialog ( ) ; <nl> + colorDialog . Color = _ColorAddedLineDiffLabel . BackColor ; <nl> + colorDialog . ShowDialog ( ) ; <nl> + _ColorAddedLineDiffLabel . BackColor = colorDialog . Color ; <nl> + _ColorAddedLineDiffLabel . Text = colorDialog . Color . Name ; <nl> + _ColorAddedLineDiffLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorAddedLineDiffLabel . BackColor ) ; <nl> + } <nl> + <nl> + private void _ColorGraphLabel_Click ( object sender , EventArgs e ) <nl> + { <nl> + ColorDialog colorDialog = new ColorDialog ( ) ; <nl> + colorDialog . Color = _ColorGraphLabel . BackColor ; <nl> + colorDialog . ShowDialog ( ) ; <nl> + _ColorGraphLabel . BackColor = colorDialog . Color ; <nl> + _ColorGraphLabel . Text = colorDialog . Color . Name ; <nl> + _ColorGraphLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorAddedLineDiffLabel . BackColor ) ; <nl> + } <nl> + <nl> + private void label28_Click ( object sender , EventArgs e ) <nl> + { <nl> + ColorDialog colorDialog = new ColorDialog ( ) ; <nl> + colorDialog . Color = _ColorAddedLineLabel . BackColor ; <nl> + colorDialog . ShowDialog ( ) ; <nl> + _ColorAddedLineLabel . BackColor = colorDialog . Color ; <nl> + _ColorAddedLineLabel . Text = colorDialog . Color . Name ; <nl> + _ColorAddedLineLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorAddedLineLabel . BackColor ) ; <nl> + } <nl> + <nl> + private void ColorRemovedLineDiffLabel_Click ( object sender , EventArgs e ) <nl> + { <nl> + ColorDialog colorDialog = new ColorDialog ( ) ; <nl> + colorDialog . Color = _ColorRemovedLineDiffLabel . BackColor ; <nl> + colorDialog . ShowDialog ( ) ; <nl> + _ColorRemovedLineDiffLabel . BackColor = colorDialog . Color ; <nl> + _ColorRemovedLineDiffLabel . Text = colorDialog . Color . Name ; <nl> + _ColorRemovedLineDiffLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemovedLineDiffLabel . BackColor ) ; <nl> + <nl> + } <nl> + <nl> + private void ColorRemovedLine_Click ( object sender , EventArgs e ) <nl> + { <nl> + ColorDialog colorDialog = new ColorDialog ( ) ; <nl> + colorDialog . Color = _ColorRemovedLine . BackColor ; <nl> + colorDialog . ShowDialog ( ) ; <nl> + _ColorRemovedLine . BackColor = colorDialog . Color ; <nl> + _ColorRemovedLine . Text = colorDialog . Color . Name ; <nl> + _ColorRemovedLine . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemovedLine . BackColor ) ; <nl> + } <nl> + <nl> + private void ColorSectionLabel_Click ( object sender , EventArgs e ) <nl> + { <nl> + ColorDialog colorDialog = new ColorDialog ( ) ; <nl> + colorDialog . Color = _ColorSectionLabel . BackColor ; <nl> + colorDialog . ShowDialog ( ) ; <nl> + _ColorSectionLabel . BackColor = colorDialog . Color ; <nl> + _ColorSectionLabel . Text = colorDialog . Color . Name ; <nl> + _ColorSectionLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorSectionLabel . BackColor ) ; <nl> + } <nl> + <nl> + private void ColorTagLabel_Click ( object sender , EventArgs e ) <nl> + { <nl> + ColorDialog colorDialog = new ColorDialog ( ) ; <nl> + colorDialog . Color = _ColorTagLabel . BackColor ; <nl> + colorDialog . ShowDialog ( ) ; <nl> + _ColorTagLabel . BackColor = colorDialog . Color ; <nl> + _ColorTagLabel . Text = colorDialog . Color . Name ; <nl> + _ColorTagLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorTagLabel . BackColor ) ; <nl> + } <nl> + <nl> + private void ColorBranchLabel_Click ( object sender , EventArgs e ) <nl> + { <nl> + ColorDialog colorDialog = new ColorDialog ( ) ; <nl> + colorDialog . Color = _ColorBranchLabel . BackColor ; <nl> + colorDialog . ShowDialog ( ) ; <nl> + _ColorBranchLabel . BackColor = colorDialog . Color ; <nl> + _ColorBranchLabel . Text = colorDialog . Color . Name ; <nl> + _ColorBranchLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorBranchLabel . BackColor ) ; <nl> + } <nl> + <nl> + private void ColorRemoteBranchLabel_Click ( object sender , EventArgs e ) <nl> + { <nl> + ColorDialog colorDialog = new ColorDialog ( ) ; <nl> + colorDialog . Color = _ColorRemoteBranchLabel . BackColor ; <nl> + colorDialog . ShowDialog ( ) ; <nl> + _ColorRemoteBranchLabel . BackColor = colorDialog . Color ; <nl> + _ColorRemoteBranchLabel . Text = colorDialog . Color . Name ; <nl> + _ColorRemoteBranchLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorRemoteBranchLabel . BackColor ) ; <nl> + } <nl> + <nl> + private void ColorOtherLabel_Click ( object sender , EventArgs e ) <nl> + { <nl> + ColorDialog colorDialog = new ColorDialog ( ) ; <nl> + colorDialog . Color = _ColorOtherLabel . BackColor ; <nl> + colorDialog . ShowDialog ( ) ; <nl> + _ColorOtherLabel . BackColor = colorDialog . Color ; <nl> + _ColorOtherLabel . Text = colorDialog . Color . Name ; <nl> + _ColorOtherLabel . ForeColor = ColorHelper . GetForeColorForBackColor ( _ColorOtherLabel . BackColor ) ; <nl> + } <nl> + <nl> + private void tabControl1_SelectedIndexChanged ( object sender , EventArgs e ) <nl> + { <nl> + if ( GlobalMergeTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) & & string . IsNullOrEmpty ( MergeToolCmd . Text ) ) <nl> + MergeToolCmd . Enabled = false ; <nl> + else <nl> + MergeToolCmd . Enabled = true ; <nl> + } <nl> + <nl> + private void radioButton1_CheckedChanged ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + } <nl> + <nl> + private void groupBox5_Enter ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + } <nl> + <nl> + private void ClearImageCache_Click ( object sender , EventArgs e ) <nl> + { <nl> + GravatarService . ClearImageCache ( ) ; <nl> + } <nl> + <nl> + private void DiffToolCmdSuggest_Click ( object sender , EventArgs e ) <nl> + { <nl> + GitCommands . GitCommands gitCommands = new GitCommands . GitCommands ( ) ; <nl> + <nl> + if ( GlobalDiffTool . Text . Equals ( \" kdiff3 \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + string kdiff3path = gitCommands . GetGlobalSetting ( \" difftool . kdiff3 . path \" ) ; <nl> + string regkdiff3path = GetRegistryValue ( Registry . LocalMachine , \" SOFTWARE \\ \\ KDiff3 \" , \" \" ) + \" \\ \\ kdiff3 . exe \" ; <nl> + <nl> + DifftoolPath . Text = FindFileInFolders ( \" kdiff3 . exe \" , kdiff3path , <nl> + @ \" c : \\ Program Files \\ KDiff3 \\ \" , <nl> + @ \" c : \\ Program Files ( x86 ) \\ KDiff3 \\ \" , <nl> + regkdiff3path ) ; <nl> + } <nl> + if ( GlobalDiffTool . Text . Equals ( \" winmerge \" , StringComparison . CurrentCultureIgnoreCase ) ) <nl> + { <nl> + string winmergepath = gitCommands . GetGlobalSetting ( \" difftool . winmerge . path \" ) ; <nl> + <nl> + DifftoolPath . Text = FindFileInFolders ( \" winmergeu . exe \" , winmergepath , <nl> + @ \" c : \\ Program Files \\ winmerge \\ \" , <nl> + @ \" c : \\ Program Files ( x86 ) \\ winmerge \\ \" ) ; <nl> + } <nl> + if ( File . Exists ( DifftoolPath . Text ) ) <nl> + DifftoolCmd . Text = \" \\ \" \" + DifftoolPath . Text + \" \\ \" \\ \" $ LOCAL \\ \" \\ \" $ REMOTE \\ \" \" ; <nl> + } <nl> + <nl> + private void GlobalDiffTool_SelectedIndexChanged ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + } <nl> + <nl> + private void helpTranslate_LinkClicked ( object sender , LinkLabelLinkClickedEventArgs e ) <nl> + { <nl> + new FormTranslate ( ) . ShowDialog ( ) ; <nl> + } <nl> + <nl> + private void TabPageGit_Click ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + } <nl> + <nl> + private void groupBox7_Enter ( object sender , EventArgs e ) <nl> + { <nl> + <nl> + } <nl> + <nl> + private void otherHomeBrowse_Click ( object sender , EventArgs e ) <nl> + { <nl> + FolderBrowserDialog browseDialog = new FolderBrowserDialog ( ) ; <nl> + browseDialog . SelectedPath = Environment . GetEnvironmentVariable ( \" USERPROFILE \" ) ; <nl> + <nl> + if ( browseDialog . ShowDialog ( ) = = DialogResult . OK ) <nl> + { <nl> + otherHomeDir . Text = browseDialog . SelectedPath ; <nl> + } <nl> + <nl> + } <nl> + <nl> + private void otherHome_CheckedChanged ( object sender , EventArgs e ) <nl> + { <nl> + otherHomeDir . ReadOnly = ! otherHome . Checked ; <nl> + } <nl> + <nl> + private void MulticolorBranches_CheckedChanged ( object sender , EventArgs e ) <nl> + { <nl> + if ( MulticolorBranches . Checked ) <nl> + { <nl> + _ColorGraphLabel . Visible = false ; <nl> + StripedBanchChange . Enabled = true ; <nl> + } <nl> + else <nl> + { <nl> + _ColorGraphLabel . Visible = true ; <nl> + StripedBanchChange . Enabled = false ; <nl> + } <nl> + } <nl> + } <nl> } <nl>\n", "msg": "more simple refactorings and reformatting in FormSettings\n", "score": 1}
{"diff_id": 14121, "repo": "ppy/osu\n", "sha": "e14ad31a071cacfc10f4ab8668f3d00634776c68\n", "time": "2017-12-26T06:32:53Z\n", "diff": "mmm a / osu . Game . Tests / Visual / TestCasePlaySongSelect . cs <nl> ppp b / osu . Game . Tests / Visual / TestCasePlaySongSelect . cs <nl> private void load ( BeatmapManager baseManager ) <nl> <nl> loadNewSongSelect ( true ) ; <nl> <nl> - AddWaitStep ( 1 ) ; <nl> + AddWaitStep ( 3 ) ; <nl> <nl> AddAssert ( \" dummy selected \" , ( ) = > songSelect . CurrentBeatmap = = defaultBeatmap ) ; <nl> <nl> private void load ( BeatmapManager baseManager ) <nl> manager . Import ( createTestBeatmapSet ( i ) ) ; <nl> } ) ; <nl> <nl> - AddWaitStep ( 1 ) ; <nl> + AddWaitStep ( 3 ) ; <nl> AddAssert ( \" random map selected \" , ( ) = > songSelect . CurrentBeatmap ! = defaultBeatmap ) ; <nl> <nl> loadNewSongSelect ( ) ; <nl> - AddWaitStep ( 1 ) ; <nl> + AddWaitStep ( 3 ) ; <nl> AddAssert ( \" random map selected \" , ( ) = > songSelect . CurrentBeatmap ! = defaultBeatmap ) ; <nl> <nl> AddStep ( @ \" Sort by Artist \" , delegate { songSelect . FilterControl . Sort = SortMode . Artist ; } ) ; <nl>\n", "msg": "Increase wait durations for test stability\n", "score": 1}
{"diff_id": 14324, "repo": "dotnet/roslyn\n", "sha": "8af89252048137a8b6b16d7947a44144d9ba162a\n", "time": "2017-02-01T05:33:25Z\n", "diff": "mmm a / src / Workspaces / Core / Portable / Differencing / LongestCommonSubsequence . cs <nl> ppp b / src / Workspaces / Core / Portable / Differencing / LongestCommonSubsequence . cs <nl> namespace Microsoft . CodeAnalysis . Differencing <nl> / / / < / summary > <nl> internal abstract class LongestCommonSubsequence < TSequence > <nl> { <nl> - / / VArray class enables array indexing in range [ - d . . . d ] . <nl> - private class VArray <nl> + / / VArray struct enables array indexing in range [ - d . . . d ] . <nl> + private struct VArray <nl> { <nl> - private int [ ] array ; <nl> - private int offset ; <nl> + private readonly int [ ] _array ; <nl> <nl> - public VArray ( int d , VArray previousVArray ) : this ( d ) <nl> + public VArray ( int d ) <nl> { <nl> - if ( previousVArray ! = null ) <nl> - { <nl> - int copyDelta = offset - previousVArray . offset ; <nl> - if ( copyDelta > = 0 ) <nl> - { <nl> - Debug . Assert ( previousVArray . array . Length + 2 * copyDelta = = array . Length ) ; <nl> - Array . Copy ( previousVArray . array , 0 , array , copyDelta , previousVArray . array . Length ) ; <nl> - } <nl> - else <nl> - { <nl> - Debug . Assert ( previousVArray . array . Length + 2 * copyDelta = = array . Length ) ; <nl> - Array . Copy ( previousVArray . array , - copyDelta , array , 0 , array . Length ) ; <nl> - } <nl> - } <nl> + _array = new int [ 2 * d + 1 ] ; <nl> } <nl> <nl> - public VArray ( int d ) <nl> + public void CopyFrom ( VArray otherVArray ) <nl> { <nl> - offset = d ; <nl> - array = new int [ 2 * d + 1 ] ; <nl> + int copyDelta = Offset - otherVArray . Offset ; <nl> + if ( copyDelta > = 0 ) <nl> + { <nl> + Array . Copy ( otherVArray . _array , 0 , _array , copyDelta , otherVArray . _array . Length ) ; <nl> + } <nl> + else <nl> + { <nl> + Array . Copy ( otherVArray . _array , - copyDelta , _array , 0 , _array . Length ) ; <nl> + } <nl> } <nl> <nl> public int this [ int index ] <nl> { <nl> get <nl> { <nl> - return array [ index + offset ] ; <nl> + return _array [ index + Offset ] ; <nl> } <nl> set <nl> { <nl> - array [ index + offset ] = value ; <nl> + _array [ index + Offset ] = value ; <nl> + } <nl> + } <nl> + <nl> + private int Offset <nl> + { <nl> + get <nl> + { <nl> + return _array . Length / 2 ; <nl> } <nl> } <nl> } <nl> <nl> protected abstract bool ItemsEqual ( TSequence oldSequence , int oldIndex , TSequence newSequence , int newIndex ) ; <nl> <nl> + / / TODO : Consolidate return types between GetMatchingPairs and GetEdit to avoid duplicated code ( https : / / github . com / dotnet / roslyn / issues / 16864 ) <nl> protected IEnumerable < KeyValuePair < int , int > > GetMatchingPairs ( TSequence oldSequence , int oldLength , TSequence newSequence , int newLength ) <nl> { <nl> Stack < VArray > stackOfVs = ComputeEditPaths ( oldSequence , oldLength , newSequence , newLength ) ; <nl> public VArray ( int d ) <nl> int x = oldLength ; <nl> int y = newLength ; <nl> <nl> - for ( int d = stackOfVs . Count - 1 ; x > 0 | | y > 0 ; d - - ) <nl> + while ( x > 0 | | y > 0 ) <nl> { <nl> VArray currentV = stackOfVs . Pop ( ) ; <nl> + int d = stackOfVs . Count ; <nl> int k = x - y ; <nl> <nl> / / \" snake \" = = single delete or insert followed by 0 or more diagonals <nl> protected IEnumerable < SequenceEdit > GetEdits ( TSequence oldSequence , int oldLengt <nl> int x = oldLength ; <nl> int y = newLength ; <nl> <nl> - for ( int d = stackOfVs . Count - 1 ; x > 0 | | y > 0 ; d - - ) <nl> + while ( x > 0 | | y > 0 ) <nl> { <nl> VArray currentV = stackOfVs . Pop ( ) ; <nl> + int d = stackOfVs . Count ; <nl> int k = x - y ; <nl> <nl> / / \" snake \" = = single delete or insert followed by 0 or more diagonals <nl> protected double ComputeDistance ( TSequence oldSequence , int oldLength , TSequence <nl> / / / < / summary > <nl> / / / < remarks > <nl> / / / <nl> + / / / The algorithm was inspired by Myers ' Diff Algorithm described in an article by Nicolas Butler : <nl> + / / / https : / / www . codeproject . com / articles / 42279 / investigating - myers - diff - algorithm - part - of <nl> + / / / The author has approved the use of his code from the article under the Apache 2 . 0 license . <nl> + / / / <nl> / / / The algorithm works on an imaginary edit graph for A and B which has a vertex at each point in the grid ( i , j ) , i in [ 0 , lengthA ] and j in [ 0 , lengthB ] . <nl> / / / The vertices of the edit graph are connected by horizontal , vertical , and diagonal directed edges to form a directed acyclic graph . <nl> / / / Horizontal edges connect each vertex to its right neighbor . <nl> protected double ComputeDistance ( TSequence oldSequence , int oldLength , TSequence <nl> / / / A \" V array \" is a list of end points of so called \" snakes \" . <nl> / / / A \" snake \" is a path with a single horizontal ( delete ) or vertical ( insert ) move followed by 0 or more diagonals ( matching pairs ) . <nl> / / / <nl> - / / / See https : / / www . codeproject . com / articles / 42279 / investigating - myers - diff - algorithm - part - of . <nl> - / / / <nl> - / / / ( Unlike the algorithm in the article this implementation stores ' y ' indexed and prefers ' right ' moves instead of ' down ' moves in ambiguous situations <nl> - / / / to preserve the behavior of the original diff algorithm ( deletes first , inserts after ) ) . <nl> + / / / Unlike the algorithm in the article this implementation stores ' y ' indexes and prefers ' right ' moves instead of ' down ' moves in ambiguous situations <nl> + / / / to preserve the behavior of the original diff algorithm ( deletes first , inserts after ) . <nl> / / / <nl> / / / The number of items in the list is the length of the shortest edit script = the number of inserts / edits between the two sequences = D . <nl> / / / The list can be used to determine the matching pairs in the sequences ( GetMatchingPairs method ) or the full editing script ( GetEdits method ) . <nl> protected double ComputeDistance ( TSequence oldSequence , int oldLength , TSequence <nl> private Stack < VArray > ComputeEditPaths ( TSequence oldSequence , int oldLength , TSequence newSequence , int newLength ) <nl> { <nl> Stack < VArray > stackOfVs = new Stack < VArray > ( ) ; <nl> - VArray previousV = null ; <nl> - VArray currentV = null ; <nl> + <nl> + / / special - case : the first \" snake \" to start at ( - 1 , 0 ) <nl> + VArray previousV = new VArray ( 1 ) ; <nl> + VArray currentV ; <nl> + <nl> bool reachedEnd = false ; <nl> <nl> for ( int d = 0 ; d < = oldLength + newLength & & ! reachedEnd ; d + + ) <nl> { <nl> - previousV = currentV ; <nl> / / V is in range [ - d . . . d ] = > use d to offset the k - based array indices to non - negative values <nl> - currentV = new VArray ( d = = 0 ? 1 : d , previousV ) ; <nl> + if ( d = = 0 ) <nl> + { <nl> + currentV = previousV ; <nl> + } <nl> + else <nl> + { <nl> + currentV = new VArray ( d ) ; <nl> + currentV . CopyFrom ( previousV ) ; <nl> + } <nl> <nl> for ( int k = - d ; k < = d ; k + = 2 ) <nl> { <nl> private Stack < VArray > ComputeEditPaths ( TSequence oldSequence , int oldLength , TSe <nl> } <nl> } <nl> stackOfVs . Push ( currentV ) ; <nl> + previousV = currentV ; <nl> } <nl> return stackOfVs ; <nl> } <nl>\n", "msg": "Changed VArray to struct and other code review feedback changes\n", "score": 1}
{"diff_id": 15030, "repo": "ppy/osu\n", "sha": "08b9cf75e964fd3665d3aa67ccb8e4ceff5b7e6b\n", "time": "2018-06-14T08:10:08Z\n", "diff": "mmm a / osu . Game . Rulesets . Mania / Difficulty / ManiaDifficultyCalculator . cs <nl> ppp b / osu . Game . Rulesets . Mania / Difficulty / ManiaDifficultyCalculator . cs <nl> internal class ManiaDifficultyCalculator : DifficultyCalculator <nl> / / / < / summary > <nl> private const double decay_weight = 0 . 9 ; <nl> <nl> + private readonly bool isForCurrentRuleset ; <nl> + <nl> public ManiaDifficultyCalculator ( Ruleset ruleset , WorkingBeatmap beatmap ) <nl> : base ( ruleset , beatmap ) <nl> { <nl> + isForCurrentRuleset = beatmap . BeatmapInfo . Ruleset . Equals ( new ManiaRuleset ( ) . RulesetInfo ) ; <nl> } <nl> <nl> protected override DifficultyAttributes Calculate ( IBeatmap beatmap , Mod [ ] mods , double timeRate ) <nl> private double calculateDifficulty ( List < ManiaHitObjectDifficulty > objects , doubl <nl> return difficulty ; <nl> } <nl> <nl> - protected override Mod [ ] DifficultyAdjustmentMods = > new Mod [ ] <nl> + protected override Mod [ ] DifficultyAdjustmentMods <nl> { <nl> - new ManiaModDoubleTime ( ) , <nl> - new ManiaModHalfTime ( ) , <nl> - new ManiaModEasy ( ) , <nl> - new ManiaModHardRock ( ) , <nl> - new ManiaModKey1 ( ) , <nl> - new ManiaModKey2 ( ) , <nl> - new ManiaModKey3 ( ) , <nl> - new ManiaModKey4 ( ) , <nl> - new ManiaModKey5 ( ) , <nl> - new ManiaModKey6 ( ) , <nl> - new ManiaModKey7 ( ) , <nl> - new ManiaModKey8 ( ) , <nl> - new ManiaModKey9 ( ) , <nl> - } ; <nl> + get <nl> + { <nl> + if ( isForCurrentRuleset ) <nl> + { <nl> + return new Mod [ ] <nl> + { <nl> + new ManiaModDoubleTime ( ) , <nl> + new ManiaModHalfTime ( ) , <nl> + new ManiaModEasy ( ) , <nl> + new ManiaModHardRock ( ) , <nl> + } ; <nl> + } <nl> <nl> + return new Mod [ ] <nl> + { <nl> + new ManiaModDoubleTime ( ) , <nl> + new ManiaModHalfTime ( ) , <nl> + new ManiaModEasy ( ) , <nl> + new ManiaModHardRock ( ) , <nl> + new ManiaModKey1 ( ) , <nl> + new ManiaModKey2 ( ) , <nl> + new ManiaModKey3 ( ) , <nl> + new ManiaModKey4 ( ) , <nl> + new ManiaModKey5 ( ) , <nl> + new ManiaModKey6 ( ) , <nl> + new ManiaModKey7 ( ) , <nl> + new ManiaModKey8 ( ) , <nl> + new ManiaModKey9 ( ) , <nl> + } ; <nl> + } <nl> + } <nl> } <nl> } <nl>\n", "msg": "Don ' t compute keymod difficulties for mania - specific beatmaps\n", "score": 1}
{"diff_id": 15072, "repo": "dotnet/roslyn\n", "sha": "9ddfbf051e648d5da7816ccfb3817266f6455e56\n", "time": "2018-11-01T20:43:18Z\n", "diff": "mmm a / src / VisualStudio / Core / Def / Experimentation / VisualStudioExperimentationService . cs <nl> ppp b / src / VisualStudio / Core / Def / Experimentation / VisualStudioExperimentationService . cs <nl> internal class VisualStudioExperimentationService : ForegroundThreadAffinitizedO <nl> [ ImportingConstructor ] <nl> [ Obsolete ( MefConstruction . ImportingConstructorMessage , error : true ) ] <nl> public VisualStudioExperimentationService ( IThreadingContext threadingContext , SVsServiceProvider serviceProvider ) <nl> - : base ( threadingContext , assertIsForeground : true ) <nl> + : base ( threadingContext ) <nl> { <nl> - try <nl> + object experimentationServiceOpt = null ; <nl> + MethodInfo isCachedFlightEnabledInfo = null ; <nl> + <nl> + threadingContext . JoinableTaskFactory . Run ( async ( ) = > <nl> { <nl> - _experimentationServiceOpt = serviceProvider . GetService ( typeof ( SVsExperimentationService ) ) ; <nl> - if ( _experimentationServiceOpt ! = null ) <nl> + await threadingContext . JoinableTaskFactory . SwitchToMainThreadAsync ( ) ; <nl> + <nl> + try <nl> { <nl> - _isCachedFlightEnabledInfo = _experimentationServiceOpt . GetType ( ) . GetMethod ( <nl> - \" IsCachedFlightEnabled \" , BindingFlags . Public | BindingFlags . Instance ) ; <nl> + experimentationServiceOpt = serviceProvider . GetService ( typeof ( SVsExperimentationService ) ) ; <nl> + if ( experimentationServiceOpt ! = null ) <nl> + { <nl> + isCachedFlightEnabledInfo = experimentationServiceOpt . GetType ( ) . GetMethod ( <nl> + \" IsCachedFlightEnabled \" , BindingFlags . Public | BindingFlags . Instance ) ; <nl> + } <nl> } <nl> - } <nl> - catch <nl> - { <nl> - } <nl> + catch <nl> + { <nl> + } <nl> + } ) ; <nl> + <nl> + _experimentationServiceOpt = experimentationServiceOpt ; <nl> + _isCachedFlightEnabledInfo = isCachedFlightEnabledInfo ; <nl> } <nl> <nl> public bool IsExperimentEnabled ( string experimentName ) <nl>\n", "msg": "Allow VisualStudioExperimentationService to initialize on a background thread\n", "score": 1}
{"diff_id": 15638, "repo": "dotnet/aspnetcore\n", "sha": "b9be30c6cdf055394eb5ca9cd95d02419fcdf4b4\n", "time": "2015-09-25T14:37:59Z\n", "diff": "mmm a / samples / IdentitySample . Mvc / Startup . cs <nl> ppp b / samples / IdentitySample . Mvc / Startup . cs <nl> <nl> using IdentitySample . Models ; <nl> using Microsoft . AspNet . Builder ; <nl> - using Microsoft . AspNet . Diagnostics ; <nl> - using Microsoft . AspNet . Identity ; <nl> using Microsoft . AspNet . Identity . EntityFramework ; <nl> using Microsoft . Data . Entity ; <nl> using Microsoft . Framework . Configuration ; <nl> public Startup ( IApplicationEnvironment env ) <nl> * Below code demonstrates usage of multiple configuration sources . For instance a setting say ' setting1 ' is found in both the registered sources , <nl> * then the later source will win . By this way a Local config can be overridden by a different setting while deployed remotely . <nl> * / <nl> - var builder = new ConfigurationBuilder ( env . ApplicationBasePath ) <nl> + var builder = new ConfigurationBuilder ( ) <nl> + . SetBasePath ( env . ApplicationBasePath ) <nl> . AddJsonFile ( \" LocalConfig . json \" ) <nl> . AddEnvironmentVariables ( ) ; / / All environment variables in the process ' s context flow in as configuration values . <nl> <nl>\n", "msg": "Reacting to configuration changes\n", "score": 1}
{"diff_id": 16068, "repo": "mRemoteNG/mRemoteNG\n", "sha": "976e02effb2847ced417e25ad5af4a1cd276991a\n", "time": "2016-07-26T18:19:54Z\n", "diff": "mmm a / mRemoteV1 / Config / Connections / XmlConnectionsLoader . cs <nl> ppp b / mRemoteV1 / Config / Connections / XmlConnectionsLoader . cs <nl> public void LoadFromXml ( bool import ) <nl> { <nl> try <nl> { <nl> - var connections = DecryptCompleteFile ( ) ; <nl> - <nl> if ( ! import ) <nl> Runtime . IsConnectionsFileLoaded = false ; <nl> - <nl> var cryptographyProvider = new LegacyRijndaelCryptographyProvider ( ) ; <nl> <nl> / / SECTION 1 . Create a DOM Document and load the XML data into it . <nl> - _xmlDocument = new XmlDocument ( ) ; <nl> - if ( connections ! = \" \" ) <nl> - _xmlDocument . LoadXml ( connections ) ; <nl> - else <nl> - _xmlDocument . Load ( ConnectionFileName ) ; <nl> - <nl> + LoadXmlConnectionData ( ) ; <nl> ValidateConnectionFileVersion ( ) ; <nl> <nl> / / SECTION 2 . Initialize the treeview control . <nl> public void LoadFromXml ( bool import ) <nl> } <nl> } <nl> <nl> + private void LoadXmlConnectionData ( ) <nl> + { <nl> + var connections = DecryptCompleteFile ( ) ; <nl> + _xmlDocument = new XmlDocument ( ) ; <nl> + if ( connections ! = \" \" ) <nl> + _xmlDocument . LoadXml ( connections ) ; <nl> + else <nl> + _xmlDocument . Load ( ConnectionFileName ) ; <nl> + } <nl> + <nl> private void ValidateConnectionFileVersion ( ) <nl> { <nl> if ( _xmlDocument . DocumentElement . HasAttribute ( \" ConfVersion \" ) ) <nl>\n", "msg": "Extracted method to load xml data\n", "score": 1}
{"diff_id": 16113, "repo": "PowerShell/PowerShell\n", "sha": "c76e1221c4516ea853d1e3f22117b12796b28eb8\n", "time": "2019-10-15T22:01:19Z\n", "diff": "mmm a / src / System . Management . Automation / singleshell / config / MshSnapinInfo . cs <nl> ppp b / src / System . Management . Automation / singleshell / config / MshSnapinInfo . cs <nl> internal static Version ReadVersionValue ( RegistryKey mshsnapinKey , string name , <nl> internal static void ReadRegistryInfo ( out Version assemblyVersion , out string publicKeyToken , out string culture , out string architecture , out string applicationBase , out Version psVersion ) <nl> { <nl> applicationBase = Utils . DefaultPowerShellAppBase ; <nl> - Dbg . Assert ( ! string . IsNullOrEmpty ( applicationBase ) , <nl> + Dbg . Assert ( <nl> + ! string . IsNullOrEmpty ( applicationBase ) , <nl> string . Format ( CultureInfo . CurrentCulture , \" { 0 } is empty or null \" , RegistryStrings . MonadEngine_ApplicationBase ) ) ; <nl> <nl> / / Get the PSVersion from Utils . . this is hardcoded <nl> psVersion = PSVersionInfo . PSVersion ; <nl> - Dbg . Assert ( psVersion ! = null , <nl> + Dbg . Assert ( <nl> + psVersion ! = null , <nl> string . Format ( CultureInfo . CurrentCulture , \" { 0 } is null \" , RegistryStrings . MonadEngine_MonadVersion ) ) ; <nl> <nl> / / Get version number in x . x . x . x format <nl> internal static void ReadRegistryInfo ( out Version assemblyVersion , out string pu <nl> / / culture , publickeytoken . . . This will break the scenarios where only one of <nl> / / the assemblies is patched . ie . , all monad assemblies should have the <nl> / / same version number . <nl> - <nl> Assembly currentAssembly = typeof ( PSSnapInReader ) . Assembly ; <nl> - assemblyVersion = currentAssembly . GetName ( ) . Version ; <nl> - byte [ ] publicTokens = currentAssembly . GetName ( ) . GetPublicKeyToken ( ) ; <nl> + AssemblyName assemblyName = currentAssembly . GetName ( ) ; <nl> + assemblyVersion = assemblyName . Version ; <nl> + byte [ ] publicTokens = assemblyName . GetPublicKeyToken ( ) ; <nl> if ( publicTokens . Length = = 0 ) <nl> { <nl> throw PSTraceSource . NewArgumentException ( \" PublicKeyToken \" , MshSnapinInfo . PublicKeyTokenAccessFailed ) ; <nl> } <nl> <nl> publicKeyToken = ConvertByteArrayToString ( publicTokens ) ; <nl> + <nl> / / save some cpu cycles by hardcoding the culture to neutral <nl> / / assembly should never be targeted to a particular culture <nl> culture = \" neutral \" ; <nl> + <nl> / / Hardcoding the architecture MSIL as PowerShell assemblies are architecture neutral , this should <nl> / / be changed if the assumption is broken . Preferred hardcoded string to using ( for perf reasons ) : <nl> / / string architecture = currentAssembly . GetName ( ) . ProcessorArchitecture . ToString ( ) <nl> internal static Collection < PSSnapInInfo > ReadEnginePSSnapIns ( ) <nl> <nl> / / create default mshsnapininfo objects . . <nl> Collection < PSSnapInInfo > engineMshSnapins = new Collection < PSSnapInInfo > ( ) ; <nl> + string assemblyVersionString = assemblyVersion . ToString ( ) ; <nl> <nl> for ( int item = 0 ; item < DefaultMshSnapins . Count ; item + + ) <nl> { <nl> DefaultPSSnapInInformation defaultMshSnapinInfo = DefaultMshSnapins [ item ] ; <nl> <nl> - string strongName = string . Format ( CultureInfo . InvariantCulture , \" { 0 } , Version = { 1 } , Culture = { 2 } , PublicKeyToken = { 3 } , ProcessorArchitecture = { 4 } \" , <nl> - defaultMshSnapinInfo . AssemblyName , assemblyVersion . ToString ( ) , culture , publicKeyToken , architecture ) ; <nl> + string strongName = string . Format ( <nl> + CultureInfo . InvariantCulture , <nl> + \" { 0 } , Version = { 1 } , Culture = { 2 } , PublicKeyToken = { 3 } , ProcessorArchitecture = { 4 } \" , <nl> + defaultMshSnapinInfo . AssemblyName , <nl> + assemblyVersionString , <nl> + culture , <nl> + publicKeyToken , <nl> + architecture ) ; <nl> <nl> Collection < string > formats = null ; <nl> Collection < string > types = null ; <nl> internal static Collection < PSSnapInInfo > ReadEnginePSSnapIns ( ) <nl> formats = smaFormats ; <nl> types = smaTypes ; <nl> } <nl> - else if ( defaultMshSnapinInfo . AssemblyName . Equals ( \" Microsoft . PowerShell . Commands . Diagnostics \" , <nl> - StringComparison . OrdinalIgnoreCase ) ) <nl> + else if ( defaultMshSnapinInfo . AssemblyName . Equals ( \" Microsoft . PowerShell . Commands . Diagnostics \" , StringComparison . OrdinalIgnoreCase ) ) <nl> { <nl> types = new Collection < string > ( new string [ ] { \" GetEvent . types . ps1xml \" } ) ; <nl> formats = new Collection < string > ( new string [ ] { \" Event . format . ps1xml \" , \" Diagnostics . format . ps1xml \" } ) ; <nl> internal static Collection < PSSnapInInfo > ReadEnginePSSnapIns ( ) <nl> <nl> string moduleName = Path . Combine ( applicationBase , defaultMshSnapinInfo . AssemblyName + \" . dll \" ) ; <nl> <nl> - if ( ! File . Exists ( moduleName ) ) <nl> - { <nl> - moduleName = defaultMshSnapinInfo . AssemblyName ; <nl> - } <nl> - <nl> PSSnapInInfo defaultMshSnapin = new PSSnapInInfo ( <nl> defaultMshSnapinInfo . PSSnapInName , <nl> isDefault : true , <nl>\n", "msg": "Minor performance improvements for Runspace initialization ( )\n", "score": 1}
{"diff_id": 16256, "repo": "nopSolutions/nopCommerce\n", "sha": "e3e091b1737029dc9bb0aed09281275ec5bcf5f8\n", "time": "2016-03-01T17:11:49Z\n", "diff": "mmm a / src / Presentation / Nop . Web / Extensions / ControllerExtensions . cs <nl> ppp b / src / Presentation / Nop . Web / Extensions / ControllerExtensions . cs <nl> public static class ControllerExtensions <nl> { <nl> # region Grouped product <nl> <nl> - var associatedProducts = productService . GetAssociatedProducts ( product . Id , storeContext . CurrentStore . Id ) ; <nl> - <nl> + var associatedProducts = productService . GetAssociatedProducts ( product . Id , storeContext . CurrentStore . Id ) ; <nl> + <nl> + / / add to cart button ( ignore \" DisableBuyButton \" property for grouped products ) <nl> + priceModel . DisableBuyButton = ! permissionService . Authorize ( StandardPermissionProvider . EnableShoppingCart ) | | <nl> + ! permissionService . Authorize ( StandardPermissionProvider . DisplayPrices ) ; <nl> + <nl> + / / add to wishlist button ( ignore \" DisableWishlistButton \" property for grouped products ) <nl> + priceModel . DisableWishlistButton = ! permissionService . Authorize ( StandardPermissionProvider . EnableWishlist ) | | <nl> + ! permissionService . Authorize ( StandardPermissionProvider . DisplayPrices ) ; <nl> + <nl> + / / compare products <nl> + priceModel . DisableAddToCompareListButton = ! catalogSettings . CompareProductsEnabled ; <nl> switch ( associatedProducts . Count ) <nl> { <nl> case 0 : <nl> { <nl> / / no associated products <nl> - / / priceModel . DisableBuyButton = true ; <nl> - / / priceModel . DisableWishlistButton = true ; <nl> - / / compare products <nl> - priceModel . DisableAddToCompareListButton = ! catalogSettings . CompareProductsEnabled ; <nl> - / / priceModel . AvailableForPreOrder = false ; <nl> } <nl> break ; <nl> default : <nl> { <nl> / / we have at least one associated product <nl> - / / priceModel . DisableBuyButton = true ; <nl> - / / priceModel . DisableWishlistButton = true ; <nl> / / compare products <nl> priceModel . DisableAddToCompareListButton = ! catalogSettings . CompareProductsEnabled ; <nl> / / priceModel . AvailableForPreOrder = false ; <nl>\n", "msg": "\" Enable shopping cart \" and \" Enable wishlist \" permissions were ignored for grouped products ( on catalog pages )\n", "score": 1}
{"diff_id": 16312, "repo": "dotnet/efcore\n", "sha": "41b04ff32289944b929ecaf7f14de9d2f9ecf696\n", "time": "2014-07-30T21:18:42Z\n", "diff": "mmm a / test / EntityFramework . Redis . FunctionalTests / RedisTestConfig . cs <nl> ppp b / test / EntityFramework . Redis . FunctionalTests / RedisTestConfig . cs <nl> public static string GetCIMachineServerPath ( ) <nl> return Path . Combine ( configFilePath , CIMachineRedisNugetPackageServerPath , RedisServerExeName ) ; <nl> } <nl> <nl> + public static string GetTMPPath ( ) <nl> + { <nl> + var tempPath = Environment . GetEnvironmentVariable ( \" TMP \" ) ; <nl> + if ( tempPath = = null ) <nl> + { <nl> + tempPath = Environment . GetEnvironmentVariable ( \" TEMP \" ) ; <nl> + if ( tempPath = = null ) <nl> + { <nl> + throw new Exception ( \" User does not have a TMP or TEMP environment variable defined . \" ) ; <nl> + } <nl> + } <nl> + <nl> + tempPath = Path . Combine ( tempPath , \" RedisFunctionalTestsServer \" ) ; <nl> + if ( ! Directory . Exists ( tempPath ) ) <nl> + { <nl> + Directory . CreateDirectory ( tempPath ) ; <nl> + } <nl> + <nl> + return tempPath ; <nl> + } <nl> + <nl> private static bool RunServer ( string serverExePath ) <nl> { <nl> if ( _redisServerProcess = = null ) <nl> private static bool RunServer ( string serverExePath ) <nl> / / copy the redis - server . exe to a directory under the user ' s TMP path . The server <nl> / / will be left running - so needs not to be under git ' s working directory as CI <nl> / / machines run cleanup on those paths before starting tests . <nl> - var tempPath = Path . Combine ( Path . GetTempPath ( ) , \" RedisFunctionalTestsServer \" ) ; <nl> - if ( ! Directory . Exists ( tempPath ) ) <nl> - { <nl> - Directory . CreateDirectory ( tempPath ) ; <nl> - } <nl> + var tempPath = GetTMPPath ( ) ; <nl> var tempRedisServerFullPath = Path . Combine ( tempPath , RedisServerExeName ) ; <nl> if ( ! File . Exists ( tempRedisServerFullPath ) ) <nl> { <nl> private static bool RunServer ( string serverExePath ) <nl> } <nl> else if ( ! CanConnectToExistingRedisServer ( 5 , 1000 ) ) <nl> { <nl> - / / wait for server to complete start - up <nl> throw new Exception ( \" Cannot connect to started Redis server process PID \" + _redisServerProcess . Id ) ; <nl> } <nl> } <nl>\n", "msg": "Updating to use TMP environment var instead of GetTempPath ( )\n", "score": 1}
{"diff_id": 16789, "repo": "ppy/osu\n", "sha": "ee5e70135f42df4bc31fa2747413886ee090a131\n", "time": "2020-11-15T14:09:02Z\n", "diff": "mmm a / osu . Game . Rulesets . Mania . Tests / ManiaLegacyModConversionTest . cs <nl> ppp b / osu . Game . Rulesets . Mania . Tests / ManiaLegacyModConversionTest . cs <nl> namespace osu . Game . Rulesets . Mania . Tests <nl> [ TestFixture ] <nl> public class ManiaLegacyModConversionTest : LegacyModConversionTest <nl> { <nl> - [ TestCase ( LegacyMods . Easy , new [ ] { typeof ( ManiaModEasy ) } ) ] <nl> - [ TestCase ( LegacyMods . HardRock | LegacyMods . DoubleTime , new [ ] { typeof ( ManiaModHardRock ) , typeof ( ManiaModDoubleTime ) } ) ] <nl> - [ TestCase ( LegacyMods . DoubleTime , new [ ] { typeof ( ManiaModDoubleTime ) } ) ] <nl> - [ TestCase ( LegacyMods . Nightcore , new [ ] { typeof ( ManiaModNightcore ) } ) ] <nl> + private static readonly object [ ] [ ] mania_mod_mapping = <nl> + { <nl> + new object [ ] { LegacyMods . NoFail , new [ ] { typeof ( ManiaModNoFail ) } } , <nl> + new object [ ] { LegacyMods . Easy , new [ ] { typeof ( ManiaModEasy ) } } , <nl> + new object [ ] { LegacyMods . Hidden , new [ ] { typeof ( ManiaModHidden ) } } , <nl> + new object [ ] { LegacyMods . HardRock , new [ ] { typeof ( ManiaModHardRock ) } } , <nl> + new object [ ] { LegacyMods . SuddenDeath , new [ ] { typeof ( ManiaModSuddenDeath ) } } , <nl> + new object [ ] { LegacyMods . DoubleTime , new [ ] { typeof ( ManiaModDoubleTime ) } } , <nl> + new object [ ] { LegacyMods . HalfTime , new [ ] { typeof ( ManiaModHalfTime ) } } , <nl> + new object [ ] { LegacyMods . Nightcore , new [ ] { typeof ( ManiaModNightcore ) } } , <nl> + new object [ ] { LegacyMods . Flashlight , new [ ] { typeof ( ManiaModFlashlight ) } } , <nl> + new object [ ] { LegacyMods . Autoplay , new [ ] { typeof ( ManiaModAutoplay ) } } , <nl> + new object [ ] { LegacyMods . Perfect , new [ ] { typeof ( ManiaModPerfect ) } } , <nl> + new object [ ] { LegacyMods . Key4 , new [ ] { typeof ( ManiaModKey4 ) } } , <nl> + new object [ ] { LegacyMods . Key5 , new [ ] { typeof ( ManiaModKey5 ) } } , <nl> + new object [ ] { LegacyMods . Key6 , new [ ] { typeof ( ManiaModKey6 ) } } , <nl> + new object [ ] { LegacyMods . Key7 , new [ ] { typeof ( ManiaModKey7 ) } } , <nl> + new object [ ] { LegacyMods . Key8 , new [ ] { typeof ( ManiaModKey8 ) } } , <nl> + new object [ ] { LegacyMods . FadeIn , new [ ] { typeof ( ManiaModFadeIn ) } } , <nl> + new object [ ] { LegacyMods . Random , new [ ] { typeof ( ManiaModRandom ) } } , <nl> + new object [ ] { LegacyMods . Cinema , new [ ] { typeof ( ManiaModCinema ) } } , <nl> + new object [ ] { LegacyMods . Key9 , new [ ] { typeof ( ManiaModKey9 ) } } , <nl> + new object [ ] { LegacyMods . KeyCoop , new [ ] { typeof ( ManiaModDualStages ) } } , <nl> + new object [ ] { LegacyMods . Key1 , new [ ] { typeof ( ManiaModKey1 ) } } , <nl> + new object [ ] { LegacyMods . Key3 , new [ ] { typeof ( ManiaModKey3 ) } } , <nl> + new object [ ] { LegacyMods . Key2 , new [ ] { typeof ( ManiaModKey2 ) } } , <nl> + new object [ ] { LegacyMods . Mirror , new [ ] { typeof ( ManiaModMirror ) } } , <nl> + new object [ ] { LegacyMods . HardRock | LegacyMods . DoubleTime , new [ ] { typeof ( ManiaModHardRock ) , typeof ( ManiaModDoubleTime ) } } <nl> + } ; <nl> + <nl> + [ TestCaseSource ( nameof ( mania_mod_mapping ) ) ] <nl> + [ TestCase ( LegacyMods . Cinema | LegacyMods . Autoplay , new [ ] { typeof ( ManiaModCinema ) } ) ] <nl> [ TestCase ( LegacyMods . Nightcore | LegacyMods . DoubleTime , new [ ] { typeof ( ManiaModNightcore ) } ) ] <nl> - [ TestCase ( LegacyMods . Flashlight | LegacyMods . Nightcore | LegacyMods . DoubleTime , new [ ] { typeof ( ManiaModFlashlight ) , typeof ( ManiaModNightcore ) } ) ] <nl> - [ TestCase ( LegacyMods . Perfect , new [ ] { typeof ( ManiaModPerfect ) } ) ] <nl> - [ TestCase ( LegacyMods . SuddenDeath , new [ ] { typeof ( ManiaModSuddenDeath ) } ) ] <nl> [ TestCase ( LegacyMods . Perfect | LegacyMods . SuddenDeath , new [ ] { typeof ( ManiaModPerfect ) } ) ] <nl> - [ TestCase ( LegacyMods . Perfect | LegacyMods . SuddenDeath | LegacyMods . DoubleTime , new [ ] { typeof ( ManiaModDoubleTime ) , typeof ( ManiaModPerfect ) } ) ] <nl> - [ TestCase ( LegacyMods . Random | LegacyMods . SuddenDeath , new [ ] { typeof ( ManiaModRandom ) , typeof ( ManiaModSuddenDeath ) } ) ] <nl> - [ TestCase ( LegacyMods . Flashlight | LegacyMods . Mirror , new [ ] { typeof ( ManiaModFlashlight ) , typeof ( ManiaModMirror ) } ) ] <nl> public new void TestFromLegacy ( LegacyMods legacyMods , Type [ ] expectedMods ) = > base . TestFromLegacy ( legacyMods , expectedMods ) ; <nl> <nl> + [ TestCaseSource ( nameof ( mania_mod_mapping ) ) ] <nl> + public new void TestToLegacy ( LegacyMods legacyMods , Type [ ] givenMods ) = > base . TestToLegacy ( legacyMods , givenMods ) ; <nl> + <nl> protected override Ruleset CreateRuleset ( ) = > new ManiaRuleset ( ) ; <nl> } <nl> } <nl>\n", "msg": "Cover mapping fully for mania mods\n", "score": 1}
{"diff_id": 16794, "repo": "sschmid/Entitas-CSharp\n", "sha": "17647caf7711f2eed5aef188bf31667205469b76\n", "time": "2016-07-01T13:55:55Z\n", "diff": "mmm a / Entitas . Unity / Assets / Entitas / Unity / VisualDebugging / DebugSystems / Editor / DebugSystemsInspector . cs <nl> ppp b / Entitas . Unity / Assets / Entitas / Unity / VisualDebugging / DebugSystems / Editor / DebugSystemsInspector . cs <nl> enum SortMethod { <nl> drawSystemList ( systems ) ; <nl> <nl> EditorUtility . SetDirty ( target ) ; <nl> - Repaint ( ) ; <nl> } <nl> <nl> static void drawSystemsOverview ( DebugSystems systems ) { <nl>\n", "msg": "Less editor repaints for DebugSystemsInspector to improve performance\n", "score": 1}
{"diff_id": 16830, "repo": "ppy/osu\n", "sha": "484268f1f206c670c05d1598c99115a6d4d1b5f4\n", "time": "2019-01-23T11:30:32Z\n", "diff": "mmm a / osu . Game / Scoring / Legacy / LegacyScoreParser . cs <nl> ppp b / osu . Game / Scoring / Legacy / LegacyScoreParser . cs <nl> public Score Parse ( Stream stream ) <nl> } <nl> } <nl> <nl> - calculateAccuracy ( score . ScoreInfo ) ; <nl> + CalculateAccuracy ( score . ScoreInfo ) ; <nl> <nl> return score ; <nl> } <nl> <nl> - private void calculateAccuracy ( ScoreInfo score ) <nl> + protected void CalculateAccuracy ( ScoreInfo score ) <nl> { <nl> int countMiss = score . Statistics [ HitResult . Miss ] ; <nl> int count50 = score . Statistics [ HitResult . Meh ] ; <nl>\n", "msg": "Expose CalculateAccuracy for performance tools\n", "score": 1}
{"diff_id": 17366, "repo": "microsoft/VFSForGit\n", "sha": "61168392aa713f46b536e72965cdd633a50e6dbd\n", "time": "2019-01-30T23:22:28Z\n", "diff": "mmm a / GVFS / GVFS . Common / ProductUpgrader . cs <nl> ppp b / GVFS / GVFS . Common / ProductUpgrader . cs <nl> public abstract class ProductUpgrader : IDisposable <nl> this . noVerify = noVerify ; <nl> this . tracer = tracer ; <nl> this . fileSystem = fileSystem ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / For mocking purposes only <nl> + / / / < / summary > <nl> + protected ProductUpgrader ( ) <nl> + { <nl> } <nl> <nl> public static bool TryCreateUpgrader ( <nl>\n", "msg": "ProductUpgrader : add empty constructor for mocking\n", "score": 1}
{"diff_id": 17771, "repo": "OpenRA/OpenRA\n", "sha": "6bca332959900788aafaeafb4eea5d0532ad95bb\n", "time": "2009-11-19T05:33:41Z\n", "diff": "mmm a / OpenRa . Game / Chrome . cs <nl> ppp b / OpenRa . Game / Chrome . cs <nl> void DrawBuildPalette ( string queueName ) <nl> <nl> var currentItem = Game . LocalPlayer . Producing ( queueName ) ; <nl> <nl> + var overlayBits = new List < Pair < Sprite , float2 > > ( ) ; <nl> + <nl> foreach ( var item in allItems ) <nl> { <nl> var rect = new Rectangle ( Game . viewport . Width - ( 3 - x ) * 64 , 40 + 48 * y , 64 , 48 ) ; <nl> buildPaletteRenderer . DrawSprite ( sprites [ item ] , Game . viewport . Location + new float2 ( rect . Location ) , 0 ) ; <nl> <nl> if ( ! buildableItems . Contains ( item ) | | ( currentItem ! = null & & currentItem . Item ! = item ) ) <nl> - buildPaletteRenderer . DrawSprite ( cantBuild . Image , Game . viewport . Location + new float2 ( rect . Location ) , 0 ) ; <nl> + overlayBits . Add ( Pair . New ( cantBuild . Image , Game . viewport . Location + new float2 ( rect . Location ) ) ) ; <nl> <nl> if ( currentItem ! = null & & currentItem . Item = = item ) <nl> { <nl> void DrawBuildPalette ( string queueName ) <nl> if ( currentItem . Done ) <nl> { <nl> ready . Play ( \" ready \" ) ; <nl> - buildPaletteRenderer . DrawSprite ( ready . Image , Game . viewport . Location <nl> + overlayBits . Add ( Pair . New ( ready . Image , Game . viewport . Location <nl> + new float2 ( rect . Location ) <nl> - + new float2 ( ( 64 - ready . Image . size . X ) / 2 , 2 ) , 0 ) ; <nl> + + new float2 ( ( 64 - ready . Image . size . X ) / 2 , 2 ) ) ) ; <nl> } <nl> else if ( currentItem . Paused ) <nl> { <nl> ready . Play ( \" hold \" ) ; <nl> - buildPaletteRenderer . DrawSprite ( ready . Image , Game . viewport . Location <nl> + overlayBits . Add ( Pair . New ( ready . Image , Game . viewport . Location <nl> + new float2 ( rect . Location ) <nl> - + new float2 ( ( 64 - ready . Image . size . X ) / 2 , 2 ) , 0 ) ; <nl> + + new float2 ( ( 64 - ready . Image . size . X ) / 2 , 2 ) ) ) ; <nl> } <nl> } <nl> <nl> void DrawBuildPalette ( string queueName ) <nl> if ( + + x = = 3 ) { x = 0 ; y + + ; } <nl> } <nl> <nl> + foreach ( var ob in overlayBits ) <nl> + buildPaletteRenderer . DrawSprite ( ob . First , ob . Second , 0 ) ; <nl> + <nl> buildPaletteRenderer . Flush ( ) ; <nl> <nl> for ( var j = 0 ; j < y ; j + + ) <nl>\n", "msg": "delayed render of dimming , etc for batch count win\n", "score": 1}
{"diff_id": 18153, "repo": "bitwarden/server\n", "sha": "cc2cef5b2705c08d0fb49bd7d3751add6aacffc9\n", "time": "2019-02-12T16:49:35Z\n", "diff": "mmm a / src / Api / Controllers / CiphersController . cs <nl> ppp b / src / Api / Controllers / CiphersController . cs <nl> public async Task < CipherResponseModel > PostAttachmentAdmin ( string id ) <nl> await Request . GetFileAsync ( async ( stream , fileName , key ) = > <nl> { <nl> await _cipherService . CreateAttachmentAsync ( cipher , stream , fileName , key , <nl> - Request . ContentLength . GetValueOrDefault ( 0 ) , userId ) ; <nl> + Request . ContentLength . GetValueOrDefault ( 0 ) , userId , true ) ; <nl> } ) ; <nl> <nl> return new CipherResponseModel ( cipher , _globalSettings ) ; <nl> public async Task DeleteAttachmentAdmin ( string id , string attachmentId ) <nl> throw new NotFoundException ( ) ; <nl> } <nl> <nl> - await _cipherService . DeleteAttachmentAsync ( cipher , attachmentId , userId , false ) ; <nl> + await _cipherService . DeleteAttachmentAsync ( cipher , attachmentId , userId , true ) ; <nl> } <nl> <nl> private void ValidateAttachment ( ) <nl>\n", "msg": "pass org admin flag for attachment actions\n", "score": 1}
{"diff_id": 18271, "repo": "bitwarden/server\n", "sha": "8a34692e7c4f7ec00cefd3bb79873cb194bae71a\n", "time": "2016-06-18T20:09:28Z\n", "diff": "mmm a / src / Core / Enums / DeviceType . cs <nl> ppp b / src / Core / Enums / DeviceType . cs <nl> <nl> { <nl> public enum DeviceType : short <nl> { <nl> - iOS = 0 , <nl> - Android = 1 <nl> + Android = 0 , <nl> + iOS = 1 <nl> } <nl> } <nl>\n", "msg": "switch device type around to match mobile enums\n", "score": 1}
{"diff_id": 18507, "repo": "unoplatform/uno\n", "sha": "45d30136215d123f8a91717dde3758987b28cd50\n", "time": "2019-07-19T18:32:12Z\n", "diff": "mmm a / src / Uno . UI / UI / Xaml / UnsetValue . cs <nl> ppp b / src / Uno . UI / UI / Xaml / UnsetValue . cs <nl> private UnsetValue ( ) <nl> <nl> public override bool Equals ( object obj ) <nl> { <nl> - return obj is UnsetValue ; <nl> + return ReferenceEquals ( obj , this ) | | obj is UnsetValue ; <nl> } <nl> <nl> public override int GetHashCode ( ) = > 0 ; <nl>\n", "msg": "Added a ` ReferenceEquals ` for UnsetValue comparison\n", "score": 1}
{"diff_id": 18747, "repo": "NancyFx/Nancy\n", "sha": "9702a6f82c1c597f2315a4fffe7c3569d01714e8\n", "time": "2014-02-03T15:10:10Z\n", "diff": "mmm a / src / Nancy / Responses / GenericFileResponse . cs <nl> ppp b / src / Nancy / Responses / GenericFileResponse . cs <nl> private void SetResponseValues ( string contentType , string fullPath , NancyContext <nl> <nl> this . Headers [ \" ETag \" ] = etag ; <nl> this . Headers [ \" Last - Modified \" ] = lastModified ; <nl> - this . Contents = GetFileContent ( fullPath , fi . Length ) ; <nl> + <nl> + if ( fi . Length > 0 ) <nl> + { <nl> + this . Contents = GetFileContent ( fullPath , fi . Length ) ; <nl> + } <nl> + <nl> this . ContentType = contentType ; <nl> this . StatusCode = HttpStatusCode . OK ; <nl> } <nl>\n", "msg": "Prevent ArgumentOutOfRangeException for emtpy files\n", "score": 1}
{"diff_id": 18952, "repo": "nopSolutions/nopCommerce\n", "sha": "1aa3e0040e865d93f30e396d12bb05b601ee7662\n", "time": "2020-06-25T17:31:11Z\n", "diff": "mmm a / src / Libraries / Nop . Data / Migrations / MigrationManager . cs <nl> ppp b / src / Libraries / Nop . Data / Migrations / MigrationManager . cs <nl> public partial class MigrationManager : IMigrationManager <nl> _typeMapping = new Dictionary < Type , Action < ICreateTableColumnAsTypeSyntax > > ( ) <nl> { <nl> [ typeof ( int ) ] = c = > c . AsInt32 ( ) , <nl> + [ typeof ( long ) ] = c = > c . AsInt64 ( ) , <nl> [ typeof ( string ) ] = c = > c . AsString ( int . MaxValue ) . Nullable ( ) , <nl> [ typeof ( bool ) ] = c = > c . AsBoolean ( ) , <nl> [ typeof ( decimal ) ] = c = > c . AsDecimal ( 18 , 4 ) , <nl>\n", "msg": "Add database type mapping for int64 / long\n", "score": 1}
{"diff_id": 19073, "repo": "StackExchange/StackExchange.Redis\n", "sha": "c2444f458108260eee7ce5f442023c31ac6f685d\n", "time": "2015-03-17T08:17:23Z\n", "diff": "mmm a / StackExchange . Redis / StackExchange / Redis / Message . cs <nl> ppp b / StackExchange . Redis / StackExchange / Redis / Message . cs <nl> <nl>  using System ; <nl> using System . Collections . Generic ; <nl> using System . Linq ; <nl> + using System . Runtime . Serialization ; <nl> using System . Text ; <nl> using System . Threading . Tasks ; <nl> <nl> namespace StackExchange . Redis <nl> [ Serializable ] <nl> public sealed class RedisCommandException : Exception <nl> { <nl> + private RedisCommandException ( SerializationInfo info , StreamingContext ctx ) : base ( info , ctx ) { } <nl> internal RedisCommandException ( string message ) : base ( message ) { } <nl> internal RedisCommandException ( string message , Exception innerException ) : base ( message , innerException ) { } <nl> } <nl> public sealed class RedisCommandException : Exception <nl> / / / Indicates a connection fault when communicating with redis <nl> / / / < / summary > <nl> [ Serializable ] <nl> - [ System . Diagnostics . CodeAnalysis . SuppressMessage ( \" Microsoft . Usage \" , \" CA2240 : ImplementISerializableCorrectly \" ) ] <nl> public sealed class RedisConnectionException : RedisException <nl> { <nl> + private RedisConnectionException ( SerializationInfo info , StreamingContext ctx ) : base ( info , ctx ) <nl> + { <nl> + this . FailureType = ( ConnectionFailureType ) info . GetInt32 ( \" failureType \" ) ; <nl> + } <nl> + / / / < summary > <nl> + / / / Serialization implementation ; not intended for general usage <nl> + / / / < / summary > <nl> + public override void GetObjectData ( SerializationInfo info , StreamingContext context ) <nl> + { <nl> + base . GetObjectData ( info , context ) ; <nl> + info . AddValue ( \" failureType \" , ( int ) this . FailureType ) ; <nl> + } <nl> + <nl> internal RedisConnectionException ( ConnectionFailureType failureType , string message ) : base ( message ) <nl> { <nl> this . FailureType = failureType ; <nl> internal RedisConnectionException ( ConnectionFailureType failureType , string mess <nl> [ Serializable ] <nl> public class RedisException : Exception <nl> { <nl> + / / / < summary > <nl> + / / / Deserialization constructor ; not intended for general usage <nl> + / / / < / summary > <nl> + protected RedisException ( SerializationInfo info , StreamingContext ctx ) : base ( info , ctx ) { } <nl> + <nl> internal RedisException ( string message ) : base ( message ) { } <nl> internal RedisException ( string message , Exception innerException ) : base ( message , innerException ) { } <nl> } <nl> public class RedisException : Exception <nl> [ Serializable ] <nl> public sealed class RedisServerException : RedisException <nl> { <nl> + private RedisServerException ( SerializationInfo info , StreamingContext ctx ) : base ( info , ctx ) { } <nl> + <nl> internal RedisServerException ( string message ) : base ( message ) { } <nl> } <nl> <nl>\n", "msg": "Add serialization API to exceptions\n", "score": 1}
{"diff_id": 19372, "repo": "ppy/osu\n", "sha": "a7d1eed3f5d938608eb9581ccde72072efd014b9\n", "time": "2020-04-08T04:12:59Z\n", "diff": "mmm a / osu . Game . Rulesets . Taiko / UI / TaikoPlayfield . cs <nl> ppp b / osu . Game . Rulesets . Taiko / UI / TaikoPlayfield . cs <nl> private void onDrumrollArbitraryHit ( TaikoAction action , bool isStrong ) <nl> drawableHit = new DrawableFlyingCentreHit ( Time . Current , isStrong ) ; <nl> <nl> drumRollHitContainer . Add ( drawableHit ) ; <nl> + topLevelHitContainer . Add ( drawableHit . CreateProxiedContent ( ) ) ; <nl> } <nl> <nl> internal void OnNewResult ( DrawableHitObject judgedObject , JudgementResult result ) <nl>\n", "msg": "Added content proxying to drull roll elements\n", "score": 1}
{"diff_id": 19391, "repo": "gitextensions/gitextensions\n", "sha": "8b021050d901e30867b9545ac335c68817c6af92\n", "time": "2011-11-25T17:47:52Z\n", "diff": "mmm a / GitUI / RevisionGrid . cs <nl> ppp b / GitUI / RevisionGrid . cs <nl> public RevisionGrid ( ) <nl> Loading . Paint + = Loading_Paint ; <nl> <nl> Revisions . CellPainting + = RevisionsCellPainting ; <nl> + Revisions . CellFormatting + = RevisionsCellFormatting ; <nl> Revisions . KeyDown + = RevisionsKeyDown ; <nl> <nl> showAuthorDateToolStripMenuItem . Checked = Settings . ShowAuthorDate ; <nl> private void RevisionsCellPainting ( object sender , DataGridViewCellPaintingEventA <nl> } <nl> } <nl> <nl> + private void RevisionsCellFormatting ( object sender , DataGridViewCellFormattingEventArgs e ) <nl> + { <nl> + var column = e . ColumnIndex ; <nl> + if ( e . RowIndex < 0 ) <nl> + return ; <nl> + <nl> + if ( Revisions . RowCount < = e . RowIndex ) <nl> + return ; <nl> + <nl> + var revision = GetRevision ( e . RowIndex ) ; <nl> + if ( revision = = null ) <nl> + return ; <nl> + <nl> + e . FormattingApplied = true ; <nl> + <nl> + switch ( column ) <nl> + { <nl> + case 0 : <nl> + e . Value = revision . Guid ; <nl> + break ; <nl> + case 1 : <nl> + e . Value = revision . Message ; <nl> + break ; <nl> + case 2 : <nl> + e . Value = revision . Author ; <nl> + break ; <nl> + case 3 : <nl> + { <nl> + var time = Settings . ShowAuthorDate ? revision . AuthorDate : revision . CommitDate ; <nl> + if ( time = = DateTime . MinValue | | time = = DateTime . MaxValue ) <nl> + e . Value = \" \" ; <nl> + else <nl> + e . Value = string . Format ( \" { 0 } { 1 } \" , time . ToShortDateString ( ) , time . ToLongTimeString ( ) ) ; <nl> + } <nl> + break ; <nl> + } <nl> + } <nl> + <nl> private void DrawColumnText ( IDeviceContext dc , string text , Font font , Color color , Rectangle bounds ) <nl> { <nl> TextRenderer . DrawText ( dc , text , font , bounds , color , TextFormatFlags . EndEllipsis | TextFormatFlags . NoPrefix ) ; <nl>\n", "msg": "Control + C for revision grid fixed\n", "score": 1}
{"diff_id": 19453, "repo": "OpenRA/OpenRA\n", "sha": "a2af79ff98f0918e1b3ecd86bb8634ad3d1224be\n", "time": "2015-04-26T06:12:20Z\n", "diff": "mmm a / OpenRA . Mods . Common / Traits / Render / RenderBuildingWall . cs <nl> ppp b / OpenRA . Mods . Common / Traits / Render / RenderBuildingWall . cs <nl> class RenderBuildingWallInfo : RenderBuildingInfo <nl> <nl> public override IEnumerable < IActorPreview > RenderPreviewSprites ( ActorPreviewInitializer init , RenderSpritesInfo rs , string image , int facings , PaletteReference p ) <nl> { <nl> - / / Show a static frame instead of animating all of the wall states <nl> + var adjacent = 0 ; <nl> + <nl> + if ( init . Contains < RuntimeNeighbourInit > ( ) ) <nl> + { <nl> + var location = CPos . Zero ; <nl> + if ( init . Contains < LocationInit > ( ) ) <nl> + location = init . Get < LocationInit , CPos > ( ) ; <nl> + <nl> + var neighbours = init . Get < RuntimeNeighbourInit , Dictionary < CPos , string [ ] > > ( ) ; <nl> + foreach ( var kv in neighbours ) <nl> + { <nl> + var haveNeighbour = false ; <nl> + foreach ( var n in kv . Value ) <nl> + { <nl> + var rb = init . World . Map . Rules . Actors [ n ] . Traits . GetOrDefault < RenderBuildingWallInfo > ( ) ; <nl> + if ( rb ! = null & & rb . Type = = Type ) <nl> + { <nl> + haveNeighbour = true ; <nl> + break ; <nl> + } <nl> + } <nl> + <nl> + if ( ! haveNeighbour ) <nl> + continue ; <nl> + <nl> + if ( kv . Key = = location + new CVec ( 0 , - 1 ) ) <nl> + adjacent | = 1 ; <nl> + else if ( kv . Key = = location + new CVec ( + 1 , 0 ) ) <nl> + adjacent | = 2 ; <nl> + else if ( kv . Key = = location + new CVec ( 0 , + 1 ) ) <nl> + adjacent | = 4 ; <nl> + else if ( kv . Key = = location + new CVec ( - 1 , 0 ) ) <nl> + adjacent | = 8 ; <nl> + } <nl> + } <nl> + <nl> var anim = new Animation ( init . World , image , ( ) = > 0 ) ; <nl> - anim . PlayFetchIndex ( RenderSprites . NormalizeSequence ( anim , init . GetDamageState ( ) , Sequence ) , ( ) = > 0 ) ; <nl> + anim . PlayFetchIndex ( RenderSprites . NormalizeSequence ( anim , init . GetDamageState ( ) , Sequence ) , ( ) = > adjacent ) ; <nl> <nl> yield return new SpriteActorPreview ( anim , WVec . Zero , 0 , p , rs . Scale ) ; <nl> } <nl> public void RemovedFromWorld ( Actor self ) <nl> UpdateNeighbours ( self ) ; <nl> } <nl> } <nl> + <nl> + public class RuntimeNeighbourInit : IActorInit < Dictionary < CPos , string [ ] > > <nl> + { <nl> + [ FieldFromYamlKey ] readonly Dictionary < CPos , string [ ] > value = null ; <nl> + public RuntimeNeighbourInit ( ) { } <nl> + public RuntimeNeighbourInit ( Dictionary < CPos , string [ ] > init ) { value = init ; } <nl> + public Dictionary < CPos , string [ ] > Value ( World world ) { return value ; } <nl> + } <nl> } <nl>\n", "msg": "Add support for wall preview neighbours .\n", "score": 1}
{"diff_id": 19528, "repo": "dotnet/reactive\n", "sha": "5ebc829b41253d5f2fce42431693d2a1ff5e6170\n", "time": "2017-09-04T23:00:00Z\n", "diff": "mmm a / Ix . NET / Source / System . Linq . Async / System / Linq / AsyncEnumerator . cs <nl> ppp b / Ix . NET / Source / System . Linq . Async / System / Linq / AsyncEnumerator . cs <nl> public static Task < bool > MoveNextAsync < T > ( this IAsyncEnumerator < T > source , Cance <nl> return source . MoveNextAsync ( ) ; <nl> } <nl> <nl> + / / / < summary > <nl> + / / / Wraps the specified enumerator with an enumerator that checks for cancellation upon every invocation <nl> + / / / of the < see cref = \" IAsyncEnumerator { T } . MoveNextAsync \" / > method . <nl> + / / / < / summary > <nl> + / / / < typeparam name = \" T \" > The type of the elements returned by the enumerator . < / typeparam > <nl> + / / / < param name = \" source \" > The enumerator to augment with cancellation support . < / param > <nl> + / / / < param name = \" cancellationToken \" > The cancellation token to observe . < / param > <nl> + / / / < returns > An enumerator that honors cancellation requests . < / returns > <nl> + public static IAsyncEnumerator < T > WithCancellation < T > ( this IAsyncEnumerator < T > source , CancellationToken cancellationToken ) <nl> + { <nl> + if ( source = = null ) <nl> + throw new ArgumentNullException ( nameof ( source ) ) ; <nl> + <nl> + return new AnonymousAsyncIterator < T > ( <nl> + moveNext : ( ) = > <nl> + { <nl> + cancellationToken . ThrowIfCancellationRequested ( ) ; <nl> + return source . MoveNextAsync ( ) ; <nl> + } , <nl> + currentFunc : ( ) = > source . Current , <nl> + dispose : source . DisposeAsync <nl> + ) ; <nl> + } <nl> + <nl> + / / / < summary > <nl> + / / / Wraps the specified enumerator in an enumerable . <nl> + / / / < / summary > <nl> + / / / < typeparam name = \" T \" > The type of the elements returned by the enumerator . < / typeparam > <nl> + / / / < param name = \" source \" > The enumerator to wrap . < / param > <nl> + / / / < returns > An enumerable wrapping the specified enumerator . < / returns > <nl> + public static IAsyncEnumerable < T > AsEnumerable < T > ( this IAsyncEnumerator < T > source ) <nl> + { <nl> + if ( source = = null ) <nl> + throw new ArgumentNullException ( nameof ( source ) ) ; <nl> + <nl> + return AsyncEnumerable . CreateEnumerable < T > ( ( ) = > source ) ; <nl> + } <nl> + <nl> internal static IAsyncEnumerator < T > Create < T > ( Func < TaskCompletionSource < bool > , Task < bool > > moveNext , Func < T > current , Func < Task > dispose ) <nl> { <nl> return new AnonymousAsyncIterator < T > ( <nl>\n", "msg": "Adding WithCancellation and AsEnumerable for async enumerators .\n", "score": 1}
{"diff_id": 19632, "repo": "dotnet/runtime\n", "sha": "5f567017b3f01fed33a4bb8469d63b311ac61d4b\n", "time": "2017-12-14T21:03:41Z\n", "diff": "mmm a / src / libraries / System . Diagnostics . DiagnosticSource / tests / HttpHandlerDiagnosticListenerTests . cs <nl> ppp b / src / libraries / System . Diagnostics . DiagnosticSource / tests / HttpHandlerDiagnosticListenerTests . cs <nl> public void TestHttpDiagnosticListenerIsRegistered ( ) <nl> / / / A simple test to make sure the Http Diagnostic Source is initialized properly after we subscribed to it , using <nl> / / / the subscribe overload with just the observer argument . <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public void TestReflectInitializationViaSubscription1 ( ) <nl> { <nl> public void TestReflectInitializationViaSubscription1 ( ) <nl> / / / A simple test to make sure the Http Diagnostic Source is initialized properly after we subscribed to it , using <nl> / / / the subscribe overload with just the observer argument and the more complicating enable filter function . <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public void TestReflectInitializationViaSubscription2 ( ) <nl> { <nl> public void TestReflectInitializationViaSubscription2 ( ) <nl> / / / A simple test to make sure the Http Diagnostic Source is initialized properly after we subscribed to it , using <nl> / / / the subscribe overload with the observer argument and the simple predicate argument . <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public void TestReflectInitializationViaSubscription3 ( ) <nl> { <nl> public void TestReflectInitializationViaSubscription3 ( ) <nl> / / / < summary > <nl> / / / Test to make sure we get both request and response events . <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public async Task TestBasicReceiveAndResponseEvents ( ) <nl> { <nl> public async Task TestBasicReceiveAndResponseEvents ( ) <nl> / / / < summary > <nl> / / / Test to make sure we get both request and response events . <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public async Task TestResponseWithoutContentEvents ( ) <nl> { <nl> public async Task TestResponseWithoutContentEvents ( ) <nl> Assert . NotNull ( headers ) ; <nl> } <nl> } <nl> + <nl> / / / < summary > <nl> / / / Test that if request is redirected , it gets only one Start and one Stop event <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public async Task TestRedirectedRequest ( ) <nl> { <nl> public async Task TestRedirectedRequest ( ) <nl> / / / < summary > <nl> / / / Test exception in request processing : exception should have expected type / status and now be swallowed by reflection hook <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public async Task TestRequestWithException ( ) <nl> { <nl> public async Task TestRequestWithException ( ) <nl> / / / < summary > <nl> / / / Test request cancellation : reflection hook does not throw <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public async Task TestCanceledRequest ( ) <nl> { <nl> public async Task TestCanceledRequest ( ) <nl> / / / < summary > <nl> / / / Test Request - Id and Correlation - Context headers injection <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public async Task TestActivityIsCreated ( ) <nl> { <nl> public async Task TestActivityIsCreated ( ) <nl> / / / < summary > <nl> / / / Tests IsEnabled order and parameters <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public async Task TestIsEnabled ( ) <nl> { <nl> bool IsEnabled ( string evnt , object arg1 , object arg2 ) <nl> Assert . Equal ( 2 , eventNumber ) ; <nl> } <nl> } <nl> - <nl> + <nl> / / / < summary > <nl> / / / Tests that nothing happens if IsEnabled returns false <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public async Task TestIsEnabledAllOff ( ) <nl> { <nl> public async Task TestIsEnabledAllOff ( ) <nl> / / / < summary > <nl> / / / Tests that if IsEnabled for request is false , request is not instrumented <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public async Task TestIsEnabledRequestOff ( ) <nl> { <nl> bool IsEnabled ( string evnt , object arg1 , object arg2 ) <nl> / / / < summary > <nl> / / / Test to make sure every event record has the right dynamic properties . <nl> / / / < / summary > <nl> + [ OuterLoop ] <nl> [ Fact ] <nl> public void TestMultipleConcurrentRequests ( ) <nl> { <nl>\n", "msg": "Set OuterLoop category for http tests\n", "score": 1}
{"diff_id": 19710, "repo": "ppy/osu\n", "sha": "75e6bbc4d895987c2837846febf242be96fa7e80\n", "time": "2018-09-15T13:33:31Z\n", "diff": "mmm a / osu . Desktop / OsuGameDesktop . cs <nl> ppp b / osu . Desktop / OsuGameDesktop . cs <nl> private class StableStorage : WindowsStorage <nl> { <nl> protected override string LocateBasePath ( ) <nl> { <nl> - bool checkExists ( string p ) = > Directory . Exists ( Path . Combine ( p , \" Songs \" ) ) & & Directory . Exists ( Path . Combine ( p , \" Skins \" ) ) ; <nl> + bool checkExists ( string p ) = > Directory . Exists ( Path . Combine ( p , \" Songs \" ) ) ; <nl> <nl> string stableInstallPath ; <nl> <nl>\n", "msg": "Revert \" Check for skins folder also \"\n", "score": 1}
{"diff_id": 19877, "repo": "OpenRA/OpenRA\n", "sha": "5a00757eabdcfd9dc70a86b0392d2527f862743c\n", "time": "2014-06-27T07:20:46Z\n", "diff": "mmm a / OpenRA . Mods . RA / World / PathfinderDebugOverlay . cs <nl> ppp b / OpenRA . Mods . RA / World / PathfinderDebugOverlay . cs <nl> <nl> using System ; <nl> using System . Collections . Generic ; <nl> using System . Drawing ; <nl> + using OpenRA ; <nl> using OpenRA . Graphics ; <nl> using OpenRA . Primitives ; <nl> using OpenRA . Traits ; <nl> namespace OpenRA . Mods . RA <nl> class PathfinderDebugOverlayInfo : TraitInfo < PathfinderDebugOverlay > { } <nl> class PathfinderDebugOverlay : IRenderOverlay , IWorldLoaded <nl> { <nl> - Dictionary < Player , int [ , ] > layers ; <nl> + Dictionary < Player , CellLayer < int > > layers ; <nl> int refreshTick ; <nl> World world ; <nl> public bool Visible ; <nl> public void WorldLoaded ( World w , WorldRenderer wr ) <nl> { <nl> world = w ; <nl> refreshTick = 0 ; <nl> - layers = new Dictionary < Player , int [ , ] > ( 8 ) ; <nl> + layers = new Dictionary < Player , CellLayer < int > > ( 8 ) ; <nl> <nl> / / Enabled via Cheats menu <nl> Visible = false ; <nl> public void AddLayer ( IEnumerable < Pair < CPos , int > > cellWeights , int maxWeight , Pl <nl> { <nl> if ( maxWeight = = 0 ) return ; <nl> <nl> - int [ , ] layer ; <nl> + CellLayer < int > layer ; <nl> if ( ! layers . TryGetValue ( pl , out layer ) ) <nl> { <nl> - layer = new int [ world . Map . MapSize . X , world . Map . MapSize . Y ] ; <nl> + layer = new CellLayer < int > ( world . Map ) ; <nl> layers . Add ( pl , layer ) ; <nl> } <nl> <nl> foreach ( var p in cellWeights ) <nl> - layer [ p . First . X , p . First . Y ] = Math . Min ( 128 , layer [ p . First . X , p . First . Y ] + ( maxWeight - p . Second ) * 64 / maxWeight ) ; <nl> + layer [ p . First ] = Math . Min ( 128 , layer [ p . First ] + ( maxWeight - p . Second ) * 64 / maxWeight ) ; <nl> } <nl> <nl> public void Render ( WorldRenderer wr ) <nl> public void Render ( WorldRenderer wr ) <nl> var doDim = refreshTick - world . WorldTick < = 0 ; <nl> if ( doDim ) refreshTick = world . WorldTick + 20 ; <nl> <nl> - var viewBounds = wr . Viewport . CellBounds ; <nl> foreach ( var pair in layers ) <nl> { <nl> var c = ( pair . Key ! = null ) ? pair . Key . Color . RGB : Color . PaleTurquoise ; <nl> var layer = pair . Value ; <nl> <nl> / / Only render quads in viewing range : <nl> - for ( var j = viewBounds . Top ; j < = viewBounds . Bottom ; + + j ) <nl> + foreach ( var cell in wr . Viewport . VisibleCells ) <nl> { <nl> - for ( var i = viewBounds . Left ; i < = viewBounds . Right ; + + i ) <nl> - { <nl> - if ( layer [ i , j ] < = 0 ) <nl> - continue ; <nl> + if ( layer [ cell ] < = 0 ) <nl> + continue ; <nl> <nl> - var w = Math . Max ( 0 , Math . Min ( layer [ i , j ] , 128 ) ) ; <nl> - if ( doDim ) <nl> - layer [ i , j ] = layer [ i , j ] * 5 / 6 ; <nl> + var w = Math . Max ( 0 , Math . Min ( layer [ cell ] , 128 ) ) ; <nl> + if ( doDim ) <nl> + layer [ cell ] = layer [ cell ] * 5 / 6 ; <nl> <nl> - / / TODO : This doesn ' t make sense for isometric terrain <nl> - var tl = wr . ScreenPxPosition ( new CPos ( i , j ) . TopLeft ) ; <nl> - var br = wr . ScreenPxPosition ( new CPos ( i , j ) . BottomRight ) ; <nl> - qr . FillRect ( RectangleF . FromLTRB ( tl . X , tl . Y , br . X , br . Y ) , Color . FromArgb ( w , c ) ) ; <nl> - } <nl> + / / TODO : This doesn ' t make sense for isometric terrain <nl> + var tl = wr . ScreenPxPosition ( cell . TopLeft ) ; <nl> + var br = wr . ScreenPxPosition ( cell . BottomRight ) ; <nl> + qr . FillRect ( RectangleF . FromLTRB ( tl . X , tl . Y , br . X , br . Y ) , Color . FromArgb ( w , c ) ) ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Use CellLayers for pathfinder debug .\n", "score": 1}
{"diff_id": 19878, "repo": "ServiceStack/ServiceStack\n", "sha": "14b7988176b6b17139c276073cfaa66522f9290d\n", "time": "2013-02-06T04:59:03Z\n", "diff": "mmm a / src / ServiceStack . Api . Swagger / SwaggerApiService . cs <nl> ppp b / src / ServiceStack . Api . Swagger / SwaggerApiService . cs <nl> public object Get ( ResourceRequest request ) <nl> var path = \" / \" + request . Name ; <nl> var map = EndpointHost . ServiceManager . ServiceController . RestPathMap ; <nl> var paths = new List < RestPath > ( ) ; <nl> - var basePath = httpReq . GetApplicationUrl ( ) ; <nl> + var basePath = httpReq . GetParentPathUrl ( ) ; <nl> foreach ( var key in map . Keys ) <nl> { <nl> paths . AddRange ( map [ key ] . Where ( x = > x . Path = = path | | x . Path . StartsWith ( path + \" / \" ) ) ) ; <nl>\n", "msg": "basePath from GetParentPathUrl to support hosting in IIS Application\n", "score": 1}
{"diff_id": 19985, "repo": "duplicati/duplicati\n", "sha": "b54a2f79c1ad7880fac9c093cb4101d4cf69a2b5\n", "time": "2014-07-06T23:33:40Z\n", "diff": "mmm a / Duplicati / GUI / Duplicati . GUI . TrayIcon / GtkRunner . cs <nl> ppp b / Duplicati / GUI / Duplicati . GUI . TrayIcon / GtkRunner . cs <nl> private class MenuItemWrapper : IMenuItem <nl> <nl> private Gtk . Image GetIcon ( MenuIcons icon ) <nl> { <nl> + if ( Duplicati . Library . Utility . Utility . IsClientOSX ) <nl> + return null ; <nl> + <nl> if ( ! _icons . ContainsKey ( icon ) ) <nl> { <nl> switch ( icon ) <nl> public MenuItemWrapper ( string text , MenuIcons icon , System . Action callback , ILis <nl> else <nl> { <nl> m_item = new ImageMenuItem ( text ) ; <nl> - if ( icon ! = MenuIcons . None ) { <nl> - ( ( ImageMenuItem ) m_item ) . Image = GetIcon ( icon ) ; <nl> - <nl> - / / TODO : Not sure we should do this , it overrides policy ? <nl> - m_item . ExposeEvent + = DrawImageMenuItemImage ; <nl> - } <nl> + if ( ! Duplicati . Library . Utility . Utility . IsClientOSX ) <nl> + if ( icon ! = MenuIcons . None ) { <nl> + ( ( ImageMenuItem ) m_item ) . Image = GetIcon ( icon ) ; <nl> + <nl> + / / TODO : Not sure we should do this , it overrides policy ? <nl> + m_item . ExposeEvent + = DrawImageMenuItemImage ; <nl> + } <nl> <nl> if ( subitems ! = null & & subitems . Count > 0 ) <nl> { <nl>\n", "msg": "More OSX - like look for the GTK version of the tray icon and menu\n", "score": 1}
{"diff_id": 20150, "repo": "ServiceStack/ServiceStack\n", "sha": "2fe1fefa338d3aac7aed6d7161dc0e2191dd52dd\n", "time": "2013-01-24T00:36:52Z\n", "diff": "mmm a / src / ServiceStack / ServiceHost / Cookies . cs <nl> ppp b / src / ServiceStack / ServiceHost / Cookies . cs <nl> public HttpCookie ToHttpCookie ( Cookie cookie ) <nl> var httpCookie = new HttpCookie ( cookie . Name , cookie . Value ) { <nl> Path = cookie . Path , <nl> Expires = cookie . Expires , <nl> + HttpOnly = true <nl> } ; <nl> if ( string . IsNullOrEmpty ( httpCookie . Domain ) ) <nl> { <nl> public void AddCookie ( Cookie cookie ) <nl> } <nl> } <nl> } <nl> - } <nl> \\ No newline at end of file <nl> + } <nl>\n", "msg": "Set HttpOnly to true to protect cookies\n", "score": 1}
{"diff_id": 20442, "repo": "JustArchiNET/ArchiSteamFarm\n", "sha": "6b4ae6a4d7ecb2b9d69de96959b39e45ccb22224\n", "time": "2016-06-24T18:27:23Z\n", "diff": "mmm a / ArchiSteamFarm / Bot . cs <nl> ppp b / ArchiSteamFarm / Bot . cs <nl> internal sealed class Bot { <nl> [ JsonProperty ] <nl> private readonly CardsFarmer CardsFarmer ; <nl> <nl> + private readonly ConcurrentHashSet < ulong > HandledGifts = new ConcurrentHashSet < ulong > ( ) ; <nl> private readonly SteamApps SteamApps ; <nl> private readonly SteamFriends SteamFriends ; <nl> private readonly SteamUser SteamUser ; <nl> internal sealed class Bot { <nl> <nl> FirstTradeSent = false ; <nl> CardsFarmer . StopFarming ( ) . Forget ( ) ; <nl> + HandledGifts . ClearAndTrim ( ) ; <nl> <nl> / / If we initiated disconnect , do not attempt to reconnect <nl> if ( callback . UserInitiated ) { <nl> internal sealed class Bot { <nl> } <nl> <nl> bool acceptedSomething = false ; <nl> - foreach ( ulong gid in callback . GuestPasses . Select ( guestPass = > guestPass [ \" gid \" ] . AsUnsignedLong ( ) ) . Where ( gid = > gid ! = 0 ) ) { <nl> + foreach ( ulong gid in callback . GuestPasses . Select ( guestPass = > guestPass [ \" gid \" ] . AsUnsignedLong ( ) ) . Where ( gid = > ( gid ! = 0 ) & & ! HandledGifts . Contains ( gid ) ) ) { <nl> Logging . LogGenericInfo ( \" Accepting gift : \" + gid + \" . . . \" , BotName ) ; <nl> if ( await ArchiWebHandler . AcceptGift ( gid ) . ConfigureAwait ( false ) ) { <nl> acceptedSomething = true ; <nl> + HandledGifts . Add ( gid ) ; <nl> Logging . LogGenericInfo ( \" Success ! \" , BotName ) ; <nl> } else { <nl> Logging . LogGenericInfo ( \" Failed ! \" , BotName ) ; <nl>\n", "msg": "Do not attempt to handle the same gift more than one time\n", "score": 1}
{"diff_id": 20910, "repo": "dotnet/roslyn\n", "sha": "663b3a9acf1a9202e8b8db3ecf01628f0ab5894b\n", "time": "2015-02-08T17:20:16Z\n", "diff": "mmm a / src / Diagnostics / Roslyn / Core / ApiDesign / DeclarePublicAPIAnalyzer . cs <nl> ppp b / src / Diagnostics / Roslyn / Core / ApiDesign / DeclarePublicAPIAnalyzer . cs <nl> public override void Initialize ( AnalysisContext context ) <nl> context . RegisterCompilationStartAction ( compilationContext = > <nl> { <nl> AdditionalText publicApiAdditionalText = TryGetPublicApiSpec ( compilationContext . Options . AdditionalFiles ) ; <nl> + var publicApiSourceText = publicApiAdditionalText . GetText ( compilationContext . CancellationToken ) ; <nl> <nl> if ( publicApiAdditionalText = = null ) <nl> { <nl> return ; <nl> } <nl> <nl> - HashSet < string > declaredPublicSymbols = ReadPublicSymbols ( publicApiAdditionalText ) ; <nl> + HashSet < string > declaredPublicSymbols = ReadPublicSymbols ( publicApiSourceText ) ; <nl> HashSet < string > examinedPublicTypes = new HashSet < string > ( ) ; <nl> object lockObj = new object ( ) ; <nl> <nl> public override void Initialize ( AnalysisContext context ) <nl> <nl> foreach ( var symbol in deletedSymbols ) <nl> { <nl> - var location = Location . Create ( publicApiAdditionalText . Path , default ( TextSpan ) , default ( LinePositionSpan ) ) ; <nl> + var span = FindString ( publicApiSourceText , symbol ) ; <nl> + Location location ; <nl> + if ( span . HasValue ) <nl> + { <nl> + var linePositionSpan = publicApiSourceText . Lines . GetLinePositionSpan ( span . Value ) ; <nl> + location = Location . Create ( publicApiAdditionalText . Path , span . Value , linePositionSpan ) ; <nl> + } <nl> + else <nl> + { <nl> + location = Location . Create ( publicApiAdditionalText . Path , default ( TextSpan ) , default ( LinePositionSpan ) ) ; <nl> + } <nl> + <nl> compilationEndContext . ReportDiagnostic ( Diagnostic . Create ( RemoveDeletedApiRule , location , symbol ) ) ; <nl> } <nl> } ) ; <nl> } ) ; <nl> } <nl> <nl> - private static HashSet < string > ReadPublicSymbols ( AdditionalText additionalFile ) <nl> + private TextSpan ? FindString ( SourceText sourceText , string symbol ) <nl> + { <nl> + foreach ( var line in sourceText . Lines ) <nl> + { <nl> + if ( line . ToString ( ) = = symbol ) <nl> + { <nl> + return line . Span ; <nl> + } <nl> + } <nl> + <nl> + return null ; <nl> + } <nl> + <nl> + private static HashSet < string > ReadPublicSymbols ( SourceText file ) <nl> { <nl> HashSet < string > publicSymbols = new HashSet < string > ( ) ; <nl> <nl> - foreach ( var line in additionalFile . GetText ( ) . Lines ) <nl> + foreach ( var line in file . Lines ) <nl> { <nl> var text = line . ToString ( ) ; <nl> <nl>\n", "msg": "Show line information for diagnostics in PublicAPI . txt .\n", "score": 1}
{"diff_id": 20920, "repo": "icsharpcode/ILSpy\n", "sha": "7b9d774738a725d36ccf25c1bf7631c7e1e0e3a9\n", "time": "2017-08-21T23:54:06Z\n", "diff": "mmm a / ICSharpCode . Decompiler / CSharp / Transforms / PatternStatementTransform . cs <nl> ppp b / ICSharpCode . Decompiler / CSharp / Transforms / PatternStatementTransform . cs <nl> <nl> using ICSharpCode . Decompiler . TypeSystem ; <nl> using ICSharpCode . Decompiler . CSharp . Analysis ; <nl> using Mono . Cecil ; <nl> + using ICSharpCode . Decompiler . Semantics ; <nl> <nl> namespace ICSharpCode . Decompiler . CSharp . Transforms <nl> { <nl> public override AstNode VisitExpressionStatement ( ExpressionStatement expressionS <nl> if ( result ! = null ) <nl> return result ; <nl> } <nl> + if ( context . Settings . AutomaticProperties ) { <nl> + result = ReplaceBackingFieldUsage ( expressionStatement ) ; <nl> + if ( result ! = null ) <nl> + return result ; <nl> + } <nl> return base . VisitExpressionStatement ( expressionStatement ) ; <nl> } <nl> <nl> void RemoveCompilerGeneratedAttribute ( AstNodeCollection < AttributeSection > attrib <nl> section . Remove ( ) ; <nl> } <nl> } <nl> + <nl> + ExpressionStatement ReplaceBackingFieldUsage ( ExpressionStatement expressionStatement ) <nl> + { <nl> + foreach ( var identifier in expressionStatement . Descendants . OfType < Identifier > ( ) ) { <nl> + if ( identifier . Name . StartsWith ( \" < \" ) & & identifier . Name . EndsWith ( \" > k__BackingField \" ) ) { <nl> + var parent = identifier . Parent ; <nl> + var mrr = parent . Annotation < MemberResolveResult > ( ) ; <nl> + var field = mrr ? . Member as IField ; <nl> + if ( field ! = null & & field . IsCompilerGenerated ( ) ) { <nl> + var propertyName = identifier . Name . Substring ( 1 , identifier . Name . Length - 1 - \" > k__BackingField \" . Length ) ; <nl> + var property = field . DeclaringTypeDefinition . GetProperties ( p = > p . Name = = propertyName , GetMemberOptions . IgnoreInheritedMembers ) . FirstOrDefault ( ) ; <nl> + if ( property ! = null ) { <nl> + identifier . ReplaceWith ( Identifier . Create ( propertyName ) ) ; <nl> + parent . RemoveAnnotations < MemberResolveResult > ( ) ; <nl> + parent . AddAnnotation ( new MemberResolveResult ( mrr . TargetResult , property ) ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + return null ; <nl> + } <nl> # endregion <nl> <nl> # region Automatic Events <nl>\n", "msg": "First attempt to remove read - only property backing field usage\n", "score": 1}
{"diff_id": 20980, "repo": "dotnet/aspnetcore\n", "sha": "5314a87c456a8604924363346bd10e9e95b6df32\n", "time": "2016-05-23T17:09:58Z\n", "diff": "mmm a / test / MusicStore . Test / TestSession . cs <nl> ppp b / test / MusicStore . Test / TestSession . cs <nl> internal class TestSession : ISession <nl> <nl> public string Id { get ; set ; } <nl> <nl> + public bool IsAvailable { get ; } = true ; <nl> + <nl> public void Clear ( ) <nl> { <nl> _store . Clear ( ) ; <nl>\n", "msg": "React to adding IsAvailable to ISession\n", "score": 1}
{"diff_id": 21388, "repo": "Sonarr/Sonarr\n", "sha": "510d538c86ddb6395be5cac5c2f9eb176b54bf83\n", "time": "2012-08-06T18:02:37Z\n", "diff": "mmm a / NzbDrone . Core / Providers / MetadataProvider . cs <nl> ppp b / NzbDrone . Core / Providers / MetadataProvider . cs <nl> public virtual void CreateForEpisodeFile ( EpisodeFile episodeFile , TvdbSeries tvD <nl> public virtual void CreateForEpisodeFiles ( List < EpisodeFile > episodeFiles ) <nl> { <nl> if ( episodeFiles = = null | | ! episodeFiles . Any ( ) ) <nl> - return ; <nl> - <nl> + { <nl> + Logger . Warn ( \" No episode files , no metadata will be created . \" ) ; <nl> + throw new ArgumentException ( \" EpsiodeFiles must not be null or empty \" , \" episodeFiles \" ) ; <nl> + } <nl> + <nl> + Logger . Trace ( \" Creating metadata for { 0 } files . \" , episodeFiles . Count ) ; <nl> + <nl> var tvDbSeries = _tvDbProvider . GetSeries ( episodeFiles . First ( ) . SeriesId , true , true ) ; <nl> <nl> foreach ( var episodeFile in episodeFiles ) <nl> { <nl> foreach ( var provider in _metadataProviders . Where ( i = > GetSettings ( i . GetType ( ) ) . Enable ) ) <nl> { <nl> + Logger . Trace ( \" Creating { 0 } metadata for { 1 } \" , provider . Name , episodeFile . EpisodeFileId ) ; <nl> provider . CreateForEpisodeFile ( episodeFile , tvDbSeries ) ; <nl> } <nl> } <nl>\n", "msg": "Added additional logging to metadata creation\n", "score": 1}
{"diff_id": 21472, "repo": "cefsharp/CefSharp\n", "sha": "16dbb10c61b15234ab9d3c54b285fdc6191592b1\n", "time": "2017-05-08T03:16:24Z\n", "diff": "mmm a / CefSharp / WebBrowserExtensions . cs <nl> ppp b / CefSharp / WebBrowserExtensions . cs <nl> public static void ExecuteScriptAsync ( this IWebBrowser browser , string script ) <nl> { <nl> if ( browser . CanExecuteJavascriptInMainFrame = = false ) <nl> { <nl> - throw new Exception ( \" Unable to execute javascript at this time , scripts can only be executed within a V8Context . \" + <nl> - \" Use the IWebBrowser . CanExecuteJavascriptInMainFrame property to guard against this exception . \" + <nl> - \" See https : / / github . com / cefsharp / CefSharp / wiki / General - Usage # when - can - i - start - executing - javascript \" + <nl> - \" for more details on when you can execute javascript . \" ) ; <nl> + ThrowExceptionIfCanExecuteJavascriptInMainFrameFalse ( ) ; <nl> } <nl> <nl> using ( var frame = browser . GetMainFrame ( ) ) <nl> public static Task < JavascriptResponse > EvaluateScriptAsync ( this IWebBrowser brow <nl> <nl> if ( browser . CanExecuteJavascriptInMainFrame = = false ) <nl> { <nl> - throw new Exception ( \" Unable to execute javascript at this time , scripts can only be executed within a V8Context . \" + <nl> - \" Use the IWebBrowser . CanExecuteJavascriptInMainFrame property to guard against this exception . \" + <nl> - \" See https : / / github . com / cefsharp / CefSharp / wiki / General - Usage # when - can - i - start - executing - javascript \" + <nl> - \" for more details on when you can execute javascript . \" ) ; <nl> + ThrowExceptionIfCanExecuteJavascriptInMainFrameFalse ( ) ; <nl> } <nl> <nl> using ( var frame = browser . GetMainFrame ( ) ) <nl> private static void ThrowExceptionIfBrowserHostNull ( IBrowserHost browserHost ) <nl> throw new Exception ( \" IBrowserHost instance is null . Browser has likely not finished initializing or is in the process of disposing . \" ) ; <nl> } <nl> } <nl> + <nl> + private static void ThrowExceptionIfCanExecuteJavascriptInMainFrameFalse ( ) <nl> + { <nl> + throw new Exception ( \" Unable to execute javascript at this time , scripts can only be executed within a V8Context . \" + <nl> + \" Use the IWebBrowser . CanExecuteJavascriptInMainFrame property to guard against this exception . \" + <nl> + \" See https : / / github . com / cefsharp / CefSharp / wiki / General - Usage # when - can - i - start - executing - javascript \" + <nl> + \" for more details on when you can execute javascript . For frames that do not contain Javascript then no \" + <nl> + \" V8Context will be created . Executing a script once the frame has loaded it ' s possible to create a V8Context . \" + <nl> + \" You can use browser . GetMainFrame ( ) . ExecuteJavaScriptAsync ( script ) or browser . GetMainFrame ( ) . EvaluateScriptAsync \" + <nl> + \" to bypass these checks ( advanced users only ) . \" ) ; <nl> + } <nl> } <nl> } <nl>\n", "msg": "Add ThrowExceptionIfCanExecuteJavascriptInMainFrameFalse method to reduce duplication .\n", "score": 1}
{"diff_id": 21711, "repo": "mono/mono\n", "sha": "d6553bc988dd9f2a3c535c6075868f233ecd3302\n", "time": "2015-07-29T20:02:43Z\n", "diff": "mmm a / mcs / class / corlib / System / Environment . cs <nl> ppp b / mcs / class / corlib / System / Environment . cs <nl> internal static string UnixGetFolderPath ( SpecialFolder folder , SpecialFolderOpt <nl> case SpecialFolder . LocalApplicationData : <nl> return data ; <nl> <nl> + case SpecialFolder . MyDocuments : <nl> + return ReadXdgUserDir ( config , home , \" XDG_DOCUMENTS_DIR \" , \" Documents \" ) ; <nl> + <nl> case SpecialFolder . Desktop : <nl> case SpecialFolder . DesktopDirectory : <nl> return ReadXdgUserDir ( config , home , \" XDG_DESKTOP_DIR \" , \" Desktop \" ) ; <nl>\n", "msg": "Report XDG Documents directory for SpecialFolder . MyDocuments\n", "score": 1}
{"diff_id": 21859, "repo": "dotnet/maui\n", "sha": "912fbcc518ce337d8d0f4aa030c5db9554ab0313\n", "time": "2019-08-01T09:55:29Z\n", "diff": "mmm a / Xamarin . Forms . Platform . iOS / CollectionView / UICollectionViewDelegator . cs <nl> ppp b / Xamarin . Forms . Platform . iOS / CollectionView / UICollectionViewDelegator . cs <nl> public override void ItemDeselected ( UICollectionView collectionView , NSIndexPath <nl> <nl> public override void CellDisplayingEnded ( UICollectionView collectionView , UICollectionViewCell cell , NSIndexPath indexPath ) <nl> { <nl> + if ( ItemsViewLayout . ScrollDirection = = UICollectionViewScrollDirection . Horizontal ) <nl> + { <nl> + var actualWidth = collectionView . ContentSize . Width - collectionView . Bounds . Size . Width ; <nl> + if ( collectionView . ContentOffset . X > = actualWidth | | collectionView . ContentOffset . X < 0 ) <nl> + return ; <nl> + } <nl> + else <nl> + { <nl> + var actualHeight = collectionView . ContentSize . Height - collectionView . Bounds . Size . Height ; <nl> + <nl> + if ( collectionView . ContentOffset . Y > = actualHeight | | collectionView . ContentOffset . Y < 0 ) <nl> + return ; <nl> + } <nl> + <nl> ItemsViewController . PrepareCellForRemoval ( cell ) ; <nl> } <nl> <nl>\n", "msg": "Prevent DisplayEnd for cell on bounce ( )\n", "score": 1}
{"diff_id": 21885, "repo": "abpframework/abp\n", "sha": "58b7e40e7c5b8cb75ac6bd31ebe3b768b31611f9\n", "time": "2018-01-08T13:32:52Z\n", "diff": "mmm a / src / AbpDesk / AbpDesk . Web . Mvc / Controllers / MultiTenancyController . cs <nl> ppp b / src / AbpDesk / AbpDesk . Web . Mvc / Controllers / MultiTenancyController . cs <nl> <nl> using System . Threading . Tasks ; <nl> using Microsoft . AspNetCore . Http ; <nl> using Microsoft . AspNetCore . Mvc ; <nl> + using Microsoft . Extensions . Options ; <nl> + using Volo . Abp . AspNetCore . MultiTenancy ; <nl> using Volo . Abp . AspNetCore . Mvc ; <nl> using Volo . Abp . MultiTenancy ; <nl> using Volo . Abp . Ui ; <nl> namespace AbpDesk . Web . Mvc . Controllers <nl> public class MultiTenancyController : AbpController <nl> { <nl> private readonly ITenantStore _tenantStore ; <nl> + private readonly AspNetCoreMultiTenancyOptions _options ; <nl> <nl> - public MultiTenancyController ( ITenantStore tenantStore ) <nl> + public MultiTenancyController ( ITenantStore tenantStore , IOptions < AspNetCoreMultiTenancyOptions > options ) <nl> { <nl> _tenantStore = tenantStore ; <nl> + _options = options . Value ; <nl> } <nl> <nl> public async Task < ActionResult > SwitchTenant ( string tenant = \" \" ) <nl> { <nl> - var tenantInfo = await FindTenantAsync ( tenant ) ; <nl> - if ( tenantInfo = = null ) <nl> + if ( tenant . IsNullOrEmpty ( ) ) <nl> { <nl> - throw new UserFriendlyException ( \" Unknown tenant : \" + tenant ) ; <nl> + HttpContext . Response . Cookies . Delete ( _options . TenantKey ) ; <nl> } <nl> - <nl> - HttpContext . Response . Cookies . Append ( <nl> - \" __tenant \" , <nl> - tenantInfo . Id . ToString ( ) , <nl> - new CookieOptions <nl> + else <nl> + { <nl> + var tenantInfo = await FindTenantAsync ( tenant ) ; <nl> + if ( tenantInfo = = null ) <nl> { <nl> - Expires = DateTimeOffset . Now . AddYears ( 1 ) <nl> + throw new UserFriendlyException ( \" Unknown tenant : \" + tenant ) ; <nl> } <nl> - ) ; <nl> + <nl> + HttpContext . Response . Cookies . Append ( <nl> + _options . TenantKey , <nl> + tenantInfo . Id . ToString ( ) , <nl> + new CookieOptions <nl> + { <nl> + Expires = DateTimeOffset . Now . AddYears ( 1 ) <nl> + } <nl> + ) ; <nl> + } <nl> <nl> return Redirect ( \" / \" ) ; <nl> } <nl>\n", "msg": "Handle to switch to host .\n", "score": 1}
{"diff_id": 22259, "repo": "AvaloniaUI/Avalonia\n", "sha": "a25a3922fa998d6421507db5cb5bed2e1694ac5a\n", "time": "2019-04-19T13:23:48Z\n", "diff": "mmm a / src / Avalonia . Build . Tasks / XamlCompilerTaskExecutor . cs <nl> ppp b / src / Avalonia . Build . Tasks / XamlCompilerTaskExecutor . cs <nl> bool CompileGroup ( IResourceGroup group ) <nl> <nl> compiler . Transform ( parsed ) ; <nl> var populateName = \" Populate : \" + res . Name ; <nl> - var buildName = classType ! = null ? \" Build : \" + res . Name : null ; <nl> + var buildName = classType = = null ? \" Build : \" + res . Name : null ; <nl> compiler . Compile ( parsed , builder , contextClass , <nl> populateName , buildName , <nl> \" NamespaceInfo : \" + res . Name , res . Uri ) ; <nl>\n", "msg": "Generate Build for xaml files without x : Class\n", "score": 1}
{"diff_id": 22393, "repo": "mono/mono\n", "sha": "6fc91cacbe371fa30d450ebf61de613b2927bb84\n", "time": "2016-05-03T09:42:39Z\n", "diff": "mmm a / mcs / class / referencesource / mscorlib / system / threading / threadpool . cs <nl> ppp b / mcs / class / referencesource / mscorlib / system / threading / threadpool . cs <nl> internal void SetWaitObject ( WaitHandle waitObject ) <nl> / / <nl> internal static class _ThreadPoolWaitCallback <nl> { <nl> + # if FEATURE_INTERCEPTABLE_THREADPOOL_CALLBACK <nl> + / / This feature is used by Xamarin . iOS to use an NSAutoreleasePool <nl> + / / for every task done by the threadpool . <nl> + static Func < Func < bool > , bool > dispatcher ; <nl> + <nl> + internal static void SetDispatcher ( Func < Func < bool > , bool > value ) <nl> + { <nl> + dispatcher = value ; <nl> + } <nl> + # endif <nl> + <nl> [ System . Security . SecurityCritical ] <nl> static internal bool PerformWaitCallback ( ) <nl> { <nl> + # if FEATURE_INTERCEPTABLE_THREADPOOL_CALLBACK <nl> + / / store locally first to ensure another thread doesn ' t clear the field between checking for null and using it . <nl> + var dispatcher = _ThreadPoolWaitCallback . dispatcher ; <nl> + if ( dispatcher ! = null ) <nl> + return dispatcher ( ThreadPoolWorkQueue . Dispatch ) ; <nl> + # endif <nl> + <nl> return ThreadPoolWorkQueue . Dispatch ( ) ; <nl> } <nl> } <nl>\n", "msg": "Add support for intercepting threadpool work .\n", "score": 1}
{"diff_id": 22548, "repo": "ppy/osu\n", "sha": "27150d6bbc484c14fd1466e3751c64149c35c53a\n", "time": "2019-12-16T08:06:52Z\n", "diff": "mmm a / osu . Game / Beatmaps / Formats / LegacyBeatmapEncoder . cs <nl> ppp b / osu . Game / Beatmaps / Formats / LegacyBeatmapEncoder . cs <nl> private void handleGeneral ( TextWriter writer ) <nl> writer . WriteLine ( FormattableString . Invariant ( $ \" AudioLeadIn : { beatmap . BeatmapInfo . AudioLeadIn } \" ) ) ; <nl> writer . WriteLine ( FormattableString . Invariant ( $ \" PreviewTime : { beatmap . Metadata . PreviewTime } \" ) ) ; <nl> / / Todo : Not all countdown types are supported by lazer yet <nl> - writer . WriteLine ( FormattableString . Invariant ( $ \" Countdown : { ( beatmap . BeatmapInfo . Countdown ? \" 1 \" : \" 0 \" ) } \" ) ) ; <nl> + writer . WriteLine ( FormattableString . Invariant ( $ \" Countdown : { ( beatmap . BeatmapInfo . Countdown ? ' 1 ' : ' 0 ' ) } \" ) ) ; <nl> writer . WriteLine ( FormattableString . Invariant ( $ \" SampleSet : { toLegacySampleBank ( beatmap . ControlPointInfo . SamplePoints [ 0 ] . SampleBank ) } \" ) ) ; <nl> writer . WriteLine ( FormattableString . Invariant ( $ \" StackLeniency : { beatmap . BeatmapInfo . StackLeniency } \" ) ) ; <nl> writer . WriteLine ( FormattableString . Invariant ( $ \" Mode : { beatmap . BeatmapInfo . RulesetID } \" ) ) ; <nl> - writer . WriteLine ( FormattableString . Invariant ( $ \" LetterboxInBreaks : { ( beatmap . BeatmapInfo . LetterboxInBreaks ? \" 1 \" : \" 0 \" ) } \" ) ) ; <nl> + writer . WriteLine ( FormattableString . Invariant ( $ \" LetterboxInBreaks : { ( beatmap . BeatmapInfo . LetterboxInBreaks ? ' 1 ' : ' 0 ' ) } \" ) ) ; <nl> / / if ( beatmap . BeatmapInfo . UseSkinSprites ) <nl> / / writer . WriteLine ( @ \" UseSkinSprites : 1 \" ) ; <nl> / / if ( b . AlwaysShowPlayfield ) <nl> private void handleGeneral ( TextWriter writer ) <nl> / / if ( b . CountdownOffset > 0 ) <nl> / / writer . WriteLine ( @ \" CountdownOffset : \" + b . CountdownOffset . ToString ( ) ) ; <nl> if ( beatmap . BeatmapInfo . RulesetID = = 3 ) <nl> - writer . WriteLine ( FormattableString . Invariant ( $ \" SpecialStyle : { ( beatmap . BeatmapInfo . SpecialStyle ? \" 1 \" : \" 0 \" ) } \" ) ) ; <nl> - writer . WriteLine ( FormattableString . Invariant ( $ \" WidescreenStoryboard : { ( beatmap . BeatmapInfo . WidescreenStoryboard ? \" 1 \" : \" 0 \" ) } \" ) ) ; <nl> + writer . WriteLine ( FormattableString . Invariant ( $ \" SpecialStyle : { ( beatmap . BeatmapInfo . SpecialStyle ? ' 1 ' : ' 0 ' ) } \" ) ) ; <nl> + writer . WriteLine ( FormattableString . Invariant ( $ \" WidescreenStoryboard : { ( beatmap . BeatmapInfo . WidescreenStoryboard ? ' 1 ' : ' 0 ' ) } \" ) ) ; <nl> / / if ( b . SamplesMatchPlaybackRate ) <nl> / / writer . WriteLine ( @ \" SamplesMatchPlaybackRate : 1 \" ) ; <nl> } <nl> private void handleTimingPoints ( TextWriter writer ) <nl> writer . Write ( FormattableString . Invariant ( $ \" { ( int ) toLegacySampleBank ( tempHitSample . Bank ) } , \" ) ) ; <nl> writer . Write ( FormattableString . Invariant ( $ \" { toLegacyCustomSampleBank ( tempHitSample . Suffix ) } , \" ) ) ; <nl> writer . Write ( FormattableString . Invariant ( $ \" { tempHitSample . Volume } , \" ) ) ; <nl> - writer . Write ( FormattableString . Invariant ( $ \" { ( timingPoint ! = null ? \" 1 \" : \" 0 \" ) } , \" ) ) ; <nl> + writer . Write ( FormattableString . Invariant ( $ \" { ( timingPoint ! = null ? ' 1 ' : ' 0 ' ) } , \" ) ) ; <nl> writer . Write ( FormattableString . Invariant ( $ \" { ( int ) effectFlags } \" ) ) ; <nl> writer . Write ( \" \\ n \" ) ; <nl> } <nl>\n", "msg": "Use char concatenation for performance\n", "score": 1}
{"diff_id": 22618, "repo": "dotnet/BenchmarkDotNet\n", "sha": "ee97ca1aaa3759342724fde3d32b3a72b0a6666d\n", "time": "2019-09-06T13:29:00Z\n", "diff": "mmm a / src / BenchmarkDotNet / Exporters / RPlotExporter . cs <nl> ppp b / src / BenchmarkDotNet / Exporters / RPlotExporter . cs <nl> public void ExportToLog ( Summary summary , ILogger logger ) <nl> throw new NotSupportedException ( ) ; <nl> } <nl> <nl> - public static bool TryFindRScript ( ILogger consoleLogger , out string rscriptPath ) <nl> + private static bool TryFindRScript ( ILogger consoleLogger , out string rscriptPath ) <nl> { <nl> string rscriptExecutable = RuntimeInformation . IsWindows ( ) ? \" Rscript . exe \" : \" Rscript \" ; <nl> rscriptPath = null ; <nl>\n", "msg": "Change access modifier to private , was not intended to be public\n", "score": 1}
{"diff_id": 23272, "repo": "ppy/osu\n", "sha": "f80cdeac5ce2e6820dd3ba4cb0c6d6530e08105c\n", "time": "2020-06-08T13:31:30Z\n", "diff": "mmm a / osu . Game / Screens / Menu / IntroWelcome . cs <nl> ppp b / osu . Game / Screens / Menu / IntroWelcome . cs <nl> private void load ( TextureStore textures ) <nl> { <nl> Anchor = Anchor . Centre , <nl> Origin = Anchor . Centre , <nl> - Scale = new Vector2 ( 0 . 5f ) , <nl> + Scale = new Vector2 ( 0 . 3f ) , <nl> + Width = 750 , <nl> + Height = 78 , <nl> + Alpha = 0 , <nl> Texture = textures . Get ( @ \" Welcome / welcome_text @ 2x \" ) <nl> } , <nl> } ; <nl> protected override void LoadComplete ( ) <nl> <nl> double remainingTime ( ) = > delay_step_two - TransformDelay ; <nl> <nl> - using ( BeginDelayedSequence ( 250 , true ) ) <nl> + using ( BeginDelayedSequence ( 0 , true ) ) <nl> { <nl> - welcomeText . FadeIn ( 700 ) ; <nl> - welcomeText . ScaleTo ( welcomeText . Scale + new Vector2 ( 0 . 5f ) , remainingTime ( ) , Easing . Out ) . OnComplete ( _ = > <nl> + welcomeText . ResizeHeightTo ( welcomeText . Height * 2 , 500 , Easing . In ) ; <nl> + welcomeText . FadeIn ( remainingTime ( ) ) ; <nl> + welcomeText . ScaleTo ( welcomeText . Scale + new Vector2 ( 0 . 1f ) , remainingTime ( ) , Easing . Out ) . OnComplete ( _ = > <nl> { <nl> elementContainer . Remove ( visualizer ) ; <nl> circleContainer . Remove ( blackCircle ) ; <nl>\n", "msg": "Change transforms to roughly match fallback visually\n", "score": 1}
{"diff_id": 23278, "repo": "QuantConnect/Lean\n", "sha": "ad1ef64acd16c48f3e36d4e377ab711573099658\n", "time": "2015-12-18T18:56:04Z\n", "diff": "mmm a / Engine / Setup / BrokerageSetupHandler . cs <nl> ppp b / Engine / Setup / BrokerageSetupHandler . cs <nl> public bool Setup ( IAlgorithm algorithm , IBrokerage brokerage , AlgorithmNodePacke <nl> algorithm . Schedule . SetEventSchedule ( realTimeHandler ) ; <nl> / / Initialise the algorithm , get the required data : <nl> algorithm . Initialize ( ) ; <nl> - / / Zero the CashBook - we ' ll populate directly from brokerage <nl> - foreach ( var kvp in algorithm . Portfolio . CashBook ) <nl> + if ( liveJob . Brokerage ! = \" PaperBrokerage \" ) <nl> { <nl> - kvp . Value . SetAmount ( 0 ) ; <nl> + / / Zero the CashBook - we ' ll populate directly from brokerage <nl> + foreach ( var kvp in algorithm . Portfolio . CashBook ) <nl> + { <nl> + kvp . Value . SetAmount ( 0 ) ; <nl> + } <nl> } <nl> } <nl> catch ( Exception err ) <nl>\n", "msg": "Don ' t zero cash balances for paper brokerages\n", "score": 1}
{"diff_id": 24079, "repo": "ShareX/ShareX\n", "sha": "f01c2b3de1f36b5f8eda2747963919c452d4aa0f\n", "time": "2015-03-26T21:30:29Z\n", "diff": "mmm a / ShareX / TaskHelpers . cs <nl> ppp b / ShareX / TaskHelpers . cs <nl> public static void OpenImageEditor ( string filePath = null ) <nl> public static void OpenImageEffects ( ) <nl> { <nl> string filePath = ImageHelpers . OpenImageFileDialog ( ) ; <nl> - <nl> + Image img = null ; <nl> if ( ! string . IsNullOrEmpty ( filePath ) ) <nl> { <nl> - Image img = ImageHelpers . LoadImage ( filePath ) ; <nl> - ImageEffectsForm form = new ImageEffectsForm ( img ) ; <nl> - form . EditorMode ( ) ; <nl> - form . Show ( ) ; <nl> + img = ImageHelpers . LoadImage ( filePath ) ; <nl> } <nl> + ImageEffectsForm form = new ImageEffectsForm ( img ) ; <nl> + form . EditorMode ( ) ; <nl> + form . Show ( ) ; <nl> } <nl> <nl> public static void OpenMonitorTest ( ) <nl>\n", "msg": "Continue to open Image Effect without image\n", "score": 1}
{"diff_id": 24726, "repo": "gitextensions/gitextensions\n", "sha": "aa61011282b2ca8756e52a1f1af9d019a5dd2f9f\n", "time": "2018-07-18T14:07:55Z\n", "diff": "mmm a / GitUI / CommandsDialogs / SettingsDialog / Pages / ChecklistSettingsPage . cs <nl> ppp b / GitUI / CommandsDialogs / SettingsDialog / Pages / ChecklistSettingsPage . cs <nl> private bool CheckGitExtensionsInstall ( ) <nl> } <nl> <nl> GitExtensionsInstall . Visible = true ; <nl> - if ( string . IsNullOrEmpty ( AppSettings . GetInstallDir ( ) ) ) <nl> + <nl> + var installDir = AppSettings . GetInstallDir ( ) ; <nl> + <nl> + if ( string . IsNullOrEmpty ( installDir ) ) <nl> { <nl> RenderSettingUnset ( GitExtensionsInstall , GitExtensionsInstall_Fix , _registryKeyGitExtensionsMissing . Text ) ; <nl> return false ; <nl> } <nl> <nl> - if ( AppSettings . GetInstallDir ( ) ! = null & & AppSettings . GetInstallDir ( ) . EndsWith ( \" . exe \" ) ) <nl> + if ( installDir . EndsWith ( \" . exe \" ) ) <nl> { <nl> RenderSettingUnset ( GitExtensionsInstall , GitExtensionsInstall_Fix , _registryKeyGitExtensionsFaulty . Text ) ; <nl> return false ; <nl>\n", "msg": "Extract variable and simplify conditions\n", "score": 1}
{"diff_id": 25035, "repo": "mono/mono\n", "sha": "b3eccc8a798847a6f405b65048acfb7ca74944d0\n", "time": "2014-11-18T09:46:15Z\n", "diff": "mmm a / mcs / class / System . Core / System / TimeZoneInfo . cs <nl> ppp b / mcs / class / System . Core / System / TimeZoneInfo . cs <nl> static TimeZoneInfo CreateLocal ( ) <nl> using ( Stream stream = GetMonoTouchData ( null ) ) { <nl> return BuildFromStream ( \" Local \" , stream ) ; <nl> } <nl> - # elif LIBC <nl> + # else <nl> + if ( IsWindows & & LocalZoneKey ! = null ) { <nl> + string name = ( string ) LocalZoneKey . GetValue ( \" TimeZoneKeyName \" ) ; <nl> + name = TrimSpecial ( name ) ; <nl> + if ( name ! = null ) <nl> + return TimeZoneInfo . FindSystemTimeZoneById ( name ) ; <nl> + } <nl> + <nl> var tz = Environment . GetEnvironmentVariable ( \" TZ \" ) ; <nl> if ( tz ! = null ) { <nl> if ( tz = = String . Empty ) <nl> static TimeZoneInfo CreateLocal ( ) <nl> return null ; <nl> } <nl> } <nl> - # else <nl> - if ( IsWindows & & LocalZoneKey ! = null ) { <nl> - string name = ( string ) LocalZoneKey . GetValue ( \" TimeZoneKeyName \" ) ; <nl> - name = TrimSpecial ( name ) ; <nl> - if ( name ! = null ) <nl> - return TimeZoneInfo . FindSystemTimeZoneById ( name ) ; <nl> - } <nl> - <nl> - return null ; <nl> # endif <nl> } <nl> <nl>\n", "msg": "Improved support for TimeZoneInfo under windows .\n", "score": 1}
{"diff_id": 25076, "repo": "dnSpy/dnSpy\n", "sha": "40ffa6e76a50f84a8a0e2346fef03ae87e7f7d9c\n", "time": "2016-08-16T17:20:25Z\n", "diff": "mmm a / dnSpy / dnSpy / Text / Editor / Search / SearchService . cs <nl> ppp b / dnSpy / dnSpy / Text / Editor / Search / SearchService . cs <nl> enum SearchKind { <nl> if ( group = = CommandConstants . TextEditorGroup ) { <nl> switch ( ( TextEditorIds ) cmdId ) { <nl> case TextEditorIds . BACKSPACE : <nl> - if ( SearchString . Length ! = 0 ) { <nl> - SearchString = SearchString . Substring ( 0 , SearchString . Length - 1 ) ; <nl> - RestartSearch ( ) ; <nl> - } <nl> + if ( SearchString . Length ! = 0 ) <nl> + SetIncrementalSearchString ( SearchString . Substring ( 0 , SearchString . Length - 1 ) ) ; <nl> return CommandTargetStatus . Handled ; <nl> <nl> case TextEditorIds . TYPECHAR : <nl> var s = args as string ; <nl> - if ( s ! = null & & s . IndexOfAny ( newLineChars ) < 0 ) { <nl> - SearchString + = s ; <nl> - RestartSearch ( ) ; <nl> - } <nl> + if ( s ! = null & & s . IndexOfAny ( newLineChars ) < 0 ) <nl> + SetIncrementalSearchString ( SearchString + s ) ; <nl> else <nl> CancelIncrementalSearch ( ) ; <nl> return CommandTargetStatus . Handled ; <nl> enum SearchKind { <nl> return CommandTargetStatus . NotHandledDontCallNextHandler ; <nl> } <nl> <nl> + void SetIncrementalSearchString ( string newSearchString ) { <nl> + isIncrementalSearchCaretMove = true ; <nl> + try { <nl> + SearchString = newSearchString ; <nl> + RestartSearch ( ) ; <nl> + } <nl> + finally { <nl> + isIncrementalSearchCaretMove = false ; <nl> + } <nl> + } <nl> + bool isIncrementalSearchCaretMove ; <nl> + <nl> bool IsSearchControlVisible = > layer ! = null & & ! layer . IsEmpty ; <nl> <nl> void ShowSearchControl ( SearchKind searchKind ) { <nl> enum SearchKind { <nl> } <nl> <nl> void Caret_PositionChanged ( object sender , CaretPositionChangedEventArgs e ) { <nl> - if ( ! isOurCaretMove ) <nl> + if ( ! isIncrementalSearchCaretMove ) <nl> CancelIncrementalSearch ( ) ; <nl> } <nl> <nl> enum SearchKind { <nl> } <nl> <nl> void ShowSearchResult ( SnapshotSpan span ) { <nl> - try { <nl> - isOurCaretMove = true ; <nl> - / / TODO : Use editorOperations . SelectAndMoveCaret ( new VirtualSnapshotPoint ( res . Value . Start ) , new VirtualSnapshotPoint ( res . Value . End ) ) ; <nl> - wpfTextView . Selection . Mode = TextSelectionMode . Stream ; <nl> - wpfTextView . Selection . Select ( new VirtualSnapshotPoint ( span . Start ) , new VirtualSnapshotPoint ( span . End ) ) ; <nl> - wpfTextView . Caret . MoveTo ( span . End ) ; <nl> - wpfTextView . Caret . EnsureVisible ( ) ; <nl> - } <nl> - finally { <nl> - isOurCaretMove = false ; <nl> - } <nl> + / / TODO : Use editorOperations . SelectAndMoveCaret ( new VirtualSnapshotPoint ( res . Value . Start ) , new VirtualSnapshotPoint ( res . Value . End ) ) ; <nl> + wpfTextView . Selection . Mode = TextSelectionMode . Stream ; <nl> + wpfTextView . Selection . Select ( new VirtualSnapshotPoint ( span . Start ) , new VirtualSnapshotPoint ( span . End ) ) ; <nl> + wpfTextView . Caret . MoveTo ( span . End ) ; <nl> + wpfTextView . Caret . EnsureVisible ( ) ; <nl> } <nl> - bool isOurCaretMove ; <nl> <nl> void SetFoundResult ( bool found ) { <nl> if ( foundSomething = = found ) <nl>\n", "msg": "Cancel inc search whenever caret moves except when we handle TYPECHAR or BACKSPACE\n", "score": 1}
{"diff_id": 25399, "repo": "ppy/osu\n", "sha": "1f80f01b53f4861a26ee8564bb7b81684cfad488\n", "time": "2020-12-24T05:46:52Z\n", "diff": "mmm a / osu . Game / Online / Spectator / FrameHeader . cs <nl> ppp b / osu . Game / Online / Spectator / FrameHeader . cs <nl> namespace osu . Game . Online . Spectator <nl> [ Serializable ] <nl> public class FrameHeader <nl> { <nl> + / / / < summary > <nl> + / / / The current accuracy of the score . <nl> + / / / < / summary > <nl> + public double Accuracy { get ; set ; } <nl> + <nl> / / / < summary > <nl> / / / The current combo of the score . <nl> / / / < / summary > <nl> public FrameHeader ( ScoreInfo score ) <nl> { <nl> Combo = score . Combo ; <nl> MaxCombo = score . MaxCombo ; <nl> + Accuracy = score . Accuracy ; <nl> <nl> / / copy for safety <nl> Statistics = new Dictionary < HitResult , int > ( score . Statistics ) ; <nl> } <nl> <nl> [ JsonConstructor ] <nl> - public FrameHeader ( int combo , int maxCombo , Dictionary < HitResult , int > statistics , DateTimeOffset receivedTime ) <nl> + public FrameHeader ( int combo , int maxCombo , double accuracy , Dictionary < HitResult , int > statistics , DateTimeOffset receivedTime ) <nl> { <nl> Combo = combo ; <nl> MaxCombo = maxCombo ; <nl> + Accuracy = accuracy ; <nl> Statistics = statistics ; <nl> ReceivedTime = receivedTime ; <nl> } <nl>\n", "msg": "Add accuracy to frame bundle header\n", "score": 1}
{"diff_id": 25705, "repo": "jellyfin/jellyfin\n", "sha": "6536c81226d5348f587119aa46635b32cc7a807e\n", "time": "2020-12-01T02:55:25Z\n", "diff": "mmm a / MediaBrowser . MediaEncoding / Probing / ProbeResultNormalizer . cs <nl> ppp b / MediaBrowser . MediaEncoding / Probing / ProbeResultNormalizer . cs <nl> private MediaStream GetMediaStream ( bool isAudio , MediaStreamInfo streamInfo , Med <nl> if ( bitrate = = 0 <nl> & & formatInfo ! = null <nl> & & ! string . IsNullOrEmpty ( formatInfo . BitRate ) <nl> - & & ( stream . Type = = MediaStreamType . Video | | stream . Type = = MediaStreamType . Audio ) ) <nl> + & & ( stream . Type = = MediaStreamType . Video | | ( isAudio & & stream . Type = = MediaStreamType . Audio ) ) ) <nl> { <nl> / / If the stream info doesn ' t have a bitrate get the value from the media format info <nl> if ( int . TryParse ( formatInfo . BitRate , NumberStyles . Any , _usCulture , out var value ) ) <nl>\n", "msg": "do not extract audio stream bitrate info for videos from formatInfo\n", "score": 1}
{"diff_id": 25923, "repo": "dotnet/aspnetcore\n", "sha": "7e1aa4e1d0990371428650d4fa723c672d0006f8\n", "time": "2016-07-14T23:08:39Z\n", "diff": "mmm a / test / Microsoft . AspNetCore . Server . Kestrel . FunctionalTests / AddressRegistrationTests . cs <nl> ppp b / test / Microsoft . AspNetCore . Server . Kestrel . FunctionalTests / AddressRegistrationTests . cs <nl> namespace Microsoft . AspNetCore . Server . Kestrel . FunctionalTests <nl> { <nl> public class AddressRegistrationTests <nl> { <nl> - <nl> [ Theory , MemberData ( nameof ( AddressRegistrationDataIPv4 ) ) ] <nl> public async Task RegisterAddresses_IPv4_Success ( string addressInput , Func < IServerAddressesFeature , string [ ] > testUrls ) <nl> { <nl> private void ThrowsWhenBindingLocalhostToAddressInUse ( AddressFamily addressFamil <nl> private static IEnumerable < IPAddress > GetIPAddresses ( ) <nl> { <nl> return NetworkInterface . GetAllNetworkInterfaces ( ) <nl> + . Where ( i = > i . OperationalStatus = = OperationalStatus . Up ) <nl> . SelectMany ( i = > i . GetIPProperties ( ) . UnicastAddresses ) <nl> . Select ( a = > a . Address ) ; <nl> } <nl>\n", "msg": "Only test binding to \" operational \" network interfaces\n", "score": 1}
{"diff_id": 26195, "repo": "ppy/osu\n", "sha": "19be111da098a03227d645ee13f75b3b42b74814\n", "time": "2020-05-31T13:33:10Z\n", "diff": "mmm a / osu . Game / Rulesets / Edit / HitObjectComposer . cs <nl> ppp b / osu . Game / Rulesets / Edit / HitObjectComposer . cs <nl> protected override void LoadComplete ( ) <nl> / / / < param name = \" ruleset \" > The ruleset used to construct its drawable counterpart . < / param > <nl> / / / < param name = \" beatmap \" > The loaded beatmap . < / param > <nl> / / / < param name = \" mods \" > The mods to be applied . < / param > <nl> - / / / < returns > An editor - relevant < see cref = \" DrawableRuleset { TObject } \" / > < / returns > . <nl> + / / / < returns > An editor - relevant < see cref = \" DrawableRuleset { TObject } \" / > . < / returns > <nl> protected virtual DrawableRuleset < TObject > CreateDrawableRuleset ( Ruleset ruleset , IBeatmap beatmap , IReadOnlyList < Mod > mods = null ) <nl> = > ( DrawableRuleset < TObject > ) ruleset . CreateDrawableRulesetWith ( beatmap , mods ) ; <nl> <nl>\n", "msg": "Move incorrect placed full stop\n", "score": 1}
{"diff_id": 26431, "repo": "ppy/osu\n", "sha": "40445d0005fe33943baf6350e8e2b35869e08643\n", "time": "2020-08-15T18:07:44Z\n", "diff": "mmm a / osu . Game . Rulesets . Osu / Objects / Drawables / DrawableSpinner . cs <nl> ppp b / osu . Game . Rulesets . Osu / Objects / Drawables / DrawableSpinner . cs <nl> protected override void LoadSamples ( ) <nl> { <nl> Volume = { Value = 0 } , <nl> Looping = true , <nl> + Frequency = { Value = 1 . 0f } <nl> } ) ; <nl> } <nl> } <nl> protected override void Update ( ) <nl> if ( HandleUserInput ) <nl> RotationTracker . Tracking = ! Result . HasResult & & ( OsuActionInputManager ? . PressedActions . Any ( x = > x = = OsuAction . LeftButton | | x = = OsuAction . RightButton ) ? ? false ) ; <nl> <nl> - if ( spinningSample ! = null ) <nl> - spinningSample . Frequency . Value = spinnerFrequencyModulate ? 0 . 5f + Progress : 0 . 5f ; <nl> + if ( spinningSample ! = null & & spinnerFrequencyModulate ) <nl> + spinningSample . Frequency . Value = 0 . 5f + Progress ; <nl> } <nl> <nl> protected override void UpdateAfterChildren ( ) <nl>\n", "msg": "replicate osu - stable behaviour for spinningSample frequency\n", "score": 1}
{"diff_id": 26567, "repo": "MahApps/MahApps.Metro\n", "sha": "62ce22de8db3f2939bd9d3954f6cbf845850632e\n", "time": "2012-04-24T10:26:15Z\n", "diff": "mmm a / MahApps . Metro / Controls / MetroWindow . cs <nl> ppp b / MahApps . Metro / Controls / MetroWindow . cs <nl> protected override void OnStateChanged ( EventArgs e ) <nl> base . OnStateChanged ( e ) ; <nl> } <nl> <nl> - private void TitleBarMouseDown ( object sender , MouseButtonEventArgs e ) <nl> + protected void TitleBarMouseDown ( object sender , MouseButtonEventArgs e ) <nl> { <nl> if ( e . RightButton ! = MouseButtonState . Pressed & & e . MiddleButton ! = MouseButtonState . Pressed & & e . LeftButton = = MouseButtonState . Pressed ) <nl> DragMove ( ) ; <nl> private void TitleBarMouseDown ( object sender , MouseButtonEventArgs e ) <nl> } <nl> } <nl> <nl> - private void TitleBarMouseUp ( object sender , MouseButtonEventArgs e ) <nl> + protected void TitleBarMouseMove ( object sender , MouseEventArgs e ) <nl> { <nl> if ( ! ShowIconOnTitleBar ) return ; <nl> var mousePosition = GetCorrectPosition ( this ) ; <nl>\n", "msg": "reverting changes to access levels of some functions\n", "score": 1}
{"diff_id": 26638, "repo": "MaterialDesignInXAML/MaterialDesignInXamlToolkit\n", "sha": "11984354adbcc463efad6caad552c7a6438a1da4\n", "time": "2015-10-27T13:01:00Z\n", "diff": "mmm a / MaterialDesignThemes . Wpf / PaletteHelper . cs <nl> ppp b / MaterialDesignThemes . Wpf / PaletteHelper . cs <nl> public enum ACLineStatus : byte <nl> { <nl> Offline = 0 , Online = 1 , Unknown = 255 <nl> } <nl> - <nl> + public static bool DisableAnimationOnBattery = true <nl> / / / < summary > <nl> / / / Replaces a certain entry anywhere in the parent dictionary and its merged dictionaries <nl> / / / < / summary > <nl> private static bool ReplaceEntry ( object entryName , object newValue , ResourceDict <nl> <nl> if ( parentDictionary . Contains ( entryName ) ) <nl> { <nl> - if ( animate & parentDictionary [ entryName ] ! = null & GetPowerState ( ) . ACLineStatus = = ACLineStatus . Online & parentDictionary [ entryName ] as SolidColorBrush ! = null ) / / Fade animation is enabled , type is solidcolorbrush and value is not null . <nl> + bool battery = GetPowerState ( ) . ACLineStatus = = ACLineStatus . Online | ! DisableAnimationOnBattery ; <nl> + if ( animate & parentDictionary [ entryName ] ! = null & battery & parentDictionary [ entryName ] as SolidColorBrush ! = null ) / / Fade animation is enabled , type is solidcolorbrush and value is not null . <nl> { <nl> ColorAnimation animation = new ColorAnimation ( ) <nl> { <nl>\n", "msg": "Added ability to config disable on battery\n", "score": 1}
{"diff_id": 27488, "repo": "gitextensions/gitextensions\n", "sha": "dbf705fe1d1efac72ccb783cab1edfa4d9f831d7\n", "time": "2013-01-29T21:53:46Z\n", "diff": "mmm a / GitUI / SettingsDialog / SettingsPageBase . cs <nl> ppp b / GitUI / SettingsDialog / SettingsPageBase . cs <nl> public virtual void SaveSettings ( ) <nl> / / to be overridden <nl> } <nl> <nl> + IList < string > childrenText ; <nl> + <nl> / / / < summary > <nl> / / / override to provide search keywords <nl> / / / < / summary > <nl> public virtual IEnumerable < string > GetSearchKeywords ( ) <nl> { <nl> - / / split at comma and return a list of trimmed strings <nl> - return GetCommaSeparatedKeywordList ( ) <nl> - . Split ( new string [ ] { \" , \" } , StringSplitOptions . RemoveEmptyEntries ) <nl> - . Select ( s = > s . Trim ( ) ) ; <nl> + return childrenText ? ? ( childrenText = GetChildrenText ( this ) ) ; <nl> + } <nl> + <nl> + static IList < string > GetChildrenText ( Control control ) <nl> + { <nl> + if ( control . HasChildren = = false ) { return new string [ 0 ] ; } <nl> + <nl> + List < string > texts = new List < string > ( ) ; <nl> + foreach ( Control child in control . Controls ) <nl> + { <nl> + texts . Add ( child . Text ) ; <nl> + texts . AddRange ( GetChildrenText ( child ) ) ; <nl> + } <nl> + return texts ; <nl> } <nl> <nl> protected virtual string GetCommaSeparatedKeywordList ( ) <nl>\n", "msg": "recurse child Controls and use for search keywords ;\n", "score": 1}
{"diff_id": 27508, "repo": "ppy/osu\n", "sha": "45729a8881dab10347765ed7375d5b84e5484a1b\n", "time": "2017-04-28T11:44:16Z\n", "diff": "mmm a / osu . Game / Screens / Select / SongSelect . cs <nl> ppp b / osu . Game / Screens / Select / SongSelect . cs <nl> <nl> using osu . Framework . Graphics . Primitives ; <nl> using osu . Framework . Input ; <nl> using osu . Framework . Screens ; <nl> + using osu . Framework . Threading ; <nl> using osu . Game . Beatmaps ; <nl> using osu . Game . Beatmaps . Drawables ; <nl> using osu . Game . Database ; <nl> protected override void OnBeatmapChanged ( WorkingBeatmap beatmap ) <nl> carousel . SelectBeatmap ( beatmap ? . BeatmapInfo ) ; <nl> } <nl> <nl> + ScheduledDelegate selectionChangedDebounce ; <nl> + <nl> + / / We need to keep track of the last selected beatmap ignoring debounce to play the correct selection sounds . <nl> + private BeatmapInfo selectionChangeNoBounce ; <nl> + <nl> / / / < summary > <nl> / / / selection has been changed as the result of interaction with the carousel . <nl> / / / < / summary > <nl> private void selectionChanged ( BeatmapInfo beatmap ) <nl> <nl> if ( ! beatmap . Equals ( Beatmap ? . BeatmapInfo ) ) <nl> { <nl> - if ( beatmap . BeatmapSetInfoID = = Beatmap ? . BeatmapInfo . BeatmapSetInfoID ) <nl> + if ( beatmap . BeatmapSetInfoID = = selectionChangeNoBounce ? . BeatmapSetInfoID ) <nl> sampleChangeDifficulty . Play ( ) ; <nl> else <nl> { <nl> sampleChangeBeatmap . Play ( ) ; <nl> beatmapSetChange = true ; <nl> } <nl> - Beatmap = database . GetWorkingBeatmap ( beatmap , Beatmap ) ; <nl> } <nl> - ensurePlayingSelected ( beatmapSetChange ) ; <nl> + <nl> + selectionChangeNoBounce = beatmap ; <nl> + <nl> + selectionChangedDebounce ? . Cancel ( ) ; <nl> + selectionChangedDebounce = Scheduler . AddDelayed ( delegate <nl> + { <nl> + Beatmap = database . GetWorkingBeatmap ( beatmap , Beatmap ) ; <nl> + ensurePlayingSelected ( beatmapSetChange ) ; <nl> + } , 100 ) ; <nl> } <nl> <nl> private void ensurePlayingSelected ( bool preview = false ) <nl>\n", "msg": "Add debounce to WorkingBeatmap creation at song select .\n", "score": 1}
{"diff_id": 27624, "repo": "dotnet/reactive\n", "sha": "694b719fad3e0de8aa4754c25d23b210f85424c8\n", "time": "2018-07-08T17:14:01Z\n", "diff": "mmm a / Rx . NET / Source / src / System . Reactive / Linq / Observable / AppendPrepend . cs <nl> ppp b / Rx . NET / Source / src / System . Reactive / Linq / Observable / AppendPrepend . cs <nl> internal sealed class _ : IdentitySink < TSource > <nl> private readonly TSource [ ] _appends ; <nl> private readonly IScheduler _scheduler ; <nl> private IDisposable _schedulerDisposable ; <nl> + private volatile bool _disposed ; <nl> <nl> public _ ( AppendPrependMultiple < TSource > parent , IObserver < TSource > observer ) <nl> : base ( observer ) <nl> protected override void Dispose ( bool disposing ) <nl> { <nl> if ( disposing ) <nl> { <nl> + _disposed = true ; <nl> Disposable . TryDispose ( ref _schedulerDisposable ) ; <nl> } <nl> + <nl> base . Dispose ( disposing ) ; <nl> } <nl> <nl> private IDisposable Schedule ( TSource [ ] array , Action < _ > continueWith ) <nl> / / to observe the cancellation and perform proper clean - up . In this case , <nl> / / we ' re sure Loop will be entered , allowing us to dispose the enumerator . <nl> / / <nl> - return longRunning . ScheduleLongRunning ( new State ( null , this , array , continueWith ) , Loop ) ; <nl> + return longRunning . ScheduleLongRunning ( new State ( this , array , continueWith ) , Loop ) ; <nl> + } <nl> + else <nl> + { <nl> + / / <nl> + / / We never allow the scheduled work to be cancelled . Instead , the _disposed flag <nl> + / / is used to have LoopRec bail out and perform proper clean - up of the <nl> + / / enumerator . <nl> + / / <nl> + _scheduler . Schedule ( new State ( this , array , continueWith ) , ( innerScheduler , state ) = > state . _sink . LoopRec ( innerScheduler , state ) ) ; <nl> + return Disposable . Empty ; <nl> } <nl> - <nl> - / / <nl> - / / We never allow the scheduled work to be cancelled . Instead , the flag <nl> - / / is used to have LoopRec bail out and perform proper clean - up of the <nl> - / / enumerator . <nl> - / / <nl> - var flag = new BooleanDisposable ( ) ; <nl> - _scheduler . Schedule ( new State ( flag , this , array , continueWith ) , LoopRec ) ; <nl> - return flag ; <nl> } <nl> <nl> private struct State <nl> { <nl> public readonly _ _sink ; <nl> - public readonly ICancelable _flag ; <nl> public readonly TSource [ ] _array ; <nl> public readonly Action < _ > _continue ; <nl> public int _current ; <nl> <nl> - public State ( ICancelable flag , _ sink , TSource [ ] array , Action < _ > c ) <nl> + public State ( _ sink , TSource [ ] array , Action < _ > c ) <nl> { <nl> _sink = sink ; <nl> - _flag = flag ; <nl> _continue = c ; <nl> _array = array ; <nl> _current = 0 ; <nl> } <nl> } <nl> <nl> - private void LoopRec ( State state , Action < State > recurse ) <nl> + private IDisposable LoopRec ( IScheduler scheduler , State state ) <nl> { <nl> - if ( state . _flag . IsDisposed ) <nl> + if ( _disposed ) <nl> { <nl> - return ; <nl> + return Disposable . Empty ; <nl> } <nl> <nl> var current = state . _array [ state . _current ] ; <nl> private void LoopRec ( State state , Action < State > recurse ) <nl> if ( state . _current = = state . _array . Length ) <nl> { <nl> state . _continue ( state . _sink ) ; <nl> - return ; <nl> + } <nl> + else <nl> + { <nl> + / / <nl> + / / We never allow the scheduled work to be cancelled . Instead , the _disposed flag <nl> + / / is used to have LoopRec bail out and perform proper clean - up of the <nl> + / / enumerator . <nl> + / / <nl> + scheduler . Schedule ( state , ( innerScheduler , s ) = > s . _sink . LoopRec ( innerScheduler , s ) ) ; <nl> } <nl> <nl> - recurse ( state ) ; <nl> + return Disposable . Empty ; <nl> } <nl> <nl> private void Loop ( State state , ICancelable cancel ) <nl> private void Loop ( State state , ICancelable cancel ) <nl> <nl> private sealed class Node < T > <nl> { <nl> - private readonly Node < T > _parent ; <nl> - private readonly T _value ; <nl> - private readonly int _count ; <nl> + public readonly Node < T > Parent ; <nl> + public readonly T Value ; <nl> + public readonly int Count ; <nl> <nl> public Node ( T value ) <nl> : this ( null , value ) <nl> public Node ( T value ) <nl> <nl> public Node ( Node < T > parent , T value ) <nl> { <nl> - _parent = parent ; <nl> - _value = value ; <nl> + Parent = parent ; <nl> + Value = value ; <nl> <nl> if ( parent = = null ) <nl> { <nl> - _count = 1 ; <nl> + Count = 1 ; <nl> } <nl> else <nl> { <nl> - if ( parent . _count = = int . MaxValue ) <nl> + if ( parent . Count = = int . MaxValue ) <nl> { <nl> throw new NotSupportedException ( $ \" Consecutive appends or prepends with a count of more than int . MaxValue ( { int . MaxValue } ) are not supported . \" ) ; <nl> } <nl> <nl> - _count = parent . _count + 1 ; <nl> + Count = parent . Count + 1 ; <nl> } <nl> } <nl> <nl> public T [ ] ToArray ( ) <nl> { <nl> - var array = new T [ _count ] ; <nl> + var array = new T [ Count ] ; <nl> var current = this ; <nl> - for ( var i = 0 ; i < _count ; i + + ) <nl> + for ( var i = 0 ; i < Count ; i + + ) <nl> { <nl> - array [ i ] = current . _value ; <nl> - current = current . _parent ; <nl> + array [ i ] = current . Value ; <nl> + current = current . Parent ; <nl> } <nl> return array ; <nl> } <nl> <nl> public T [ ] ToReverseArray ( ) <nl> { <nl> - var array = new T [ _count ] ; <nl> + var array = new T [ Count ] ; <nl> var current = this ; <nl> - for ( var i = _count - 1 ; i > = 0 ; i - - ) <nl> + for ( var i = Count - 1 ; i > = 0 ; i - - ) <nl> { <nl> - array [ i ] = current . _value ; <nl> - current = current . _parent ; <nl> + array [ i ] = current . Value ; <nl> + current = current . Parent ; <nl> } <nl> return array ; <nl> } <nl>\n", "msg": "Use a light recurring scheduling , similar to the ` ToObservable ( ) ` class\n", "score": 1}
{"diff_id": 28025, "repo": "ppy/osu\n", "sha": "ad1dccf6ceca2707c607bc9905add924cc556006\n", "time": "2016-11-07T13:25:37Z\n", "diff": "mmm a / osu . Game / Overlays / MusicController . cs <nl> ppp b / osu . Game / Overlays / MusicController . cs <nl> public class MusicController : OverlayContainer <nl> private Texture fallbackTexture ; <nl> <nl> private List < BeatmapSetInfo > playList ; <nl> - private List < BeatmapInfo > playHistory ; <nl> + private List < BeatmapInfo > playHistory = new List < BeatmapInfo > ( ) ; <nl> private int playListIndex ; <nl> - private int playHistoryIndex ; <nl> + private int playHistoryIndex = - 1 ; <nl> <nl> private TrackManager trackManager ; <nl> private BeatmapDatabase database ; <nl> private void workingChanged ( object sender = null , EventArgs e = null ) <nl> updateCurrent ( current , null ) ; <nl> } <nl> <nl> - private int findInPlaylist ( Beatmap beatmap ) <nl> + private void appendToHistory ( BeatmapInfo beatmap ) <nl> { <nl> - if ( beatmap = = null ) return - 1 ; <nl> - for ( int i = 0 ; i < playList . Count ; i + + ) <nl> - if ( beatmap . BeatmapInfo . BeatmapSetID = = playList [ i ] . BeatmapSetID ) <nl> - return i ; <nl> - return - 1 ; <nl> + if ( playHistoryIndex > = 0 ) <nl> + { <nl> + BeatmapInfo stackHead = playHistory [ playHistoryIndex ] ; <nl> + if ( beatmap . BeatmapSet . Path = = stackHead . BeatmapSet . Path & & beatmap . Metadata . AudioFile = = stackHead . Metadata . AudioFile ) <nl> + return ; <nl> + if ( playHistoryIndex < playHistory . Count - 1 ) <nl> + playHistory . RemoveRange ( playHistoryIndex + 1 , playHistory . Count - playHistoryIndex - 1 ) ; <nl> + } <nl> + playHistory . Insert ( + + playHistoryIndex , beatmap ) ; <nl> } <nl> <nl> private void prev ( ) <nl> { <nl> - int i = findInPlaylist ( current ? . Beatmap ) ; <nl> - if ( i = = - 1 ) <nl> - { <nl> - if ( playList . Count > 0 ) <nl> - play ( playList [ 0 ] . Beatmaps [ 0 ] , null ) ; <nl> - else return ; <nl> - } <nl> - i = ( i - 1 + playList . Count ) % playList . Count ; <nl> - play ( playList [ i ] . Beatmaps [ 0 ] , false ) ; <nl> + if ( playHistoryIndex > 0 ) <nl> + play ( playHistory [ - - playHistoryIndex ] , false ) ; <nl> } <nl> <nl> private void next ( ) <nl> { <nl> - int i = findInPlaylist ( current ? . Beatmap ) ; <nl> - if ( i = = - 1 ) <nl> + if ( playHistoryIndex < playHistory . Count - 1 ) <nl> + play ( playHistory [ + + playHistoryIndex ] , true ) ; <nl> + else <nl> { <nl> - if ( playList . Count > 0 ) <nl> - play ( playList [ 0 ] . Beatmaps [ 0 ] , null ) ; <nl> - else return ; <nl> + BeatmapInfo nextToPlay = playList [ playListIndex + + ] . Beatmaps [ 0 ] ; <nl> + if ( playListIndex = = playList . Count ) playListIndex = 0 ; <nl> + play ( nextToPlay , true ) ; <nl> + appendToHistory ( nextToPlay ) ; <nl> } <nl> - i = ( i + 1 ) % playList . Count ; <nl> - play ( playList [ i ] . Beatmaps [ 0 ] , true ) ; <nl> } <nl> <nl> private void play ( BeatmapInfo info , bool ? isNext ) <nl>\n", "msg": "Use play history for back and forward .\n", "score": 1}
{"diff_id": 28269, "repo": "ServiceStack/ServiceStack\n", "sha": "c09e2c06843bda82ae5b864cdef0bef6749a8191\n", "time": "2020-11-04T11:16:56Z\n", "diff": "mmm a / src / ServiceStack . Server / AutoQueryFeature . AutoCrud . cs <nl> ppp b / src / ServiceStack . Server / AutoQueryFeature . AutoCrud . cs <nl> <nl> using ServiceStack . Configuration ; <nl> using ServiceStack . MiniProfiler ; <nl> using ServiceStack . Data ; <nl> - using ServiceStack . DataAnnotations ; <nl> - using ServiceStack . Model ; <nl> using ServiceStack . OrmLite ; <nl> using ServiceStack . Text ; <nl> using ServiceStack . Web ; <nl> public partial class AutoQueryFeature <nl> { typeof ( CheckCrudEventService ) , new [ ] { \" / \" + \" crudevents \" . Localize ( ) + \" / check \" } } , <nl> } ; <nl> <nl> + public Action < CrudContext > OnBeforeCreate { get ; set ; } <nl> + public Func < CrudContext , Task > OnBeforeCreateAsync { get ; set ; } <nl> + public Action < CrudContext > OnAfterCreate { get ; set ; } <nl> + public Func < CrudContext , Task > OnAfterCreateAsync { get ; set ; } <nl> + <nl> + public Action < CrudContext > OnBeforePatch { get ; set ; } <nl> + public Func < CrudContext , Task > OnBeforePatchAsync { get ; set ; } <nl> + public Action < CrudContext > OnAfterPatch { get ; set ; } <nl> + public Func < CrudContext , Task > OnAfterPatchAsync { get ; set ; } <nl> + <nl> + public Action < CrudContext > OnBeforeUpdate { get ; set ; } <nl> + public Func < CrudContext , Task > OnBeforeUpdateAsync { get ; set ; } <nl> + public Action < CrudContext > OnAfterUpdate { get ; set ; } <nl> + public Func < CrudContext , Task > OnAfterUpdateAsync { get ; set ; } <nl> + <nl> + public Action < CrudContext > OnBeforeDelete { get ; set ; } <nl> + public Func < CrudContext , Task > OnBeforeDeleteAsync { get ; set ; } <nl> + public Action < CrudContext > OnAfterDelete { get ; set ; } <nl> + public Func < CrudContext , Task > OnAfterDeleteAsync { get ; set ; } <nl> + <nl> protected void OnRegister ( IAppHost appHost ) <nl> { <nl> if ( AccessRole ! = null & & appHost . GetContainer ( ) . Exists < ICrudEvents > ( ) ) <nl> public class CrudContext <nl> <nl> public object Id { get ; set ; } <nl> <nl> + public object Response { get ; set ; } <nl> + <nl> public long ? RowsUpdated { get ; set ; } <nl> <nl> internal void SetResult ( AutoQuery . ExecValue result ) <nl> public void Add ( AutoFilterAttribute filterAttr ) <nl> AutoFiltersDbFields . Add ( ExprResult . ToDbFieldAttribute ( filterAttr ) ) ; <nl> } <nl> } <nl> - <nl> + <nl> public partial class AutoQuery : IAutoCrudDb <nl> { <nl> public static HashSet < string > IgnoreCrudProperties { get ; } = new HashSet < string > { <nl> public object Create < Table > ( ICreateDb < Table > dto , IRequest req ) <nl> using var db = GetDb < Table > ( req ) ; <nl> using var profiler = Profiler . Current . Step ( \" AutoQuery . Create \" ) ; <nl> <nl> - var response = ExecAndReturnResponse < Table > ( CrudContext . Create < Table > ( req , db , dto , AutoCrudOperation . Create ) , <nl> + var ctx = CrudContext . Create < Table > ( req , db , dto , AutoCrudOperation . Create ) ; <nl> + var feature = HostContext . GetPlugin < AutoQueryFeature > ( ) ; <nl> + feature . OnBeforeCreate ? . Invoke ( ctx ) ; <nl> + <nl> + ctx . Response = ExecAndReturnResponse < Table > ( ctx , <nl> ctx = > { <nl> var dtoValues = ResolveDtoValues ( req , dto ) ; <nl> var pkField = ctx . ModelDef . PrimaryKey ; <nl> public object Create < Table > ( ICreateDb < Table > dto , IRequest req ) <nl> var autoIntId = db . Insert < Table > ( dtoValues , selectIdentity : selectIdentity ) ; <nl> return CreateInternal ( dtoValues , pkField , selectIdentity , autoIntId ) ; <nl> } ) ; <nl> - <nl> - return response ; <nl> + <nl> + feature . OnAfterCreate ? . Invoke ( ctx ) ; <nl> + return ctx . Response ; <nl> } <nl> <nl> public async Task < object > CreateAsync < Table > ( ICreateDb < Table > dto , IRequest req ) <nl> public async Task < object > CreateAsync < Table > ( ICreateDb < Table > dto , IRequest req ) <nl> using var db = GetDb < Table > ( req ) ; <nl> using var profiler = Profiler . Current . Step ( \" AutoQuery . Create \" ) ; <nl> <nl> - var response = await ExecAndReturnResponseAsync < Table > ( CrudContext . Create < Table > ( req , db , dto , AutoCrudOperation . Create ) , <nl> + var ctx = CrudContext . Create < Table > ( req , db , dto , AutoCrudOperation . Create ) ; <nl> + var feature = HostContext . GetPlugin < AutoQueryFeature > ( ) ; <nl> + if ( feature . OnBeforeCreateAsync ! = null ) <nl> + await feature . OnBeforeCreateAsync ( ctx ) ; <nl> + <nl> + ctx . Response = await ExecAndReturnResponseAsync < Table > ( ctx , <nl> async ctx = > { <nl> var dtoValues = ResolveDtoValues ( ctx . Request , ctx . Dto ) ; <nl> var pkField = ctx . ModelDef . PrimaryKey ; <nl> public async Task < object > CreateAsync < Table > ( ICreateDb < Table > dto , IRequest req ) <nl> var autoIntId = await db . InsertAsync < Table > ( dtoValues , selectIdentity : selectIdentity ) . ConfigAwait ( ) ; <nl> return CreateInternal ( dtoValues , pkField , selectIdentity , autoIntId ) ; <nl> } ) . ConfigAwait ( ) ; <nl> - <nl> - return response ; <nl> + <nl> + if ( feature . OnAfterCreateAsync ! = null ) <nl> + await feature . OnAfterCreateAsync ( ctx ) ; <nl> + return ctx . Response ; <nl> } <nl> <nl> private static ExecValue CreateInternal ( Dictionary < string , object > dtoValues , <nl> private object UpdateInternal < Table > ( IRequest req , object dto , string operation ) <nl> using var db = GetDb < Table > ( req ) ; <nl> using ( Profiler . Current . Step ( \" AutoQuery . Update \" ) ) <nl> { <nl> - var response = ExecAndReturnResponse < Table > ( CrudContext . Create < Table > ( req , db , dto , operation ) , <nl> + var ctx = CrudContext . Create < Table > ( req , db , dto , operation ) ; <nl> + <nl> + var feature = HostContext . GetPlugin < AutoQueryFeature > ( ) ; <nl> + if ( skipDefaults ) <nl> + feature . OnBeforePatch ? . Invoke ( ctx ) ; <nl> + else <nl> + feature . OnBeforeUpdate ? . Invoke ( ctx ) ; <nl> + <nl> + ctx . Response = ExecAndReturnResponse < Table > ( ctx , <nl> ctx = > { <nl> var dtoValues = ResolveDtoValues ( req , dto , skipDefaults ) ; <nl> var pkField = ctx . ModelDef ? . PrimaryKey ; <nl> private object UpdateInternal < Table > ( IRequest req , object dto , string operation ) <nl> return new ExecValue ( idValue , rowsUpdated ) ; <nl> } ) ; / / TODO : UpdateOnly <nl> <nl> - return response ; <nl> + if ( skipDefaults ) <nl> + feature . OnAfterPatch ? . Invoke ( ctx ) ; <nl> + else <nl> + feature . OnAfterUpdate ? . Invoke ( ctx ) ; <nl> + <nl> + return ctx . Response ; <nl> } <nl> } <nl> <nl> private async Task < object > UpdateInternalAsync < Table > ( IRequest req , object dto , <nl> using var db = GetDb < Table > ( req ) ; <nl> using ( Profiler . Current . Step ( \" AutoQuery . Update \" ) ) <nl> { <nl> - var response = await ExecAndReturnResponseAsync < Table > ( CrudContext . Create < Table > ( req , db , dto , operation ) , <nl> + var ctx = CrudContext . Create < Table > ( req , db , dto , operation ) ; <nl> + <nl> + var feature = HostContext . GetPlugin < AutoQueryFeature > ( ) ; <nl> + if ( skipDefaults ) <nl> + { <nl> + if ( feature . OnBeforePatchAsync ! = null ) <nl> + await feature . OnBeforePatchAsync ( ctx ) ; <nl> + } <nl> + else <nl> + { <nl> + if ( feature . OnBeforeUpdateAsync ! = null ) <nl> + await feature . OnBeforeUpdateAsync ( ctx ) ; <nl> + } <nl> + <nl> + ctx . Response = await ExecAndReturnResponseAsync < Table > ( ctx , <nl> async ctx = > { <nl> var dtoValues = ResolveDtoValues ( req , dto , skipDefaults ) ; <nl> var pkField = ctx . ModelDef ? . PrimaryKey ; <nl> private async Task < object > UpdateInternalAsync < Table > ( IRequest req , object dto , <nl> return new ExecValue ( idValue , rowsUpdated ) ; <nl> } ) . ConfigAwait ( ) ; / / TODO : UpdateOnly <nl> <nl> - return response ; <nl> + if ( skipDefaults ) <nl> + { <nl> + if ( feature . OnAfterPatchAsync ! = null ) <nl> + await feature . OnAfterPatchAsync ( ctx ) ; <nl> + } <nl> + else <nl> + { <nl> + if ( feature . OnAfterUpdateAsync ! = null ) <nl> + await feature . OnAfterUpdateAsync ( ctx ) ; <nl> + } <nl> + <nl> + return ctx . Response ; <nl> } <nl> } <nl> <nl> public object Delete < Table > ( IDeleteDb < Table > dto , IRequest req ) <nl> <nl> var meta = AutoCrudMetadata . Create ( dto . GetType ( ) ) ; <nl> if ( meta . SoftDelete ) <nl> - return UpdateInternal < Table > ( req , dto , AutoCrudOperation . Patch ) ; <nl> - <nl> - var response = ExecAndReturnResponse < Table > ( CrudContext . Create < Table > ( req , db , dto , AutoCrudOperation . Delete ) , <nl> + return PartialUpdate < Table > ( dto , req ) ; <nl> + <nl> + var ctx = CrudContext . Create < Table > ( req , db , dto , AutoCrudOperation . Delete ) ; <nl> + var feature = HostContext . GetPlugin < AutoQueryFeature > ( ) ; <nl> + feature . OnBeforeDelete ? . Invoke ( ctx ) ; <nl> + <nl> + ctx . Response = ExecAndReturnResponse < Table > ( ctx , <nl> ctx = > { <nl> var dtoValues = ResolveDtoValues ( ctx . Request , ctx . Dto , skipDefaults : true ) ; <nl> var idValue = ctx . ModelDef . PrimaryKey ! = null & & dtoValues . TryGetValue ( ctx . ModelDef . PrimaryKey . Name , out var oId ) <nl> public object Delete < Table > ( IDeleteDb < Table > dto , IRequest req ) <nl> return new ExecValue ( idValue , ctx . Db . Delete < Table > ( dtoValues ) ) ; <nl> } ) ; <nl> <nl> - return response ; <nl> + feature . OnAfterDelete ? . Invoke ( ctx ) ; <nl> + return ctx . Response ; <nl> } <nl> <nl> public async Task < object > DeleteAsync < Table > ( IDeleteDb < Table > dto , IRequest req ) <nl> public async Task < object > DeleteAsync < Table > ( IDeleteDb < Table > dto , IRequest req ) <nl> var meta = AutoCrudMetadata . Create ( dto . GetType ( ) ) ; <nl> if ( meta . SoftDelete ) <nl> return await UpdateInternalAsync < Table > ( req , dto , AutoCrudOperation . Patch ) . ConfigAwait ( ) ; <nl> + <nl> + var ctx = CrudContext . Create < Table > ( req , db , dto , AutoCrudOperation . Delete ) ; <nl> + var feature = HostContext . GetPlugin < AutoQueryFeature > ( ) ; <nl> + if ( feature . OnBeforeDeleteAsync ! = null ) <nl> + await feature . OnBeforeDeleteAsync ( ctx ) ; <nl> <nl> - var response = await ExecAndReturnResponseAsync < Table > ( CrudContext . Create < Table > ( req , db , dto , AutoCrudOperation . Delete ) , <nl> + ctx . Response = await ExecAndReturnResponseAsync < Table > ( ctx , <nl> async ctx = > { <nl> var dtoValues = ResolveDtoValues ( req , dto , skipDefaults : true ) ; <nl> var idValue = ctx . ModelDef . PrimaryKey ! = null & & dtoValues . TryGetValue ( ctx . ModelDef . PrimaryKey . Name , out var oId ) <nl> public async Task < object > DeleteAsync < Table > ( IDeleteDb < Table > dto , IRequest req ) <nl> return new ExecValue ( idValue , await ctx . Db . DeleteAsync < Table > ( dtoValues ) . ConfigAwait ( ) ) ; <nl> } ) . ConfigAwait ( ) ; <nl> <nl> - return response ; <nl> + if ( feature . OnAfterDeleteAsync ! = null ) <nl> + await feature . OnAfterDeleteAsync ( ctx ) ; <nl> + <nl> + return ctx . Response ; <nl> } <nl> <nl> internal SqlExpression < Table > DeleteInternal < Table > ( CrudContext ctx , Dictionary < string , object > dtoValues ) <nl>\n", "msg": "Add OnBefore / After events for each AutoCrud operation\n", "score": 1}
{"diff_id": 28597, "repo": "dnSpy/dnSpy\n", "sha": "37e14715df4a4f904c2a4d10140aa769d6169fa3\n", "time": "2016-06-16T20:17:25Z\n", "diff": "mmm a / dnSpy / dnSpy / Search / SearchToolWindowContent . cs <nl> ppp b / dnSpy / dnSpy / Search / SearchToolWindowContent . cs <nl> sealed class SearchToolCommandLoader : IAutoLoaded { <nl> sealed class SearchToolWindowContentCreator : IMainToolWindowContentCreator { <nl> readonly Lazy < ISearchManager > searchManager ; <nl> <nl> - public SearchToolWindowContent SearchToolWindowContent = > searchToolWindowContent ? ? ( searchToolWindowContent = new SearchToolWindowContent ( searchManager ) ) ; <nl> + SearchToolWindowContent SearchToolWindowContent = > searchToolWindowContent ? ? ( searchToolWindowContent = new SearchToolWindowContent ( searchManager ) ) ; <nl> SearchToolWindowContent searchToolWindowContent ; <nl> <nl> [ ImportingConstructor ] <nl> sealed class SearchToolWindowContentCreator : IMainToolWindowContentCreator { <nl> } <nl> <nl> sealed class SearchToolWindowContent : IToolWindowContent , IFocusable { <nl> - public static readonly Guid THE_GUID = new Guid ( \" 91802684 - 9D1F - 4491 - 90FD - AFE1DE7C4D46 \" ) ; <nl> - public const AppToolWindowLocation DEFAULT_LOCATION = AppToolWindowLocation . Top ; <nl> + public static readonly Guid THE_GUID = new Guid ( \" 8E359BE0 - C8CD - 4CA7 - B228 - 8C836219AF85 \" ) ; <nl> + public const AppToolWindowLocation DEFAULT_LOCATION = AppToolWindowLocation . DefaultHorizontal ; <nl> <nl> public IInputElement FocusedElement = > searchManager . Value . FocusedElement ; <nl> public FrameworkElement ScaleElement = > searchManager . Value . ScaleElement ; <nl>\n", "msg": "Move search tool window to bottom location by default\n", "score": 1}
{"diff_id": 28827, "repo": "ppy/osu\n", "sha": "246812e0b1b550c0bebb63739ad67a4b45f0f124\n", "time": "2020-05-13T09:54:45Z\n", "diff": "mmm a / osu . Game / Graphics / UserInterfaceV2 / DirectorySelector . cs <nl> ppp b / osu . Game / Graphics / UserInterfaceV2 / DirectorySelector . cs <nl> private void load ( ) <nl> <nl> private class ComputerRow : CurrentDisplayRow <nl> { <nl> - public override IconUsage ? Icon = > null ; <nl> + protected override IconUsage ? Icon = > null ; <nl> <nl> public ComputerRow ( ) <nl> : base ( null , \" Computer \" ) <nl> private void load ( ) <nl> Size = new Vector2 ( FONT_SIZE / 2 ) <nl> } ) ; <nl> } <nl> + <nl> + protected override IconUsage ? Icon = > Directory . Name . Contains ( \" / \" ) ? base . Icon : null ; <nl> } <nl> } <nl> <nl> private class ParentDirectoryRow : DirectoryRow <nl> { <nl> - public override IconUsage ? Icon = > FontAwesome . Solid . Folder ; <nl> + protected override IconUsage ? Icon = > FontAwesome . Solid . Folder ; <nl> <nl> public ParentDirectoryRow ( DirectoryInfo directory ) <nl> : base ( directory , \" . . \" ) <nl> private class DirectoryRow : CompositeDrawable <nl> <nl> protected const float FONT_SIZE = 16 ; <nl> <nl> - private readonly DirectoryInfo directory ; <nl> + protected readonly DirectoryInfo Directory ; <nl> + <nl> private readonly string displayName ; <nl> <nl> protected FillFlowContainer Flow ; <nl> private class DirectoryRow : CompositeDrawable <nl> <nl> public DirectoryRow ( DirectoryInfo directory , string displayName = null ) <nl> { <nl> - this . directory = directory ; <nl> + Directory = directory ; <nl> this . displayName = displayName ; <nl> } <nl> <nl> private void load ( OsuColour colours ) <nl> { <nl> Anchor = Anchor . CentreLeft , <nl> Origin = Anchor . CentreLeft , <nl> - Text = displayName ? ? directory . Name , <nl> + Text = displayName ? ? Directory . Name , <nl> Font = OsuFont . Default . With ( size : FONT_SIZE ) <nl> } ) ; <nl> } <nl> <nl> protected override bool OnClick ( ClickEvent e ) <nl> { <nl> - currentDirectory . Value = directory ; <nl> + currentDirectory . Value = Directory ; <nl> return true ; <nl> } <nl> <nl> - public virtual IconUsage ? Icon = > FontAwesome . Regular . Folder ; <nl> + protected virtual IconUsage ? Icon = > Directory . Name . Contains ( \" / \" ) ? FontAwesome . Solid . Database : FontAwesome . Regular . Folder ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Change breadcrumb display icons to match design\n", "score": 1}
{"diff_id": 29071, "repo": "ppy/osu\n", "sha": "6dfe95db74b6d12d1ed5b9567a0652eb6303d589\n", "time": "2019-08-26T07:34:12Z\n", "diff": "mmm a / osu . Game / Rulesets / RulesetConfigCache . cs <nl> ppp b / osu . Game / Rulesets / RulesetConfigCache . cs <nl> public RulesetConfigCache ( SettingsStore settingsStore ) <nl> public IRulesetConfigManager GetConfigFor ( Ruleset ruleset ) <nl> { <nl> if ( ruleset . RulesetInfo . ID = = null ) <nl> - throw new InvalidOperationException ( \" The provided ruleset doesn ' t have a valid id . \" ) ; <nl> + return null ; <nl> <nl> return configCache . GetOrAdd ( ruleset . RulesetInfo . ID . Value , _ = > ruleset . CreateConfig ( settingsStore ) ) ; <nl> } <nl>\n", "msg": "Allow RulesetConfigCache to return null configs\n", "score": 1}
{"diff_id": 29412, "repo": "dotnet/roslyn\n", "sha": "ee4abf5680b7ec8498ed918b3f3f902b3be27971\n", "time": "2018-06-01T05:45:02Z\n", "diff": "mmm a / src / VisualStudio / Core / Def / Implementation / Venus / ContainedLanguage . cs <nl> ppp b / src / VisualStudio / Core / Def / Implementation / Venus / ContainedLanguage . cs <nl> internal partial class ContainedLanguage < TPackage , TLanguageService > : AbstractC <nl> uint itemid , <nl> TLanguageService languageService , <nl> SourceCodeKind sourceCodeKind , <nl> - IFormattingRule vbHelperFormattingRule = null ) <nl> + IFormattingRule vbHelperFormattingRule = null , <nl> + Workspace workspace = null ) <nl> : base ( project ) <nl> { <nl> this . BufferCoordinator = bufferCoordinator ; <nl> this . ComponentModel = componentModel ; <nl> _languageService = languageService ; <nl> <nl> - this . Workspace = componentModel . GetService < VisualStudioWorkspace > ( ) ; <nl> + this . Workspace = workspace ? ? componentModel . GetService < VisualStudioWorkspace > ( ) ; <nl> <nl> _editorAdaptersFactoryService = componentModel . GetService < IVsEditorAdaptersFactoryService > ( ) ; <nl> _diagnosticAnalyzerService = componentModel . GetService < IDiagnosticAnalyzerService > ( ) ; <nl>\n", "msg": "Allow passing in a workspace for a ContainedLanguage\n", "score": 1}
{"diff_id": 29450, "repo": "MonoGame/MonoGame\n", "sha": "49db7e364c2c2561dd28f1c4690dbfdd097d19f4\n", "time": "2019-08-12T20:28:06Z\n", "diff": "mmm a / MonoGame . Framework / DrawableGameComponent . cs <nl> ppp b / MonoGame . Framework / DrawableGameComponent . cs <nl> namespace Microsoft . Xna . Framework <nl> public class DrawableGameComponent : GameComponent , IDrawable <nl> { <nl> private bool _initialized ; <nl> + private bool _disposed ; <nl> private int _drawOrder ; <nl> private bool _visible = true ; <nl> <nl> public override void Initialize ( ) <nl> } <nl> } <nl> <nl> + protected override void Dispose ( bool disposing ) <nl> + { <nl> + if ( ! _disposed ) <nl> + { <nl> + _disposed = true ; <nl> + UnloadContent ( ) ; <nl> + } <nl> + } <nl> + <nl> protected virtual void LoadContent ( ) { } <nl> <nl> protected virtual void UnloadContent ( ) { } <nl>\n", "msg": "Implemented Dispose in DrawableGameComponent to unload content\n", "score": 1}
{"diff_id": 29637, "repo": "MonoGame/MonoGame\n", "sha": "90f221163695f6ec4012a9c6565e7833cb82004e\n", "time": "2014-08-13T01:48:32Z\n", "diff": "mmm a / Tools / Pipeline / Windows / MainView . cs <nl> ppp b / Tools / Pipeline / Windows / MainView . cs <nl> private void ExitMenuItemClick ( object sender , System . EventArgs e ) <nl> <nl> private void MainView_Load ( object sender , EventArgs e ) <nl> { <nl> - if ( History . Default . ProjectHistory . Count > 0 ) <nl> + / / Priority is given to any command line arguments . <nl> + if ( string . IsNullOrEmpty ( OpenProjectPath ) & & History . Default . ProjectHistory . Count > 0 ) <nl> { <nl> OpenProjectPath = History . Default . ProjectHistory . Last ( ) ; <nl> } <nl>\n", "msg": "Giving priority to any command line arguments over the History loading .\n", "score": 1}
{"diff_id": 29859, "repo": "SignalR/SignalR\n", "sha": "1e24e4a61feb358d64904aca3925cf64087a15ec\n", "time": "2013-03-20T22:11:18Z\n", "diff": "mmm a / src / Microsoft . AspNet . SignalR . Client / Transports / ServerSentEvents / ChunkBuffer . cs <nl> ppp b / src / Microsoft . AspNet . SignalR . Client / Transports / ServerSentEvents / ChunkBuffer . cs <nl> public void Add ( byte [ ] buffer , int length ) <nl> _buffer . Append ( Encoding . UTF8 . GetString ( buffer , 0 , length ) ) ; <nl> } <nl> <nl> + public void Add ( ArraySegment < byte > buffer ) <nl> + { <nl> + _buffer . Append ( Encoding . UTF8 . GetString ( buffer . Array , buffer . Offset , buffer . Count ) ) ; <nl> + } <nl> + <nl> public string ReadLine ( ) <nl> { <nl> / / Lock while reading so that we can make safe assuptions about the buffer indicies <nl>\n", "msg": "Added method to ChunkBuffer to take in ArraySegments\n", "score": 1}
{"diff_id": 29867, "repo": "chocolatey/choco\n", "sha": "2665f3aa3c2e65ab4b09a086d742d6c86106f6e4\n", "time": "2015-01-01T20:52:37Z\n", "diff": "mmm a / src / chocolatey / infrastructure . app / services / ChocolateyConfigSettingsService . cs <nl> ppp b / src / chocolatey / infrastructure . app / services / ChocolateyConfigSettingsService . cs <nl> public void source_add ( ChocolateyConfiguration configuration ) <nl> Password = NugetEncryptionUtility . EncryptString ( configuration . SourceCommand . Password ) , <nl> } ) ; <nl> <nl> - _xmlService . serialize ( _configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> + _xmlService . serialize ( configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> <nl> this . Log ( ) . Info ( ( ) = > \" Added { 0 } - { 1 } \" . format_with ( configuration . SourceCommand . Name , configuration . Source ) ) ; <nl> } <nl> public void source_remove ( ChocolateyConfiguration configuration ) <nl> if ( source ! = null ) <nl> { <nl> configFileSettings . Sources . Remove ( source ) ; <nl> - _xmlService . serialize ( _configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> + _xmlService . serialize ( configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> <nl> this . Log ( ) . Info ( ( ) = > \" Removed { 0 } \" . format_with ( source . Id ) ) ; <nl> } <nl> public void source_disable ( ChocolateyConfiguration configuration ) <nl> if ( source ! = null & & ! source . Disabled ) <nl> { <nl> source . Disabled = true ; <nl> - _xmlService . serialize ( _configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> + _xmlService . serialize ( configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> this . Log ( ) . Info ( ( ) = > \" Disabled { 0 } \" . format_with ( source . Id ) ) ; <nl> } <nl> } <nl> public void source_enable ( ChocolateyConfiguration configuration ) <nl> if ( source ! = null & & source . Disabled ) <nl> { <nl> source . Disabled = false ; <nl> - _xmlService . serialize ( _configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> + _xmlService . serialize ( configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> this . Log ( ) . Info ( ( ) = > \" Enabled { 0 } \" . format_with ( source . Id ) ) ; <nl> } <nl> } <nl> public void set_api_key ( ChocolateyConfiguration configuration ) <nl> Key = NugetEncryptionUtility . EncryptString ( configuration . ApiKeyCommand . Key ) , <nl> } ) ; <nl> <nl> - _xmlService . serialize ( _configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> + _xmlService . serialize ( configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> <nl> this . Log ( ) . Info ( ( ) = > \" Added ApiKey for { 0 } \" . format_with ( configuration . Source ) ) ; <nl> } <nl> public void set_api_key ( ChocolateyConfiguration configuration ) <nl> if ( ! NugetEncryptionUtility . DecryptString ( apiKey . Key ) . to_string ( ) . is_equal_to ( configuration . ApiKeyCommand . Key ) ) <nl> { <nl> apiKey . Key = NugetEncryptionUtility . EncryptString ( configuration . ApiKeyCommand . Key ) ; <nl> - _xmlService . serialize ( _configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> + _xmlService . serialize ( configFileSettings , ApplicationParameters . GlobalConfigFileLocation ) ; <nl> this . Log ( ) . Info ( ( ) = > \" Updated ApiKey for { 0 } \" . format_with ( configuration . Source ) ) ; <nl> } <nl> } <nl>\n", "msg": "( bug ) Fix ConfigSettingsService to save ConfigFileSettings\n", "score": 1}
{"diff_id": 29928, "repo": "ServiceStack/ServiceStack\n", "sha": "30b6057744cfaa2cf011033e3a8178c986547085\n", "time": "2016-06-11T20:11:47Z\n", "diff": "Binary files a / lib / ServiceStack . Text . dll and b / lib / ServiceStack . Text . dll differ <nl> mmm a / src / ServiceStack / Auth / AuthProvider . cs <nl> ppp b / src / ServiceStack / Auth / AuthProvider . cs <nl> public virtual object Logout ( IServiceBase service , Authenticate request ) <nl> var referrerUrl = ( request ! = null ? request . Continue : null ) <nl> ? ? ( feature . HtmlLogoutRedirect ! = null ? service . Request . ResolveAbsoluteUrl ( feature . HtmlLogoutRedirect ) : null ) <nl> ? ? session . ReferrerUrl <nl> - ? ? service . Request . GetHeader ( \" Referer \" ) <nl> - ? ? this . CallbackUrl ; <nl> + ? ? service . Request . GetHeader ( \" Referer \" ) . NotLogoutUrl ( ) <nl> + ? ? this . RedirectUrl ; <nl> <nl> session . OnLogout ( service ) ; <nl> AuthEvents . OnLogout ( service . Request , session , service ) ; <nl> public virtual object Logout ( IServiceBase service , Authenticate request ) <nl> if ( feature ! = null & & feature . DeleteSessionCookiesOnLogout ) <nl> { <nl> service . Request . Response . DeleteSessionCookies ( ) ; <nl> + service . Request . Response . DeleteJwtCookie ( ) ; <nl> } <nl> <nl> if ( service . Request . ResponseContentType = = MimeTypes . Html & & ! string . IsNullOrEmpty ( referrerUrl ) ) <nl> protected virtual void SaveUserAuth ( IServiceBase authService , IAuthSession sessi <nl> <nl> authRepo . LoadUserAuth ( session , tokens ) ; <nl> <nl> - foreach ( var oAuthToken in session . ProviderOAuthAccess ) <nl> + foreach ( var oAuthToken in session . GetAuthTokens ( ) ) <nl> { <nl> var authProvider = AuthenticateService . GetAuthProvider ( oAuthToken . Provider ) ; <nl> if ( authProvider = = null ) continue ; <nl> public virtual IHttpResult OnAuthenticated ( IServiceBase authService , IAuthSessio <nl> <nl> authRepo . LoadUserAuth ( session , tokens ) ; <nl> <nl> - foreach ( var oAuthToken in session . ProviderOAuthAccess ) <nl> + foreach ( var oAuthToken in session . GetAuthTokens ( ) ) <nl> { <nl> var authProvider = AuthenticateService . GetAuthProvider ( oAuthToken . Provider ) ; <nl> if ( authProvider = = null ) continue ; <nl> public virtual string CreateOrMergeAuthSession ( IAuthSession session , IAuthTokens <nl> if ( session . Email . IsNullOrEmpty ( ) ) <nl> session . Email = tokens . Email ; <nl> <nl> - var oAuthProvider = session . ProviderOAuthAccess . FirstOrDefault ( <nl> - x = > x . Provider = = tokens . Provider & & x . UserId = = tokens . UserId ) ; <nl> - if ( oAuthProvider ! = null ) <nl> + var oAuthTokens = session . GetAuthTokens ( tokens . Provider ) ; <nl> + if ( oAuthTokens ! = null & & oAuthTokens . UserId = = tokens . UserId ) <nl> { <nl> - if ( ! oAuthProvider . UserName . IsNullOrEmpty ( ) ) <nl> - session . UserName = oAuthProvider . UserName ; <nl> - if ( ! oAuthProvider . DisplayName . IsNullOrEmpty ( ) ) <nl> - session . DisplayName = oAuthProvider . DisplayName ; <nl> - if ( ! oAuthProvider . Email . IsNullOrEmpty ( ) ) <nl> - session . Email = oAuthProvider . Email ; <nl> - if ( ! oAuthProvider . FirstName . IsNullOrEmpty ( ) ) <nl> - session . FirstName = oAuthProvider . FirstName ; <nl> - if ( ! oAuthProvider . LastName . IsNullOrEmpty ( ) ) <nl> - session . LastName = oAuthProvider . LastName ; <nl> + if ( ! oAuthTokens . UserName . IsNullOrEmpty ( ) ) <nl> + session . UserName = oAuthTokens . UserName ; <nl> + if ( ! oAuthTokens . DisplayName . IsNullOrEmpty ( ) ) <nl> + session . DisplayName = oAuthTokens . DisplayName ; <nl> + if ( ! oAuthTokens . Email . IsNullOrEmpty ( ) ) <nl> + session . Email = oAuthTokens . Email ; <nl> + if ( ! oAuthTokens . FirstName . IsNullOrEmpty ( ) ) <nl> + session . FirstName = oAuthTokens . FirstName ; <nl> + if ( ! oAuthTokens . LastName . IsNullOrEmpty ( ) ) <nl> + session . LastName = oAuthTokens . LastName ; <nl> } <nl> <nl> var key = tokens . Provider + \" : \" + ( tokens . UserId ? ? tokens . UserName ) ; <nl> internal static bool PopulateFromRequestIfHasSessionId ( this IRequest req , object <nl> } <nl> return false ; <nl> } <nl> + <nl> + internal static string NotLogoutUrl ( this string url ) <nl> + { <nl> + return url = = null | | url . EndsWith ( \" / auth / logout \" ) <nl> + ? null <nl> + : url ; <nl> + } <nl> } <nl> <nl> } <nl>\n", "msg": "Change referrerUrl to fallback to RedirectUrl instead of CallbackUrl\n", "score": 1}
{"diff_id": 30877, "repo": "IdentityServer/IdentityServer4\n", "sha": "342f6e4941d178e6d2a73314bcc29bb748e90fad\n", "time": "2017-03-22T17:07:46Z\n", "diff": "mmm a / src / IdentityServer4 / Hosting / CookieMiddleware . cs <nl> ppp b / src / IdentityServer4 / Hosting / CookieMiddleware . cs <nl> public static void ConfigureCookies ( this IApplicationBuilder app ) <nl> SlidingExpiration = options . Authentication . CookieSlidingExpiration , <nl> ExpireTimeSpan = options . Authentication . CookieLifetime , <nl> CookieName = IdentityServerConstants . DefaultCookieAuthenticationScheme , <nl> + LoginPath = ExtractLocalUrl ( options . UserInteraction . LoginUrl ) , <nl> + LogoutPath = ExtractLocalUrl ( options . UserInteraction . LogoutUrl ) , <nl> + ReturnUrlParameter = options . UserInteraction . LoginReturnUrlParameter <nl> } ) ; <nl> <nl> logger . LogDebug ( \" Adding CookieAuthentication middleware for external authentication with scheme : { authenticationScheme } \" , IdentityServerConstants . ExternalCookieAuthenticationScheme ) ; <nl> public static void ConfigureCookies ( this IApplicationBuilder app ) <nl> app . UseMiddleware < FederatedSignOutMiddleware > ( ) ; <nl> } <nl> } <nl> + <nl> + private static string ExtractLocalUrl ( string url ) <nl> + { <nl> + if ( url . IsLocalUrl ( ) ) <nl> + { <nl> + if ( url . StartsWith ( \" ~ / \" ) ) <nl> + { <nl> + url = url . Substring ( 1 ) ; <nl> + } <nl> + <nl> + return url ; <nl> + } <nl> + <nl> + return null ; <nl> + } <nl> } <nl> } <nl>\n", "msg": "Pass LoginUrl / LogoutUrl from IdentityServerOptions to auth cookie ( )\n", "score": 1}
{"diff_id": 31056, "repo": "gitextensions/gitextensions\n", "sha": "2e6aa9cbb791a5e50827cde0fc60bd420dd5088f\n", "time": "2016-09-13T10:28:12Z\n", "diff": "mmm a / GitCommands / Git / GitModule . cs <nl> ppp b / GitCommands / Git / GitModule . cs <nl> private string GetFetchArgs ( string remote , string remoteBranch , string localBran <nl> <nl> string arguments = fetchTags = = true ? \" - - tags \" : fetchTags = = false ? \" - - no - tags \" : \" \" ; <nl> <nl> + string pruneArguments = prune ? \" - - prune \" : \" \" ; <nl> <nl> if ( isUnshallow ) <nl> arguments + = \" - - unshallow \" ; <nl> <nl> - return \" \\ \" \" + remote . Trim ( ) + \" \\ \" \" + remoteBranchArguments + localBranchArguments + arguments ; <nl> + return \" \\ \" \" + remote . Trim ( ) + \" \\ \" \" + remoteBranchArguments + localBranchArguments + arguments + pruneArguments ; <nl> } <nl> <nl> public string GetRebaseDir ( ) <nl>\n", "msg": "Append \" - - prune \" to argument string when GetFetchArgs called with prune = true\n", "score": 1}
