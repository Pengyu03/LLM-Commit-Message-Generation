{"diff_id": 77, "repo": "Automattic/mongoose\n", "sha": "b110117d2e70b2a926d4123bda3d67cfb8363a81\n", "time": "2011-09-28T19:30:25Z\n", "diff": "mmm a / test / model . test . js <nl> ppp b / test / model . test . js <nl> module . exports = { <nl> } ) ; <nl> } , <nl> <nl> - ' pull should work with arrays of Mixed ' : function ( ) { <nl> - var db = start ( ) <nl> - , schema = new Schema ( { arr : [ ] } ) ; <nl> - <nl> - var M = db . model ( ' pullFromMixedArray ' , schema ) ; <nl> - <nl> - M . create ( { arr : [ { y : 1 } , { y : 2 , z : 3 , a : { aa : [ ' hi ' ] } } ] } , function ( err , t ) { <nl> - should . strictEqual ( null , err ) ; <nl> - t . arr . should . have . length ( 2 ) ; <nl> - t . arr . pull ( { y : 2 , a : { aa : [ ' hi ' ] } } ) ; <nl> - t . arr . should . have . length ( 1 ) ; <nl> - t . save ( function ( err ) { <nl> - should . strictEqual ( null , err ) ; <nl> - M . findOne ( t , function ( err , t ) { <nl> - db . close ( ) ; <nl> - should . strictEqual ( null , err ) ; <nl> - t . arr . should . have . length ( 1 ) ; <nl> - t . arr [ 0 ] . y . should . equal ( 1 ) ; <nl> - } ) ; <nl> - } ) ; <nl> - } ) ; <nl> - } , <nl> - <nl> ' $ shift ' : function ( ) { <nl> var db = start ( ) <nl> , schema = new Schema ( { <nl>\n", "msg": "Revert \" failing test ; $ pull from array obj literals \"\n", "score": 1}
{"diff_id": 121, "repo": "facebook/react-native\n", "sha": "c3e8c825af106d75170a8dc5bc0fbdb45fcf0e80\n", "time": "2016-07-27T11:43:47Z\n", "diff": "mmm a / local - cli / server / util / launchEditor . js <nl> ppp b / local - cli / server / util / launchEditor . js <nl> function getArgumentsForLineNumber ( editor , fileName , lineNumber , workspace ) { <nl> return addWorkspaceToArgumentsIfExists ( [ fileName + ' : ' + lineNumber ] , workspace ) ; <nl> case ' subl ' : <nl> case ' sublime ' : <nl> + case ' wstorm ' : <nl> + case ' appcode ' : <nl> + case ' idea ' : <nl> return [ fileName + ' : ' + lineNumber ] ; <nl> case ' joe ' : <nl> case ' emacs ' : <nl>\n", "msg": "Open to correct line on Webstorm , IntelliJ and AppCode\n", "score": 1}
{"diff_id": 305, "repo": "RocketChat/Rocket.Chat\n", "sha": "fa20b86696298e4405bf49843d71ef7dbfc84b13\n", "time": "2017-10-17T11:40:27Z\n", "diff": "mmm a / packages / rocketchat - lib / lib / RoomTypeConfig . js <nl> ppp b / packages / rocketchat - lib / lib / RoomTypeConfig . js <nl> export class RoomTypeConfig { <nl> return true ; <nl> } <nl> <nl> + canBeCreated ( ) { <nl> + return Meteor . isServer ? <nl> + RocketChat . authz . hasAtLeastOnePermission ( Meteor . userId ( ) , [ ` create - $ { this . _identifier } ` ] ) : <nl> + RocketChat . authz . hasAtLeastOnePermission ( [ ` create - $ { this . _identifier } ` ] ) ; <nl> + } <nl> + <nl> canBeDeleted ( room ) { <nl> return Meteor . isServer ? <nl> RocketChat . authz . hasAtLeastOnePermission ( Meteor . userId ( ) , [ ` delete - $ { room . t } ` ] , room . _id ) : <nl>\n", "msg": "Add creation validation configuration , e . g . in order to check whether the user is authorized to create the room type\n", "score": 1}
{"diff_id": 432, "repo": "gatsbyjs/gatsby\n", "sha": "ae7a45fb150eca373d91184fffcb143350d80d0a\n", "time": "2016-09-28T23:42:49Z\n", "diff": "mmm a / lib / utils / webpack . config . js <nl> ppp b / lib / utils / webpack . config . js <nl> module . exports = ( program , directory , suppliedStage , webpackPort = 1500 , pages = <nl> / / most people don ' t navigate to most pages , take tradeoff of <nl> / / loading / evaling modules multiple times over loading / evaling lots <nl> / / of unused code on the initial opening of the app . <nl> - minChunks : Math . floor ( components . length / 2 ) , <nl> + / / <nl> + / / Use Math . max as there must be at least two chunks . <nl> + minChunks : Math . max ( 2 , Math . floor ( components . length / 2 ) ) , <nl> } ) , <nl> / / Add a few global variables . Set NODE_ENV to production ( enables <nl> / / optimizations for React ) and whether prefixing links is enabled <nl>\n", "msg": "Ensure there ' s at least two set for minChunks\n", "score": 1}
{"diff_id": 502, "repo": "ajaxorg/ace\n", "sha": "50aac69d56c43b918b858aadaed764a63cca1ceb\n", "time": "2011-05-23T17:42:11Z\n", "diff": "mmm a / demo / demo . js <nl> ppp b / demo / demo . js <nl> exports . launch = function ( env ) { <nl> addFold = true ; <nl> } <nl> } else { <nl> - var folds = session . getFoldsInRange ( range ) ; <nl> - if ( tryToUnfold & & folds . length ) <nl> - session . expandFolds ( folds ) ; <nl> - else if ( folds . length = = 1 & & folds [ 0 ] . range . compare ( range ) = = 0 ) <nl> - session . expandFolds ( folds ) ; <nl> - else <nl> - addFold = true ; <nl> + addFold = true ; <nl> } <nl> if ( addFold ) { <nl> var placeHolder = session . getTextRange ( range ) ; <nl>\n", "msg": "Fold on selection - dont expand in the demo . Otherwise it ' s hard to test nested folding\n", "score": 1}
{"diff_id": 613, "repo": "balderdashy/sails\n", "sha": "e87648c951ec789b5b7528da918030eea0080441\n", "time": "2014-07-25T18:01:45Z\n", "diff": "mmm a / lib / router / bind . js <nl> ppp b / lib / router / bind . js <nl> function bindFunction ( path , fn , verb , options ) { <nl> sails . emit ( ' router : bind ' , { <nl> path : path , <nl> target : util . clone ( targetFn ) , <nl> - verb : verb <nl> + verb : verb , <nl> + originalFn : fn <nl> } ) ; <nl> <nl> } <nl>\n", "msg": "Expose original function being bound to route in router : bind event\n", "score": 1}
{"diff_id": 815, "repo": "SortableJS/Sortable\n", "sha": "764b060cbd2ff26a5570c0047d7f2b1941aa763b\n", "time": "2016-01-12T17:01:45Z\n", "diff": "mmm a / react - sortable - mixin . js <nl> ppp b / react - sortable - mixin . js <nl> <nl> <nl> emitEvent = function ( / * * string * / type , / * * Event * / evt ) { <nl> var method = options [ type ] ; <nl> + if ( method & & typeof method = = = \" string \" ) { <nl> + method = this [ method ] ; <nl> + } <nl> method & & typeof method = = = \" function \" & & method . call ( this , evt , this . _sortableInstance ) ; <nl> } . bind ( this ) ; <nl> <nl>\n", "msg": "Allow event functions to be defined as functions AND strings .\n", "score": 1}
{"diff_id": 871, "repo": "ajaxorg/ace\n", "sha": "b0475ce3e4aa6dc0daa3913a0c439a17c59c4f35\n", "time": "2015-02-16T14:27:22Z\n", "diff": "mmm a / lib / ace / mode / c_cpp_highlight_rules . js <nl> ppp b / lib / ace / mode / c_cpp_highlight_rules . js <nl> var c_cppHighlightRules = function ( ) { <nl> var storageType = ( <nl> \" asm | __asm__ | auto | bool | _Bool | char | _Complex | double | enum | float | \" + <nl> \" _Imaginary | int | long | short | signed | struct | typedef | union | unsigned | void | \" + <nl> - \" class | wchar_t | template \" <nl> + \" class | wchar_t | template | char16_t | char32_t \" <nl> ) ; <nl> <nl> var storageModifiers = ( <nl> \" const | extern | register | restrict | static | volatile | inline | private | \" + <nl> \" protected | public | friend | explicit | virtual | export | mutable | typename | \" + <nl> - \" constexpr | new | delete \" <nl> + \" constexpr | new | delete | alignas | alignof | decltype | noexcept | thread_local \" <nl> ) ; <nl> <nl> var keywordOperators = ( <nl> var c_cppHighlightRules = function ( ) { <nl> ) ; <nl> <nl> var builtinConstants = ( <nl> - \" NULL | true | false | TRUE | FALSE \" <nl> + \" NULL | true | false | TRUE | FALSE | nullptr \" <nl> ) ; <nl> <nl> var keywordMapper = this . $ keywords = this . createKeywordMapper ( { <nl>\n", "msg": "Added C + + 11 tokens to highlighting rules\n", "score": 1}
{"diff_id": 951, "repo": "lodash/lodash\n", "sha": "b72fba911d8828883fd3d5bdd301cd786e50269a\n", "time": "2016-04-19T18:26:55Z\n", "diff": "mmm a / test / test . js <nl> ppp b / test / test . js <nl> <nl> QUnit . module ( ' lodash . mixin ' ) ; <nl> <nl> ( function ( ) { <nl> + function reset ( wrapper ) { <nl> + delete wrapper . a ; <nl> + delete wrapper . prototype . a ; <nl> + delete wrapper . b ; <nl> + delete wrapper . prototype . b ; <nl> + } <nl> + <nl> function Wrapper ( value ) { <nl> if ( ! ( this instanceof Wrapper ) ) { <nl> return new Wrapper ( value ) ; <nl> <nl> <nl> assert . strictEqual ( _ . a ( array ) , ' a ' ) ; <nl> assert . strictEqual ( _ ( array ) . a ( ) . value ( ) , ' a ' ) ; <nl> - <nl> - delete _ . a ; <nl> - delete _ . prototype . a ; <nl> - <nl> assert . notOk ( ' b ' in _ ) ; <nl> assert . notOk ( ' b ' in _ . prototype ) ; <nl> <nl> - delete _ . b ; <nl> - delete _ . prototype . b ; <nl> + reset ( _ ) ; <nl> } <nl> else { <nl> skipAssert ( assert , 4 ) ; <nl> <nl> assert . strictEqual ( _ . a ( array ) , ' b ' ) ; <nl> assert . strictEqual ( _ ( array ) . a ( ) . value ( ) , ' a ' ) ; <nl> <nl> - delete _ . a ; <nl> - delete _ . prototype . a ; <nl> + reset ( _ ) ; <nl> } <nl> else { <nl> skipAssert ( assert , 2 ) ; <nl> <nl> object . mixin ( source ) ; <nl> <nl> assert . strictEqual ( object . a ( array ) , ' a ' ) ; <nl> - <nl> assert . notOk ( ' a ' in _ ) ; <nl> assert . notOk ( ' a ' in _ . prototype ) ; <nl> <nl> - delete Wrapper . a ; <nl> - delete Wrapper . prototype . a ; <nl> - delete Wrapper . b ; <nl> - delete Wrapper . prototype . b ; <nl> + reset ( _ ) ; <nl> } ) ; <nl> <nl> QUnit . test ( ' should accept an ` object ` argument ' , function ( assert ) { <nl> <nl> assert . strictEqual ( object . a ( array ) , ' a ' ) ; <nl> } ) ; <nl> <nl> - QUnit . test ( ' should return ` object ` ' , function ( assert ) { <nl> - assert . expect ( 2 ) ; <nl> - <nl> - var object = { } ; <nl> - assert . strictEqual ( _ . mixin ( object , source ) , object ) ; <nl> - assert . strictEqual ( _ . mixin ( ) , _ ) ; <nl> - } ) ; <nl> - <nl> - QUnit . test ( ' should work with a function for ` object ` ' , function ( assert ) { <nl> + QUnit . test ( ' should accept a function ` object ` ' , function ( assert ) { <nl> assert . expect ( 2 ) ; <nl> <nl> _ . mixin ( Wrapper , source ) ; <nl> <nl> assert . strictEqual ( actual . value ( ) , ' a ' ) ; <nl> assert . ok ( actual instanceof Wrapper ) ; <nl> <nl> - delete Wrapper . a ; <nl> - delete Wrapper . prototype . a ; <nl> - delete Wrapper . b ; <nl> - delete Wrapper . prototype . b ; <nl> + reset ( Wrapper ) ; <nl> + } ) ; <nl> + <nl> + QUnit . test ( ' should return ` object ` ' , function ( assert ) { <nl> + assert . expect ( 3 ) ; <nl> + <nl> + var object = { } ; <nl> + assert . strictEqual ( _ . mixin ( object , source ) , object ) ; <nl> + assert . strictEqual ( _ . mixin ( Wrapper , source ) , Wrapper ) ; <nl> + assert . strictEqual ( _ . mixin ( ) , _ ) ; <nl> + <nl> + reset ( Wrapper ) ; <nl> } ) ; <nl> <nl> QUnit . test ( ' should not assign inherited ` source ` methods ' , function ( assert ) { <nl> <nl> assert . strictEqual ( actual , ' a ' , message ( func , false ) ) ; <nl> assert . notOk ( actual instanceof func , message ( func , false ) ) ; <nl> } <nl> - delete func . a ; <nl> - delete func . prototype . a ; <nl> - delete func . b ; <nl> - delete func . prototype . b ; <nl> + reset ( func ) ; <nl> } <nl> else { <nl> skipAssert ( assert , 2 ) ; <nl> <nl> <nl> _ . mixin ( { ' a ' : noop } , { } ) ; <nl> assert . notOk ( ' a ' in _ ) ; <nl> - delete _ . a ; <nl> + reset ( _ ) ; <nl> } ) ; <nl> <nl> QUnit . test ( ' should not error for non - object ` options ` values ' , function ( assert ) { <nl> <nl> } catch ( e ) { <nl> pass = false ; <nl> } <nl> - delete _ . a ; <nl> - delete _ . prototype . a ; <nl> - delete _ . b ; <nl> - delete _ . prototype . b ; <nl> - <nl> assert . ok ( pass ) ; <nl> + <nl> + reset ( _ ) ; <nl> } ) ; <nl> <nl> QUnit . test ( ' should not return the existing wrapped value when chaining ' , function ( assert ) { <nl> <nl> actual = wrapped . mixin ( source ) ; <nl> assert . notStrictEqual ( actual , wrapped ) ; <nl> } <nl> - delete func . a ; <nl> - delete func . prototype . a ; <nl> - delete func . b ; <nl> - delete func . prototype . b ; <nl> + reset ( func ) ; <nl> } <nl> else { <nl> skipAssert ( assert ) ; <nl> <nl> <nl> assert . deepEqual ( actual , _ . take ( _ . b ( _ . map ( _ . a ( array ) , square ) , isEven ) ) ) ; <nl> <nl> - delete _ . a ; <nl> - delete _ . prototype . a ; <nl> - delete _ . b ; <nl> - delete _ . prototype . b ; <nl> + reset ( _ ) ; <nl> } <nl> else { <nl> skipAssert ( assert ) ; <nl>\n", "msg": "Cleanup wrapper resets and add assert for returning function ` object ` values .\n", "score": 1}
{"diff_id": 1923, "repo": "mozilla/pdf.js\n", "sha": "bbbf30c81ffb44ca56ec2745a7a1963f1929b8a2\n", "time": "2011-05-10T01:10:15Z\n", "diff": "mmm a / pdf . js <nl> ppp b / pdf . js <nl> <nl> / * - * - Mode : Java ; tab - width : 4 ; indent - tabs - mode : nil ; c - basic - offset : 4 - * - / <nl> / * vim : set shiftwidth = 4 tabstop = 8 autoindent cindent expandtab : * / <nl> <nl> + function warn ( msg ) { <nl> + if ( console & & console . log ) <nl> + console . log ( msg ) ; <nl> + if ( print ) <nl> + print ( msg ) ; <nl> + } <nl> + <nl> + function error ( msg ) { <nl> + throw new Error ( msg ) ; <nl> + } <nl> + <nl> var Stream = ( function ( ) { <nl> function constructor ( arrayBuffer ) { <nl> this . bytes = Uint8Array ( arrayBuffer ) ; <nl> var FlateStream = ( function ( ) { <nl> const lengthDecode = [ <nl> [ 0 , 3 ] , <nl> [ 0 , 4 ] , <nl> - [ 0 , 5 } , <nl> - [ 0 , 6 } , <nl> - [ 0 , 7 } , <nl> - [ 0 , 8 } , <nl> - [ 0 , 9 } , <nl> + [ 0 , 5 ] , <nl> + [ 0 , 6 ] , <nl> + [ 0 , 7 ] , <nl> + [ 0 , 8 ] , <nl> + [ 0 , 9 ] , <nl> [ 0 , 10 ] , <nl> [ 1 , 11 ] , <nl> [ 1 , 13 ] , <nl> function IsEOF ( v ) { <nl> return v = = EOF ; <nl> } <nl> <nl> - var Error = { } ; <nl> - <nl> - function IsError ( v ) { <nl> - return v = = Error ; <nl> - } <nl> - <nl> var None = { } ; <nl> <nl> function IsNone ( v ) { <nl> var Lexer = ( function ( ) { <nl> } <nl> <nl> constructor . prototype = { <nl> - error : function ( msg ) { <nl> - / / TODO <nl> - print ( msg ) ; <nl> - } , <nl> getNumber : function ( ch ) { <nl> var floating = false ; <nl> var str = ch ; <nl> var Lexer = ( function ( ) { <nl> } else if ( ch = = \" - \" ) { <nl> / / ignore minus signs in the middle of numbers to match <nl> / / Adobe ' s behavior <nl> - this . error ( \" Badly formated number \" ) ; <nl> + warn ( \" Badly formated number \" ) ; <nl> } else if ( ch > = \" 0 \" & & ch < = \" 9 \" ) { <nl> str + = ch ; <nl> } else if ( ch = = \" e \" | | ch = = \" E \" ) { <nl> var Lexer = ( function ( ) { <nl> } while ( true ) ; <nl> var value = parseFloat ( str ) ; <nl> if ( isNaN ( value ) ) <nl> - return Error ; <nl> + error ( \" Invalid floating point number \" ) ; <nl> return value ; <nl> } , <nl> getString : function ( ch ) { <nl> var Lexer = ( function ( ) { <nl> do { <nl> switch ( ch = stream . getChar ( ) ) { <nl> case undefined : <nl> - this . error ( \" Unterminated string \" ) ; <nl> + warn ( \" Unterminated string \" ) ; <nl> done = true ; <nl> break ; <nl> case ' ( ' : <nl> var Lexer = ( function ( ) { <nl> case ' \\ \\ ' : <nl> switch ( ch = stream . getChar ( ) ) { <nl> case undefined : <nl> - this . error ( \" Unterminated string \" ) ; <nl> + warn ( \" Unterminated string \" ) ; <nl> done = true ; <nl> break ; <nl> case ' n ' : <nl> var Lexer = ( function ( ) { <nl> stream . getChar ( ) ; <nl> var x2 = ToHexDigit ( stream . getChar ( ) ) ; <nl> if ( x2 = = - 1 ) <nl> - this . error ( \" Illegal digit in hex char in name \" ) ; <nl> + error ( \" Illegal digit in hex char in name \" ) ; <nl> str + = String . fromCharCode ( ( x < < 4 ) | x2 ) ; <nl> } else { <nl> str + = \" # \" ; <nl> var Lexer = ( function ( ) { <nl> } <nl> } <nl> if ( str . length > 128 ) <nl> - this . error ( \" Warning : name token is longer than allowed by the specification \" ) ; <nl> + error ( \" Warning : name token is longer than allowed by the specification \" ) ; <nl> return new Name ( str ) ; <nl> } , <nl> getHexString : function ( ch ) { <nl> var Lexer = ( function ( ) { <nl> if ( ch = = ' > ' ) { <nl> break ; <nl> } else if ( ! ch ) { <nl> - this . error ( \" Unterminated hex string \" ) ; <nl> + warn ( \" Unterminated hex string \" ) ; <nl> break ; <nl> } else if ( specialChars [ ch . charCodeAt ( 0 ) ] ! = 1 ) { <nl> var x , x2 ; <nl> if ( ( ( x = ToHexDigit ( ch ) ) = = - 1 ) | | <nl> ( ( x2 = ToHexDigit ( stream . getChar ( ) ) ) = = - 1 ) ) { <nl> - this . error ( \" Illegal character in hex string \" ) ; <nl> + error ( \" Illegal character in hex string \" ) ; <nl> break ; <nl> } <nl> str + = String . fromCharCode ( ( x < < 4 ) | x2 ) ; <nl> var Lexer = ( function ( ) { <nl> case ' ) ' : <nl> case ' { ' : <nl> case ' } ' : <nl> - this . error ( \" Illegal character \" ) ; <nl> + error ( \" Illegal character \" ) ; <nl> return Error ; <nl> } <nl> <nl> var Lexer = ( function ( ) { <nl> while ( ! ! ( ch = stream . lookChar ( ) ) & & ! specialChars [ ch . charCodeAt ( 0 ) ] ) { <nl> stream . getChar ( ) ; <nl> if ( str . length = = 128 ) { <nl> - this . error ( \" Command token too long \" ) ; <nl> + error ( \" Command token too long \" ) ; <nl> break ; <nl> } <nl> str + = ch ; <nl> var Parser = ( function ( ) { <nl> while ( ! IsCmd ( this . buf1 , \" ] \" ) & & ! IsEOF ( this . buf1 ) ) <nl> array . push ( this . getObj ( ) ) ; <nl> if ( IsEOF ( this . buf1 ) ) <nl> - this . error ( \" End of file inside array \" ) ; <nl> + error ( \" End of file inside array \" ) ; <nl> this . shift ( ) ; <nl> return array ; <nl> } else if ( IsCmd ( this . buf1 , \" < < \" ) ) { / / dictionary or stream <nl> var Parser = ( function ( ) { <nl> var dict = new Dict ( ) ; <nl> while ( ! IsCmd ( this . buf1 , \" > > \" ) & & ! IsEOF ( this . buf1 ) ) { <nl> if ( ! IsName ( this . buf1 ) ) { <nl> - this . error ( \" Dictionary key must be a name object \" ) ; <nl> + error ( \" Dictionary key must be a name object \" ) ; <nl> shift ( ) ; <nl> } else { <nl> var key = this . buf1 . name ; <nl> this . shift ( ) ; <nl> - if ( IsEOF ( this . buf1 ) | | IsError ( this . buf1 ) ) <nl> + if ( IsEOF ( this . buf1 ) ) <nl> break ; <nl> dict . set ( key , this . getObj ( ) ) ; <nl> } <nl> } <nl> if ( IsEOF ( this . buf1 ) ) <nl> - this . error ( \" End of file inside dictionary \" ) ; <nl> + error ( \" End of file inside dictionary \" ) ; <nl> <nl> / / stream objects are not allowed inside content streams or <nl> / / object streams <nl> var Parser = ( function ( ) { <nl> / / get length <nl> var length ; <nl> if ( ! IsInt ( length = dict . get ( \" Length \" ) ) ) { <nl> - this . error ( \" Bad ' Length ' attribute in stream \" ) ; <nl> + error ( \" Bad ' Length ' attribute in stream \" ) ; <nl> lenght = 0 ; <nl> } <nl> <nl> var Parser = ( function ( ) { <nl> this . shift ( ) ; / / ' > > ' <nl> this . shift ( ) ; / / ' stream ' <nl> if ( ! IsCmd ( this . buf1 , \" endstream \" ) ) <nl> - this . error ( \" Missing ' endstream ' \" ) ; <nl> + error ( \" Missing ' endstream ' \" ) ; <nl> this . shift ( ) ; <nl> <nl> stream = stream . makeSubStream ( pos , length ) ; <nl> var Parser = ( function ( ) { <nl> var paramsArray = params ; <nl> for ( filter in filterArray ) { <nl> if ( ! IsName ( filter ) ) <nl> - this . error ( \" Bad filter name \" ) ; <nl> + error ( \" Bad filter name \" ) ; <nl> else { <nl> params = null ; <nl> if ( IsArray ( paramsArray ) & & ( i in paramsArray ) ) <nl> var Linearization = ( function ( ) { <nl> obj > 0 ) { <nl> return obj ; <nl> } <nl> - this . error ( \" ' \" + name + \" ' field in linearization table is invalid \" ) ; <nl> + error ( \" ' \" + name + \" ' field in linearization table is invalid \" ) ; <nl> return 0 ; <nl> } , <nl> getHint : function ( index ) { <nl> var Linearization = ( function ( ) { <nl> obj2 > 0 ) { <nl> return obj2 ; <nl> } <nl> - this . error ( \" Hints table in linearization table is invalid \" ) ; <nl> + error ( \" Hints table in linearization table is invalid \" ) ; <nl> return 0 ; <nl> } , <nl> get length ( ) { <nl> var Interpreter = ( function ( ) { <nl> var fn = map [ cmd ] ; <nl> if ( fn ) { <nl> if ( fn . length ! = args . length ) <nl> - this . error ( \" Invalid number of arguments ' \" + cmd + \" ' \" ) ; <nl> + error ( \" Invalid number of arguments ' \" + cmd + \" ' \" ) ; <nl> fn . apply ( gfx , args ) ; <nl> } else <nl> - this . error ( \" Unknown command ' \" + cmd + \" ' \" ) ; <nl> + error ( \" Unknown command ' \" + cmd + \" ' \" ) ; <nl> args . length = 0 ; <nl> } else { <nl> if ( args . length > 33 ) <nl> - this . error ( \" Too many arguments ' \" + cmd + \" ' \" ) ; <nl> + error ( \" Too many arguments ' \" + cmd + \" ' \" ) ; <nl> args . push ( obj ) ; <nl> } <nl> } <nl> this . gfx . endDrawing ( ) ; <nl> - } , <nl> - error : function ( what ) { <nl> - throw new Error ( what ) ; <nl> - } , <nl> + } <nl> } ; <nl> <nl> return constructor ; <nl> var CanvasGraphics = ( function ( ) { <nl> } else if ( IsString ( e ) ) { <nl> this . showText ( e ) ; <nl> } else { <nl> - this . error ( \" Unexpected element in TJ array \" ) ; <nl> + error ( \" Unexpected element in TJ array \" ) ; <nl> } <nl> } <nl> } , <nl>\n", "msg": "throw Error for errors , and warn in browser and shell\n", "score": 1}
{"diff_id": 2485, "repo": "Automattic/mongoose\n", "sha": "87752e33bbf3c04b22e05a499273ba10ed2f1703\n", "time": "2020-05-13T12:08:57Z\n", "diff": "mmm a / lib / helpers / model / castBulkWrite . js <nl> ppp b / lib / helpers / model / castBulkWrite . js <nl> module . exports = function castBulkWrite ( originalModel , op , options ) { <nl> } else if ( op [ ' updateOne ' ] ) { <nl> return ( callback ) = > { <nl> try { <nl> + if ( ! op [ ' updateOne ' ] [ ' filter ' ] ) throw new Error ( ' Must provide a filter object . ' ) ; <nl> + if ( ! op [ ' updateOne ' ] [ ' update ' ] ) throw new Error ( ' Must provide an update object . ' ) ; <nl> + <nl> const model = decideModelByObject ( originalModel , op [ ' updateOne ' ] [ ' filter ' ] ) ; <nl> const schema = model . schema ; <nl> const strict = options . strict ! = null ? options . strict : model . schema . options . strict ; <nl> <nl> - if ( ! op [ ' updateOne ' ] [ ' filter ' ] ) throw new Error ( ' Must provide a filter object . ' ) ; <nl> - if ( ! op [ ' updateOne ' ] [ ' update ' ] ) throw new Error ( ' Must provide an update object . ' ) ; <nl> - <nl> _addDiscriminatorToObject ( schema , op [ ' updateOne ' ] [ ' filter ' ] ) ; <nl> op [ ' updateOne ' ] [ ' filter ' ] = cast ( model . schema , op [ ' updateOne ' ] [ ' filter ' ] , { <nl> strict : strict , <nl>\n", "msg": "validate operation before attempting to get model on ` updateOne `\n", "score": 1}
{"diff_id": 3024, "repo": "pure-css/pure\n", "sha": "b51c421888ab7832f4d9d6805358958bc8a17147\n", "time": "2013-11-27T19:36:18Z\n", "diff": "mmm a / Gruntfile . js <nl> ppp b / Gruntfile . js <nl> grunt . initConfig ( { <nl> <nl> { ' build / < % = pkg . name % > . css ' : [ <nl> ' build / base . css ' , <nl> + ' build / grids . css ' , <nl> ' build / buttons . css ' , <nl> ' build / forms . css ' , <nl> - ' build / grids . css ' , <nl> ' build / menus . css ' , <nl> ' build / tables . css ' <nl> ] } , <nl> <nl> { ' build / < % = pkg . name % > - nr . css ' : [ <nl> ' build / base . css ' , <nl> + ' build / grids - nr . css ' , <nl> ' build / buttons . css ' , <nl> ' build / forms - nr . css ' , <nl> - ' build / grids - nr . css ' , <nl> ' build / menus - nr . css ' , <nl> ' build / tables . css ' <nl> ] } <nl>\n", "msg": "Rearrange modules in pure . css rollup to : Base , Grids , etc .\n", "score": 1}
{"diff_id": 3027, "repo": "Automattic/mongoose\n", "sha": "5c0d2629674d891eb495f5967fb9b295134333f0\n", "time": "2016-12-10T10:46:46Z\n", "diff": "mmm a / lib / model . js <nl> ppp b / lib / model . js <nl> function convertTo_id ( val ) { <nl> } <nl> } <nl> if ( val . isMongooseArray ) { <nl> - return new MongooseArray ( val , val . _path , val . _parent ) ; <nl> + return val . _parent . schema . path ( val . _path ) . cast ( val , val . _parent ) ; <nl> } <nl> <nl> return [ ] . concat ( val ) ; <nl>\n", "msg": "Restored ability to override populated array caster from 4 . 6 . 2\n", "score": 1}
{"diff_id": 3155, "repo": "codemirror/CodeMirror\n", "sha": "fe2bdb372b7c1f2978d8b5934a1d16546f032a9a\n", "time": "2019-01-03T10:28:23Z\n", "diff": "mmm a / mode / javascript / javascript . js <nl> ppp b / mode / javascript / javascript . js <nl> CodeMirror . defineMode ( \" javascript \" , function ( config , parserConfig ) { <nl> else return cont ( pushlex ( \" form \" ) , pattern , expect ( \" { \" ) , pushlex ( \" } \" ) , block , poplex , poplex ) <nl> } else if ( isTS & & value = = \" namespace \" ) { <nl> cx . marked = \" keyword \" <nl> - return cont ( pushlex ( \" form \" ) , expression , block , poplex ) <nl> + return cont ( pushlex ( \" form \" ) , expression , statement , poplex ) <nl> } else if ( isTS & & value = = \" abstract \" ) { <nl> cx . marked = \" keyword \" <nl> return cont ( statement ) <nl> CodeMirror . defineMode ( \" javascript \" , function ( config , parserConfig ) { <nl> } , proceed ) ; <nl> } <nl> if ( type = = end | | value = = end ) return cont ( ) ; <nl> + if ( sep & & sep . indexOf ( \" ; \" ) > - 1 ) return pass ( what ) <nl> return cont ( expect ( end ) ) ; <nl> } <nl> return function ( type , value ) { <nl> CodeMirror . defineMode ( \" javascript \" , function ( config , parserConfig ) { <nl> return cont ( typeexpr ) <nl> } else if ( type = = \" [ \" ) { <nl> return cont ( expression , maybetype , expect ( \" ] \" ) , typeprop ) <nl> + } else if ( type = = \" ( \" ) { <nl> + return cont ( pushlex ( \" ) \" ) , commasep ( funarg , \" ) \" ) , poplex , typeprop ) <nl> } <nl> } <nl> function typearg ( type , value ) { <nl>\n", "msg": "[ javascript mode ] Improve support for syntactic corner cases in TypeScript\n", "score": 1}
{"diff_id": 3433, "repo": "TryGhost/Ghost\n", "sha": "a1fef1fc7ce54fd49901fa154632f08e090f6412\n", "time": "2020-02-19T11:55:32Z\n", "diff": "mmm a / core / server / api / canary / members . js <nl> ppp b / core / server / api / canary / members . js <nl> const members = { <nl> } , { <nl> name : ' labels ' , <nl> lookup : / labels / i <nl> + } , { <nl> + name : ' created_at ' , <nl> + lookup : / created_at / i <nl> } ] ; <nl> <nl> return fsLib . readCSV ( { <nl> const members = { <nl> subscribed : subscribed , <nl> stripe_customer_id : entry . stripe_customer_id , <nl> comped : ( String ( entry . complimentary_plan ) . toLocaleLowerCase ( ) = = = ' true ' ) , <nl> - labels : entryLabels <nl> + labels : entryLabels , <nl> + created_at : entry . created_at <nl> } ] <nl> } , <nl> options : { <nl>\n", "msg": "Added ` created_at ` field to accepted fields for members CSV import\n", "score": 1}
{"diff_id": 3604, "repo": "meteor/meteor\n", "sha": "a270dee1a0ab07e7ccef4fc31d0f43c4da7843a8\n", "time": "2016-02-11T09:26:56Z\n", "diff": "mmm a / packages / launch - screen / package . js <nl> ppp b / packages / launch - screen / package . js <nl> Package . describe ( { <nl> } ) ; <nl> <nl> Cordova . depends ( { <nl> - ' cordova - plugin - splashscreen ' : ' 3 . 0 . 0 ' <nl> + ' cordova - plugin - splashscreen ' : ' https : / / github . com / apache / cordova - plugin - splashscreen . git # 2e1ec329168633b39c0251ca9e1ec87d9a9483c9 ' <nl> } ) ; <nl> <nl> Package . onUse ( function ( api ) { <nl>\n", "msg": "Temporarily use cordova - plugin - splashscreen from git until new version is released\n", "score": 1}
{"diff_id": 4016, "repo": "meteor/meteor\n", "sha": "aed9907aefe65a8416eed38d814a0a26c149cc5b\n", "time": "2017-07-21T18:34:53Z\n", "diff": "mmm a / packages / babel - compiler / babel - compiler . js <nl> ppp b / packages / babel - compiler / babel - compiler . js <nl> BCp . processOneFileForTarget = function ( inputFile , source ) { <nl> <nl> var extraFeatures = Object . assign ( { } , this . extraFeatures ) ; <nl> <nl> + if ( inputFile . getArch ( ) . startsWith ( \" os . \" ) ) { <nl> + / / Start with a much simpler set of Babel presets and plugins if <nl> + / / we ' re compiling for Node 8 . <nl> + extraFeatures . nodeMajorVersion = parseInt ( process . versions . node ) ; <nl> + } <nl> + <nl> if ( ! extraFeatures . hasOwnProperty ( \" jscript \" ) ) { <nl> / / Perform some additional transformations to improve compatibility <nl> / / in older browsers ( e . g . wrapping named function expressions , per <nl>\n", "msg": "Use Babel options appropriate for Node 8 to compile server code .\n", "score": 1}
{"diff_id": 4368, "repo": "balderdashy/sails\n", "sha": "09181a6bd8087199ce8909cee4ac4792a996b2fa\n", "time": "2014-04-27T08:30:05Z\n", "diff": "mmm a / lib / app / request . js <nl> ppp b / lib / app / request . js <nl> module . exports = function request ( / * address , body , cb * / ) { <nl> <nl> var sails = this ; <nl> <nl> + / / <nl> + / / TODO : <nl> + / / Allow body params to be passed in to DELETE , HEAD , and GET requests <nl> + / / ( just serialize them into a querystring ) <nl> + / / <nl> + / / TODO : <nl> + / / Support other methods on req and res , and parse the querystring . <nl> + / / Implement basic bodyParser shim for non - http requests for consistency <nl> + / / in testing and usage . <nl> + / / ( i . e . merge w / lib / router / req . js and lib / hooks / sockets / lib / interpreter / * . js ) <nl> + / / <nl> + <nl> + <nl> / / Normalize usage <nl> var address = arguments [ 0 ] ; <nl> var body ; <nl> module . exports = function request ( / * address , body , cb * / ) { <nl> <nl> } ) ; <nl> <nl> - / / Req stream ends automatically if this is a GET or HEAD request . <nl> - if ( opts . method ! = = ' GET ' & & opts . method ! = = ' HEAD ' ) { <nl> + / / Req stream ends automatically if this is a GET or HEAD request <nl> + / / - no need to do it again <nl> + if ( opts . method ! = = ' GET ' & & opts . method ! = = ' HEAD ' & & opts . method ! = = ' DELETE ' ) { <nl> / / Only write the body if there IS a body . <nl> if ( opts . body ) { <nl> req . write ( opts . body ) ; <nl>\n", "msg": "Add ' DELETE ' to list of methods where the stream need not be ended manually . Added todo and explanation about next steps .\n", "score": 1}
{"diff_id": 4412, "repo": "facebook/react\n", "sha": "8e2134beee2b174ea9cd16ba1d2f5d50aaea1ead\n", "time": "2019-07-28T15:42:21Z\n", "diff": "mmm a / src / backend / agent . js <nl> ppp b / src / backend / agent . js <nl> export default class Agent extends EventEmitter < { | <nl> ( rendererID : any ) <nl> ] : any ) : RendererInterface ) ; <nl> <nl> - const id = renderer . getFiberIDForNative ( node , true ) ; <nl> - <nl> - if ( id ! = = null ) { <nl> - return id ; <nl> + try { <nl> + const id = renderer . getFiberIDForNative ( node , true ) ; <nl> + if ( id ! = = null ) { <nl> + return id ; <nl> + } <nl> + } catch ( error ) { <nl> + / / Some old React versions might throw if they can ' t find a match . <nl> + / / If so we should ignore it . . . <nl> } <nl> } <nl> return null ; <nl>\n", "msg": "Re - add try / catch inside Agent ' s getIDForNode ( )\n", "score": 1}
{"diff_id": 4510, "repo": "emberjs/ember.js\n", "sha": "9ea43769bb5f7b8538471d6c0710a81322cd0bae\n", "time": "2020-05-09T02:41:58Z\n", "diff": "mmm a / packages / @ ember / application / lib / application . js <nl> ppp b / packages / @ ember / application / lib / application . js <nl> const Application = Engine . extend ( { <nl> @ return { ApplicationInstance } the application instance <nl> * / <nl> buildInstance ( options = { } ) { <nl> + assert ( <nl> + ' You cannot build new instances of this application since it has already been destroyed ' , <nl> + ! this . isDestroyed <nl> + ) ; <nl> + <nl> + assert ( <nl> + ' You cannot build new instances of this application since it is being destroyed ' , <nl> + ! this . isDestroying <nl> + ) ; <nl> + <nl> options . base = this ; <nl> options . application = this ; <nl> return ApplicationInstance . create ( options ) ; <nl> const Application = Engine . extend ( { <nl> @ method domReady <nl> * / <nl> domReady ( ) { <nl> - if ( this . isDestroyed ) { <nl> + if ( this . isDestroying | | this . isDestroyed ) { <nl> return ; <nl> } <nl> <nl> const Application = Engine . extend ( { <nl> ' You must call deferReadiness on an instance of Application ' , <nl> this instanceof Application <nl> ) ; <nl> + <nl> + assert ( ' You cannot defer readiness since application has already destroyed ' , ! this . isDestroyed ) ; <nl> + <nl> + assert ( <nl> + ' You cannot defer readiness since the application is being destroyed ' , <nl> + ! this . isDestroying <nl> + ) ; <nl> + <nl> assert ( <nl> - ' You cannot defer readiness since the ` ready ( ) ` hook has already been called . ' , <nl> + ' You cannot defer readiness since the ` ready ( ) ` hook has already been called ' , <nl> this . _readinessDeferrals > 0 <nl> ) ; <nl> + <nl> this . _readinessDeferrals + + ; <nl> } , <nl> <nl> const Application = Engine . extend ( { <nl> ' You must call advanceReadiness on an instance of Application ' , <nl> this instanceof Application <nl> ) ; <nl> + <nl> + assert ( <nl> + ' You cannot advance readiness since application has already destroyed ' , <nl> + ! this . isDestroyed <nl> + ) ; <nl> + <nl> + assert ( <nl> + ' You cannot advance readiness since the application is being destroyed ' , <nl> + ! this . isDestroying <nl> + ) ; <nl> + <nl> + assert ( <nl> + ' You cannot advance readiness since the ` ready ( ) ` hook has already been called ' , <nl> + this . _readinessDeferrals > 0 <nl> + ) ; <nl> + <nl> this . _readinessDeferrals - - ; <nl> <nl> if ( this . _readinessDeferrals = = = 0 ) { <nl> const Application = Engine . extend ( { <nl> @ return { Promise < Application , Error > } <nl> * / <nl> boot ( ) { <nl> + assert ( <nl> + ' You cannot boot this application since it has already been destroyed ' , <nl> + ! this . isDestroyed <nl> + ) ; <nl> + <nl> + assert ( ' You cannot boot this application since it is being destroyed ' , ! this . isDestroying ) ; <nl> + <nl> if ( this . _bootPromise ) { <nl> return this . _bootPromise ; <nl> } <nl> const Application = Engine . extend ( { <nl> @ private <nl> * / <nl> _bootSync ( ) { <nl> - if ( this . _booted ) { <nl> + if ( this . _booted | | this . isDestroying | | this . isDestroyed ) { <nl> return ; <nl> } <nl> <nl> const Application = Engine . extend ( { <nl> @ public <nl> * / <nl> reset ( ) { <nl> + assert ( <nl> + ' You cannot reset this application since it has already been destroyed ' , <nl> + ! this . isDestroyed <nl> + ) ; <nl> + <nl> + assert ( ' You cannot reset this application since it is being destroyed ' , ! this . isDestroying ) ; <nl> + <nl> assert ( <nl> ` Calling reset ( ) on instances of \\ ` Application \\ ` is not <nl> supported when globals mode is disabled ; call \\ ` visit ( ) \\ ` to <nl> const Application = Engine . extend ( { <nl> @ method didBecomeReady <nl> * / <nl> didBecomeReady ( ) { <nl> + if ( this . isDestroying | | this . isDestroyed ) { <nl> + return ; <nl> + } <nl> + <nl> try { <nl> / / TODO : Is this still needed for _globalsMode = false ? <nl> if ( ! isTesting ( ) ) { <nl> const Application = Engine . extend ( { <nl> / / This method must be moved to the application instance object <nl> willDestroy ( ) { <nl> this . _super ( . . . arguments ) ; <nl> + <nl> setNamespaceSearchDisabled ( false ) ; <nl> - this . _booted = false ; <nl> - this . _bootPromise = null ; <nl> - this . _bootResolver = null ; <nl> <nl> if ( _loaded . application = = = this ) { <nl> _loaded . application = undefined ; <nl> const Application = Engine . extend ( { <nl> @ return { Promise < ApplicationInstance , Error > } <nl> * / <nl> visit ( url , options ) { <nl> + assert ( <nl> + ' You cannot visit this application since it has already been destroyed ' , <nl> + ! this . isDestroyed <nl> + ) ; <nl> + <nl> + assert ( ' You cannot visit this application since it is being destroyed ' , ! this . isDestroying ) ; <nl> + <nl> return this . boot ( ) . then ( ( ) = > { <nl> let instance = this . buildInstance ( ) ; <nl> <nl>\n", "msg": "[ BUGFIX lts ] More assertions for Application lifecycle methods\n", "score": 1}
{"diff_id": 4885, "repo": "TryGhost/Ghost\n", "sha": "d89992321004355e8fa4e65b39edc97a28e7013e\n", "time": "2019-10-01T06:05:48Z\n", "diff": "mmm a / core / frontend / services / themes / middleware . js <nl> ppp b / core / frontend / services / themes / middleware . js <nl> function updateLocalTemplateOptions ( req , res , next ) { <nl> email : req . member . email , <nl> name : req . member . name , <nl> subscriptions : req . member . stripe . subscriptions , <nl> - subscribed : req . member . stripe . subscriptions . length ! = = 0 <nl> + paid : req . member . stripe . subscriptions . length ! = = 0 <nl> } : null ; <nl> <nl> hbs . updateLocalTemplateOptions ( res . locals , _ . merge ( { } , localTemplateOptions , { <nl>\n", "msg": "Renamed @ member . subscribed to @ member . paid\n", "score": 1}
{"diff_id": 4918, "repo": "photonstorm/phaser\n", "sha": "fb775d4063ca431b55247a0c84717529f1eb3c3e\n", "time": "2018-01-17T18:13:21Z\n", "diff": "mmm a / src / sound / html5 / HTML5AudioSound . js <nl> ppp b / src / sound / html5 / HTML5AudioSound . js <nl> var HTML5AudioSound = new Class ( { <nl> return true ; <nl> } , <nl> pause : function ( ) { <nl> - if ( this . checkTouchLocked ( ' method ' , ' pause ' ) ) { <nl> + if ( this . manager . isLocked ( this , ' pause ' ) ) { <nl> return false ; <nl> } <nl> if ( this . startTime > 0 ) { <nl>\n", "msg": "Using manager . isLocked instead of removed checkTouchLocked method for pause method\n", "score": 1}
{"diff_id": 5132, "repo": "markedjs/marked\n", "sha": "9880f22c4f4d71c84ebf5690b085bd75ec9203af\n", "time": "2012-04-06T07:41:28Z\n", "diff": "mmm a / lib / marked . js <nl> ppp b / lib / marked . js <nl> marked . options = <nl> marked . setOptions = function ( opt ) { <nl> defaults = opt ; <nl> setOptions ( opt ) ; <nl> + return marked ; <nl> } ; <nl> <nl> marked . options ( { <nl>\n", "msg": "returning ' marked ' in setOptions to allow for fluent interface\n", "score": 1}
{"diff_id": 5144, "repo": "lodash/lodash\n", "sha": "28171945e9f6367ac39dc6315c73a07b46a0f68a\n", "time": "2016-03-02T15:39:08Z\n", "diff": "mmm a / perf / perf . js <nl> ppp b / perf / perf . js <nl> <nl> suites . push ( <nl> Benchmark . Suite ( ' ` _ . assign ` ' ) <nl> . add ( buildName , { <nl> - ' fn ' : ' lodashAssign ( { } , object ) ' , <nl> + ' fn ' : ' lodashAssign ( { } , { \" a \" : 1 , \" b \" : 2 , \" c \" : 3 } ) ' , <nl> ' teardown ' : ' function assign ( ) { } ' <nl> } ) <nl> . add ( otherName , { <nl> - ' fn ' : ' _assign ( { } , object ) ' , <nl> + ' fn ' : ' _assign ( { } , { \" a \" : 1 , \" b \" : 2 , \" c \" : 3 } ) ' , <nl> ' teardown ' : ' function assign ( ) { } ' <nl> } ) <nl> ) ; <nl> <nl> suites . push ( <nl> Benchmark . Suite ( ' ` _ . assign ` with multiple sources ' ) <nl> . add ( buildName , { <nl> - ' fn ' : ' lodashAssign ( { } , object , object ) ' , <nl> + ' fn ' : ' lodashAssign ( { } , { \" a \" : 1 , \" b \" : 2 } , { \" c \" : 3 , \" d \" : 4 } ) ' , <nl> ' teardown ' : ' function assign ( ) { } ' <nl> } ) <nl> . add ( otherName , { <nl> - ' fn ' : ' _assign ( { } , object , object ) ' , <nl> + ' fn ' : ' _assign ( { } , { \" a \" : 1 , \" b \" : 2 } , { \" c \" : 3 , \" d \" : 4 } ) ' , <nl> ' teardown ' : ' function assign ( ) { } ' <nl> } ) <nl> ) ; <nl>\n", "msg": "Use smaller objects for ` _ . assign ` bench .\n", "score": 1}
{"diff_id": 5639, "repo": "photonstorm/phaser\n", "sha": "95a348d634e2a938f67f695b4814fdb01ef533bc\n", "time": "2018-01-08T16:30:49Z\n", "diff": "mmm a / v3 / src / loader / filetypes / HTML5AudioFile . js <nl> ppp b / v3 / src / loader / filetypes / HTML5AudioFile . js <nl> var HTML5AudioFile = new Class ( { <nl> audio . preload = ' auto ' ; <nl> audio . oncanplaythrough = this . onProgress . bind ( this ) ; <nl> audio . onerror = this . onError . bind ( this ) ; <nl> - audio . src = GetURL ( this , baseURL | | ' ' ) ; <nl> - audio . load ( ) ; <nl> <nl> this . data . push ( audio ) ; <nl> } <nl> + <nl> + for ( i = 0 ; i < this . data . length ; i + + ) <nl> + { <nl> + audio = this . data [ i ] ; <nl> + audio . src = GetURL ( this , baseURL | | ' ' ) ; <nl> + audio . load ( ) ; <nl> + } <nl> } <nl> <nl> } ) ; <nl>\n", "msg": "Splitting audio objects initialization and loading to make sure all event listeners are set before any file starts loading\n", "score": 1}
{"diff_id": 5736, "repo": "balderdashy/sails\n", "sha": "1c3c0f9a47848da44c1b0f9b2d5cc676e1b485ed\n", "time": "2014-04-29T20:02:58Z\n", "diff": "mmm a / lib / hooks / views / res . view . js <nl> ppp b / lib / hooks / views / res . view . js <nl> module . exports = function _addResViewMethod ( req , res , next ) { <nl> } <nl> sails . log . silly ( ' Serving view at rel path : ' , relPathToView ) ; <nl> sails . log . silly ( ' View root : ' , sails . config . paths . views ) ; <nl> - return res . render ( relPathToView , sails . config . views . engineOptions | | { } , function renderView ( err , renderedViewStr ) { <nl> + return res . render ( relPathToView , function renderView ( err , renderedViewStr ) { <nl> <nl> <nl> / / if a template error occurred , don ' t rely on any of the Sails request / response methods <nl>\n", "msg": "Reverse commit 2e83ed6 , since we realized we can just set sails . config . views . locals to do the same thing .\n", "score": 1}
{"diff_id": 5757, "repo": "lodash/lodash\n", "sha": "141630f5570bbef04cbbe180bcc79f3fc2b0b180\n", "time": "2015-10-07T06:16:02Z\n", "diff": "mmm a / test / test . js <nl> ppp b / test / test . js <nl> <nl> } ) ; <nl> <nl> QUnit . test ( ' ` _ . cloneDeepWith ` should provide ` stack ` to ` customizer ` ' , function ( assert ) { <nl> - assert . expect ( 5 ) ; <nl> + assert . expect ( 12 ) ; <nl> <nl> var stack , <nl> object = new Foo ; <nl> <nl> assert . strictEqual ( stack . get ( object ) , clone ) ; <nl> assert . strictEqual ( stack [ ' delete ' ] ( object ) , true ) ; <nl> assert . strictEqual ( stack . has ( object ) , false ) ; <nl> + assert . strictEqual ( stack . get ( object ) , undefined ) ; <nl> assert . strictEqual ( stack [ ' delete ' ] ( object ) , false ) ; <nl> + <nl> + stack = new stack . constructor ( [ [ ' a ' , 1 ] , [ ' b ' , 2 ] ] ) ; <nl> + <nl> + assert . strictEqual ( stack . has ( ' a ' ) , true ) ; <nl> + assert . strictEqual ( stack . get ( ' a ' ) , 1 ) ; <nl> + assert . strictEqual ( stack [ ' delete ' ] ( ' a ' ) , true ) ; <nl> + assert . strictEqual ( stack . has ( ' a ' ) , false ) ; <nl> + assert . strictEqual ( stack . get ( ' a ' ) , undefined ) ; <nl> + assert . strictEqual ( stack [ ' delete ' ] ( ' a ' ) , false ) ; <nl> } ) ; <nl> <nl> _ . each ( [ ' clone ' , ' cloneDeep ' ] , function ( methodName ) { <nl> <nl> } ) ; <nl> <nl> QUnit . test ( ' should expose a ` cache ` object on the ` memoized ` function which implements ` Map ` interface ' , function ( assert ) { <nl> - assert . expect ( 10 ) ; <nl> + assert . expect ( 12 ) ; <nl> <nl> _ . times ( 2 , function ( index ) { <nl> var resolver = index ? _ . identity : null ; <nl> <nl> assert . strictEqual ( cache . get ( ' a ' ) , ' value : a ' ) ; <nl> assert . strictEqual ( cache [ ' delete ' ] ( ' a ' ) , true ) ; <nl> assert . strictEqual ( cache . has ( ' a ' ) , false ) ; <nl> + assert . strictEqual ( cache . get ( ' a ' ) , undefined ) ; <nl> assert . strictEqual ( cache [ ' delete ' ] ( ' a ' ) , false ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> <nl> assert . strictEqual ( count , 1 ) ; <nl> assert . strictEqual ( cache . get ( key ) , array ) ; <nl> - assert . strictEqual ( cache [ ' delete ' ] ( key ) , true ) ; <nl> assert . notOk ( cache . __data__ instanceof Array ) ; <nl> + assert . strictEqual ( cache [ ' delete ' ] ( key ) , true ) ; <nl> } ) ; <nl> } ) ; <nl> <nl>\n", "msg": "Add more ` MapCache ` and ` Stack ` tests .\n", "score": 1}
{"diff_id": 6081, "repo": "lodash/lodash\n", "sha": "49b33d667d74cc5d68441b581809891723cb2102\n", "time": "2016-03-07T16:04:11Z\n", "diff": "mmm a / test / test . js <nl> ppp b / test / test . js <nl> <nl> QUnit . module ( ' toPairs methods ' ) ; <nl> <nl> lodashStable . each ( [ ' toPairs ' , ' toPairsIn ' ] , function ( methodName ) { <nl> - var func = _ [ methodName ] ; <nl> + var func = _ [ methodName ] , <nl> + isToPairs = methodName = = ' toPairs ' ; <nl> <nl> - QUnit . test ( ' ` _ . ' + methodName + ' ` should create a two dimensional array of key - value pairs ' , function ( assert ) { <nl> + QUnit . test ( ' ` _ . ' + methodName + ' ` should create an array of string keyed - value pairs ' , function ( assert ) { <nl> assert . expect ( 1 ) ; <nl> <nl> - var object = { ' a ' : 1 , ' b ' : 2 } ; <nl> - assert . deepEqual ( func ( object ) , [ [ ' a ' , 1 ] , [ ' b ' , 2 ] ] ) ; <nl> + var object = { ' a ' : 1 , ' b ' : 2 } , <nl> + actual = lodashStable . sortBy ( func ( object ) , 0 ) ; <nl> + <nl> + assert . deepEqual ( actual , [ [ ' a ' , 1 ] , [ ' b ' , 2 ] ] ) ; <nl> } ) ; <nl> <nl> QUnit . test ( ' ` _ . ' + methodName + ' ` should work with an object that has a ` length ` property ' , function ( assert ) { <nl> assert . expect ( 1 ) ; <nl> <nl> - var object = { ' 0 ' : ' a ' , ' 1 ' : ' b ' , ' length ' : 2 } ; <nl> - assert . deepEqual ( func ( object ) , [ [ ' 0 ' , ' a ' ] , [ ' 1 ' , ' b ' ] , [ ' length ' , 2 ] ] ) ; <nl> + var object = { ' 0 ' : ' a ' , ' 1 ' : ' b ' , ' length ' : 2 } , <nl> + actual = lodashStable . sortBy ( func ( object ) , 0 ) ; <nl> + <nl> + assert . deepEqual ( actual , [ [ ' 0 ' , ' a ' ] , [ ' 1 ' , ' b ' ] , [ ' length ' , 2 ] ] ) ; <nl> + } ) ; <nl> + <nl> + QUnit . test ( ' ` _ . ' + methodName + ' ` should ' + ( isToPairs ? ' not ' : ' ' ) + ' include inherited string keyed property values ' , function ( assert ) { <nl> + assert . expect ( 1 ) ; <nl> + <nl> + function Foo ( ) { <nl> + this . a = 1 ; <nl> + } <nl> + Foo . prototype . b = 2 ; <nl> + <nl> + var expected = isToPairs ? [ [ ' a ' , 1 ] ] : [ [ ' a ' , 1 ] , [ ' b ' , 2 ] ] , <nl> + actual = lodashStable . sortBy ( func ( new Foo ) , 0 ) ; <nl> + <nl> + assert . deepEqual ( actual , expected ) ; <nl> } ) ; <nl> <nl> QUnit . test ( ' ` _ . ' + methodName + ' ` should work with strings ' , function ( assert ) { <nl> assert . expect ( 2 ) ; <nl> <nl> lodashStable . each ( [ ' xo ' , Object ( ' xo ' ) ] , function ( string ) { <nl> - assert . deepEqual ( func ( string ) , [ [ ' 0 ' , ' x ' ] , [ ' 1 ' , ' o ' ] ] ) ; <nl> + var actual = lodashStable . sortBy ( func ( string ) , 0 ) ; <nl> + assert . deepEqual ( actual , [ [ ' 0 ' , ' x ' ] , [ ' 1 ' , ' o ' ] ] ) ; <nl> } ) ; <nl> } ) ; <nl> } ) ; <nl>\n", "msg": "Add ` toPairs ` test for inherited string keyed properties .\n", "score": 1}
{"diff_id": 6174, "repo": "adobe/brackets\n", "sha": "7a6233aff165e8406be38aa6a5d3dc655ea73f5d\n", "time": "2013-10-31T21:30:14Z\n", "diff": "mmm a / src / search / FindInFiles . js <nl> ppp b / src / search / FindInFiles . js <nl> define ( function ( require , exports , module ) { <nl> var currentEditor = EditorManager . getActiveEditor ( ) , <nl> initialString = currentEditor & & currentEditor . getSelectedText ( ) ; <nl> <nl> + if ( dialog & & ! dialog . closed & & dialog . hasOwnProperty ( \" modalBar \" ) & & dialog . modalBar ) { <nl> + / / The modalBar was already up . When creating the new modalBar , copy the <nl> + / / current query instead of using the passed - in selected text . <nl> + initialString = dialog . getDialogTextField ( ) . val ( ) ; <nl> + dialog . modalBar . close ( true , false ) ; <nl> + } <nl> + <nl> dialog = new FindInFilesDialog ( ) ; <nl> searchResults = { } ; <nl> currentStart = 0 ; <nl>\n", "msg": "Set focus to input field when hitting Find In Files when it is already open\n", "score": 1}
{"diff_id": 6517, "repo": "Unitech/pm2\n", "sha": "14590ec3f97c8056ae9b1ec1ca0cec48b6d50a37\n", "time": "2014-04-09T07:53:23Z\n", "diff": "mmm a / lib / Interactor . js <nl> ppp b / lib / Interactor . js <nl> var Interact = { <nl> console . log ( ' Connecting to local PM2 ' ) ; <nl> <nl> ipm2a . on ( ' ready ' , function ( ) { <nl> - debug ( ' Succesfully connected to local PM2 ' ) ; <nl> + console . log ( ' Succesfully connected to local PM2 ' ) ; <nl> / * * <nl> * Forward all events to remote <nl> * / <nl> var Interact = { <nl> } ) ; <nl> <nl> ipm2a . on ( ' reconnecting ' , function ( ) { <nl> - debug ( ' Disconnected from PM2 - Reconnecting ' ) ; <nl> + console . error ( ' Disconnected from PM2 - Reconnecting ' ) ; <nl> Interact . stop_workers ( ) ; <nl> ipm2a . removeAllListeners ( ) ; <nl> ipm2a . disconnect ( ) ; <nl>\n", "msg": "Display successfull / failure connection in interactor . log\n", "score": 1}
{"diff_id": 6876, "repo": "Semantic-Org/Semantic-UI\n", "sha": "7ad2931ddf93a858864f7e8b010b48401e1ccada\n", "time": "2015-01-15T07:48:10Z\n", "diff": "mmm a / src / definitions / modules / dropdown . js <nl> ppp b / src / definitions / modules / dropdown . js <nl> $ . fn . dropdown = function ( parameters ) { <nl> ? callback <nl> : function ( ) { } <nl> ; <nl> - if ( module . can . show ( ) & & ! module . is . active ( ) & & ! module . is . allFiltered ( ) ) { <nl> + if ( module . is . searchSelection ( ) & & module . is . allFiltered ( ) ) { <nl> + return ; <nl> + } <nl> + if ( module . can . show ( ) & & ! module . is . active ( ) ) { <nl> module . debug ( ' Showing dropdown ' ) ; <nl> module . animate . show ( function ( ) { <nl> if ( module . can . click ( ) ) { <nl>\n", "msg": "Show filtered menu if search input placed in menu .\n", "score": 1}
{"diff_id": 6985, "repo": "adobe/brackets\n", "sha": "635f2393b730e393f88b7a8b65e950d93a9643b4\n", "time": "2014-05-20T15:45:56Z\n", "diff": "mmm a / src / extensions / default / CSSCodeHints / main . js <nl> ppp b / src / extensions / default / CSSCodeHints / main . js <nl> define ( function ( require , exports , module ) { <nl> / / adjust the cursor position and show code hints for property values . <nl> end . ch = start . ch + this . info . name . length ; <nl> ctx = TokenUtils . getInitialContext ( this . editor . _codeMirror , cursor ) ; <nl> - if ( ctx . token . string . length > 0 & & ! ctx . token . string . match ( / \\ S / ) ) { <nl> + if ( ctx . token . string . length > 0 & & ! / \\ S / . test ( ctx . token . string ) ) { <nl> / / We ' re at the very beginning of a property name . So skip it <nl> / / before we locate the colon following it . <nl> TokenUtils . moveNextToken ( ctx ) ; <nl> define ( function ( require , exports , module ) { <nl> adjustCursor = true ; <nl> newCursor = { line : cursor . line , <nl> ch : cursor . ch + ( hint . length - this . info . name . length ) } ; <nl> + / / Adjust cursor to the position after the trailing whitespace if there is any . <nl> + if ( TokenUtils . moveNextToken ( ctx ) & & ctx . token . string . length > 0 & & ! / \\ S / . test ( ctx . token . string ) ) { <nl> + newCursor . ch + = ctx . token . string . length ; <nl> + } <nl> } else { <nl> hint + = \" : \" ; <nl> } <nl>\n", "msg": "Adjust the cursor to the pos after the trailing whitespace when replacing an existing property name .\n", "score": 1}
{"diff_id": 7250, "repo": "RocketChat/Rocket.Chat\n", "sha": "10d53ce7d364022de2c7c81e4045bc9913f4c3f7\n", "time": "2020-10-30T02:55:59Z\n", "diff": "mmm a / client / omnichannel / agents / AgentInfo . js <nl> ppp b / client / omnichannel / agents / AgentInfo . js <nl> import { useTranslation } from ' . . / . . / contexts / TranslationContext ' ; <nl> import VerticalBar from ' . . / . . / components / basic / VerticalBar ' ; <nl> import { useEndpointDataExperimental , ENDPOINT_STATES } from ' . . / . . / hooks / useEndpointDataExperimental ' ; <nl> import { UserInfo } from ' . . / . . / components / basic / UserInfo ' ; <nl> - import * as UserStatus from ' . . / . . / components / basic / UserStatus ' ; <nl> + import { UserStatus } from ' . . / . . / components / basic / UserStatus ' ; <nl> import { FormSkeleton } from ' . / Skeleton ' ; <nl> import { formsSubscription } from ' . . / additionalForms ' ; <nl> <nl> export const AgentInfo = React . memo ( function AgentInfo ( { <nl> status : userStatus , <nl> } = user ; <nl> <nl> - const status = UserStatus . getStatus ( userStatus ) ; <nl> - <nl> return < VerticalBar . ScrollableContent p = ' x24 ' { . . . props } > <nl> <nl> < UserInfo . Avatar size = { ' x332 ' } username = { username } / > <nl> export const AgentInfo = React . memo ( function AgentInfo ( { <nl> < / ButtonGroup > <nl> <nl> < Margins block = ' x4 ' > <nl> - < UserInfo . Username name = { username } status = { status } / > <nl> + < UserInfo . Username name = { username } status = { < UserStatus status = { userStatus } / > } / > <nl> <nl> { statusLivechat & & < > <nl> < UserInfo . Label > { t ( ' Livechat_status ' ) } < / UserInfo . Label > <nl>\n", "msg": "Regression : Agent Status leading to broken page ( )\n", "score": 1}
{"diff_id": 7261, "repo": "serverless/serverless\n", "sha": "e12e45ebd2ec6ac2760d5e0f4f91cc86166d8c36\n", "time": "2017-05-22T01:44:42Z\n", "diff": "mmm a / lib / plugins / aws / package / compile / events / cognitoUserPool / index . js <nl> ppp b / lib / plugins / aws / package / compile / events / cognitoUserPool / index . js <nl> class AwsCompileCognitoUserPoolEvents { <nl> const lambdaLogicalId = this . provider . naming . getLambdaLogicalId ( value . functionName ) ; <nl> <nl> / / Return a new object to avoid lint errors <nl> - return Object . assign ( { } , result , { [ value . triggerSource ] : lambdaLogicalId } ) ; <nl> + return Object . assign ( { } , result , { <nl> + [ value . triggerSource ] : { <nl> + ' Fn : : GetAtt ' : [ <nl> + lambdaLogicalId , <nl> + ' Arn ' , <nl> + ] , <nl> + } , <nl> + } ) ; <nl> } , { } ) ; <nl> <nl> const userPoolLogicalId = this . provider . naming . getCognitoUserPoolLogicalId ( poolName ) ; <nl>\n", "msg": "Use Lambda logical ID to retrieve its ' ARN\n", "score": 1}
{"diff_id": 7355, "repo": "balderdashy/sails\n", "sha": "c261fb18e92b5edc5730e9d3e8d69f1f7fe4c291\n", "time": "2013-12-02T23:28:59Z\n", "diff": "mmm a / bin / _arguments . js <nl> ppp b / bin / _arguments . js <nl> module . exports = function interpretArguments ( argv , handlers ) { <nl> / / ) ; <nl> / / } <nl> <nl> + <nl> / / Third argument is the id of the module we ' re creating <nl> / / ( otherwise it ' s the second argument - - we ' ll generate a model AND controller ) <nl> var id = third | | second ; <nl> module . exports = function interpretArguments ( argv , handlers ) { <nl> dry : argv . dry <nl> } ) ; <nl> <nl> - case ' view ' : <nl> - case ' policy ' : <nl> - case ' adapter ' : <nl> - return handlers . error ( <nl> - ' Sorry , ` sails generate ' + <nl> - second + ' ` is currently out of commission . ' ) ; <nl> - <nl> - <nl> - / / A ` generate ` without a specified type is assumed to <nl> - / / be the combination of ` sails generate model ` and ` sails generate controller ` <nl> - default : <nl> + case ' api ' : <nl> handlers . generate ( { <nl> id : id , <nl> module : ' controller ' , <nl> module . exports = function interpretArguments ( argv , handlers ) { <nl> attributes : argv . _ . splice ( 3 ) , <nl> dry : argv . dry <nl> } ) ; <nl> - <nl> return ; <nl> + <nl> + / / TODO : <nl> + case ' view ' : <nl> + case ' policy ' : <nl> + case ' adapter ' : <nl> + return handlers . error ( <nl> + ' Sorry , ` sails generate ' + <nl> + second + ' ` is currently out of commission . ' ) ; <nl> + <nl> + <nl> + / / A ` generate ` without a specified type is assumed to <nl> + / / be the combination of ` sails generate model ` and ` sails generate controller ` <nl> + default : <nl> + return handlers . error ( <nl> + ' Sorry , I don \\ ' t know how to generate a \" ' + <nl> + second + ' \" . ' ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "' sails generate ' is now ' sails generate api ' . This allows us to allow new types of generators to be registered .\n", "score": 1}
{"diff_id": 7960, "repo": "adobe/brackets\n", "sha": "9d204d76f1e3824d4bb2e68c9f626731ecad1100\n", "time": "2012-10-16T23:52:52Z\n", "diff": "mmm a / src / command / KeyBindingManager . js <nl> ppp b / src / command / KeyBindingManager . js <nl> define ( function ( require , exports , module ) { <nl> right = right . trim ( ) . toLowerCase ( ) ; <nl> var matched = ( left . length > 0 & & left = = = right ) ; <nl> if ( matched & & previouslyFound ) { <nl> - console . log ( \" KeyBindingManager normalizeKeyDescriptorString ( ) - Modifier defined twice : \" + origDescriptor ) ; <nl> + console . log ( \" KeyBindingManager normalizeKeyDescriptorString ( ) - Modifier \" + left + \" defined twice : \" + origDescriptor ) ; <nl> } <nl> return matched ; <nl> } <nl> <nl> origDescriptor . split ( \" - \" ) . forEach ( function parseDescriptor ( ele , i , arr ) { <nl> - if ( _compareModifierString ( \" ctrl \" , ele , hasCtrl ) ) { <nl> + if ( _compareModifierString ( \" ctrl \" , ele , hasCtrl , origDescriptor ) ) { <nl> if ( brackets . platform = = = \" mac \" ) { <nl> hasMacCtrl = true ; <nl> } else { <nl>\n", "msg": "Improved error message when trying to use a modifier twice in a shortcut\n", "score": 1}
{"diff_id": 8063, "repo": "Unitech/pm2\n", "sha": "16b79d3aeb2e41e5c5b0a8068afafca31ea1f054\n", "time": "2017-06-29T10:08:09Z\n", "diff": "mmm a / lib / God . js <nl> ppp b / lib / God . js <nl> God . prepare = function prepare ( env , cb ) { <nl> env . instances = 1 ; <nl> } <nl> <nl> - async . times ( env . instances , function ( n , next ) { <nl> + async . timesLimit ( env . instances , 1 , function ( n , next ) { <nl> env . vizion_running = false ; <nl> if ( env . env & & env . env . vizion_running ) { <nl> env . env . vizion_running = false ; <nl> } <nl> <nl> - God . injectVariables ( env , function inject ( _err , proc ) { <nl> - return God . executeApp ( Utility . clone ( proc ) , function ( err , clu ) { <nl> + God . injectVariables ( env , function inject ( err , _env ) { <nl> + if ( err ) return next ( err ) ; <nl> + return God . executeApp ( Utility . clone ( _env ) , function ( err , clu ) { <nl> if ( err ) return next ( err ) ; <nl> God . notify ( ' start ' , clu , true ) ; <nl> / / here call next wihtout an array because <nl>\n", "msg": "( god ) launch one by one to avoid race condition\n", "score": 1}
{"diff_id": 8116, "repo": "mozilla/pdf.js\n", "sha": "07c81a624e17bd321f7fc48b5fc34ee5d45e584b\n", "time": "2011-06-15T19:24:44Z\n", "diff": "mmm a / pdf . js <nl> ppp b / pdf . js <nl> var CanvasGraphics = ( function ( ) { <nl> w : \" setLineWidth \" , <nl> J : \" setLineCap \" , <nl> j : \" setLineJoin \" , <nl> + M : \" setMiterLimit \" , <nl> d : \" setDash \" , <nl> ri : \" setRenderingIntent \" , <nl> i : \" setFlatness \" , <nl> var CanvasGraphics = ( function ( ) { <nl> m : \" moveTo \" , <nl> l : \" lineTo \" , <nl> c : \" curveTo \" , <nl> + v : \" curveTo2 \" , <nl> + y : \" curveTo3 \" , <nl> h : \" closePath \" , <nl> re : \" rectangle \" , <nl> S : \" stroke \" , <nl> + s : \" closeStroke \" , <nl> f : \" fill \" , <nl> \" f * \" : \" eoFill \" , <nl> B : \" fillStroke \" , <nl> + \" B * \" : \" eoFillStroke \" , <nl> b : \" closeFillStroke \" , <nl> + \" b * \" : \" closeEOFillStroke \" , <nl> n : \" endPath \" , <nl> <nl> / / Clipping <nl> var CanvasGraphics = ( function ( ) { <nl> / / Text <nl> BT : \" beginText \" , <nl> ET : \" endText \" , <nl> + Tc : \" setCharSpacing \" , <nl> + Tw : \" setWordSpacing \" , <nl> + Tz : \" setHScale \" , <nl> TL : \" setLeading \" , <nl> Tf : \" setFont \" , <nl> + Tr : \" setTextRenderingMode \" , <nl> + Ts : \" setTextRise \" , <nl> Td : \" moveText \" , <nl> + TD : \" setLeadingMoveText \" , <nl> Tm : \" setTextMatrix \" , <nl> \" T * \" : \" nextLine \" , <nl> Tj : \" showText \" , <nl> TJ : \" showSpacedText \" , <nl> + \" ' \" : \" nextLineShowText \" , <nl> + ' \" ' : \" nextLineSetSpacingShowText \" , <nl> <nl> / / Type3 fonts <nl> + d0 : \" setCharWidth \" , <nl> + d1 : \" setCharWidthAndBounds \" , <nl> <nl> / / Color <nl> CS : \" setStrokeColorSpace \" , <nl> var CanvasGraphics = ( function ( ) { <nl> g : \" setFillGray \" , <nl> RG : \" setStrokeRGBColor \" , <nl> rg : \" setFillRGBColor \" , <nl> + K : \" setStrokeCMYKColor \" , <nl> + k : \" setFillCMYKColor \" , <nl> <nl> / / Shading <nl> sh : \" shadingFill \" , <nl> <nl> / / Images <nl> + BI : \" beginInlineImage \" , <nl> + <nl> / / XObjects <nl> Do : \" paintXObject \" , <nl> <nl> / / Marked content <nl> + MP : \" markPoint \" , <nl> + DP : \" markPointProps \" , <nl> + BMC : \" beginMarkedContent \" , <nl> + BDC : \" beginMarkedContentProps \" , <nl> + EMC : \" endMarkedContent \" , <nl> + <nl> / / Compatibility <nl> + BX : \" beginCompat \" , <nl> + EX : \" endCompat \" , <nl> } ; <nl> } <nl> <nl> var CanvasGraphics = ( function ( ) { <nl> setLineJoin : function ( style ) { <nl> this . ctx . lineJoin = LINE_JOIN_STYLES [ style ] ; <nl> } , <nl> + setMiterLimit : function ( limit ) { <nl> + this . ctx . miterLimit = limit ; <nl> + } , <nl> setDash : function ( dashArray , dashPhase ) { <nl> TODO ( \" set dash \" ) ; <nl> } , <nl> var CanvasGraphics = ( function ( ) { <nl> curveTo : function ( x1 , y1 , x2 , y2 , x3 , y3 ) { <nl> this . ctx . bezierCurveTo ( x1 , y1 , x2 , y2 , x3 , y3 ) ; <nl> } , <nl> + curveTo2 : function ( x2 , y2 , x3 , y3 ) { <nl> + TODO ( \" ' v ' operator : need current point in gfx context \" ) ; <nl> + } , <nl> + curveTo3 : function ( x1 , y1 , x3 , y3 ) { <nl> + this . curveTo ( x1 , y1 , x3 , y3 , x3 , y3 ) ; <nl> + } , <nl> closePath : function ( ) { <nl> this . ctx . closePath ( ) ; <nl> } , <nl> var CanvasGraphics = ( function ( ) { <nl> this . ctx . stroke ( ) ; <nl> this . consumePath ( ) ; <nl> } , <nl> + closeStroke : function ( ) { <nl> + this . closePath ( ) ; <nl> + this . stroke ( ) ; <nl> + } , <nl> fill : function ( ) { <nl> this . ctx . fill ( ) ; <nl> this . consumePath ( ) ; <nl> var CanvasGraphics = ( function ( ) { <nl> this . ctx . stroke ( ) ; <nl> this . consumePath ( ) ; <nl> } , <nl> + eoFillStroke : function ( ) { <nl> + var savedFillRule = this . setEOFillRule ( ) ; <nl> + this . fillStroke ( ) ; <nl> + this . restoreFillRule ( savedFillRule ) ; <nl> + } , <nl> closeFillStroke : function ( ) { <nl> return this . fillStroke ( ) ; <nl> } , <nl> + closeEOFillStroke : function ( ) { <nl> + var savedFillRule = this . setEOFillRule ( ) ; <nl> + this . fillStroke ( ) ; <nl> + this . restoreFillRule ( savedFillRule ) ; <nl> + } , <nl> endPath : function ( ) { <nl> this . consumePath ( ) ; <nl> } , <nl> var CanvasGraphics = ( function ( ) { <nl> } , <nl> endText : function ( ) { <nl> } , <nl> + setCharSpacing : function ( spacing ) { <nl> + TODO ( \" character ( glyph ? ) spacing \" ) ; <nl> + } , <nl> + setWordSpacing : function ( spacing ) { <nl> + TODO ( \" word spacing \" ) ; <nl> + } , <nl> + setHSpacing : function ( scale ) { <nl> + TODO ( \" horizontal text scale \" ) ; <nl> + } , <nl> setLeading : function ( leading ) { <nl> this . current . leading = leading ; <nl> } , <nl> var CanvasGraphics = ( function ( ) { <nl> TODO ( \" using hard - coded font for testing \" ) ; <nl> this . ctx . font = this . current . fontSize + ' px \" Nimbus Roman No9 L \" ' ; <nl> } , <nl> + setTextRenderingMode : function ( mode ) { <nl> + TODO ( \" text rendering mode \" ) ; <nl> + } , <nl> + setTextRise : function ( rise ) { <nl> + TODO ( \" text rise \" ) ; <nl> + } , <nl> moveText : function ( x , y ) { <nl> this . current . x = this . current . lineX + = x ; <nl> this . current . y = this . current . lineY + = y ; <nl> } , <nl> + setLeadingMoveText : function ( x , y ) { <nl> + this . setLeading ( - y ) ; <nl> + this . moveText ( x , y ) ; <nl> + } , <nl> setTextMatrix : function ( a , b , c , d , e , f ) { <nl> this . current . textMatrix = [ a , b , c , d , e , f ] ; <nl> this . current . x = this . current . lineX = 0 ; <nl> var CanvasGraphics = ( function ( ) { <nl> } <nl> } <nl> } , <nl> + nextLineShowText : function ( text ) { <nl> + this . nextLine ( ) ; <nl> + this . showText ( text ) ; <nl> + } , <nl> + nextLineSetSpacingShowText : function ( wordSpacing , charSpacing , text ) { <nl> + this . setWordSpacing ( wordSpacing ) ; <nl> + this . setCharSpacing ( charSpacing ) ; <nl> + this . nextLineShowText ( text ) ; <nl> + } , <nl> <nl> / / Type3 fonts <nl> + setCharWidth : function ( xWidth , yWidth ) { <nl> + TODO ( \" type 3 fonts ( ' d0 ' operator ) \" ) ; <nl> + } , <nl> + setCharWidthAndBounds : function ( xWidth , yWidth , llx , lly , urx , ury ) { <nl> + TODO ( \" type 3 fonts ( ' d1 ' operator ) \" ) ; <nl> + } , <nl> <nl> / / Color <nl> setStrokeColorSpace : function ( space ) { <nl> var CanvasGraphics = ( function ( ) { <nl> setFillRGBColor : function ( r , g , b ) { <nl> this . ctx . fillStyle = this . makeCssRgb ( r , g , b ) ; <nl> } , <nl> + setStrokeCMYKColor : function ( c , m , y , k ) { <nl> + TODO ( \" CMYK space \" ) ; <nl> + } , <nl> + setFillCMYKColor : function ( c , m , y , k ) { <nl> + TODO ( \" CMYK space \" ) ; <nl> + } , <nl> <nl> / / Shading <nl> shadingFill : function ( entryRef ) { <nl> var CanvasGraphics = ( function ( ) { <nl> this . consumePath ( ) ; <nl> } , <nl> <nl> + / / Images <nl> + beginInlineImage : function ( ) { <nl> + TODO ( \" inline images \" ) ; <nl> + error ( \" ( Stream will not be parsed properly , bailing now ) \" ) ; <nl> + / / Like an inline stream : <nl> + / / - key / value pairs up to Cmd ( ID ) <nl> + / / - then image data up to Cmd ( EI ) <nl> + } , <nl> + <nl> / / XObjects <nl> paintXObject : function ( obj ) { <nl> var xobj = this . xobjs . get ( obj . name ) ; <nl> var CanvasGraphics = ( function ( ) { <nl> this . restore ( ) ; <nl> } , <nl> <nl> + / / Marked content <nl> + <nl> + markPoint : function ( tag ) { <nl> + TODO ( \" Marked content \" ) ; <nl> + } , <nl> + markPointProps : function ( tag , properties ) { <nl> + TODO ( \" Marked content \" ) ; <nl> + } , <nl> + beginMarkedContent : function ( tag ) { <nl> + TODO ( \" Marked content \" ) ; <nl> + } , <nl> + beginMarkedContentProps : function ( tag , properties ) { <nl> + TODO ( \" Marked content \" ) ; <nl> + } , <nl> + endMarkedContent : function ( ) { <nl> + TODO ( \" Marked content \" ) ; <nl> + } , <nl> + <nl> + / / Compatibility <nl> + <nl> + beginCompat : function ( ) { <nl> + TODO ( \" ignore undefined operators ( should we do that anyway ? ) \" ) ; <nl> + } , <nl> + endCompat : function ( ) { <nl> + TODO ( \" stop ignoring undefined operators \" ) ; <nl> + } , <nl> + <nl> / / Helper functions <nl> <nl> consumePath : function ( ) { <nl>\n", "msg": "implement some operators and add TODOs for remaining undefined ones\n", "score": 1}
{"diff_id": 8174, "repo": "TryGhost/Ghost\n", "sha": "ed4fde4f006281c48880ff24ba997dc83b097bdd\n", "time": "2018-02-07T11:31:21Z\n", "diff": "mmm a / core / server / data / schema / fixtures / utils . js <nl> ppp b / core / server / data / schema / fixtures / utils . js <nl> <nl> / / Standalone file which can be required to help with advanced operations on the fixtures . json file <nl> var _ = require ( ' lodash ' ) , <nl> Promise = require ( ' bluebird ' ) , <nl> + common = require ( ' . . / . . / . . / lib / common ' ) , <nl> models = require ( ' . . / . . / . . / models ' ) , <nl> baseUtils = require ( ' . . / . . / . . / models / base / utils ' ) , <nl> sequence = require ( ' . . / . . / . . / lib / promise / sequence ' ) , <nl> addFixturesForRelation = function addFixturesForRelation ( relationFixture , option <nl> _ . each ( relationFixture . entries , function processEntries ( entry , key ) { <nl> var fromItem = data . from . find ( matchFunc ( relationFixture . from . match , key ) ) ; <nl> <nl> + / / CASE : You add new fixtures e . g . a new role in a new release . <nl> + / / As soon as an * * older * * migration script wants to add permissions for any resource , it iterates over the <nl> + / / permissions for each role . But if the role does not exist yet , it won ' t find the matching db entry and breaks . <nl> + if ( ! fromItem ) { <nl> + common . logging . warn ( ' Skip : Target database entry not found for key : ' + key ) ; <nl> + return Promise . resolve ( ) ; <nl> + } <nl> + <nl> _ . each ( entry , function processEntryValues ( value , key ) { <nl> var toItems = data . to . filter ( matchFunc ( relationFixture . to . match , key , value ) ) ; <nl> max + = toItems . length ; <nl>\n", "msg": " Fixed migrating from < 1 . 13 to 1 . 21\n", "score": 1}
{"diff_id": 8349, "repo": "gorhill/uBlock\n", "sha": "7dd48a6c8c4d9153b4bc3f56904f3abfb5b23512\n", "time": "2020-07-30T15:58:49Z\n", "diff": "mmm a / src / js / contentscript . js <nl> ppp b / src / js / contentscript . js <nl> vAPI . injectScriptlet = function ( doc , text ) { <nl> const PSelectorSpathTask = class { <nl> constructor ( task ) { <nl> this . spath = task [ 1 ] ; <nl> + this . nth = / ^ ( ? : \\ s * [ + ~ ] | : ) / . test ( this . spath ) ; <nl> } <nl> - transpose ( node , output ) { <nl> + qsa ( node ) { <nl> + if ( this . nth = = = false ) { <nl> + return node . querySelectorAll ( this . spath ) ; <nl> + } <nl> const parent = node . parentElement ; <nl> if ( parent = = = null ) { return ; } <nl> let pos = 1 ; <nl> vAPI . injectScriptlet = function ( doc , text ) { <nl> if ( node = = = null ) { break ; } <nl> pos + = 1 ; <nl> } <nl> - const nodes = parent . querySelectorAll ( <nl> + return parent . querySelectorAll ( <nl> ` : scope > : nth - child ( $ { pos } ) $ { this . spath } ` <nl> ) ; <nl> + } <nl> + transpose ( node , output ) { <nl> + const nodes = this . qsa ( node ) ; <nl> + if ( nodes = = = undefined ) { return ; } <nl> for ( const node of nodes ) { <nl> output . push ( node ) ; <nl> } <nl>\n", "msg": "Allow ` : upward ( ) ` operator to select ` html ` element\n", "score": 1}
{"diff_id": 8630, "repo": "meteor/meteor\n", "sha": "92bf32b6aa325e2f1803f6f468623fd712c0d6d9\n", "time": "2015-08-26T17:26:45Z\n", "diff": "mmm a / tools / cordova / cordova - runner . js <nl> ppp b / tools / cordova / cordova - runner . js <nl> export default class CordovaRunner { <nl> constructor ( projectContext , cordovaProject , options ) { <nl> this . projectContext = projectContext ; <nl> this . cordovaProject = cordovaProject ; <nl> - <nl> this . options = options ; <nl> - this . title = ` app on $ { this . displayName } ` ; <nl> + } <nl> + <nl> + get title ( ) { <nl> + return ` app on $ { this . displayName } ` ; <nl> } <nl> <nl> prestart ( ) { <nl>\n", "msg": "Don ' t access displayName before subclasses have been initialized\n", "score": 1}
{"diff_id": 8672, "repo": "angular/angular.js\n", "sha": "5f080193cbc0d84676cf267adcdc6307fb601610\n", "time": "2011-01-04T21:25:49Z\n", "diff": "mmm a / src / parser . js <nl> ppp b / src / parser . js <nl> function lex ( text , parseStringsForObjects ) { <nl> <nl> function parser ( text , json ) { <nl> var ZERO = valueFn ( 0 ) , <nl> - tokens = lex ( text , json ) ; <nl> + tokens = lex ( text , json ) , <nl> + assignment = _assignment , <nl> + functionCall = _functionCall , <nl> + fieldAccess = _fieldAccess , <nl> + objectIndex = _objectIndex , <nl> + filterChain = _filterChain , <nl> + functionIdent = _functionIdent , <nl> + pipeFunction = _pipeFunction ; <nl> + if ( json ) { <nl> + / / The extra level of aliasing is here , just in case the lexer misses something , so that <nl> + / / we prevent any accidental execution in JSON . <nl> + assignment = logicalOR ; <nl> + functionCall = <nl> + fieldAccess = <nl> + objectIndex = <nl> + filterChain = <nl> + functionIdent = <nl> + pipeFunction = <nl> + function ( ) { throwError ( \" is not valid json \" , { text : text , index : 0 } ) ; } ; <nl> + } <nl> return { <nl> assertAllConsumed : assertAllConsumed , <nl> primary : primary , <nl> function parser ( text , json ) { <nl> } <nl> } <nl> <nl> - function filterChain ( ) { <nl> + function _filterChain ( ) { <nl> var left = expression ( ) ; <nl> var token ; <nl> while ( true ) { <nl> function parser ( text , json ) { <nl> return pipeFunction ( angularValidator ) ; <nl> } <nl> <nl> - function pipeFunction ( fnScope ) { <nl> + function _pipeFunction ( fnScope ) { <nl> var fn = functionIdent ( fnScope ) ; <nl> var argsFn = [ ] ; <nl> var token ; <nl> function parser ( text , json ) { <nl> return assignment ( ) ; <nl> } <nl> <nl> - function assignment ( ) { <nl> + function _assignment ( ) { <nl> var left = logicalOR ( ) ; <nl> var right ; <nl> var token ; <nl> function parser ( text , json ) { <nl> } <nl> } <nl> <nl> - function functionIdent ( fnScope ) { <nl> + function _functionIdent ( fnScope ) { <nl> var token = expect ( ) ; <nl> var element = token . text . split ( ' . ' ) ; <nl> var instance = fnScope ; <nl> function parser ( text , json ) { <nl> return primary ; <nl> } <nl> <nl> - function fieldAccess ( object ) { <nl> + function _fieldAccess ( object ) { <nl> var field = expect ( ) . text ; <nl> var getter = getterFn ( field ) ; <nl> return extend ( function ( self ) { <nl> function parser ( text , json ) { <nl> } ) ; <nl> } <nl> <nl> - function objectIndex ( obj ) { <nl> + function _objectIndex ( obj ) { <nl> var indexFn = expression ( ) ; <nl> consume ( ' ] ' ) ; <nl> return extend ( <nl> function parser ( text , json ) { <nl> } ) ; <nl> } <nl> <nl> - function functionCall ( fn ) { <nl> + function _functionCall ( fn ) { <nl> var argsFn = [ ] ; <nl> if ( peekToken ( ) . text ! = ' ) ' ) { <nl> do { <nl>\n", "msg": "Added an extra security check to make sure that the parser can not execute anything while evaluting JSON .\n", "score": 1}
{"diff_id": 8779, "repo": "socketio/socket.io\n", "sha": "e41aab84f8a5f26db61219ceb77c14d6ca9e6f3a\n", "time": "2011-08-29T06:00:03Z\n", "diff": "mmm a / lib / transports / websocket / hybi - 07 - 12 . js <nl> ppp b / lib / transports / websocket / hybi - 07 - 12 . js <nl> function WebSocket ( mng , data , req ) { <nl> } ) ; <nl> this . parser . on ( ' ping ' , function ( ) { <nl> / / version 8 ping = > pong <nl> - this . socket . write ( ' \\ u008a \\ u0000 ' ) ; <nl> + self . socket . write ( ' \\ u008a \\ u0000 ' ) ; <nl> } ) ; <nl> this . parser . on ( ' close ' , function ( ) { <nl> self . end ( ) ; <nl> } ) ; <nl> - this . parser . on ( ' error ' , function ( ) { <nl> + this . parser . on ( ' error ' , function ( reason ) { <nl> + self . log . warn ( self . name + ' parser error : ' + reason ) ; <nl> self . end ( ) ; <nl> } ) ; <nl> <nl>\n", "msg": "corrected ping handling from websocket transport , and added warning output on parser error\n", "score": 1}
{"diff_id": 9378, "repo": "preactjs/preact\n", "sha": "6aad7e8e297c4c724ed25054956b4664e718a2ac\n", "time": "2018-07-20T00:34:47Z\n", "diff": "mmm a / src / component . js <nl> ppp b / src / component . js <nl> Component . prototype . forceUpdate = function ( callback ) { <nl> let q = [ ] ; <nl> <nl> / / const defer = typeof Promise = = ' function ' ? Promise . resolve ( ) . then . bind ( Promise . resolve ( ) ) : setTimeout ; <nl> - Component . debounce = typeof Promise = = ' function ' ? Promise . resolve ( ) . then . bind ( Promise . resolve ( ) ) : setTimeout ; <nl> + / / Component . debounce = typeof Promise = = ' function ' ? Promise . resolve ( ) . then . bind ( Promise . resolve ( ) ) : setTimeout ; <nl> + const defer = typeof Promise = = ' function ' ? Promise . resolve ( ) . then . bind ( Promise . resolve ( ) ) : setTimeout ; <nl> / / Component . debounce = setTimeout ; <nl> <nl> export function enqueueRender ( c ) { <nl> / / console . log ( ' enqueueRender ' , c . id , q . length = = = 0 , c . _dirty ) ; <nl> if ( ! c . _dirty & & ( c . _dirty = true ) & & q . push ( c ) = = = 1 ) { <nl> - ( 0 , Component . debounce ) ( process ) ; <nl> + / / ( 0 , Component . debounce ) ( process ) ; <nl> + ( Component . debounce | | defer ) ( process ) ; <nl> / / ( Component . debounce | | setTimeout ) ( process ) ; <nl> / / defer ( process ) ; <nl> / / ( Component . debounce | | setTimeout ) ( process ) ; <nl>\n", "msg": "don ' t rely on a default value for Component . debounce , so it can be ` null ` ' d and still work .\n", "score": 1}
{"diff_id": 9557, "repo": "lodash/lodash\n", "sha": "b25a86f352ce13be279cf601552f6e3270430493\n", "time": "2016-09-20T14:49:59Z\n", "diff": "mmm a / test / test . js <nl> ppp b / test / test . js <nl> <nl> QUnit . test ( ' should create a wrapped function ' , function ( assert ) { <nl> assert . expect ( 1 ) ; <nl> <nl> - var p = _ . wrap ( _ . escape , function ( func , text ) { <nl> + var p = _ . wrap ( lodashStable . escape , function ( func , text ) { <nl> return ' < p > ' + func ( text ) + ' < / p > ' ; <nl> } ) ; <nl> <nl> <nl> QUnit . test ( ' should use ` this ` binding of function ' , function ( assert ) { <nl> assert . expect ( 1 ) ; <nl> <nl> - var p = _ . wrap ( _ . escape , function ( func ) { <nl> + var p = _ . wrap ( lodashStable . escape , function ( func ) { <nl> return ' < p > ' + func ( this . text ) + ' < / p > ' ; <nl> } ) ; <nl> <nl>\n", "msg": "Use ` lodashStable . escape ` in more places .\n", "score": 1}
{"diff_id": 9599, "repo": "facebook/react-native\n", "sha": "75ff136f036fd4ded267b0262db1defff1542a97\n", "time": "2018-05-12T00:18:03Z\n", "diff": "mmm a / Libraries / ReactNative / renderApplication . js <nl> ppp b / Libraries / ReactNative / renderApplication . js <nl> <nl> <nl> const AppContainer = require ( ' AppContainer ' ) ; <nl> const React = require ( ' React ' ) ; <nl> - const ReactFabric = require ( ' ReactFabric ' ) ; <nl> - const ReactNative = require ( ' ReactNative ' ) ; <nl> <nl> const invariant = require ( ' fbjs / lib / invariant ' ) ; <nl> <nl> function renderApplication < Props : Object > ( <nl> } <nl> <nl> if ( fabric ) { <nl> - ReactFabric . render ( renderable , rootTag ) ; <nl> + require ( ' ReactFabric ' ) . render ( renderable , rootTag ) ; <nl> } else { <nl> - ReactNative . render ( renderable , rootTag ) ; <nl> + require ( ' ReactNative ' ) . render ( renderable , rootTag ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Load ' ReactFabric ' only when it is required to render a Fabric component\n", "score": 1}
{"diff_id": 10097, "repo": "photonstorm/phaser\n", "sha": "24f4abe7600e7e35909d73c112e3098c54437375\n", "time": "2016-06-09T13:58:35Z\n", "diff": "mmm a / src / core / Group . js <nl> ppp b / src / core / Group . js <nl> Phaser . Group = function ( game , parent , name , addToStage , enableBody , physicsBody <nl> * / <nl> this . cursor = null ; <nl> <nl> + / * * <nl> + * A Group with ` inputEnableChildren ` set to ` true ` will automatically call ` inputEnabled = true ` <nl> + * on any children _added_ to , or _created by_ , this Group . <nl> + * <nl> + * If there are children already in the Group at the time you set this property , they are not changed . <nl> + * <nl> + * @ property { boolean } inputEnableChildren <nl> + * @ default <nl> + * / <nl> + this . inputEnableChildren = false ; <nl> + <nl> / * * <nl> * If true all Sprites created by , or added to this group , will have a physics body enabled on them . <nl> * <nl> + * If there are children already in the Group at the time you set this property , they are not changed . <nl> + * <nl> * The default body type is controlled with { @ link # physicsBodyType } . <nl> * @ property { boolean } enableBody <nl> * / <nl> Phaser . Group . SORT_DESCENDING = 1 ; <nl> / * * <nl> * Adds an existing object as the top child in this group . <nl> * <nl> - * The child is automatically added to the top of the group and is displayed on top of every previous child . <nl> + * The child is automatically added to the top of the group , and is displayed above every previous child . <nl> + * <nl> + * Or if the _optional_ index is specified , the child is added at the location specified by the index value , <nl> + * this allows you to control child ordering . <nl> + * <nl> + * If the child was already in this Group , it is simply returned , and nothing else happens to it . <nl> * <nl> - * If Group . enableBody is set then a physics body will be created on the object , so long as one does not already exist . <nl> + * If ` Group . enableBody ` is set , then a physics body will be created on the object , so long as one does not already exist . <nl> + * <nl> + * If ` Group . inputEnableChildren ` is set , then an Input Handler will be created on the object , so long as one does not already exist . <nl> * <nl> * Use { @ link # addAt } to control where a child is added . Use { @ link # create } to create and add a new child . <nl> * <nl> * @ method Phaser . Group # add <nl> * @ param { DisplayObject } child - The display object to add as a child . <nl> * @ param { boolean } [ silent = false ] - If true the child will not dispatch the ` onAddedToGroup ` event . <nl> + * @ param { integer } [ index ] - The index within the group to insert the child to . Where 0 is the bottom of the Group . <nl> * @ return { DisplayObject } The child that was added to the group . <nl> * / <nl> - Phaser . Group . prototype . add = function ( child , silent ) { <nl> + Phaser . Group . prototype . add = function ( child , silent , index ) { <nl> <nl> if ( silent = = = undefined ) { silent = false ; } <nl> <nl> - if ( child . parent ! = = this ) <nl> + if ( child . parent = = = this ) <nl> { <nl> - if ( child . body & & child . parent & & child . parent . hash ) <nl> - { <nl> - child . parent . removeFromHash ( child ) ; <nl> - } <nl> + return child ; <nl> + } <nl> + <nl> + if ( child . body & & child . parent & & child . parent . hash ) <nl> + { <nl> + child . parent . removeFromHash ( child ) ; <nl> + } <nl> <nl> + if ( index = = = undefined ) <nl> + { <nl> child . z = this . children . length ; <nl> <nl> this . addChild ( child ) ; <nl> + } <nl> + else <nl> + { <nl> + this . addChildAt ( child , index ) ; <nl> <nl> - if ( this . enableBody & & child . body = = = null ) <nl> - { <nl> - this . game . physics . enable ( child , this . physicsBodyType ) ; <nl> - } <nl> - else if ( child . body ) <nl> - { <nl> - this . addToHash ( child ) ; <nl> - } <nl> + this . updateZ ( ) ; <nl> + } <nl> <nl> - if ( ! silent & & child . events ) <nl> - { <nl> - child . events . onAddedToGroup $ dispatch ( child , this ) ; <nl> - } <nl> + if ( this . enableBody & & child . hasProperty ( ' body ' ) & & child . body = = = null ) <nl> + { <nl> + this . game . physics . enable ( child , this . physicsBodyType ) ; <nl> + } <nl> + else if ( child . body ) <nl> + { <nl> + this . addToHash ( child ) ; <nl> + } <nl> <nl> - if ( this . cursor = = = null ) <nl> - { <nl> - this . cursor = child ; <nl> - } <nl> + if ( this . inputEnableChildren & & child . hasProperty ( ' input ' ) & & ! child . inputEnabled ) <nl> + { <nl> + child . inputEnabled = true ; <nl> + } <nl> + <nl> + if ( ! silent & & child . events ) <nl> + { <nl> + child . events . onAddedToGroup $ dispatch ( child , this ) ; <nl> + } <nl> + <nl> + if ( this . cursor = = = null ) <nl> + { <nl> + this . cursor = child ; <nl> } <nl> <nl> return child ; <nl> <nl> } ; <nl> <nl> + / * * <nl> + * Adds an existing object to this group . <nl> + * <nl> + * The child is added to the group at the location specified by the index value , this allows you to control child ordering . <nl> + * <nl> + * If ` Group . enableBody ` is set , then a physics body will be created on the object , so long as one does not already exist . <nl> + * <nl> + * If ` Group . inputEnableChildren ` is set , then an Input Handler will be created on the object , so long as one does not already exist . <nl> + * <nl> + * @ method Phaser . Group # addAt <nl> + * @ param { DisplayObject } child - The display object to add as a child . <nl> + * @ param { integer } [ index = 0 ] - The index within the group to insert the child to . <nl> + * @ param { boolean } [ silent = false ] - If true the child will not dispatch the ` onAddedToGroup ` event . <nl> + * @ return { DisplayObject } The child that was added to the group . <nl> + * / <nl> + Phaser . Group . prototype . addAt = function ( child , index , silent ) { <nl> + <nl> + this . add ( child , silent , index ) ; <nl> + <nl> + } ; <nl> + <nl> / * * <nl> * Adds a child of this Group into the hash array . <nl> * This call will return false if the child is not a child of this Group , or is already in the hash . <nl> Phaser . Group . prototype . removeFromHash = function ( child ) { <nl> * <nl> * As well as an array you can also pass another Group as the first argument . In this case all of the children from that <nl> * Group will be removed from it and added into this Group . <nl> + * <nl> + * If ` Group . enableBody ` is set , then a physics body will be created on the objects , so long as one does not already exist . <nl> + * <nl> + * If ` Group . inputEnableChildren ` is set , then an Input Handler will be created on the objects , so long as one does not already exist . <nl> * <nl> * @ method Phaser . Group # addMultiple <nl> * @ param { DisplayObject [ ] | Phaser . Group } children - An array of display objects or a Phaser . Group . If a Group is given then * all * children will be moved from it . <nl> Phaser . Group . prototype . addMultiple = function ( children , silent ) { <nl> <nl> } ; <nl> <nl> - / * * <nl> - * Adds an existing object to this group . <nl> - * <nl> - * The child is added to the group at the location specified by the index value , this allows you to control child ordering . <nl> - * <nl> - * @ method Phaser . Group # addAt <nl> - * @ param { DisplayObject } child - The display object to add as a child . <nl> - * @ param { integer } [ index = 0 ] - The index within the group to insert the child to . <nl> - * @ param { boolean } [ silent = false ] - If true the child will not dispatch the ` onAddedToGroup ` event . <nl> - * @ return { DisplayObject } The child that was added to the group . <nl> - * / <nl> - Phaser . Group . prototype . addAt = function ( child , index , silent ) { <nl> - <nl> - if ( silent = = = undefined ) { silent = false ; } <nl> - <nl> - if ( child . parent ! = = this ) <nl> - { <nl> - if ( child . body & & child . parent ) <nl> - { <nl> - child . parent . removeFromHash ( child ) ; <nl> - } <nl> - <nl> - this . addChildAt ( child , index ) ; <nl> - <nl> - this . updateZ ( ) ; <nl> - <nl> - if ( this . enableBody & & child . body = = = null ) <nl> - { <nl> - this . game . physics . enable ( child , this . physicsBodyType ) ; <nl> - } <nl> - else if ( child . body ) <nl> - { <nl> - this . addToHash ( child ) ; <nl> - } <nl> - <nl> - if ( ! silent & & child . events ) <nl> - { <nl> - child . events . onAddedToGroup $ dispatch ( child , this ) ; <nl> - } <nl> - <nl> - if ( this . cursor = = = null ) <nl> - { <nl> - this . cursor = child ; <nl> - } <nl> - } <nl> - <nl> - return child ; <nl> - <nl> - } ; <nl> - <nl> / * * <nl> * Returns the child found at the given index within this group . <nl> * <nl> Phaser . Group . prototype . getAt = function ( index ) { <nl> * Creates a new Phaser . Sprite object and adds it to the top of this group . <nl> * <nl> * Use { @ link # classType } to change the type of object created . <nl> + * <nl> + * The child is automatically added to the top of the group , and is displayed above every previous child . <nl> + * <nl> + * Or if the _optional_ index is specified , the child is added at the location specified by the index value , <nl> + * this allows you to control child ordering . <nl> + * <nl> + * If ` Group . enableBody ` is set , then a physics body will be created on the object , so long as one does not already exist . <nl> + * <nl> + * If ` Group . inputEnableChildren ` is set , then an Input Handler will be created on the object , so long as one does not already exist . <nl> * <nl> * @ method Phaser . Group # create <nl> * @ param { number } x - The x coordinate to display the newly created Sprite at . The value is in relation to the group . x point . <nl> Phaser . Group . prototype . getAt = function ( index ) { <nl> * @ param { string | Phaser . RenderTexture | Phaser . BitmapData | Phaser . Video | PIXI . Texture } [ key ] - This is the image or texture used by the Sprite during rendering . It can be a string which is a reference to the Cache Image entry , or an instance of a RenderTexture , BitmapData , Video or PIXI . Texture . <nl> * @ param { string | number } [ frame ] - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index . <nl> * @ param { boolean } [ exists = true ] - The default exists state of the Sprite . <nl> + * @ param { integer } [ index ] - The index within the group to insert the child to . Where 0 is the bottom of the Group . <nl> * @ return { DisplayObject } The child that was created : will be a { @ link Phaser . Sprite } unless { @ link # classType } has been changed . <nl> * / <nl> - Phaser . Group . prototype . create = function ( x , y , key , frame , exists ) { <nl> + Phaser . Group . prototype . create = function ( x , y , key , frame , exists , index ) { <nl> <nl> if ( exists = = = undefined ) { exists = true ; } <nl> <nl> Phaser . Group . prototype . create = function ( x , y , key , frame , exists ) { <nl> child . visible = exists ; <nl> child . alive = exists ; <nl> <nl> - child . z = this . children . length ; <nl> - <nl> - this . addChild ( child ) ; <nl> - <nl> - if ( this . enableBody ) <nl> - { <nl> - this . game . physics . enable ( child , this . physicsBodyType , this . enableBodyDebug ) ; <nl> - } <nl> - <nl> - if ( child . events ) <nl> - { <nl> - child . events . onAddedToGroup $ dispatch ( child , this ) ; <nl> - } <nl> - <nl> - if ( this . cursor = = = null ) <nl> - { <nl> - this . cursor = child ; <nl> - } <nl> - <nl> - return child ; <nl> + return this . add ( child , false , index ) ; <nl> <nl> } ; <nl> <nl> / * * <nl> - * Creates multiple Phaser . Sprite objects and adds them to the top of this group . <nl> + * Creates multiple Phaser . Sprite objects and adds them to the top of this Group . <nl> * <nl> - * Useful if you need to quickly generate a pool of identical sprites , such as bullets . <nl> - * <nl> - * By default the sprites will be set to not exist and will be positioned at 0 , 0 ( relative to the group . x / y ) . <nl> * Use { @ link # classType } to change the type of object created . <nl> * <nl> + * This method is useful if you need to quickly generate a pool of identical sprites , such as bullets . <nl> + * <nl> + * By default the Sprites will have their ` exists ` property set to ` false ` , and they will be <nl> + * positioned at 0x0 , relative to the ` Group . x / y ` values . <nl> + * <nl> + * If ` Group . enableBody ` is set , then a physics body will be created on the objects , so long as one does not already exist . <nl> + * <nl> + * If ` Group . inputEnableChildren ` is set , then an Input Handler will be created on the objects , so long as one does not already exist . <nl> + * <nl> * @ method Phaser . Group # createMultiple <nl> * @ param { integer } quantity - The number of Sprites to create . <nl> * @ param { string } key - The Game . cache key of the image that this Sprite will use . <nl> * @ param { integer | string } [ frame ] - If the Sprite image contains multiple frames you can specify which one to use here . <nl> * @ param { boolean } [ exists = false ] - The default exists state of the Sprite . <nl> + * @ return { array } An array containing all of the Sprites that were created . <nl> * / <nl> Phaser . Group . prototype . createMultiple = function ( quantity , key , frame , exists ) { <nl> <nl> if ( exists = = = undefined ) { exists = false ; } <nl> <nl> + var children = [ ] ; <nl> + <nl> for ( var i = 0 ; i < quantity ; i + + ) <nl> { <nl> - this . create ( 0 , 0 , key , frame , exists ) ; <nl> + children . push ( this . create ( 0 , 0 , key , frame , exists ) ) ; <nl> } <nl> <nl> + return children ; <nl> + <nl> } ; <nl> <nl> / * * <nl> Phaser . Group . prototype . getByName = function ( name ) { <nl> } ; <nl> <nl> / * * <nl> - * Replaces a child of this group with the given newChild . The newChild cannot be a member of this group . <nl> + * Replaces a child of this Group with the given newChild . The newChild cannot be a member of this Group . <nl> + * <nl> + * If ` Group . enableBody ` is set , then a physics body will be created on the object , so long as one does not already exist . <nl> + * <nl> + * If ` Group . inputEnableChildren ` is set , then an Input Handler will be created on the object , so long as one does not already exist . <nl> * <nl> * @ method Phaser . Group # replace <nl> * @ param { any } oldChild - The child in this group that will be replaced . <nl> Phaser . Group . prototype . replace = function ( oldChild , newChild ) { <nl> * Will scan up to 4 levels deep only . <nl> * <nl> * @ method Phaser . Group # hasProperty <nl> - * @ param { any } child - The child to check for the existance of the property on . <nl> + * @ param { any } child - The child to check for the existence of the property on . <nl> * @ param { string [ ] } key - An array of strings that make up the property . <nl> * @ return { boolean } True if the child has the property , otherwise false . <nl> * / <nl>\n", "msg": "Group . add has a new optional argument ` index ` which controls the index within the group to insert the child to . Where 0 is the bottom of the Group .\n", "score": 1}
{"diff_id": 10487, "repo": "preactjs/preact\n", "sha": "d33a4dca18a5ca157ec043f2201ef5ff3f7c8944\n", "time": "2016-02-20T23:00:37Z\n", "diff": "mmm a / src / dom / index . js <nl> ppp b / src / dom / index . js <nl> export function getAccessor ( node , name , value , cache ) { <nl> * / <nl> export function setAccessor ( node , name , value ) { <nl> if ( name = = = ' class ' ) { <nl> - node . className = value ; <nl> + node . className = value | | ' ' ; <nl> } <nl> else if ( name = = = ' style ' ) { <nl> - node . style . cssText = value ; <nl> + node . style . cssText = value | | ' ' ; <nl> } <nl> else if ( name = = = ' dangerouslySetInnerHTML ' ) { <nl> node . innerHTML = value . __html ; <nl>\n", "msg": "Coerce falsey ` className ` and ` style ` values to an empty string to avoid ` class = \" null \" ` and ` style = \" null \" ` .\n", "score": 1}
{"diff_id": 10553, "repo": "adobe/brackets\n", "sha": "ca36410d74c631aad8ce6d7cc37f438ab0dc75a0\n", "time": "2015-06-15T11:31:51Z\n", "diff": "mmm a / src / extensions / default / CodeFolding / main . js <nl> ppp b / src / extensions / default / CodeFolding / main . js <nl> define ( function ( require , exports , module ) { <nl> collapseKey = \" Ctrl - Alt - [ \" , <nl> expandKey = \" Ctrl - Alt - ] \" , <nl> collapseAllKey = \" Alt - 1 \" , <nl> - expandAllKey = \" Shift - Alt - 1 \" ; <nl> + expandAllKey = \" Shift - Alt - 1 \" , <nl> + collapseAllKeyMac = \" Cmd - 1 \" , <nl> + expandAllKeyMac = \" Cmd - Shift - 1 \" ; <nl> <nl> ExtensionUtils . loadStyleSheet ( module , \" main . less \" ) ; <nl> <nl> define ( function ( require , exports , module ) { <nl> KeyBindingManager . removeBinding ( expandKey ) ; <nl> KeyBindingManager . removeBinding ( collapseAllKey ) ; <nl> KeyBindingManager . removeBinding ( expandAllKey ) ; <nl> + KeyBindingManager . removeBinding ( collapseAllKeyMac ) ; <nl> + KeyBindingManager . removeBinding ( expandAllKeyMac ) ; <nl> <nl> / / remove menus <nl> Menus . getMenu ( Menus . AppMenuBar . VIEW_MENU ) . removeMenuDivider ( codeFoldingMenuDivider . id ) ; <nl> define ( function ( require , exports , module ) { <nl> Menus . getMenu ( Menus . AppMenuBar . VIEW_MENU ) . addMenuItem ( EXPAND ) ; <nl> <nl> / / register keybindings <nl> - KeyBindingManager . addBinding ( COLLAPSE_ALL , collapseAllKey ) ; <nl> - KeyBindingManager . addBinding ( EXPAND_ALL , expandAllKey ) ; <nl> + KeyBindingManager . addBinding ( COLLAPSE_ALL , [ { key : collapseAllKey } , { key : collapseAllKeyMac , platform : \" mac \" } ] ) ; <nl> + KeyBindingManager . addBinding ( EXPAND_ALL , [ { key : expandAllKey } , { key : expandAllKeyMac , platform : \" mac \" } ] ) ; <nl> KeyBindingManager . addBinding ( COLLAPSE , collapseKey ) ; <nl> KeyBindingManager . addBinding ( EXPAND , expandKey ) ; <nl> <nl>\n", "msg": "Add Mac specific key binding for expand and collapse all\n", "score": 1}
{"diff_id": 10573, "repo": "codemirror/CodeMirror\n", "sha": "42f23ed9dcddaef01f5ad16c5eb61801414a5e6a\n", "time": "2012-08-29T11:38:51Z\n", "diff": "mmm a / lib / codemirror . js <nl> ppp b / lib / codemirror . js <nl> window . CodeMirror = ( function ( ) { <nl> } <nl> } else { <nl> var match = this . string . slice ( this . pos ) . match ( pattern ) ; <nl> + if ( match & & match . index > 0 ) return null ; <nl> if ( match & & consume ! = = false ) this . pos + = match [ 0 ] . length ; <nl> return match ; <nl> } <nl>\n", "msg": "Make StringStream . match return null when the match isn ' t at current position\n", "score": 1}
{"diff_id": 10783, "repo": "meteor/meteor\n", "sha": "af801545bf30bf3e5f1f48726d7075b793be4721\n", "time": "2013-07-08T16:47:20Z\n", "diff": "mmm a / packages / meteor / helpers . js <nl> ppp b / packages / meteor / helpers . js <nl> _ . extend ( Meteor , { <nl> var callback ; <nl> var fut ; <nl> var newArgs = Array . prototype . slice . call ( arguments ) ; <nl> - if ( newArgs . length & & <nl> - typeof ( newArgs [ newArgs . length - 1 ] ) = = = \" function \" ) { <nl> + var haveCb = newArgs . length & & <nl> + ( newArgs [ newArgs . length - 1 ] instanceof Function ) ; <nl> + if ( Meteor . isClient & & ! haveCb ) { <nl> + newArgs . push ( function ( ) { } ) ; <nl> + haveCb = true ; <nl> + } <nl> + if ( haveCb ) { <nl> var origCb = newArgs [ newArgs . length - 1 ] ; <nl> callback = Meteor . bindEnvironment ( origCb , function ( e ) { <nl> Meteor . _debug ( \" Exception in callback of async function \" , e . stack ) ; <nl> _ . extend ( Meteor , { <nl> newArgs [ newArgs . length ] = fut . resolver ( ) ; <nl> } <nl> fn . apply ( self , newArgs ) ; <nl> - if ( fut ) <nl> + if ( ! haveCb ) <nl> return fut . wait ( ) ; <nl> } ; <nl> } <nl>\n", "msg": "Use a noop callback if client code doesn ' t provide one\n", "score": 1}
{"diff_id": 11171, "repo": "meteor/meteor\n", "sha": "6835354580a568369e2e4eed1c66e72a47b85ab3\n", "time": "2015-08-07T00:41:17Z\n", "diff": "mmm a / examples / todos / client / templates / app - body . js <nl> ppp b / examples / todos / client / templates / app - body . js <nl> Template . appBody . onRendered ( function ( ) { <nl> . hide ( ) <nl> . insertBefore ( next ) <nl> . fadeIn ( function ( ) { <nl> - listFadeInHold . release ( ) ; <nl> + if ( listFadeInHold ) { <nl> + listFadeInHold . release ( ) ; <nl> + } <nl> } ) ; <nl> } , <nl> removeElement : function ( node ) { <nl> Template . appBody . events ( { <nl> <nl> ' click . js - logout ' : function ( ) { <nl> Meteor . logout ( ) ; <nl> - <nl> + <nl> / / if we are on a private list , we ' ll need to go to a public one <nl> var current = Router . current ( ) ; <nl> if ( current . route . name = = = ' listsShow ' & & current . data ( ) . userId ) { <nl>\n", "msg": "Don ' t release the hold if it doesn ' t exist\n", "score": 1}
{"diff_id": 11217, "repo": "balderdashy/sails\n", "sha": "ade8621062d6cc064b00c66cd16e9f22de9bc5fe\n", "time": "2014-03-05T23:16:34Z\n", "diff": "mmm a / lib / app / index . js <nl> ppp b / lib / app / index . js <nl> function Sails ( ) { <nl> / / TODO : defer this to the http and sockets hooks - - use sails . emit ( ' lowering ' ) <nl> / / Shut down Socket server <nl> / / wait for all attached servers to stop <nl> + sails . emit ( ' lower ' ) ; <nl> var log = sails . log . verbose ; <nl> <nl> async . series ( [ <nl> function Sails ( ) { <nl> for ( var key in sails . _events ) { <nl> sails . removeAllListeners ( key ) ; <nl> } <nl> + process . removeAllListeners ( ) ; <nl> cb ( ) ; <nl> } <nl> ] , cb ) ; <nl>\n", "msg": "Emit ' lower ' event upon lowering , and remove all process listeners\n", "score": 1}
{"diff_id": 11349, "repo": "TryGhost/Ghost\n", "sha": "8d0a6b2674864c5605ac268de93c089cb6868afa\n", "time": "2020-04-15T09:52:30Z\n", "diff": "mmm a / core / frontend / apps / private - blogging / lib / middleware . js <nl> ppp b / core / frontend / apps / private - blogging / lib / middleware . js <nl> const privateBlogging = { <nl> <nl> return session ( { <nl> maxAge : constants . ONE_MONTH_MS , <nl> - signed : false <nl> + signed : false , <nl> + sameSite : ' none ' <nl> } ) ( req , res , next ) ; <nl> } , <nl> <nl>\n", "msg": " Fixed \" View site \" not logging into private sites with separate admin domains\n", "score": 1}
{"diff_id": 11629, "repo": "meteor/meteor\n", "sha": "98a21446cabed2863ed722f7efa2fba1ad71d37d\n", "time": "2015-03-05T23:49:05Z\n", "diff": "mmm a / tools / run - all . js <nl> ppp b / tools / run - all . js <nl> _ . extend ( Runner . prototype , { <nl> if ( ! self . stopped & & ! self . quiet ) { <nl> runLog . log ( \" \" ) ; <nl> runLog . log ( \" App running at : \" + self . rootUrl , { arrow : true } ) ; <nl> + <nl> + if ( process . platform = = = \" win32 \" ) { <nl> + runLog . log ( \" Type Control - C twice to stop . \" ) ; <nl> + } <nl> } <nl> <nl> if ( self . selenium & & ! self . stopped ) { <nl>\n", "msg": "Add special directions for killing the server on Windows\n", "score": 1}
{"diff_id": 11713, "repo": "balderdashy/sails\n", "sha": "0d49b71e59aa073c51e1741d8298952b27f4b566\n", "time": "2014-08-03T00:08:25Z\n", "diff": "mmm a / lib / hooks / http / index . js <nl> ppp b / lib / hooks / http / index . js <nl> module . exports = function ( sails ) { <nl> / / Merge in legacy ` sails . config . express ` object for backwards - compat . <nl> sails . util . defaultsDeep ( sails . config . http , sails . config . express | | { } ) ; <nl> <nl> + / / If no custom middlrware order is specified , make sure the default one is used . <nl> + / / This lets you override default middleware without having to explicitly include the <nl> + / / \" order \" array in your http . js config file . <nl> + sails . config . http . middleware . order = sails . config . middleware . order | | sails . hooks . http . defaults ( sails . config ) . http . middleware . order ; <nl> + <nl> } , <nl> <nl> <nl>\n", "msg": "Allow default middleware order to be used when custom middleware is specified .\n", "score": 1}
{"diff_id": 12545, "repo": "Leaflet/Leaflet\n", "sha": "e1e1504a1bc312d0ac4c1f69f9e9af2375ac3ae8\n", "time": "2011-07-12T12:00:31Z\n", "diff": "mmm a / src / core / Class . js <nl> ppp b / src / core / Class . js <nl> L . Class . extend = function ( / * Object * / props ) / * - > Class * / { <nl> <nl> / / extended class with the new prototype <nl> var NewClass = function ( ) { <nl> - if ( ! L . Class . _prototyping & & this . initialize ) { <nl> + if ( this . initialize ) { <nl> this . initialize . apply ( this , arguments ) ; <nl> } <nl> } ; <nl> <nl> / / instantiate class without calling constructor <nl> - L . Class . _prototyping = true ; <nl> - var proto = new this ( ) ; <nl> - L . Class . _prototyping = false ; <nl> - <nl> + var F = function ( ) { } ; <nl> + F . prototype = this . prototype ; <nl> + var proto = new F ( ) ; <nl> + <nl> proto . constructor = NewClass ; <nl> NewClass . prototype = proto ; <nl> <nl> / / add superclass access <nl> - proto . superclass = this . prototype ; <nl> + NewClass . superclass = this . prototype ; <nl> <nl> / / add class name <nl> / / proto . className = props ; <nl> <nl> / / inherit parent ' s statics <nl> for ( var i in this ) { <nl> - if ( this . hasOwnProperty ( i ) & & i ! = ' prototype ' ) { <nl> + if ( this . hasOwnProperty ( i ) & & i ! = ' prototype ' & & i ! = ' superclass ' ) { <nl> NewClass [ i ] = this [ i ] ; <nl> } <nl> } <nl>\n", "msg": "Improved inheritance mechanism , fixed access to the superclass\n", "score": 1}
{"diff_id": 12904, "repo": "meteor/meteor\n", "sha": "bed799f240325282a7a0506c2aed1ea0e3566065\n", "time": "2014-01-30T20:16:51Z\n", "diff": "mmm a / packages / accounts - base / accounts_server . js <nl> ppp b / packages / accounts - base / accounts_server . js <nl> Accounts . registerLoginHandler = function ( handler ) { <nl> loginHandlers = [ ] ; <nl> <nl> <nl> - / / Checks a user ' s credentials against all the registered login handlers , and <nl> - / / returns a newly created login token if the credentials are valid . It is like <nl> - / / the login method , except that it doesn ' t set the logged - in user on the <nl> - / / connection . Throws a Meteor . Error if logging in fails , including the case <nl> - / / where none of the login handlers handled the login request . Otherwise , returns <nl> - / / { id : userId , token : * , tokenExpires : * } . <nl> + / / Checks a user ' s credentials against all the registered login <nl> + / / handlers , and returns a login token if the credentials are valid . It <nl> + / / is like the login method , except that it doesn ' t set the logged - in <nl> + / / user on the connection . Throws a Meteor . Error if logging in fails , <nl> + / / including the case where none of the login handlers handled the login <nl> + / / request . Otherwise , returns { id : userId , token : * , tokenExpires : * } . <nl> / / <nl> / / For example , if you want to login with a plaintext password , ` options ` could be <nl> / / { user : { username : < username > } , password : < password > } , or <nl> / / { user : { email : < email > } , password : < password > } . <nl> - Accounts . createToken = function ( options ) { <nl> + Accounts . _runLoginHandlers = function ( options ) { <nl> / / Try all of the registered login handlers until one of them doesn ' t return <nl> / / ` undefined ` , meaning it handled this call to ` login ` . Return that return <nl> / / value , which ought to be a { id / token } pair . <nl> for ( var i = 0 ; i < loginHandlers . length ; + + i ) { <nl> var handler = loginHandlers [ i ] ; <nl> - var result = handler ( options ) ; <nl> + var result = handler . apply ( this , [ options ] ) ; <nl> if ( result ! = = undefined ) <nl> return result ; <nl> } <nl> Meteor . methods ( { <nl> / / Login handlers should really also check whatever field they look at in <nl> / / options , but we don ' t enforce it . <nl> check ( options , Object ) ; <nl> - var result = Accounts . createToken ( options ) ; <nl> + var result = Accounts . _runLoginHandlers . apply ( this , [ options ] ) ; <nl> if ( result ! = = null ) { <nl> / / This order ( and the avoidance of yields ) is important to make <nl> / / sure that when publish functions are rerun , they see a <nl>\n", "msg": "Preserve ` this ` for login handlers when run from a method .\n", "score": 1}
{"diff_id": 12942, "repo": "balderdashy/sails\n", "sha": "937aea991282041c41ea4d4f73cfbf04f5f717ef\n", "time": "2014-03-02T20:36:35Z\n", "diff": "mmm a / test / integration / lift . test . js <nl> ppp b / test / integration / lift . test . js <nl> describe ( ' Starting sails server with lift ' , function ( ) { <nl> sailsBin = sailsBin . substr ( 1 ) ; <nl> } ) ; <nl> <nl> - it ( ' should throw an error ' , function ( done ) { <nl> - <nl> - sailsServer = spawn ( sailsBin , [ ' lift ' ] ) ; <nl> - <nl> - sailsServer . stderr . on ( ' data ' , function ( data ) { <nl> - var dataString = data + ' ' ; <nl> - assert ( dataString . indexOf ( ' [ err ] ' ) ! = = - 1 ) ; <nl> - sailsServer . stderr . removeAllListeners ( ' data ' ) ; <nl> - sailsServer . kill ( ) ; <nl> - done ( ) ; <nl> - } ) ; <nl> - } ) ; <nl> + / / TODO : make this test more useful <nl> + / / it ( ' should throw an error ' , function ( done ) { <nl> + <nl> + / / sailsServer = spawn ( sailsBin , [ ' lift ' ] ) ; <nl> + <nl> + / / sailsServer . stderr . on ( ' data ' , function ( data ) { <nl> + / / var dataString = data + ' ' ; <nl> + / / assert ( dataString . indexOf ( ' [ err ] ' ) ! = = - 1 ) ; <nl> + / / sailsServer . stderr . removeAllListeners ( ' data ' ) ; <nl> + / / sailsServer . kill ( ) ; <nl> + / / done ( ) ; <nl> + / / } ) ; <nl> + / / } ) ; <nl> } ) ; <nl> <nl> describe ( ' in an sails app directory ' , function ( ) { <nl>\n", "msg": "Comment out deprecated test . Added todo to make it better .\n", "score": 1}
{"diff_id": 12947, "repo": "meteor/meteor\n", "sha": "cb1a62924f215b44df61420364d5cd4f18ccd9b5\n", "time": "2015-08-26T17:26:55Z\n", "diff": "mmm a / tools / cordova / project . js <nl> ppp b / tools / cordova / project . js <nl> requirements for platform $ { displayNameForPlatform ( platform ) } ` , <nl> $ { displayNameForPlatform ( platform ) } ` ) ; <nl> return false ; <nl> } else if ( requirements instanceof CordovaError ) { <nl> - Console . error ( ` cordova : $ { requirements . message } ` ) ; <nl> + Console . error ( ` Cordova error : $ { requirements . message } ` ) ; <nl> return false ; <nl> } <nl> <nl> from Cordova project ` , async ( ) = > { <nl> / / ( We do print the stack trace if we are in verbose mode . ) <nl> const errorMessage = Console . verbose ? ( error . stack | | error . message ) : <nl> error . message ; <nl> - Console . error ( errorMessage , consoleOptions ) ; <nl> + Console . error ( ` Cordova error : $ { errorMessage } ` , consoleOptions ) ; <nl> Console . error ( chalk . green ( ` ( If the error message contains suggestions \\ <nl> for a fix , note that this may not apply to the Meteor integration . You can try \\ <nl> running again with the - - verbose option to help diagnose the issue . ) ` ) , <nl>\n", "msg": "Add ' Cordova error : ' to Cordova error messages\n", "score": 1}
{"diff_id": 12989, "repo": "facebook/react-native\n", "sha": "b7d873b1a07c863a96d8a9a494f699fdc81ede9c\n", "time": "2017-04-11T19:25:39Z\n", "diff": "mmm a / Libraries / Lists / ListView / ListViewDataSource . js <nl> ppp b / Libraries / Lists / ListView / ListViewDataSource . js <nl> class ListViewDataSource { <nl> * this function as the ` dataBlob ` . <nl> * / <nl> cloneWithRows ( <nl> - dataBlob : Array < any > | { [ key : string ] : any } , <nl> - rowIdentities : ? Array < string > <nl> + dataBlob : $ ReadOnlyArray < any > | { + [ key : string ] : any } , <nl> + rowIdentities : ? $ ReadOnlyArray < string > <nl> ) : ListViewDataSource { <nl> - var rowIds = rowIdentities ? [ rowIdentities ] : null ; <nl> + var rowIds = rowIdentities ? [ [ . . . rowIdentities ] ] : null ; <nl> if ( ! this . _sectionHeaderHasChanged ) { <nl> this . _sectionHeaderHasChanged = ( ) = > false ; <nl> } <nl>\n", "msg": "Flow type improvements to accept co - variant types\n", "score": 1}
{"diff_id": 13040, "repo": "photonstorm/phaser\n", "sha": "d3caa815d13872d1500d25f0c9e934f68a723cb5\n", "time": "2018-01-08T18:30:42Z\n", "diff": "mmm a / v3 / src / sound / html5 / HTML5AudioSoundManager . js <nl> ppp b / v3 / src / sound / html5 / HTML5AudioSoundManager . js <nl> var HTML5AudioSoundManager = new Class ( { <nl> Extends : BaseSoundManager , <nl> initialize : function HTML5AudioSoundManager ( game ) { <nl> this . onBlurPausedSounds = [ ] ; <nl> + this . _mute = false ; <nl> BaseSoundManager . call ( this , game ) ; <nl> } , <nl> add : function ( key , config ) { <nl>\n", "msg": "Initializing _mute property used for storing global mute setting\n", "score": 1}
{"diff_id": 13215, "repo": "jashkenas/backbone\n", "sha": "179887e11683a7efeea5614c50ed8bea3659af2b\n", "time": "2013-01-15T15:01:32Z\n", "diff": "mmm a / backbone . js <nl> ppp b / backbone . js <nl> <nl> <nl> / / Optimized internal dispatch function for triggering events . Tries to <nl> / / keep the usual cases speedy ( most Backbone events have 3 arguments ) . <nl> - var triggerEvents = function ( obj , events , args ) { <nl> + var triggerEvents = function ( events , args ) { <nl> var ev , i = - 1 , l = events . length ; <nl> switch ( args . length ) { <nl> case 0 : while ( + + i < l ) ( ev = events [ i ] ) . callback . call ( ev . ctx ) ; <nl> <nl> if ( ! eventsApi ( this , ' trigger ' , name , args ) ) return this ; <nl> var events = this . _events [ name ] ; <nl> var allEvents = this . _events . all ; <nl> - if ( events ) triggerEvents ( this , events , args ) ; <nl> - if ( allEvents ) triggerEvents ( this , allEvents , arguments ) ; <nl> + if ( events ) triggerEvents ( events , args ) ; <nl> + if ( allEvents ) triggerEvents ( allEvents , arguments ) ; <nl> return this ; <nl> } , <nl> <nl> / / An inversion - of - control version of ` on ` . Tell * this * object to listen to <nl> / / an event in another object . . . keeping track of what it ' s listening to . <nl> - listenTo : function ( object , events , callback ) { <nl> + listenTo : function ( obj , name , callback ) { <nl> var listeners = this . _listeners | | ( this . _listeners = { } ) ; <nl> - var id = object . _listenerId | | ( object . _listenerId = _ . uniqueId ( ' l ' ) ) ; <nl> - listeners [ id ] = object ; <nl> - object . on ( events , typeof events = = = ' object ' ? this : callback , this ) ; <nl> + var id = obj . _listenerId | | ( obj . _listenerId = _ . uniqueId ( ' l ' ) ) ; <nl> + listeners [ id ] = obj ; <nl> + obj . on ( name , typeof name = = = ' object ' ? this : callback , this ) ; <nl> return this ; <nl> } , <nl> <nl> / / Tell this object to stop listening to either specific events . . . or <nl> / / to every object it ' s currently listening to . <nl> - stopListening : function ( object , events , callback ) { <nl> + stopListening : function ( obj , name , callback ) { <nl> var listeners = this . _listeners ; <nl> if ( ! listeners ) return ; <nl> - if ( object ) { <nl> - object . off ( events , typeof events = = = ' object ' ? this : callback , this ) ; <nl> - if ( ! events & & ! callback ) delete listeners [ object . _listenerId ] ; <nl> + if ( obj ) { <nl> + obj . off ( name , typeof name = = = ' object ' ? this : callback , this ) ; <nl> + if ( ! name & & ! callback ) delete listeners [ obj . _listenerId ] ; <nl> } else { <nl> - if ( typeof events = = = ' object ' ) callback = this ; <nl> + if ( typeof name = = = ' object ' ) callback = this ; <nl> for ( var id in listeners ) { <nl> - listeners [ id ] . off ( events , callback , this ) ; <nl> + listeners [ id ] . off ( name , callback , this ) ; <nl> } <nl> this . _listeners = { } ; <nl> } <nl>\n", "msg": "Consistent argument names across event functions , remove unused argument from ` triggerEvents `\n", "score": 1}
{"diff_id": 13323, "repo": "serverless/serverless\n", "sha": "3e4d62acfe6732bca9b32d28a83972611a8d6d7f\n", "time": "2017-07-27T17:34:24Z\n", "diff": "mmm a / lib / plugins / aws / remove / lib / stack . js <nl> ppp b / lib / plugins / aws / remove / lib / stack . js <nl> const BbPromise = require ( ' bluebird ' ) ; <nl> module . exports = { <nl> remove ( ) { <nl> this . serverless . cli . log ( ' Removing Stack . . . ' ) ; <nl> - const stackName = ` $ { this . serverless . service . service } - $ { this . options . stage } ` ; <nl> + const stackName = this . provider . naming . getStackName ( ) ; <nl> const params = { <nl> StackName : stackName , <nl> } ; <nl>\n", "msg": "Use naming . getStackName method instead of hardcoding .\n", "score": 1}
{"diff_id": 13364, "repo": "adobe/brackets\n", "sha": "f8c41a4f4940fa25341f8567d5c968cabd65fd63\n", "time": "2013-04-20T00:47:18Z\n", "diff": "mmm a / test / spec / LanguageManager - test . js <nl> ppp b / test / spec / LanguageManager - test . js <nl> define ( function ( require , exports , module ) { <nl> \" id \" : \" html \" , <nl> \" name \" : \" HTML \" , <nl> \" mode \" : [ \" htmlmixed \" , \" text / x - brackets - html \" ] , <nl> - \" fileExtensions \" : [ \" html \" , \" htm \" , \" shtm \" , \" shtml \" , \" xhtml \" , \" cfm \" , \" cfml \" , \" cfc \" , \" dhtml \" , \" xht \" ] , <nl> + \" fileExtensions \" : [ \" html \" , \" htm \" , \" shtm \" , \" shtml \" , \" xhtml \" , \" cfm \" , \" cfml \" , \" cfc \" , \" dhtml \" , \" xht \" , \" tpl \" , \" twig \" ] , <nl> \" blockComment \" : { prefix : \" < ! - - \" , suffix : \" - - > \" } <nl> } ; <nl> <nl>\n", "msg": "update HTML file extensions for smarty and twig file extensions\n", "score": 1}
{"diff_id": 13465, "repo": "caolan/async\n", "sha": "04c554894f95c5cb043167a0d54f81396bb73f1c\n", "time": "2016-04-03T23:38:36Z\n", "diff": "mmm a / lib / internal / initialParams . js <nl> ppp b / lib / internal / initialParams . js <nl> import rest from ' lodash / rest ' ; <nl> export default function ( fn ) { <nl> return rest ( function ( args / * . . . , callback * / ) { <nl> var callback = args . pop ( ) ; <nl> - fn ( args , callback ) ; <nl> + fn . call ( this , args , callback ) ; <nl> } ) ; <nl> } <nl>\n", "msg": "explicitly bind ' this ' , curried by lodash ' s rest method , to the wrapped method before invoking\n", "score": 1}
{"diff_id": 13554, "repo": "meteor/meteor\n", "sha": "c5044e57cd464765baa87489fba29b4485145319\n", "time": "2012-10-10T03:18:19Z\n", "diff": "mmm a / packages / accounts - base / accounts_common . js <nl> ppp b / packages / accounts - base / accounts_common . js <nl> if ( ! Accounts . _options ) { <nl> / / - forbidClientAccountCreation { Boolean } <nl> / / Do not allow clients to create accounts directly . <nl> Accounts . config = function ( options ) { <nl> - Accounts . _options = options ; <nl> + _ . each ( [ \" sendConfirmationEmail \" , \" forbidClientAccountCreation \" ] , function ( key ) { <nl> + if ( key in options ) { <nl> + if ( key in Accounts . _options ) <nl> + throw new Error ( \" Can ' t set ` \" + key + \" ` more than once \" ) ; <nl> + else <nl> + Accounts . _options [ key ] = options [ key ] ; <nl> + } <nl> + } ) ; <nl> } ; <nl> <nl> / / Users table . Don ' t use the normal autopublish , since we want to hide <nl>\n", "msg": "Allow multiple calls to Accounts . config without overriding settings\n", "score": 1}
{"diff_id": 13602, "repo": "atom/atom\n", "sha": "34167d426fec22c66461b0824fb060c68106a7ac\n", "time": "2019-01-04T16:07:06Z\n", "diff": "mmm a / spec / main - process / atom - application . test . js <nl> ppp b / spec / main - process / atom - application . test . js <nl> describe ( ' AtomApplication ' , function ( ) { <nl> const [ window ] = await atomApplication . launch ( parseCommandLine ( [ ' - - wait ' , ' - - pid ' , ' 101 ' , projectDir ] ) ) <nl> await focusWindow ( window ) <nl> <nl> - const [ reusedWindow ] = await atomApplication . launch ( parseCommandLine ( [ ' - - wait ' , ' - - pid ' , ' 102 ' , filePath1 , filePath2 ] ) ) <nl> + const [ reusedWindow ] = await atomApplication . launch ( parseCommandLine ( [ ' - - add ' , ' - - wait ' , ' - - pid ' , ' 102 ' , filePath1 , filePath2 ] ) ) <nl> assert . equal ( reusedWindow , window ) <nl> <nl> const activeEditorPath = await evalInWebContents ( window . browserWindow . webContents , send = > { <nl>\n", "msg": "Adjust tests to use - - add when necessary\n", "score": 1}
{"diff_id": 13737, "repo": "adobe/brackets\n", "sha": "b4010f8dd6030048251ff7c5af7f4611250ccb10\n", "time": "2012-03-30T13:26:53Z\n", "diff": "mmm a / src / LiveDevelopment / LiveDevelopment . js <nl> ppp b / src / LiveDevelopment / LiveDevelopment . js <nl> define ( function LiveDevelopment ( require , exports , module ) { <nl> } <nl> retryCount + + ; <nl> <nl> - if ( ! browserStarted ) { <nl> + if ( ! browserStarted & & exports . status ! = = - 1 ) { <nl> NativeApp . openLiveBrowser ( <nl> doc . root . url <nl> ) <nl>\n", "msg": "Don ' t try to start the browser if an error occurred .\n", "score": 1}
{"diff_id": 13743, "repo": "lodash/lodash\n", "sha": "10c44b08c93c886c942f1aa7b1e677cb9eb5fe18\n", "time": "2015-07-20T18:25:54Z\n", "diff": "mmm a / lodash . src . js <nl> ppp b / lodash . src . js <nl> <nl> } ; <nl> } <nl> <nl> - / * * <nl> - * The base implementation of ` _ . merge ` without support for argument juggling , <nl> - * multiple sources , and ` this ` binding ` customizer ` functions . <nl> - * <nl> - * @ private <nl> - * @ param { Object } object The destination object . <nl> - * @ param { Object } source The source object . <nl> - * @ param { Function } [ customizer ] The function to customize merged values . <nl> - * @ param { Array } [ stackA = [ ] ] Tracks traversed source objects . <nl> - * @ param { Array } [ stackB = [ ] ] Associates values with source counterparts . <nl> - * @ returns { Object } Returns ` object ` . <nl> - * / <nl> - function baseMerge ( object , source , customizer , stackA , stackB ) { <nl> - if ( ! isObject ( object ) ) { <nl> - return object ; <nl> - } <nl> - var isSrcArr = isArrayLike ( source ) & & ( isArray ( source ) | | isTypedArray ( source ) ) , <nl> - props = isSrcArr ? undefined : keys ( source ) ; <nl> - <nl> - arrayEach ( props | | source , function ( srcValue , key ) { <nl> - if ( props ) { <nl> - key = srcValue ; <nl> - srcValue = source [ key ] ; <nl> - } <nl> - if ( isObjectLike ( srcValue ) ) { <nl> - stackA | | ( stackA = [ ] ) ; <nl> - stackB | | ( stackB = [ ] ) ; <nl> - baseMergeDeep ( object , source , key , baseMerge , customizer , stackA , stackB ) ; <nl> - } <nl> - else { <nl> - var value = object [ key ] , <nl> - result = customizer ? customizer ( value , srcValue , key , object , source ) : undefined , <nl> - isCommon = result = = = undefined ; <nl> - <nl> - if ( isCommon ) { <nl> - result = srcValue ; <nl> - } <nl> - if ( ( result ! = = undefined | | ( isSrcArr & & ! ( key in object ) ) ) & & <nl> - ( isCommon | | ( result = = = result ? ( result ! = = value ) : ( value = = = value ) ) ) ) { <nl> - object [ key ] = result ; <nl> - } <nl> - } <nl> - } ) ; <nl> - return object ; <nl> - } <nl> - <nl> / * * <nl> * A specialized version of ` baseMerge ` for arrays and objects which performs <nl> * deep merges and tracks traversed objects enabling objects with circular <nl> <nl> } <nl> <nl> / * * <nl> - * Creates a ` _ . assign ` , ` _ . defaults ` , or ` _ . merge ` function . <nl> + * Creates a ` _ . assign ` or ` _ . merge ` function . <nl> * <nl> * @ private <nl> * @ param { Function } assigner The function to assign values . <nl> <nl> } <nl> <nl> / * * <nl> - * Creates a function that produces compound words out of the words in a <nl> - * given string . <nl> + * Creates a ` _ . camelCase ` , ` _ . kebabCase ` , ` _ . snakeCase ` , or ` _ . startCase ` function . <nl> * <nl> * @ private <nl> * @ param { Function } callback The function to combine each word . <nl> <nl> } ; <nl> } <nl> <nl> - / * * <nl> - * Creates a ` _ . curry ` or ` _ . curryRight ` function . <nl> - * <nl> - * @ private <nl> - * @ param { boolean } flag The curry bit flag . <nl> - * @ returns { Function } Returns the new curry function . <nl> - * / <nl> - function createCurry ( flag ) { <nl> - function curryFunc ( func , arity , guard ) { <nl> - if ( guard & & isIterateeCall ( func , arity , guard ) ) { <nl> - arity = undefined ; <nl> - } <nl> - var result = createWrapper ( func , flag , undefined , undefined , undefined , undefined , undefined , arity ) ; <nl> - result . placeholder = curryFunc . placeholder ; <nl> - return result ; <nl> - } <nl> - return curryFunc ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a ` _ . defaults ` or ` _ . defaultsDeep ` function . <nl> - * <nl> - * @ private <nl> - * @ param { Function } assigner The function to assign values . <nl> - * @ param { Function } customizer The function to customize assigned values . <nl> - * @ returns { Function } Returns the new defaults function . <nl> - * / <nl> - function createDefaults ( assigner , customizer ) { <nl> - return restParam ( function ( args ) { <nl> - var object = args [ 0 ] ; <nl> - if ( object = = null ) { <nl> - return object ; <nl> - } <nl> - args . push ( customizer ) ; <nl> - return assigner . apply ( undefined , args ) ; <nl> - } ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a ` _ . max ` or ` _ . min ` function . <nl> - * <nl> - * @ private <nl> - * @ param { Function } extremumBy The function used to get the extremum value . <nl> - * @ returns { Function } Returns the new extremum function . <nl> - * / <nl> - function createExtremum ( extremumBy ) { <nl> - return function ( collection ) { <nl> - return extremumBy ( collection , identity ) ; <nl> - } ; <nl> - } <nl> - <nl> / * * <nl> * Creates a ` _ . maxBy ` or ` _ . minBy ` function . <nl> * <nl> <nl> } ; <nl> } <nl> <nl> - / * * <nl> - * Creates a ` _ . find ` or ` _ . findLast ` function . <nl> - * <nl> - * @ private <nl> - * @ param { Function } eachFunc The function to iterate over a collection . <nl> - * @ param { boolean } [ fromRight ] Specify iterating from right to left . <nl> - * @ returns { Function } Returns the new find function . <nl> - * / <nl> - function createFind ( eachFunc , fromRight ) { <nl> - return function ( collection , predicate ) { <nl> - predicate = getIteratee ( predicate ) ; <nl> - if ( isArray ( collection ) ) { <nl> - var index = baseFindIndex ( collection , predicate , fromRight ) ; <nl> - return index > - 1 ? collection [ index ] : undefined ; <nl> - } <nl> - return baseFind ( collection , predicate , eachFunc ) ; <nl> - } ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a ` _ . findIndex ` or ` _ . findLastIndex ` function . <nl> - * <nl> - * @ private <nl> - * @ param { boolean } [ fromRight ] Specify iterating from right to left . <nl> - * @ returns { Function } Returns the new find function . <nl> - * / <nl> - function createFindIndex ( fromRight ) { <nl> - return function ( array , predicate ) { <nl> - if ( ! ( array & & array . length ) ) { <nl> - return - 1 ; <nl> - } <nl> - predicate = getIteratee ( predicate ) ; <nl> - return baseFindIndex ( array , predicate , fromRight ) ; <nl> - } ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a ` _ . findKey ` or ` _ . findLastKey ` function . <nl> - * <nl> - * @ private <nl> - * @ param { Function } objectFunc The function to iterate over an object . <nl> - * @ returns { Function } Returns the new find function . <nl> - * / <nl> - function createFindKey ( objectFunc ) { <nl> - return function ( object , predicate ) { <nl> - predicate = getIteratee ( predicate ) ; <nl> - return baseFind ( object , predicate , objectFunc , true ) ; <nl> - } ; <nl> - } <nl> - <nl> / * * <nl> * Creates a ` _ . flow ` or ` _ . flowRight ` function . <nl> * <nl> <nl> } ; <nl> } <nl> <nl> - / * * <nl> - * Creates a function for ` _ . forEach ` or ` _ . forEachRight ` . <nl> - * <nl> - * @ private <nl> - * @ param { Function } arrayFunc The function to iterate over an array . <nl> - * @ param { Function } eachFunc The function to iterate over a collection . <nl> - * @ returns { Function } Returns the new each function . <nl> - * / <nl> - function createForEach ( arrayFunc , eachFunc ) { <nl> - return function ( collection , iteratee ) { <nl> - return ( typeof iteratee = = ' function ' & & isArray ( collection ) ) <nl> - ? arrayFunc ( collection , iteratee ) <nl> - : eachFunc ( collection , toFunction ( iteratee ) ) ; <nl> - } ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a function for ` _ . forIn ` or ` _ . forInRight ` . <nl> - * <nl> - * @ private <nl> - * @ param { Function } objectFunc The function to iterate over an object . <nl> - * @ returns { Function } Returns the new each function . <nl> - * / <nl> - function createForIn ( objectFunc ) { <nl> - return function ( object , iteratee ) { <nl> - return objectFunc ( object , toFunction ( iteratee ) , keysIn ) ; <nl> - } ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a function for ` _ . forOwn ` or ` _ . forOwnRight ` . <nl> - * <nl> - * @ private <nl> - * @ param { Function } objectFunc The function to iterate over an object . <nl> - * @ returns { Function } Returns the new each function . <nl> - * / <nl> - function createForOwn ( objectFunc ) { <nl> - return function ( object , iteratee ) { <nl> - return objectFunc ( object , toFunction ( iteratee ) ) ; <nl> - } ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a function for ` _ . mapKeys ` or ` _ . mapValues ` . <nl> - * <nl> - * @ private <nl> - * @ param { boolean } [ isMapKeys ] Specify mapping keys instead of values . <nl> - * @ returns { Function } Returns the new map function . <nl> - * / <nl> - function createObjectMapper ( isMapKeys ) { <nl> - return function ( object , iteratee ) { <nl> - var result = { } ; <nl> - iteratee = getIteratee ( iteratee ) ; <nl> - <nl> - baseForOwn ( object , function ( value , key , object ) { <nl> - var mapped = iteratee ( value , key , object ) ; <nl> - key = isMapKeys ? mapped : key ; <nl> - value = isMapKeys ? value : mapped ; <nl> - result [ key ] = value ; <nl> - } ) ; <nl> - return result ; <nl> - } ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a function for ` _ . padLeft ` or ` _ . padRight ` . <nl> - * <nl> - * @ private <nl> - * @ param { boolean } [ fromRight ] Specify padding from the right . <nl> - * @ returns { Function } Returns the new pad function . <nl> - * / <nl> - function createPadDir ( fromRight ) { <nl> - return function ( string , length , chars ) { <nl> - string = baseToString ( string ) ; <nl> - return ( fromRight ? string : ' ' ) + createPadding ( string , length , chars ) + ( fromRight ? ' ' : string ) ; <nl> - } ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a ` _ . partial ` or ` _ . partialRight ` function . <nl> - * <nl> - * @ private <nl> - * @ param { boolean } flag The partial bit flag . <nl> - * @ returns { Function } Returns the new partial function . <nl> - * / <nl> - function createPartial ( flag ) { <nl> - var partialFunc = restParam ( function ( func , partials ) { <nl> - var holders = replaceHolders ( partials , partialFunc . placeholder ) ; <nl> - return createWrapper ( func , flag , undefined , partials , holders ) ; <nl> - } ) ; <nl> - return partialFunc ; <nl> - } <nl> - <nl> - / * * <nl> - * Creates a function for ` _ . reduce ` or ` _ . reduceRight ` . <nl> - * <nl> - * @ private <nl> - * @ param { Function } arrayFunc The function to iterate over an array . <nl> - * @ param { Function } eachFunc The function to iterate over a collection . <nl> - * @ returns { Function } Returns the new each function . <nl> - * / <nl> - function createReduce ( arrayFunc , eachFunc ) { <nl> - return function ( collection , iteratee , accumulator ) { <nl> - var initFromArray = arguments . length < 3 ; <nl> - return ( typeof iteratee = = ' function ' & & isArray ( collection ) ) <nl> - ? arrayFunc ( collection , iteratee , accumulator , initFromArray ) <nl> - : baseReduce ( collection , getIteratee ( iteratee ) , accumulator , initFromArray , eachFunc ) ; <nl> - } ; <nl> - } <nl> - <nl> / * * <nl> * Creates a function that wraps ` func ` and invokes it with optional ` this ` <nl> * binding of , partial application , and currying . <nl> <nl> } ; <nl> } <nl> <nl> - / * * <nl> - * Creates a ` _ . sortedIndex ` or ` _ . sortedLastIndex ` function . <nl> - * <nl> - * @ private <nl> - * @ param { boolean } [ retHighest ] Specify returning the highest qualified index . <nl> - * @ returns { Function } Returns the new index function . <nl> - * / <nl> - function createSortedIndex ( retHighest ) { <nl> - return function ( array , value , iteratee ) { <nl> - var toIteratee = getIteratee ( ) ; <nl> - return ( iteratee = = null & & toIteratee = = = baseIteratee ) <nl> - ? binaryIndex ( array , value , retHighest ) <nl> - : binaryIndexBy ( array , value , toIteratee ( iteratee ) , retHighest ) ; <nl> - } ; <nl> - } <nl> - <nl> / * * <nl> * Creates a function that either curries or invokes ` func ` with optional <nl> * ` this ` binding and partially applied arguments . <nl> <nl> * _ . findIndex ( users , ' active ' ) ; <nl> * / / = > 2 <nl> * / <nl> - var findIndex = createFindIndex ( ) ; <nl> + function findIndex ( array , predicate ) { <nl> + return ( array & & array . length ) <nl> + ? baseFindIndex ( array , getIteratee ( predicate ) ) <nl> + : - 1 ; <nl> + } <nl> <nl> / * * <nl> * This method is like ` _ . findIndex ` except that it iterates over elements <nl> <nl> * _ . findLastIndex ( users , ' active ' ) ; <nl> * / / = > 0 <nl> * / <nl> - var findLastIndex = createFindIndex ( true ) ; <nl> + function findLastIndex ( array , predicate ) { <nl> + return ( array & & array . length ) <nl> + ? baseFindIndex ( array , getIteratee ( predicate ) , true ) <nl> + : - 1 ; <nl> + } <nl> <nl> / * * <nl> * Gets the first element of ` array ` . <nl> <nl> * _ . sortedIndex ( [ { ' x ' : 30 } , { ' x ' : 50 } ] , { ' x ' : 40 } , ' x ' ) ; <nl> * / / = > 1 <nl> * / <nl> - var sortedIndex = createSortedIndex ( ) ; <nl> + function sortedIndex ( array , value , iteratee ) { <nl> + var toIteratee = getIteratee ( ) ; <nl> + return ( iteratee = = null & & toIteratee = = = baseIteratee ) <nl> + ? binaryIndex ( array , value ) <nl> + : binaryIndexBy ( array , value , toIteratee ( iteratee ) ) ; <nl> + } <nl> <nl> / * * <nl> * This method is like ` _ . sortedIndex ` except that it returns the highest <nl> <nl> * _ . sortedLastIndex ( [ 4 , 4 , 5 , 5 ] , 5 ) ; <nl> * / / = > 4 <nl> * / <nl> - var sortedLastIndex = createSortedIndex ( true ) ; <nl> + function sortedLastIndex ( array , value , iteratee ) { <nl> + var toIteratee = getIteratee ( ) ; <nl> + return ( iteratee = = null & & toIteratee = = = baseIteratee ) <nl> + ? binaryIndex ( array , value , true ) <nl> + : binaryIndexBy ( array , value , toIteratee ( iteratee ) , true ) ; <nl> + } <nl> <nl> / * * <nl> * Creates a slice of ` array ` with ` n ` elements taken from the beginning . <nl> <nl> * resolve ( _ . find ( users , ' active ' ) ) ; <nl> * / / = > ' barney ' <nl> * / <nl> - var find = createFind ( baseEach ) ; <nl> + function find ( collection , predicate ) { <nl> + predicate = getIteratee ( predicate ) ; <nl> + if ( isArray ( collection ) ) { <nl> + var index = baseFindIndex ( collection , predicate ) ; <nl> + return index > - 1 ? collection [ index ] : undefined ; <nl> + } <nl> + return baseFind ( collection , predicate , baseEach ) ; <nl> + } <nl> <nl> / * * <nl> * This method is like ` _ . find ` except that it iterates over elements of <nl> <nl> * } ) ; <nl> * / / = > 3 <nl> * / <nl> - var findLast = createFind ( baseEachRight , true ) ; <nl> + function findLast ( collection , predicate ) { <nl> + predicate = getIteratee ( predicate ) ; <nl> + if ( isArray ( collection ) ) { <nl> + var index = baseFindIndex ( collection , predicate , true ) ; <nl> + return index > - 1 ? collection [ index ] : undefined ; <nl> + } <nl> + return baseFind ( collection , predicate , baseEachRight ) ; <nl> + } <nl> <nl> / * * <nl> * Iterates over elements of ` collection ` invoking ` iteratee ` for each element . <nl> <nl> * } ) ; <nl> * / / = > logs each value - key pair and returns the object ( iteration order is not guaranteed ) <nl> * / <nl> - var forEach = createForEach ( arrayEach , baseEach ) ; <nl> + function forEach ( collection , iteratee ) { <nl> + return ( typeof iteratee = = ' function ' & & isArray ( collection ) ) <nl> + ? arrayEach ( collection , iteratee ) <nl> + : baseEach ( collection , toFunction ( iteratee ) ) ; <nl> + } <nl> <nl> / * * <nl> * This method is like ` _ . forEach ` except that it iterates over elements of <nl> <nl> * } ) ; <nl> * / / = > logs each value from right to left and returns the array <nl> * / <nl> - var forEachRight = createForEach ( arrayEachRight , baseEachRight ) ; <nl> + function forEachRight ( collection , iteratee ) { <nl> + return ( typeof iteratee = = ' function ' & & isArray ( collection ) ) <nl> + ? arrayEachRight ( collection , iteratee ) <nl> + : baseEachRight ( collection , toFunction ( iteratee ) ) ; <nl> + } <nl> <nl> / * * <nl> * Creates an object composed of keys generated from the results of running <nl> <nl> * } , { } ) ; <nl> * / / = > { ' a ' : 3 , ' b ' : 6 } ( iteration order is not guaranteed ) <nl> * / <nl> - var reduce = createReduce ( arrayReduce , baseEach ) ; <nl> + function reduce ( collection , iteratee , accumulator ) { <nl> + var initFromArray = arguments . length < 3 ; <nl> + return ( typeof iteratee = = ' function ' & & isArray ( collection ) ) <nl> + ? arrayReduce ( collection , iteratee , accumulator , initFromArray ) <nl> + : baseReduce ( collection , getIteratee ( iteratee ) , accumulator , initFromArray , baseEach ) ; <nl> + } <nl> <nl> / * * <nl> * This method is like ` _ . reduce ` except that it iterates over elements of <nl> <nl> * } , [ ] ) ; <nl> * / / = > [ 4 , 5 , 2 , 3 , 0 , 1 ] <nl> * / <nl> - var reduceRight = createReduce ( arrayReduceRight , baseEachRight ) ; <nl> + function reduceRight ( collection , iteratee , accumulator ) { <nl> + var initFromArray = arguments . length < 3 ; <nl> + return ( typeof iteratee = = ' function ' & & isArray ( collection ) ) <nl> + ? arrayReduceRight ( collection , iteratee , accumulator , initFromArray ) <nl> + : baseReduce ( collection , getIteratee ( iteratee ) , accumulator , initFromArray , baseEachRight ) ; <nl> + } <nl> <nl> / * * <nl> * The opposite of ` _ . filter ` ; this method returns the elements of ` collection ` <nl> <nl> * curried ( 1 ) ( _ , 3 ) ( 2 ) ; <nl> * / / = > [ 1 , 2 , 3 ] <nl> * / <nl> - var curry = createCurry ( CURRY_FLAG ) ; <nl> + function curry ( func , arity , guard ) { <nl> + if ( guard & & isIterateeCall ( func , arity , guard ) ) { <nl> + arity = undefined ; <nl> + } <nl> + var result = createWrapper ( func , CURRY_FLAG , undefined , undefined , undefined , undefined , undefined , arity ) ; <nl> + result . placeholder = curry . placeholder ; <nl> + return result ; <nl> + } <nl> <nl> / * * <nl> * This method is like ` _ . curry ` except that arguments are applied to ` func ` <nl> <nl> * curried ( 3 ) ( 1 , _ ) ( 2 ) ; <nl> * / / = > [ 1 , 2 , 3 ] <nl> * / <nl> - var curryRight = createCurry ( CURRY_RIGHT_FLAG ) ; <nl> + function curryRight ( func , arity , guard ) { <nl> + if ( guard & & isIterateeCall ( func , arity , guard ) ) { <nl> + arity = undefined ; <nl> + } <nl> + var result = createWrapper ( func , CURRY_RIGHT_FLAG , undefined , undefined , undefined , undefined , undefined , arity ) ; <nl> + result . placeholder = curryRight . placeholder ; <nl> + return result ; <nl> + } <nl> <nl> / * * <nl> * Creates a debounced function that delays invoking ` func ` until after ` wait ` <nl> <nl> * greetFred ( ' hi ' ) ; <nl> * / / = > ' hi fred ' <nl> * / <nl> - var partial = createPartial ( PARTIAL_FLAG ) ; <nl> + var partial = restParam ( function ( func , partials ) { <nl> + var holders = replaceHolders ( partials , partial . placeholder ) ; <nl> + return createWrapper ( func , PARTIAL_FLAG , undefined , partials , holders ) ; <nl> + } ) ; <nl> <nl> / * * <nl> * This method is like ` _ . partial ` except that partially applied arguments <nl> <nl> * sayHelloTo ( ' fred ' ) ; <nl> * / / = > ' hello fred ' <nl> * / <nl> - var partialRight = createPartial ( PARTIAL_RIGHT_FLAG ) ; <nl> + var partialRight = restParam ( function ( func , partials ) { <nl> + var holders = replaceHolders ( partials , partialRight . placeholder ) ; <nl> + return createWrapper ( func , PARTIAL_RIGHT_FLAG , undefined , partials , holders ) ; <nl> + } ) ; <nl> <nl> / * * <nl> * Creates a function that invokes ` func ` with arguments arranged according <nl> <nl> * } ) ; <nl> * / / = > { ' fruits ' : [ ' apple ' , ' banana ' ] , ' vegetables ' : [ ' beet ' , ' carrot ' ] } <nl> * / <nl> - var merge = createAssigner ( baseMerge ) ; <nl> + var merge = createAssigner ( function baseMerge ( object , source , customizer , stackA , stackB ) { <nl> + if ( ! isObject ( object ) ) { <nl> + return object ; <nl> + } <nl> + var isSrcArr = isArrayLike ( source ) & & ( isArray ( source ) | | isTypedArray ( source ) ) , <nl> + props = isSrcArr ? undefined : keys ( source ) ; <nl> + <nl> + arrayEach ( props | | source , function ( srcValue , key ) { <nl> + if ( props ) { <nl> + key = srcValue ; <nl> + srcValue = source [ key ] ; <nl> + } <nl> + if ( isObjectLike ( srcValue ) ) { <nl> + stackA | | ( stackA = [ ] ) ; <nl> + stackB | | ( stackB = [ ] ) ; <nl> + baseMergeDeep ( object , source , key , baseMerge , customizer , stackA , stackB ) ; <nl> + } <nl> + else { <nl> + var value = object [ key ] , <nl> + result = customizer ? customizer ( value , srcValue , key , object , source ) : undefined , <nl> + isCommon = result = = = undefined ; <nl> + <nl> + if ( isCommon ) { <nl> + result = srcValue ; <nl> + } <nl> + if ( ( result ! = = undefined | | ( isSrcArr & & ! ( key in object ) ) ) & & <nl> + ( isCommon | | ( result = = = result ? ( result ! = = value ) : ( value = = = value ) ) ) ) { <nl> + object [ key ] = result ; <nl> + } <nl> + } <nl> + } ) ; <nl> + return object ; <nl> + } ) ; <nl> <nl> / * * <nl> * Assigns own enumerable properties of source object ( s ) to the destination <nl> <nl> * _ . defaults ( { ' user ' : ' barney ' } , { ' age ' : 36 } , { ' user ' : ' fred ' } ) ; <nl> * / / = > { ' user ' : ' barney ' , ' age ' : 36 } <nl> * / <nl> - var defaults = createDefaults ( assign , assignDefaults ) ; <nl> + var defaults = restParam ( function ( args ) { <nl> + var object = args [ 0 ] ; <nl> + if ( object = = null ) { <nl> + return object ; <nl> + } <nl> + args . push ( assignDefaults ) ; <nl> + return assign . apply ( undefined , args ) ; <nl> + } ) ; <nl> <nl> / * * <nl> * This method is like ` _ . defaults ` except that it recursively assigns <nl> <nl> * / / = > { ' user ' : { ' name ' : ' barney ' , ' age ' : 36 } } <nl> * <nl> * / <nl> - var defaultsDeep = createDefaults ( merge , mergeDefaults ) ; <nl> + var defaultsDeep = restParam ( function ( args ) { <nl> + var object = args [ 0 ] ; <nl> + if ( object = = null ) { <nl> + return object ; <nl> + } <nl> + args . push ( mergeDefaults ) ; <nl> + return merge . apply ( undefined , args ) ; <nl> + } ) ; <nl> <nl> / * * <nl> * This method is like ` _ . find ` except that it returns the key of the first <nl> <nl> * _ . findKey ( users , ' active ' ) ; <nl> * / / = > ' barney ' <nl> * / <nl> - var findKey = createFindKey ( baseForOwn ) ; <nl> + function findKey ( object , predicate ) { <nl> + predicate = getIteratee ( predicate ) ; <nl> + return baseFind ( object , predicate , baseForOwn , true ) ; <nl> + } <nl> <nl> / * * <nl> * This method is like ` _ . findKey ` except that it iterates over elements of <nl> <nl> * _ . findLastKey ( users , ' active ' ) ; <nl> * / / = > ' pebbles ' <nl> * / <nl> - var findLastKey = createFindKey ( baseForOwnRight ) ; <nl> + function findLastKey ( object , predicate ) { <nl> + predicate = getIteratee ( predicate ) ; <nl> + return baseFind ( object , predicate , baseForOwnRight , true ) ; <nl> + } <nl> <nl> / * * <nl> * Iterates over own and inherited enumerable properties of an object invoking <nl> <nl> * } ) ; <nl> * / / = > logs ' a ' , ' b ' , and ' c ' ( iteration order is not guaranteed ) <nl> * / <nl> - var forIn = createForIn ( baseFor ) ; <nl> + function forIn ( object , iteratee ) { <nl> + return baseFor ( object , toFunction ( iteratee ) , keysIn ) ; <nl> + } <nl> <nl> / * * <nl> * This method is like ` _ . forIn ` except that it iterates over properties of <nl> <nl> * } ) ; <nl> * / / = > logs ' c ' , ' b ' , and ' a ' assuming ` _ . forIn ` logs ' a ' , ' b ' , and ' c ' <nl> * / <nl> - var forInRight = createForIn ( baseForRight ) ; <nl> + function forInRight ( object , iteratee ) { <nl> + return baseForRight ( object , toFunction ( iteratee ) , keysIn ) ; <nl> + } <nl> <nl> / * * <nl> * Iterates over own enumerable properties of an object invoking ` iteratee ` <nl> <nl> * } ) ; <nl> * / / = > logs ' a ' and ' b ' ( iteration order is not guaranteed ) <nl> * / <nl> - var forOwn = createForOwn ( baseForOwn ) ; <nl> + function forOwn ( object , iteratee ) { <nl> + return baseForOwn ( object , toFunction ( iteratee ) ) ; <nl> + } <nl> <nl> / * * <nl> * This method is like ` _ . forOwn ` except that it iterates over properties of <nl> <nl> * } ) ; <nl> * / / = > logs ' b ' and ' a ' assuming ` _ . forOwn ` logs ' a ' and ' b ' <nl> * / <nl> - var forOwnRight = createForOwn ( baseForOwnRight ) ; <nl> + function forOwnRight ( object , iteratee ) { <nl> + return baseForOwnRight ( object , toFunction ( iteratee ) ) ; <nl> + } <nl> + <nl> <nl> / * * <nl> * Creates an array of function property names from all enumerable properties , <nl> <nl> * } ) ; <nl> * / / = > { ' a1 ' : 1 , ' b2 ' : 2 } <nl> * / <nl> - var mapKeys = createObjectMapper ( true ) ; <nl> + function mapKeys ( object , iteratee ) { <nl> + var result = { } ; <nl> + iteratee = getIteratee ( iteratee ) ; <nl> + <nl> + baseForOwn ( object , function ( value , key , object ) { <nl> + result [ iteratee ( value , key , object ) ] = value ; <nl> + } ) ; <nl> + return result ; <nl> + } <nl> <nl> / * * <nl> * Creates an object with the same keys as ` object ` and values generated by <nl> <nl> * _ . mapValues ( users , ' age ' ) ; <nl> * / / = > { ' fred ' : 40 , ' pebbles ' : 1 } ( iteration order is not guaranteed ) <nl> * / <nl> - var mapValues = createObjectMapper ( ) ; <nl> + function mapValues ( object , iteratee ) { <nl> + var result = { } ; <nl> + iteratee = getIteratee ( iteratee ) ; <nl> + <nl> + baseForOwn ( object , function ( value , key , object ) { <nl> + result [ key ] = iteratee ( value , key , object ) ; <nl> + } ) ; <nl> + return result ; <nl> + } <nl> <nl> / * * <nl> * The opposite of ` _ . pick ` ; this method creates an object composed of the <nl> <nl> * _ . padLeft ( ' abc ' , 3 ) ; <nl> * / / = > ' abc ' <nl> * / <nl> - var padLeft = createPadDir ( ) ; <nl> + function padLeft ( string , length , chars ) { <nl> + string = baseToString ( string ) ; <nl> + return createPadding ( string , length , chars ) + string ; <nl> + } <nl> <nl> / * * <nl> * Pads ` string ` on the right side if it ' s shorter than ` length ` . Padding <nl> <nl> * _ . padRight ( ' abc ' , 3 ) ; <nl> * / / = > ' abc ' <nl> * / <nl> - var padRight = createPadDir ( true ) ; <nl> + function padRight ( string , length , chars ) { <nl> + string = baseToString ( string ) ; <nl> + return string + createPadding ( string , length , chars ) ; <nl> + } <nl> <nl> / * * <nl> * Converts ` string ` to an integer of the specified radix . If ` radix ` is <nl> <nl> * / <nl> var floor = createRound ( ' floor ' ) ; <nl> <nl> + / * * <nl> + * Gets the maximum value of ` collection ` . If ` collection ` is empty or falsey <nl> + * ` - Infinity ` is returned . <nl> + * <nl> + * @ static <nl> + * @ memberOf _ <nl> + * @ category Math <nl> + * @ param { Array | Object | string } collection The collection to iterate over . <nl> + * @ returns { * } Returns the maximum value . <nl> + * @ example <nl> + * <nl> + * _ . max ( [ 4 , 2 , 8 , 6 ] ) ; <nl> + * / / = > 8 <nl> + * <nl> + * _ . max ( [ ] ) ; <nl> + * / / = > - Infinity <nl> + * / <nl> + function max ( collection ) { <nl> + return maxBy ( collection , identity ) ; <nl> + } <nl> + <nl> / * * <nl> * This method is like ` _ . max ` except that it accepts an iteratee which is <nl> * invoked for each value in ` collection ` to generate the criterion by which <nl> <nl> var maxBy = createExtremumBy ( gt , NEGATIVE_INFINITY ) ; <nl> <nl> / * * <nl> - * Gets the maximum value of ` collection ` . If ` collection ` is empty or falsey <nl> - * ` - Infinity ` is returned . <nl> + * Gets the minimum value of ` collection ` . If ` collection ` is empty or falsey <nl> + * ` Infinity ` is returned . <nl> * <nl> * @ static <nl> * @ memberOf _ <nl> * @ category Math <nl> * @ param { Array | Object | string } collection The collection to iterate over . <nl> - * @ returns { * } Returns the maximum value . <nl> + * @ returns { * } Returns the minimum value . <nl> * @ example <nl> * <nl> - * _ . max ( [ 4 , 2 , 8 , 6 ] ) ; <nl> - * / / = > 8 <nl> + * _ . min ( [ 4 , 2 , 8 , 6 ] ) ; <nl> + * / / = > 2 <nl> * <nl> - * _ . max ( [ ] ) ; <nl> - * / / = > - Infinity <nl> + * _ . min ( [ ] ) ; <nl> + * / / = > Infinity <nl> * / <nl> - var max = createExtremum ( maxBy ) ; <nl> + function min ( collection ) { <nl> + return minBy ( collection , identity ) ; <nl> + } <nl> <nl> / * * <nl> * This method is like ` _ . min ` except that it accepts an iteratee which is <nl> <nl> * / <nl> var minBy = createExtremumBy ( lt , POSITIVE_INFINITY ) ; <nl> <nl> - / * * <nl> - * Gets the minimum value of ` collection ` . If ` collection ` is empty or falsey <nl> - * ` Infinity ` is returned . <nl> - * <nl> - * @ static <nl> - * @ memberOf _ <nl> - * @ category Math <nl> - * @ param { Array | Object | string } collection The collection to iterate over . <nl> - * @ returns { * } Returns the minimum value . <nl> - * @ example <nl> - * <nl> - * _ . min ( [ 4 , 2 , 8 , 6 ] ) ; <nl> - * / / = > 2 <nl> - * <nl> - * _ . min ( [ ] ) ; <nl> - * / / = > Infinity <nl> - * / <nl> - var min = createExtremum ( minBy ) ; <nl> - <nl> / * * <nl> * Calculates ` n ` rounded to ` precision ` . <nl> * <nl>\n", "msg": "Reduce the number of function creator helpers to improve readabilty .\n", "score": 1}
{"diff_id": 13793, "repo": "emberjs/ember.js\n", "sha": "bce0b25123f5758c3549462b5ff2369a4dc5c6cd\n", "time": "2012-05-24T23:50:17Z\n", "diff": "mmm a / packages / ember - handlebars / lib / views / metamorph_view . js <nl> ppp b / packages / ember - handlebars / lib / views / metamorph_view . js <nl> var DOMManager = { <nl> view . invalidateRecursively ( ' element ' ) ; <nl> view . _notifyWillInsertElement ( ) ; <nl> morph . replaceWith ( buffer . string ( ) ) ; <nl> - view . transitionTo ( ' inDOM ' ) ; <nl> + view . transitionTo ( ' hasElement . inDOM ' ) ; <nl> view . _notifyDidInsertElement ( ) ; <nl> } ) ; <nl> } , <nl>\n", "msg": "Correct state transition name to reflect StateMachine state nesting .\n", "score": 1}
{"diff_id": 13862, "repo": "ajaxorg/ace\n", "sha": "496b798d4a336dcc2929eae93d8d145c11f9474f\n", "time": "2017-02-09T12:49:24Z\n", "diff": "mmm a / lib / ace / editor . js <nl> ppp b / lib / ace / editor . js <nl> var Editor = function ( renderer , session ) { <nl> <nl> oldSession & & oldSession . _signal ( \" changeEditor \" , { oldEditor : this } ) ; <nl> session & & session . _signal ( \" changeEditor \" , { editor : this } ) ; <nl> + <nl> + if ( session & & session . bgTokenizer ) <nl> + session . bgTokenizer . scheduleStart ( ) ; <nl> } ; <nl> <nl> / * * <nl>\n", "msg": "start bgTokenizer worker in case session was changed outside of an editor\n", "score": 1}
{"diff_id": 13899, "repo": "atom/atom\n", "sha": "f658e69285d4ca2842461923929dbf6ccfe363ce\n", "time": "2020-02-27T17:59:25Z\n", "diff": "mmm a / script / lib / notarize - on - mac . js <nl> ppp b / script / lib / notarize - on - mac . js <nl> module . exports = async function ( packagedAppPath ) { <nl> appleIdPassword : appleIdPassword <nl> } ) ; <nl> } catch ( e ) { <nl> - throw new Error ( e ) ; <nl> + / / throw new Error ( e ) ; <nl> } <nl> } ; <nl>\n", "msg": "allow build to continue if notarization failed for testing pruposes only\n", "score": 1}
{"diff_id": 14039, "repo": "adobe/brackets\n", "sha": "52f3d5a251b69481bde4e34f8743dd85a02edeb0\n", "time": "2013-03-06T21:04:16Z\n", "diff": "mmm a / src / extensions / default / JavaScriptCodeHints / main . js <nl> ppp b / src / extensions / default / JavaScriptCodeHints / main . js <nl> define ( function ( require , exports , module ) { <nl> * @ return { boolean } - can the provider provide hints for this session ? <nl> * / <nl> JSHints . prototype . hasHints = function ( editor , key ) { <nl> - if ( ( key = = = null ) | | HintUtils . maybeIdentifier ( key ) ) { <nl> + if ( session & & ( ( key = = = null ) | | HintUtils . maybeIdentifier ( key ) ) ) { <nl> var cursor = session . getCursor ( ) , <nl> token = session . getToken ( cursor ) ; <nl> <nl> / / don ' t autocomplete within strings or comments , etc . <nl> if ( token & & HintUtils . hintable ( token ) ) { <nl> var offset = session . getOffset ( ) ; <nl> - <nl> + <nl> / / Invalidate cached information if : 1 ) no scope exists ; 2 ) the <nl> / / cursor has moved a line ; 3 ) the scope is dirty ; or 4 ) if the <nl> / / cursor has moved into a different scope . Cached information <nl> define ( function ( require , exports , module ) { <nl> function initializeSession ( editor ) { <nl> ScopeManager . handleEditorChange ( editor . document ) ; <nl> session = new Session ( editor ) ; <nl> - cachedScope = null ; <nl> - cachedLine = null ; <nl> - cachedHints = null ; <nl> - cachedType = null ; <nl> } <nl> <nl> / * <nl> define ( function ( require , exports , module ) { <nl> * changes <nl> * / <nl> function installEditorListeners ( editor ) { <nl> - if ( ! editor ) { <nl> - return ; <nl> - } <nl> - <nl> - if ( editor . getModeForSelection ( ) = = = HintUtils . MODE_NAME ) { <nl> + / / always clean up cached scope and hint info <nl> + cachedScope = null ; <nl> + cachedLine = null ; <nl> + cachedHints = null ; <nl> + cachedType = null ; <nl> + <nl> + if ( editor & & editor . getModeForDocument ( ) = = = HintUtils . MODE_NAME ) { <nl> initializeSession ( editor ) ; <nl> $ ( editor ) <nl> . on ( HintUtils . eventName ( \" change \" ) , function ( ) { <nl> ScopeManager . handleFileChange ( editor . document ) ; <nl> } ) ; <nl> + } else { <nl> + session = null ; <nl> } <nl> } <nl> <nl>\n", "msg": "Only provide hints for JavaScript files ( and not JavaScript within HTML files ) , and cleanup stale session objects when switching to non - hintable files .\n", "score": 1}
{"diff_id": 14096, "repo": "redux-saga/redux-saga\n", "sha": "afc8b18c9001e50aef8dd2bf6213b78183d690ee\n", "time": "2016-12-31T00:05:17Z\n", "diff": "mmm a / src / internal / utils . js <nl> ppp b / src / internal / utils . js <nl> export function check ( value , predicate , error ) { <nl> } <nl> } <nl> <nl> + const hasOwnProperty = Object . prototype . hasOwnProperty <nl> + export function hasProperty ( object , property ) { <nl> + return is . notUndef ( object ) & & hasOwnProperty . call ( object , property ) <nl> + } <nl> + <nl> export const is = { <nl> undef : v = > v = = = null | | v = = = undefined , <nl> notUndef : v = > v ! = = null & & v ! = = undefined , <nl> export const is = { <nl> pattern : pat = > pat & & ( ( typeof pat = = = ' string ' ) | | ( typeof pat = = = ' symbol ' ) | | is . func ( pat ) | | is . array ( pat ) ) , <nl> channel : ch = > ch & & is . func ( ch . take ) & & is . func ( ch . close ) , <nl> helper : it = > it & & it [ HELPER ] , <nl> - stringableFunc : f = > is . func ( f ) & & f . hasOwnProperty ( ' toString ' ) <nl> + stringableFunc : f = > is . func ( f ) & & hasProperty ( f , ' toString ' ) <nl> } <nl> <nl> export function remove ( array , item ) { <nl>\n", "msg": "Added hasProperty helper to safely check object . hasOwnProperty\n", "score": 1}
{"diff_id": 14230, "repo": "adobe/brackets\n", "sha": "9e9acd3b119e77de3411ed545b5ee3e34f34f5d5\n", "time": "2014-09-24T01:54:31Z\n", "diff": "mmm a / src / project / ProjectManager . js <nl> ppp b / src / project / ProjectManager . js <nl> define ( function ( require , exports , module ) { <nl> * / <nl> function _fileViewControllerChange ( ) { <nl> actionCreator . setFocused ( _hasFileSelectionFocus ( ) ) ; <nl> + $ projectTreeContainer . trigger ( \" scroll \" ) ; <nl> } <nl> <nl> / * * <nl>\n", "msg": "Ensure that the selection marker is drawn in the right place . . .\n", "score": 1}
{"diff_id": 14396, "repo": "meteor/meteor\n", "sha": "d8923c5874afa2587a3db9166a5fb8adeec52b57\n", "time": "2014-10-08T22:27:03Z\n", "diff": "mmm a / tools / tests / cordova - plugins . js <nl> ppp b / tools / tests / cordova - plugins . js <nl> var localCordova = path . join ( files . getCurrentToolsDir ( ) , \" tools \" , <nl> / / <nl> / / sand : a sandbox , that has the main app directory as its cwd . <nl> / / plugins : an array of plugins in order . <nl> - var checkCordovaPlugins = function ( sand , plugins ) { <nl> + var checkCordovaPlugins = selftest . markStack ( function ( sand , plugins ) { <nl> var lines = selftest . execFileSync ( localCordova , [ ' plugins ' ] , <nl> { <nl> cwd : path . join ( sand . cwd , ' . meteor ' , ' local ' , ' cordova - build ' ) , <nl> var checkCordovaPlugins = function ( sand , plugins ) { <nl> i + + ; <nl> } ) ; <nl> selftest . expectEqual ( plugins . length , i ) ; <nl> - } ; <nl> + } ) ; <nl> <nl> / / Given a sandbox , that has the app as its cwd , read the cordova plugins <nl> / / file and check that it contains exactly the plugins specified , in order . <nl> selftest . define ( \" add cordova plugins \" , [ \" slow \" ] , function ( ) { <nl> <nl> run = s . run ( \" run \" , \" android \" ) ; <nl> run . matchErr ( \" not added to the project \" ) ; <nl> - run . matchErr ( \" meteor add - platform \" ) ; <nl> + run . match ( \" meteor add - platform \" ) ; <nl> <nl> run = s . run ( \" add - platform \" , \" android \" ) ; <nl> run . match ( \" Do you agree \" ) ; <nl> selftest . define ( \" add cordova plugins \" , [ \" slow \" ] , function ( ) { <nl> run = s . run ( \" list - platforms \" ) ; <nl> run . match ( \" android \" ) ; <nl> <nl> - run = s . run ( \" build \" , \" . . / a \" , \" - - settings \" , \" settings . json \" ) ; <nl> + run = s . run ( \" build \" , \" . . / a \" , \" - - server \" , \" localhost : 3000 \" ) ; <nl> run . waitSecs ( 30 ) ; <nl> / / This fails because the FB plugin does not compile without additional <nl> / / configuration for android . <nl> selftest . define ( \" add cordova plugins \" , [ \" slow \" ] , function ( ) { <nl> run = s . run ( \" remove \" , \" contains - cordova - plugin \" ) ; <nl> run . match ( \" removed \" ) ; <nl> <nl> - run = s . run ( \" build \" , \" . . / a \" , \" - - settings \" , \" settings . json \" ) ; <nl> + run = s . run ( \" build \" , \" . . / a \" , \" - - server \" , \" localhost : 3000 \" ) ; <nl> run . waitSecs ( 60 ) ; <nl> run . expectExit ( 0 ) ; <nl> <nl> selftest . define ( \" add cordova plugins \" , [ \" slow \" ] , function ( ) { <nl> run . match ( \" removed \" ) ; <nl> run . expectExit ( 0 ) ; <nl> <nl> - run = s . run ( \" build \" , \" . . / a \" , \" - - settings \" , \" settings . json \" ) ; <nl> + run = s . run ( \" build \" , \" . . / a \" , \" - - server \" , \" localhost : 3000 \" ) ; <nl> run . waitSecs ( 60 ) ; <nl> run . expectExit ( 0 ) ; <nl> <nl> selftest . define ( \" add cordova plugins \" , [ \" slow \" ] , function ( ) { <nl> run . match ( \" added \" ) ; <nl> run . expectExit ( 0 ) ; <nl> <nl> - run = s . run ( \" build \" , \" . . / a \" , \" - - settings \" , \" settings . json \" ) ; <nl> + run = s . run ( \" build \" , \" . . / a \" , \" - - server \" , \" localhost : 3000 \" ) ; <nl> run . waitSecs ( 60 ) ; <nl> run . expectExit ( 0 ) ; <nl> checkCordovaPlugins ( s , [ \" org . apache . cordova . device \" ] ) ; <nl>\n", "msg": "Fixes to ' add cordova plugins ' selftest .\n", "score": 1}
{"diff_id": 14513, "repo": "RocketChat/Rocket.Chat\n", "sha": "82c106cf36a30aa4a06b0778747b00d3793af3eb\n", "time": "2016-10-28T12:54:24Z\n", "diff": "new file mode 100644 <nl> index 00000000000 . . c9335fd6891 <nl> mmm / dev / null <nl> ppp b / server / startup / migrations / v064 . js <nl> <nl> + RocketChat . Migrations . add ( { <nl> + version : 64 , <nl> + up : function ( ) { <nl> + RocketChat . models . Messages . find ( { ' t ' : ' room_changed_topic ' , ' msg ' : / < / } , { msg : 1 } ) . forEach ( function ( message ) { <nl> + let msg = s . escapeHTML ( message . msg ) ; <nl> + RocketChat . models . Message . update ( { _id : message . _id } , { $ set : { msg : msg } } ) ; <nl> + } ) ; <nl> + } <nl> + } ) ; <nl>\n", "msg": "Add migration to escape old room topic changed messages\n", "score": 1}
{"diff_id": 14606, "repo": "emberjs/ember.js\n", "sha": "e39d5f81ea9a2cd0e66c669200930042c6f17ed2\n", "time": "2011-07-14T06:36:16Z\n", "diff": "mmm a / packages / sproutcore - views / lib / system / event_dispatcher . js <nl> ppp b / packages / sproutcore - views / lib / system / event_dispatcher . js <nl> SC . EventDispatcher = SC . Object . extend ( <nl> setupHandler : function ( rootElement , event , eventName ) { <nl> rootElement . delegate ( ' . sc - view ' , event + ' . sproutcore ' , function ( evt ) { <nl> var view = SC . View . views [ this . id ] , <nl> - result = true , handler ; <nl> + result = true , manager = null , <nl> + self = this ; <nl> + <nl> + manager = self . _findNearestEventManager ( view , eventName ) ; <nl> + <nl> + if ( manager ) { <nl> + result = self . _dispatchEvent ( manager , evt , eventName ) ; <nl> + } <nl> + else { <nl> + result = self . _bubbleEvent ( view , evt , eventName ) ; <nl> + } <nl> + <nl> + evt . stopPropagation ( ) ; <nl> + <nl> + return result ; <nl> + } ) ; <nl> + } , <nl> + <nl> + / * * @ private * / <nl> + _findNearestEventManager : function ( view , eventName ) { <nl> + var manager = null ; <nl> + <nl> + while ( view ) { <nl> + manager = get ( view , ' eventManager ' ) ; <nl> + if ( manager & & manager [ eventName ] ) { break ; } <nl> + <nl> + view = get ( view , ' parentView ' ) ; <nl> + } <nl> + <nl> + return manager ; <nl> + } , <nl> + <nl> + / * * @ private * / <nl> + _dispatchEvent : function ( object , evt , eventName ) { <nl> + handler = object [ eventName ] ; <nl> + if ( SC . typeOf ( handler ) = = = ' function ' ) { <nl> + result = handler . call ( object , evt ) ; <nl> + } <nl> + <nl> + return result ; <nl> + } , <nl> + <nl> + / * * @ private * / <nl> + _bubbleEvent : function ( view , evt , eventName ) { <nl> + var result = true , handler , <nl> + self = this ; <nl> <nl> SC . run ( function ( ) { <nl> handler = view [ eventName ] ; <nl> SC . EventDispatcher = SC . Object . extend ( <nl> } ) ; <nl> <nl> return result ; <nl> - } ) ; <nl> } , <nl> <nl> / * * @ private * / <nl>\n", "msg": "Update event dispatcher to use SC . EventManager API\n", "score": 1}
{"diff_id": 14622, "repo": "lodash/lodash\n", "sha": "7863256de5901d1907603da3a4250088a04fa9e0\n", "time": "2015-09-07T05:41:07Z\n", "diff": "mmm a / test / test . js <nl> ppp b / test / test . js <nl> <nl> } ) ; <nl> <nl> test ( ' should partial match maps ' , 3 , function ( ) { <nl> - var objects = [ { ' a ' : new Map } , { ' a ' : new Map } ] ; <nl> - objects [ 0 ] . a . set ( ' a ' , 1 ) ; <nl> - objects [ 1 ] . a . set ( ' a ' , 1 ) ; <nl> - objects [ 1 ] . a . set ( ' b ' , 2 ) ; <nl> + if ( Map ) { <nl> + var objects = [ { ' a ' : new Map } , { ' a ' : new Map } ] ; <nl> + objects [ 0 ] . a . set ( ' a ' , 1 ) ; <nl> + objects [ 1 ] . a . set ( ' a ' , 1 ) ; <nl> + objects [ 1 ] . a . set ( ' b ' , 2 ) ; <nl> <nl> - var map = new Map ; <nl> - map . set ( ' b ' , 2 ) ; <nl> + var map = new Map ; <nl> + map . set ( ' b ' , 2 ) ; <nl> <nl> - var source = { ' a ' : map } , <nl> - predicate = function ( object ) { return _ . isMatch ( object , source ) ; } , <nl> - actual = _ . filter ( objects , predicate ) ; <nl> + var source = { ' a ' : map } , <nl> + predicate = function ( object ) { return _ . isMatch ( object , source ) ; } , <nl> + actual = _ . filter ( objects , predicate ) ; <nl> <nl> - deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> + deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> <nl> - map [ ' delete ' ] ( ' b ' ) ; <nl> - sourece = { ' a ' : map } ; <nl> - actual = _ . filter ( objects , predicate ) ; <nl> + map [ ' delete ' ] ( ' b ' ) ; <nl> + sourece = { ' a ' : map } ; <nl> + actual = _ . filter ( objects , predicate ) ; <nl> <nl> - deepEqual ( actual , objects ) ; <nl> + deepEqual ( actual , objects ) ; <nl> <nl> - map . set ( ' c ' , 3 ) ; <nl> - source = { ' a ' : map } ; <nl> - actual = _ . filter ( objects , predicate ) ; <nl> + map . set ( ' c ' , 3 ) ; <nl> + source = { ' a ' : map } ; <nl> + actual = _ . filter ( objects , predicate ) ; <nl> <nl> - deepEqual ( actual , [ ] ) ; <nl> + deepEqual ( actual , [ ] ) ; <nl> + } <nl> + else { <nl> + skipTest ( 3 ) ; <nl> + } <nl> } ) ; <nl> <nl> test ( ' should partial match sets ' , 3 , function ( ) { <nl> - var objects = [ { ' a ' : new Set } , { ' a ' : new Set } ] ; <nl> - objects [ 0 ] . a . add ( 1 ) ; <nl> - objects [ 1 ] . a . add ( 1 ) ; <nl> - objects [ 1 ] . a . add ( 2 ) ; <nl> + if ( Set ) { <nl> + var objects = [ { ' a ' : new Set } , { ' a ' : new Set } ] ; <nl> + objects [ 0 ] . a . add ( 1 ) ; <nl> + objects [ 1 ] . a . add ( 1 ) ; <nl> + objects [ 1 ] . a . add ( 2 ) ; <nl> <nl> - var set = new Set ; <nl> - set . add ( 2 ) ; <nl> + var set = new Set ; <nl> + set . add ( 2 ) ; <nl> <nl> - var source = { ' a ' : set } , <nl> - predicate = function ( object ) { return _ . isMatch ( object , source ) ; } , <nl> - actual = _ . filter ( objects , predicate ) ; <nl> + var source = { ' a ' : set } , <nl> + predicate = function ( object ) { return _ . isMatch ( object , source ) ; } , <nl> + actual = _ . filter ( objects , predicate ) ; <nl> <nl> - deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> + deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> <nl> - set [ ' delete ' ] ( 2 ) ; <nl> - source = { ' a ' : set } ; <nl> - actual = _ . filter ( objects , predicate ) ; <nl> + set [ ' delete ' ] ( 2 ) ; <nl> + source = { ' a ' : set } ; <nl> + actual = _ . filter ( objects , predicate ) ; <nl> <nl> - deepEqual ( actual , objects ) ; <nl> + deepEqual ( actual , objects ) ; <nl> <nl> - set . add ( 3 ) ; <nl> - source = { ' a ' : set } ; <nl> - actual = _ . filter ( objects , predicate ) ; <nl> + set . add ( 3 ) ; <nl> + source = { ' a ' : set } ; <nl> + actual = _ . filter ( objects , predicate ) ; <nl> <nl> - deepEqual ( actual , [ ] ) ; <nl> + deepEqual ( actual , [ ] ) ; <nl> + } <nl> + else { <nl> + skipTest ( 3 ) ; <nl> + } <nl> } ) ; <nl> <nl> test ( ' should match properties when ` object ` is not a plain object ' , 1 , function ( ) { <nl> <nl> } ) ; <nl> <nl> test ( ' should partial match maps ' , 3 , function ( ) { <nl> - var objects = [ { ' a ' : new Map } , { ' a ' : new Map } ] ; <nl> - objects [ 0 ] . a . set ( ' a ' , 1 ) ; <nl> - objects [ 1 ] . a . set ( ' a ' , 1 ) ; <nl> - objects [ 1 ] . a . set ( ' b ' , 2 ) ; <nl> + if ( Map ) { <nl> + var objects = [ { ' a ' : new Map } , { ' a ' : new Map } ] ; <nl> + objects [ 0 ] . a . set ( ' a ' , 1 ) ; <nl> + objects [ 1 ] . a . set ( ' a ' , 1 ) ; <nl> + objects [ 1 ] . a . set ( ' b ' , 2 ) ; <nl> <nl> - var map = new Map ; <nl> - map . set ( ' b ' , 2 ) ; <nl> - var actual = _ . filter ( objects , _ . matches ( { ' a ' : map } ) ) ; <nl> + var map = new Map ; <nl> + map . set ( ' b ' , 2 ) ; <nl> + var actual = _ . filter ( objects , _ . matches ( { ' a ' : map } ) ) ; <nl> <nl> - deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> + deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> <nl> - map [ ' delete ' ] ( ' b ' ) ; <nl> - actual = _ . filter ( objects , _ . matches ( { ' a ' : map } ) ) ; <nl> + map [ ' delete ' ] ( ' b ' ) ; <nl> + actual = _ . filter ( objects , _ . matches ( { ' a ' : map } ) ) ; <nl> <nl> - deepEqual ( actual , objects ) ; <nl> + deepEqual ( actual , objects ) ; <nl> <nl> - map . set ( ' c ' , 3 ) ; <nl> - actual = _ . filter ( objects , _ . matches ( { ' a ' : map } ) ) ; <nl> + map . set ( ' c ' , 3 ) ; <nl> + actual = _ . filter ( objects , _ . matches ( { ' a ' : map } ) ) ; <nl> <nl> - deepEqual ( actual , [ ] ) ; <nl> + deepEqual ( actual , [ ] ) ; <nl> + } <nl> + else { <nl> + skipTest ( 3 ) ; <nl> + } <nl> } ) ; <nl> <nl> test ( ' should partial match sets ' , 3 , function ( ) { <nl> - var objects = [ { ' a ' : new Set } , { ' a ' : new Set } ] ; <nl> - objects [ 0 ] . a . add ( 1 ) ; <nl> - objects [ 1 ] . a . add ( 1 ) ; <nl> - objects [ 1 ] . a . add ( 2 ) ; <nl> + if ( Set ) { <nl> + var objects = [ { ' a ' : new Set } , { ' a ' : new Set } ] ; <nl> + objects [ 0 ] . a . add ( 1 ) ; <nl> + objects [ 1 ] . a . add ( 1 ) ; <nl> + objects [ 1 ] . a . add ( 2 ) ; <nl> <nl> - var set = new Set ; <nl> - set . add ( 2 ) ; <nl> - var actual = _ . filter ( objects , _ . matches ( { ' a ' : set } ) ) ; <nl> + var set = new Set ; <nl> + set . add ( 2 ) ; <nl> + var actual = _ . filter ( objects , _ . matches ( { ' a ' : set } ) ) ; <nl> <nl> - deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> + deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> <nl> - set [ ' delete ' ] ( 2 ) ; <nl> - actual = _ . filter ( objects , _ . matches ( { ' a ' : set } ) ) ; <nl> + set [ ' delete ' ] ( 2 ) ; <nl> + actual = _ . filter ( objects , _ . matches ( { ' a ' : set } ) ) ; <nl> <nl> - deepEqual ( actual , objects ) ; <nl> + deepEqual ( actual , objects ) ; <nl> <nl> - set . add ( 3 ) ; <nl> - actual = _ . filter ( objects , _ . matches ( { ' a ' : set } ) ) ; <nl> + set . add ( 3 ) ; <nl> + actual = _ . filter ( objects , _ . matches ( { ' a ' : set } ) ) ; <nl> <nl> - deepEqual ( actual , [ ] ) ; <nl> + deepEqual ( actual , [ ] ) ; <nl> + } <nl> + else { <nl> + skipTest ( 3 ) ; <nl> + } <nl> } ) ; <nl> <nl> test ( ' should match properties when ` object ` is not a plain object ' , 1 , function ( ) { <nl> <nl> deepEqual ( actual , [ objects [ 0 ] ] ) ; <nl> } ) ; <nl> test ( ' should partial match maps ' , 3 , function ( ) { <nl> - var objects = [ { ' a ' : new Map } , { ' a ' : new Map } ] ; <nl> - objects [ 0 ] . a . set ( ' a ' , 1 ) ; <nl> - objects [ 1 ] . a . set ( ' a ' , 1 ) ; <nl> - objects [ 1 ] . a . set ( ' b ' , 2 ) ; <nl> + if ( Map ) { <nl> + var objects = [ { ' a ' : new Map } , { ' a ' : new Map } ] ; <nl> + objects [ 0 ] . a . set ( ' a ' , 1 ) ; <nl> + objects [ 1 ] . a . set ( ' a ' , 1 ) ; <nl> + objects [ 1 ] . a . set ( ' b ' , 2 ) ; <nl> <nl> - var map = new Map ; <nl> - map . set ( ' b ' , 2 ) ; <nl> - var actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , map ) ) ; <nl> + var map = new Map ; <nl> + map . set ( ' b ' , 2 ) ; <nl> + var actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , map ) ) ; <nl> <nl> - deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> + deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> <nl> - map [ ' delete ' ] ( ' b ' ) ; <nl> - actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , map ) ) ; <nl> + map [ ' delete ' ] ( ' b ' ) ; <nl> + actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , map ) ) ; <nl> <nl> - deepEqual ( actual , objects ) ; <nl> + deepEqual ( actual , objects ) ; <nl> <nl> - map . set ( ' c ' , 3 ) ; <nl> - actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , map ) ) ; <nl> + map . set ( ' c ' , 3 ) ; <nl> + actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , map ) ) ; <nl> <nl> - deepEqual ( actual , [ ] ) ; <nl> + deepEqual ( actual , [ ] ) ; <nl> + } <nl> + else { <nl> + skipTest ( 3 ) ; <nl> + } <nl> } ) ; <nl> <nl> test ( ' should partial match sets ' , 3 , function ( ) { <nl> - var objects = [ { ' a ' : new Set } , { ' a ' : new Set } ] ; <nl> - objects [ 0 ] . a . add ( 1 ) ; <nl> - objects [ 1 ] . a . add ( 1 ) ; <nl> - objects [ 1 ] . a . add ( 2 ) ; <nl> + if ( Set ) { <nl> + var objects = [ { ' a ' : new Set } , { ' a ' : new Set } ] ; <nl> + objects [ 0 ] . a . add ( 1 ) ; <nl> + objects [ 1 ] . a . add ( 1 ) ; <nl> + objects [ 1 ] . a . add ( 2 ) ; <nl> <nl> - var set = new Set ; <nl> - set . add ( 2 ) ; <nl> - var actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , set ) ) ; <nl> + var set = new Set ; <nl> + set . add ( 2 ) ; <nl> + var actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , set ) ) ; <nl> <nl> - deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> + deepEqual ( actual , [ objects [ 1 ] ] ) ; <nl> <nl> - set [ ' delete ' ] ( 2 ) ; <nl> - actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , set ) ) ; <nl> + set [ ' delete ' ] ( 2 ) ; <nl> + actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , set ) ) ; <nl> <nl> - deepEqual ( actual , objects ) ; <nl> + deepEqual ( actual , objects ) ; <nl> <nl> - set . add ( 3 ) ; <nl> - actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , set ) ) ; <nl> + set . add ( 3 ) ; <nl> + actual = _ . filter ( objects , _ . matchesProperty ( ' a ' , set ) ) ; <nl> <nl> - deepEqual ( actual , [ ] ) ; <nl> + deepEqual ( actual , [ ] ) ; <nl> + } <nl> + else { <nl> + skipTest ( 3 ) ; <nl> + } <nl> } ) ; <nl> <nl> test ( ' should match properties when ` srcValue ` is not a plain object ' , 1 , function ( ) { <nl>\n", "msg": "Add map and set guards to tests to fix travis runs .\n", "score": 1}
{"diff_id": 14772, "repo": "gorhill/uBlock\n", "sha": "5f63398af83541d44fc584255f093403c449227a\n", "time": "2017-05-17T21:40:55Z\n", "diff": "mmm a / src / js / cosmetic - filtering . js <nl> ppp b / src / js / cosmetic - filtering . js <nl> FilterContainer . prototype . skipGenericCompiledContent = function ( lineIter ) { <nl> continue ; <nl> } <nl> <nl> - fieldIter . first ( line ) ; <nl> - field0 = fieldIter . next ( ) ; <nl> + field0 = fieldIter . first ( line ) ; <nl> field1 = fieldIter . next ( ) ; <nl> <nl> / / h [ \\ v ] hash [ \\ v ] example . com [ \\ v ] . promoted - tweet <nl> FilterContainer . prototype . skipCompiledContent = function ( lineIter ) { <nl> continue ; <nl> } <nl> <nl> - fieldIter . first ( line ) ; <nl> - field0 = fieldIter . next ( ) ; <nl> + field0 = fieldIter . first ( line ) ; <nl> <nl> / / js [ \\ v ] hash [ \\ v ] example . com [ \\ v ] script : contains ( . . . ) <nl> / / js [ \\ v ] hash [ \\ v ] example . com [ \\ v ] script : inject ( . . . ) <nl>\n", "msg": "fix regression reported at http : / / forums . mozillazine . org / viewtopic . php ? p = 14748380 # p14748380\n", "score": 1}
{"diff_id": 14885, "repo": "meteor/meteor\n", "sha": "a073280e3f769886d6e3022f976b11e97b8f0142\n", "time": "2016-04-08T15:11:01Z\n", "diff": "mmm a / tools / isobuild / package - source . js <nl> ppp b / tools / isobuild / package - source . js <nl> _ . extend ( PackageSource . prototype , { <nl> : topLevelExcludes <nl> } ) ; <nl> <nl> + let nodeModulesDir ; <nl> + <nl> subdirectories . forEach ( subdir = > { <nl> if ( / ( ^ | \\ / ) node_modules \\ / $ / . test ( subdir ) ) { <nl> - if ( inNodeModules ) { <nl> - / / Don ' t descend into nested node_modules directories on any <nl> - / / platform , package or app . <nl> - return ; <nl> + if ( ! inNodeModules ) { <nl> + sourceArch . localNodeModulesDirs [ subdir ] = true ; <nl> } <nl> <nl> - / / Record this local node_modules directory so that we can copy <nl> - / / it into programs / server / npm later . <nl> - sourceArch . localNodeModulesDirs [ subdir ] = true ; <nl> - <nl> - if ( isApp & & archinfo . matches ( arch , \" web \" ) ) { <nl> - / / If we ' re building an app for the web , treat direct <nl> - / / node_modules dependencies as part of the app , so that files <nl> - / / other than . js and . json can be imported from node_modules . <nl> - / / In particular , this enables . css , . less , etc . ( # 6037 ) . <nl> - sources . push ( . . . find ( subdir , depth + 1 , true ) ) ; <nl> - } <nl> + / / Defer handling node_modules until after we handle all other <nl> + / / subdirectories , so that we know whether we need to descend <nl> + / / further . If sources is still empty after we handle everything <nl> + / / else in dir , then nothing in this node_modules subdir can be <nl> + / / imported by anthing outside of it , so we can ignore it . <nl> + nodeModulesDir = subdir ; <nl> <nl> } else { <nl> sources . push ( . . . find ( subdir , depth + 1 , inNodeModules ) ) ; <nl> } <nl> } ) ; <nl> <nl> + if ( isApp & & <nl> + nodeModulesDir & & <nl> + ( ! inNodeModules | | sources . length > 0 ) ) { <nl> + / / If we found a node_modules subdirectory above , and either we <nl> + / / are not already inside another node_modules directory or we <nl> + / / found source files elsewhere in this directory or its other <nl> + / / subdirectories , and we ' re building an app ( as opposed to a <nl> + / / Meteor package ) , continue searching this node_modules <nl> + / / directory , so that any non - . js ( on ) files it contains can be <nl> + / / imported by the app ( # 6037 ) . <nl> + sources . push ( . . . find ( nodeModulesDir , depth + 1 , true ) ) ; <nl> + } <nl> + <nl> return sources ; <nl> } <nl> <nl>\n", "msg": "Ignore nested node_modules directories if parent contains no sources .\n", "score": 1}
{"diff_id": 14904, "repo": "emberjs/ember.js\n", "sha": "7973ed4b1bf406aad7c8ae598299fd0a3f325471\n", "time": "2018-01-14T13:37:21Z\n", "diff": "mmm a / config / s3ProjectConfig . js <nl> ppp b / config / s3ProjectConfig . js <nl> function fileMap ( revision , tag , date ) { <nl> \" ember . min . js \" : fileObject ( \" ember . min \" , \" . js \" , \" text / javascript \" , revision , tag , date ) , <nl> \" ember . prod . js \" : fileObject ( \" ember . prod \" , \" . js \" , \" text / javascript \" , revision , tag , date ) , <nl> \" . . / docs / data . json \" : fileObject ( \" ember - docs \" , \" . json \" , \" application / json \" , revision , tag , date ) , <nl> - \" tests / index . html \" : fileObject ( \" ember - tests - index \" , \" . json \" , \" application / json \" , revision , tag , date ) , <nl> - \" bower . json \" : fileObject ( \" bower \" , \" . json \" , \" application / json \" , revision , tag , date ) , <nl> - \" component . json \" : fileObject ( \" component \" , \" . json \" , \" application / json \" , revision , tag , date ) , <nl> - \" composer . json \" : fileObject ( \" composer \" , \" . json \" , \" application / json \" , revision , tag , date ) , <nl> - \" package . json \" : fileObject ( \" package \" , \" . json \" , \" application / json \" , revision , tag , date ) , <nl> + \" tests / index . html \" : fileObject ( \" ember - tests - index \" , \" . json \" , \" application / json \" , revision , tag , date ) <nl> } ; <nl> <nl> let version = require ( ' . . / package ' ) . version ; <nl>\n", "msg": "Remove reference to files no longer present for S3 upload . . .\n", "score": 1}
{"diff_id": 14907, "repo": "adobe/brackets\n", "sha": "63ffc99ccfd7f4bdb6372e1dea53e6f73bca0ff9\n", "time": "2017-03-02T23:32:09Z\n", "diff": "mmm a / src / utils / ExtensionUtils . js <nl> ppp b / src / utils / ExtensionUtils . js <nl> <nl> define ( function ( require , exports , module ) { <nl> \" use strict \" ; <nl> <nl> - var Async = require ( \" utils / Async \" ) , <nl> - FileSystem = require ( \" filesystem / FileSystem \" ) , <nl> - FileUtils = require ( \" file / FileUtils \" ) , <nl> - PathUtils = require ( \" thirdparty / path - utils / path - utils \" ) ; <nl> + var Async = require ( \" utils / Async \" ) , <nl> + FileSystem = require ( \" filesystem / FileSystem \" ) , <nl> + FileUtils = require ( \" file / FileUtils \" ) , <nl> + PathUtils = require ( \" thirdparty / path - utils / path - utils \" ) , <nl> + PreferencesManager = require ( \" preferences / PreferencesManager \" ) ; <nl> <nl> / * * <nl> * Appends a < style > tag to the document ' s head . <nl> define ( function ( require , exports , module ) { <nl> function loadMetadata ( folder ) { <nl> var packageJSONFile = FileSystem . getFileForPath ( folder + \" / package . json \" ) , <nl> disabledFile = FileSystem . getFileForPath ( folder + \" / . disabled \" ) , <nl> + baseName = FileUtils . getBaseName ( folder ) , <nl> result = new $ . Deferred ( ) , <nl> jsonPromise = new $ . Deferred ( ) , <nl> disabledPromise = new $ . Deferred ( ) , <nl> define ( function ( require , exports , module ) { <nl> } else { <nl> disabled = exists ; <nl> } <nl> + <nl> + var defaultDisabled = PreferencesManager . get ( \" extensions . default . disabled \" ) ; <nl> + if ( Array . isArray ( defaultDisabled ) & & defaultDisabled . indexOf ( folder ) ! = = - 1 ) { <nl> + console . warn ( \" Default extension has been disabled on startup : \" + baseName ) ; <nl> + disabled = true ; <nl> + } <nl> + <nl> disabledPromise . resolve ( ) ; <nl> } ) ; <nl> Async . waitForAll ( [ jsonPromise , disabledPromise ] ) <nl> . always ( function ( ) { <nl> if ( ! json ) { <nl> - result . reject ( disabled ) ; <nl> - } else { <nl> - json . disabled = disabled ; <nl> - result . resolve ( json ) ; <nl> + / / if we don ' t have any metadata for the extension <nl> + / / we should still create an empty one , so we can attach <nl> + / / disabled property on it in case it ' s disabled <nl> + json = { <nl> + name : baseName <nl> + } ; <nl> } <nl> + json . disabled = disabled ; <nl> + result . resolve ( json ) ; <nl> } ) ; <nl> return result . promise ( ) ; <nl> } <nl>\n", "msg": "use the preference when attempting to load an extension\n", "score": 1}
{"diff_id": 14929, "repo": "lodash/lodash\n", "sha": "9b26b968364996997d3205a61ee7cc9ff654eea4\n", "time": "2012-05-09T06:14:03Z\n", "diff": "mmm a / lodash . js <nl> ppp b / lodash . js <nl> <nl> var reInterpolateDelimiter = / < % = ( [ \\ s \\ S ] + ? ) % > / g ; <nl> <nl> / * * Used to detect if a method is native * / <nl> - var reNative = / \\ { \\ s * \\ [ native code \\ ] \\ s * \\ } / ; <nl> + var reNative = RegExp ( ' ^ ' + ( { } . valueOf + ' ' ) <nl> + . replace ( / [ . * + ? ^ = ! : $ { } ( ) | [ \\ ] \\ / \\ \\ ] / g , ' \\ \\ $ & ' ) <nl> + . replace ( / valueOf / g , ' . + ? ' ) + ' $ ' ) <nl> <nl> / * * Used to match tokens in template text * / <nl> var reToken = / __token__ ( \\ d + ) / g ; <nl>\n", "msg": "Implement a more robust native function detection . [ Krinkle ]\n", "score": 1}
{"diff_id": 15090, "repo": "photonstorm/phaser\n", "sha": "f58ec09489879f8d85271dbe965a105196b1d347\n", "time": "2020-10-02T12:47:27Z\n", "diff": "new file mode 100644 <nl> index 0000000000 . . 4e18b2456d <nl> mmm / dev / null <nl> ppp b / src / tilemaps / components / CullBounds . js <nl> <nl> + / * * <nl> + * @ author Richard Davey < rich @ photonstorm . com > <nl> + * @ copyright 2020 Photon Storm Ltd . <nl> + * @ license { @ link https : / / opensource . org / licenses / MIT | MIT License } <nl> + * / <nl> + <nl> + var SnapCeil = require ( ' . . / . . / math / snap / SnapCeil ' ) ; <nl> + var SnapFloor = require ( ' . . / . . / math / snap / SnapFloor ' ) ; <nl> + <nl> + / * * <nl> + * Returns the bounds in the given orthogonal layer that are within the cameras viewport . <nl> + * This is used internally by the cull tiles function . <nl> + * <nl> + * @ function Phaser . Tilemaps . Components . CullBounds <nl> + * @ since 3 . 50 . 0 <nl> + * <nl> + * @ param { Phaser . Tilemaps . LayerData } layer - The Tilemap Layer to act upon . <nl> + * @ param { Phaser . Cameras . Scene2D . Camera } camera - The Camera to run the cull check against . <nl> + * <nl> + * @ return { object } An object containing the ` left ` , ` right ` , ` top ` and ` bottom ` bounds . <nl> + * / <nl> + var CullBounds = function ( layer , camera ) <nl> + { <nl> + var tilemap = layer . tilemapLayer . tilemap ; <nl> + var tilemapLayer = layer . tilemapLayer ; <nl> + <nl> + / / We need to use the tile sizes defined for the map as a whole , not the layer , <nl> + / / in order to calculate the bounds correctly . As different sized tiles may be <nl> + / / placed on the grid and we cannot trust layer . baseTileWidth to give us the true size . <nl> + var tileW = Math . floor ( tilemap . tileWidth * tilemapLayer . scaleX ) ; <nl> + var tileH = Math . floor ( tilemap . tileHeight * tilemapLayer . scaleY ) ; <nl> + <nl> + var boundsLeft = SnapFloor ( camera . worldView . x - tilemapLayer . x , tileW , 0 , true ) - tilemapLayer . cullPaddingX ; <nl> + var boundsRight = SnapCeil ( camera . worldView . right - tilemapLayer . x , tileW , 0 , true ) + tilemapLayer . cullPaddingX ; <nl> + <nl> + var boundsTop = SnapFloor ( camera . worldView . y - tilemapLayer . y , tileH , 0 , true ) - tilemapLayer . cullPaddingY ; <nl> + var boundsBottom = SnapCeil ( camera . worldView . bottom - tilemapLayer . y , tileH , 0 , true ) + tilemapLayer . cullPaddingY ; <nl> + <nl> + return { <nl> + left : boundsLeft , <nl> + right : boundsRight , <nl> + top : boundsTop , <nl> + bottom : boundsBottom <nl> + } ; <nl> + } ; <nl> + <nl> + module . exports = CullBounds ; <nl>\n", "msg": "` Tilemaps . Components . CullBounds ` is a new function that calculates the cull bounds for an orthogonal map .\n", "score": 1}
{"diff_id": 15095, "repo": "meteor/meteor\n", "sha": "1c2d6c6382723e7b9fa1fb465cbc386ad7cf80b7\n", "time": "2017-11-17T18:29:49Z\n", "diff": "mmm a / packages / dynamic - import / server . js <nl> ppp b / packages / dynamic - import / server . js <nl> function readTree ( tree , platform ) { <nl> const pathParts = [ ] ; <nl> <nl> function walk ( node ) { <nl> - if ( node & & typeof node = = = \" object \" ) { <nl> - let empty = true ; <nl> - Object . keys ( node ) . forEach ( name = > { <nl> - pathParts . push ( name ) ; <nl> - const result = walk ( node [ name ] ) ; <nl> - if ( result = = = null ) { <nl> - / / If the read function returns null , omit this module from the <nl> - / / resulting tree . <nl> - delete node [ name ] ; <nl> - } else { <nl> - node [ name ] = result ; <nl> - empty = false ; <nl> - } <nl> - assert . strictEqual ( pathParts . pop ( ) , name ) ; <nl> - } ) ; <nl> - if ( empty ) { <nl> - / / If every recursive call to walk ( node [ name ] ) returned null , <nl> - / / remove this node from the resulting tree by returning null . <nl> - return null ; <nl> - } <nl> - } else { <nl> + if ( ! node ) { <nl> + return null ; <nl> + } <nl> + <nl> + if ( typeof node ! = = \" object \" ) { <nl> return read ( pathParts , platform ) ; <nl> } <nl> + <nl> + let empty = true ; <nl> + <nl> + Object . keys ( node ) . forEach ( name = > { <nl> + pathParts . push ( name ) ; <nl> + const result = walk ( node [ name ] ) ; <nl> + if ( result = = = null ) { <nl> + / / If the read function returns null , omit this module from the <nl> + / / resulting tree . <nl> + delete node [ name ] ; <nl> + } else { <nl> + node [ name ] = result ; <nl> + empty = false ; <nl> + } <nl> + assert . strictEqual ( pathParts . pop ( ) , name ) ; <nl> + } ) ; <nl> + <nl> + if ( empty ) { <nl> + / / If every recursive call to walk ( node [ name ] ) returned null , <nl> + / / remove this node from the resulting tree by returning null . <nl> + return null ; <nl> + } <nl> + <nl> return node ; <nl> } <nl> <nl>\n", "msg": "Improve readability of dynamic - import helper function .\n", "score": 1}
{"diff_id": 15130, "repo": "emberjs/ember.js\n", "sha": "efc2d7749537cde17b486256ce52263f9be3c462\n", "time": "2013-12-02T05:54:22Z\n", "diff": "mmm a / packages / loader / lib / main . js <nl> ppp b / packages / loader / lib / main . js <nl> <nl> - var define , requireModule ; <nl> + var define , requireModule , require , requirejs ; <nl> <nl> ( function ( ) { <nl> var registry = { } , seen = { } ; <nl> var define , requireModule ; <nl> registry [ name ] = { deps : deps , callback : callback } ; <nl> } ; <nl> <nl> - requireModule = function ( name ) { <nl> + requirejs = require = requireModule = function ( name ) { <nl> + requirejs . _eak_seen = registry ; <nl> + <nl> if ( seen [ name ] ) { return seen [ name ] ; } <nl> seen [ name ] = { } ; <nl> <nl> - var mod , deps , callback , reified , exports ; <nl> - <nl> - mod = registry [ name ] ; <nl> - <nl> - if ( ! mod ) { <nl> - throw new Error ( \" Module ' \" + name + \" ' not found . \" ) ; <nl> + if ( ! registry [ name ] ) { <nl> + throw new Error ( \" Could not find module \" + name ) ; <nl> } <nl> <nl> - deps = mod . deps ; <nl> - callback = mod . callback ; <nl> - reified = [ ] ; <nl> + var mod = registry [ name ] , <nl> + deps = mod . deps , <nl> + callback = mod . callback , <nl> + reified = [ ] , <nl> + exports ; <nl> <nl> for ( var i = 0 , l = deps . length ; i < l ; i + + ) { <nl> if ( deps [ i ] = = = ' exports ' ) { <nl> reified . push ( exports = { } ) ; <nl> } else { <nl> - reified . push ( requireModule ( deps [ i ] ) ) ; <nl> + reified . push ( requireModule ( resolve ( deps [ i ] ) ) ) ; <nl> } <nl> } <nl> <nl> var value = callback . apply ( this , reified ) ; <nl> return seen [ name ] = exports | | value ; <nl> + <nl> + function resolve ( child ) { <nl> + if ( child . charAt ( 0 ) ! = = ' . ' ) { return child ; } <nl> + var parts = child . split ( \" / \" ) ; <nl> + var parentBase = name . split ( \" / \" ) . slice ( 0 , - 1 ) ; <nl> + <nl> + for ( var i = 0 , l = parts . length ; i < l ; i + + ) { <nl> + var part = parts [ i ] ; <nl> + <nl> + if ( part = = = ' . . ' ) { parentBase . pop ( ) ; } <nl> + else if ( part = = = ' . ' ) { continue ; } <nl> + else { parentBase . push ( part ) ; } <nl> + } <nl> + <nl> + return parentBase . join ( \" / \" ) ; <nl> + } <nl> } ; <nl> } ) ( ) ; <nl>\n", "msg": "use @ wycats amd micro - loader , which supports relative paths\n", "score": 1}
{"diff_id": 15131, "repo": "meteor/meteor\n", "sha": "943d8178ccdd03837000b71996b756e5be2f5899\n", "time": "2014-10-04T05:25:27Z\n", "diff": "mmm a / tools / commands - cordova . js <nl> ppp b / tools / commands - cordova . js <nl> _ . extend ( Android . prototype , { <nl> <nl> getAndroidBundlePath : function ( ) { <nl> / / XXX : Support USE_GLOBAL_ADK <nl> - return path . join ( files . getCurrentToolsDir ( ) , ' android_bundle ' ) ; <nl> + <nl> + / / XXX XXX is this right ? <nl> + if ( files . usesWarehouse ( ) ) <nl> + return path . join ( tropo . root , ' android_bundle ' ) ; <nl> + else <nl> + return path . join ( files . getCurrentToolsDir ( ) , ' android_bundle ' ) ; <nl> } , <nl> <nl> runAndroidTool : function ( args , options ) { <nl>\n", "msg": "Use the right path to android bundle when running from a release .\n", "score": 1}
{"diff_id": 15217, "repo": "gorhill/uBlock\n", "sha": "62387fb87a71d2282cec8162f919db563df7b109\n", "time": "2019-05-17T23:26:48Z\n", "diff": "mmm a / src / js / scriptlets / element - picker . js <nl> ppp b / src / js / scriptlets / element - picker . js <nl> const filterToDOMInterface = ( function ( ) { <nl> const elem = item . elem ; <nl> / / https : / / github . com / gorhill / uBlock / issues / 1629 <nl> if ( elem = = = pickerRoot ) { continue ; } <nl> - const style = elem . style ; <nl> if ( <nl> ( elem ! = = htmlElem ) & & <nl> ( item . type = = = ' cosmetic ' | | item . type = = = ' network ' & & item . src ! = = undefined ) <nl> ) { <nl> - item . display = style . getPropertyValue ( ' display ' ) ; <nl> - item . displayPriority = style . getPropertyPriority ( ' display ' ) ; <nl> - style . setProperty ( ' display ' , ' none ' , ' important ' ) ; <nl> + vAPI . domFilterer . hideNode ( elem ) ; <nl> + item . hidden = true ; <nl> } <nl> if ( item . type = = = ' network ' & & item . style = = = ' background - image ' ) { <nl> + const style = elem . style ; <nl> item . backgroundImage = style . getPropertyValue ( ' background - image ' ) ; <nl> item . backgroundImagePriority = style . getPropertyPriority ( ' background - image ' ) ; <nl> style . setProperty ( ' background - image ' , ' none ' , ' important ' ) ; <nl> const filterToDOMInterface = ( function ( ) { <nl> const unapplyHide = function ( ) { <nl> if ( lastResultset = = = undefined ) { return ; } <nl> for ( const item of lastResultset ) { <nl> - if ( item . hasOwnProperty ( ' display ' ) ) { <nl> - item . elem . style . setProperty ( <nl> - ' display ' , <nl> - item . display , <nl> - item . displayPriority <nl> - ) ; <nl> - delete item . display ; <nl> + if ( item . hidden = = = true ) { <nl> + vAPI . domFilterer . unhideNode ( item . elem ) ; <nl> + item . hidden = false ; <nl> } <nl> if ( item . hasOwnProperty ( ' backgroundImage ' ) ) { <nl> item . elem . style . setProperty ( <nl>\n", "msg": "Prevent picker ' s preview mode from modifying style attribute\n", "score": 1}
{"diff_id": 15598, "repo": "meteor/meteor\n", "sha": "5beb6ef982772948aa526116665dcf90f77d50d0\n", "time": "2014-09-25T06:37:20Z\n", "diff": "mmm a / tools / commands - cordova . js <nl> ppp b / tools / commands - cordova . js <nl> var installPlugin = function ( cordovaPath , name , version , settings ) { <nl> } <nl> } ; <nl> <nl> - var uninstallPlugin = function ( cordovaPath , name ) { <nl> + var uninstallPlugin = function ( cordovaPath , name , isFromTarballUrl ) { <nl> verboseLog ( ' Uninstalling a plugin ' , name ) ; <nl> try { <nl> execFileSyncOrThrow ( localCordova , [ ' plugin ' , ' rm ' , name ] , <nl> { cwd : cordovaPath } ) ; <nl> + <nl> + if ( isFromTarballUrl ) { <nl> + / / also remove from tarball - url - based plugins lock <nl> + var lock = getTarballPluginsLock ( cordovaPath ) ; <nl> + delete lock [ name ] ; <nl> + writeTarballPluginsLock ( cordovaPath , lock ) ; <nl> + } <nl> } catch ( err ) { <nl> / / Catch when an uninstall fails , because it might just be a dependency <nl> / / issue . For example , plugin A depends on plugin B and we try to remove <nl> var ensureCordovaPlugins = function ( localPath , options ) { <nl> ' utf8 ' ) ; <nl> } <nl> <nl> - / / XXX compare the latest used sha ' s with the currently required sha ' s for <nl> - / / plugins fetched from a github / tarball url . <nl> - <nl> var installedPlugins = getInstalledPlugins ( cordovaPath ) ; <nl> <nl> / / Due to the dependency structure of Cordova plugins , it is impossible to <nl> var ensureCordovaPlugins = function ( localPath , options ) { <nl> / / XXX there is a hack here that never updates a package if you are <nl> / / trying to install it from a URL , because we can ' t determine if <nl> / / it ' s the right version or not <nl> - if ( ! _ . has ( installedPlugins , name ) | | <nl> - ( installedPlugins [ name ] ! = = version & & ! utils . isUrlWithSha ( version ) ) ) { <nl> + if ( ! _ . has ( installedPlugins , name ) | | installedPlugins [ name ] ! = = version ) { <nl> / / The version of the plugin has changed , or we do not contain a plugin . <nl> shouldReinstallPlugins = true ; <nl> } <nl> var ensureCordovaPlugins = function ( localPath , options ) { <nl> var uninstallAllPlugins = function ( ) { <nl> installedPlugins = getInstalledPlugins ( cordovaPath ) ; <nl> while ( _ . size ( installedPlugins ) ) { <nl> - _ . each ( _ . keys ( installedPlugins ) , function ( name ) { <nl> - uninstallPlugin ( cordovaPath , name ) ; <nl> + _ . each ( installedPlugins , function ( version , name ) { <nl> + uninstallPlugin ( cordovaPath , name , utils . isUrlWithSha ( version ) ) ; <nl> } ) ; <nl> installedPlugins = getInstalledPlugins ( cordovaPath ) ; <nl> } <nl>\n", "msg": "Correctly reinstall tarball - based Cordova plugins if they change between builds\n", "score": 1}
{"diff_id": 15619, "repo": "JedWatson/react-select\n", "sha": "9d6f3b761e2b3b196379dfc760bbe4efe6bb3cde\n", "time": "2015-12-09T12:50:16Z\n", "diff": "mmm a / src / Select . js <nl> ppp b / src / Select . js <nl> const Select = React . createClass ( { <nl> autofocus : React . PropTypes . bool , / / autofocus the component on mount <nl> backspaceRemoves : React . PropTypes . bool , / / whether backspace removes an item if there is no text input <nl> className : React . PropTypes . string , / / className for the outer element <nl> - clearAllText : React . PropTypes . string , / / title for the \" clear \" control when multi : true <nl> - clearValueText : React . PropTypes . string , / / title for the \" clear \" control <nl> + clearAllText : React . PropTypes . oneOfType ( [ <nl> + React . PropTypes . string , <nl> + React . PropTypes . node <nl> + ] ) , / / title for the \" clear \" control when multi : true <nl> + clearValueText : React . PropTypes . oneOfType ( [ <nl> + React . PropTypes . string , <nl> + React . PropTypes . node <nl> + ] ) , / / title for the \" clear \" control <nl> clearable : React . PropTypes . bool , / / should it be possible to reset value <nl> delimiter : React . PropTypes . string , / / delimiter to use to join multiple values for the hidden field value <nl> disabled : React . PropTypes . bool , / / whether the Select is disabled or not <nl> const Select = React . createClass ( { <nl> multi : React . PropTypes . bool , / / multi - value input <nl> name : React . PropTypes . string , / / generates a hidden < input / > tag with this field name for html forms <nl> newOptionCreator : React . PropTypes . func , / / factory to create new options when allowCreate set <nl> - noResultsText : React . PropTypes . string , / / placeholder displayed when there are no matching search results <nl> + noResultsText : React . PropTypes . oneOfType ( [ <nl> + React . PropTypes . string , <nl> + React . PropTypes . node <nl> + ] ) , / / placeholder displayed when there are no matching search results <nl> onBlur : React . PropTypes . func , / / onBlur handler : function ( event ) { } <nl> onChange : React . PropTypes . func , / / onChange handler : function ( newValue ) { } <nl> onFocus : React . PropTypes . func , / / onFocus handler : function ( event ) { } <nl> const Select = React . createClass ( { <nl> optionComponent : React . PropTypes . func , / / option component to render in dropdown <nl> optionRenderer : React . PropTypes . func , / / optionRenderer : function ( option ) { } <nl> options : React . PropTypes . array , / / array of options <nl> - placeholder : React . PropTypes . string , / / field placeholder , displayed when there ' s no value <nl> + placeholder : React . PropTypes . oneOfType ( [ <nl> + React . PropTypes . string , <nl> + React . PropTypes . node <nl> + ] ) , / / field placeholder , displayed when there ' s no value <nl> searchable : React . PropTypes . bool , / / whether to enable searching feature or not <nl> simpleValue : React . PropTypes . bool , / / pass the value to onChange as a simple value ( legacy pre 1 . 0 mode ) , defaults to false <nl> style : React . PropTypes . object , / / optional style to apply to the control <nl>\n", "msg": "Less strict PropTypes for string placeholders to optionally allow React nodes\n", "score": 1}
{"diff_id": 15629, "repo": "photonstorm/phaser\n", "sha": "56caeb126fa17acb183dc9bcde8d486cfc8e9bdd\n", "time": "2020-09-20T23:17:14Z\n", "diff": "mmm a / src / renderer / webgl / pipelines / MeshPipeline . js <nl> ppp b / src / renderer / webgl / pipelines / MeshPipeline . js <nl> var MeshPipeline = new Class ( { <nl> <nl> config . fragShader = GetFastValue ( config , ' fragShader ' , ShaderSourceFS ) , <nl> config . vertShader = GetFastValue ( config , ' vertShader ' , ShaderSourceVS ) , <nl> - config . vertexCapacity = GetFastValue ( config , ' vertexCapacity ' , 2048 * 8 ) , <nl> + config . vertexCapacity = GetFastValue ( config , ' vertexCapacity ' , 8 ) , <nl> config . vertexSize = GetFastValue ( config , ' vertexSize ' , 32 ) , <nl> config . attributes = GetFastValue ( config , ' attributes ' , [ <nl> { <nl> var MeshPipeline = new Class ( { <nl> <nl> WebGLPipeline . call ( this , config ) ; <nl> <nl> - / * * <nl> - * Float32 view of the array buffer containing the pipeline ' s vertices . <nl> - * <nl> - * @ name Phaser . Renderer . WebGL . Pipelines . MeshPipeline # vertexViewF32 <nl> - * @ type { Float32Array } <nl> - * @ since 3 . 0 . 0 <nl> - * / <nl> - this . vertexViewF32 = new Float32Array ( this . vertexData ) ; <nl> - <nl> this . forceZero = true ; <nl> } , <nl> <nl> var MeshPipeline = new Class ( { <nl> renderer . setFloat3 ( program , ' uLightAmbient ' , light . ambient . x , light . ambient . y , light . ambient . z ) ; <nl> renderer . setFloat3 ( program , ' uLightDiffuse ' , light . diffuse . x , light . diffuse . y , light . diffuse . z ) ; <nl> renderer . setFloat3 ( program , ' uLightSpecular ' , light . specular . x , light . specular . y , light . specular . z ) ; <nl> + <nl> renderer . setFloat3 ( program , ' uCameraPosition ' , camera . x , camera . y , camera . z ) ; <nl> + <nl> + renderer . setFloat3 ( program , ' uFogColor ' , mesh . fogColor . r , mesh . fogColor . g , mesh . fogColor . b ) ; <nl> + renderer . setFloat1 ( program , ' uFogNear ' , mesh . forNear ) ; <nl> + renderer . setFloat1 ( program , ' uFogFar ' , mesh . forFar ) ; <nl> } , <nl> <nl> drawModel : function ( mesh , model ) <nl> var MeshPipeline = new Class ( { <nl> renderer . setTextureZero ( model . frame . glTexture ) ; <nl> renderer . setInt1 ( program , ' uTexture ' , 0 ) ; <nl> <nl> - / / All the uniforms are finally bound , so now lets draw our faces ! <nl> + / / All the uniforms are finally bound , so let ' s buffer our data <nl> <nl> - var vertexViewF32 = this . vertexViewF32 ; <nl> - <nl> - var vertices = model . vertices ; <nl> - <nl> - for ( var i = 0 ; i < vertices . length ; i + + ) <nl> - { <nl> - if ( this . shouldFlush ( 1 ) ) <nl> - { <nl> - this . flush ( ) ; <nl> - } <nl> - <nl> - var vertexOffset = ( this . vertexCount * this . vertexComponentCount ) - 1 ; <nl> - <nl> - var vert = vertices [ i ] ; <nl> - <nl> - vertexViewF32 [ + + vertexOffset ] = vert . x ; <nl> - vertexViewF32 [ + + vertexOffset ] = vert . y ; <nl> - vertexViewF32 [ + + vertexOffset ] = vert . z ; <nl> - vertexViewF32 [ + + vertexOffset ] = vert . nx ; <nl> - vertexViewF32 [ + + vertexOffset ] = vert . ny ; <nl> - vertexViewF32 [ + + vertexOffset ] = vert . nz ; <nl> - vertexViewF32 [ + + vertexOffset ] = vert . u ; <nl> - vertexViewF32 [ + + vertexOffset ] = vert . v ; <nl> + var gl = this . gl ; <nl> <nl> - this . vertexCount + + ; <nl> - } <nl> + / / STATIC because the buffer data doesn ' t change , the uniforms do <nl> + gl . bufferData ( gl . ARRAY_BUFFER , model . vertexData , gl . STATIC_DRAW ) ; <nl> <nl> - this . flush ( ) ; <nl> + gl . drawArrays ( this . topology , 0 , model . vertexCount ) ; <nl> } <nl> <nl> } ) ; <nl>\n", "msg": "Renders whole buffer in a single draw with no vertex iteration\n", "score": 1}
{"diff_id": 15797, "repo": "emberjs/ember.js\n", "sha": "c7d6a0da389245fda85107dcb508fe36d3cc258c\n", "time": "2017-06-02T19:27:21Z\n", "diff": "mmm a / packages / container / lib / container . js <nl> ppp b / packages / container / lib / container . js <nl> Container . prototype = { <nl> function wrapManagerInDeprecationProxy ( manager ) { <nl> if ( HAS_NATIVE_PROXY ) { <nl> let validator = { <nl> - get ( obj , prop ) { <nl> - if ( prop ! = = ' class ' & & prop ! = = ' create ' ) { <nl> - throw new Error ( ` You attempted to access \" $ { prop } \" on a factory manager created by container # factoryFor . \" $ { prop } \" is not a member of a factory manager . \" ` ) ; <nl> - } <nl> - <nl> - return obj [ prop ] ; <nl> - } , <nl> set ( obj , prop , value ) { <nl> throw new Error ( ` You attempted to set \" $ { prop } \" on a factory manager created by container # factoryFor . A factory manager is a read - only construct . ` ) ; <nl> } <nl>\n", "msg": "[ BUGFIX ] Improve fastboot debugger / repl experience\n", "score": 1}
{"diff_id": 15939, "repo": "Semantic-Org/Semantic-UI\n", "sha": "eb331afdc262ccf9235b4966e8451366d99501e2\n", "time": "2015-08-13T15:25:06Z\n", "diff": "mmm a / tasks / build . js <nl> ppp b / tasks / build . js <nl> var <nl> <nl> / / config <nl> config = require ( ' . / config / user ' ) , <nl> - runSequence = require ( ' run - sequence ' ) , <nl> install = require ( ' . / config / project / install ' ) <nl> ; <nl> <nl> module . exports = function ( callback ) { <nl> return ; <nl> } <nl> <nl> - var tasks = [ ] ; <nl> - <nl> / / check for right - to - left ( RTL ) language <nl> if ( config . rtl = = ' both ' ) { <nl> - tasks . push ( ' build - rtl ' ) ; <nl> + gulp . start ( ' build - rtl ' ) ; <nl> } <nl> if ( config . rtl = = = true | | config . rtl = = = ' Yes ' ) { <nl> gulp . start ( ' build - rtl ' ) ; <nl> return ; <nl> } <nl> <nl> - tasks . push ( ' build - javascript ' ) ; <nl> - tasks . push ( ' build - css ' ) ; <nl> - tasks . push ( ' build - assets ' ) ; <nl> + gulp . start ( ' build - javascript ' ) ; <nl> + gulp . start ( ' build - css ' ) ; <nl> + gulp . start ( ' build - assets ' ) ; <nl> + <nl> <nl> - runSequence ( tasks , callback ) ; <nl> } ; <nl>\n", "msg": "Revert \" Fix callback return from build task \"\n", "score": 1}
{"diff_id": 16133, "repo": "meteor/meteor\n", "sha": "0ab298dd34c951ae0d07eb708ef88db98067cbdb\n", "time": "2017-11-29T19:33:26Z\n", "diff": "mmm a / tools / tool - testing / selftest . js <nl> ppp b / tools / tool - testing / selftest . js <nl> class TestList { <nl> tagsToSkip = ( tagsToSkip | | [ ] ) ; <nl> testState = ( testState | | null ) ; / / optional <nl> this . allTests = allTests ; <nl> + this . failedTests = [ ] ; <nl> this . skippedTags = tagsToSkip ; <nl> this . skipCounts = { } ; <nl> this . testState = testState ; <nl> class TestList { <nl> / / Mark the file that this test lives in as having failures . <nl> this . fileInfo [ test . file ] . hasFailures = true ; <nl> <nl> + this . failedTests . push ( test ) ; <nl> + <nl> / / Mark that the specific test failed . <nl> test . failed = true ; <nl> <nl> export function runTests ( options ) { <nl> testList . startTime = new Date ; <nl> <nl> let totalRun = 0 ; <nl> - const failedTests = [ ] ; <nl> <nl> const totalTries = ( options . retries | | 0 ) + 1 ; <nl> <nl> export function runTests ( options ) { <nl> Console . rawError ( \" = > Test threw exception : \" + failure . stack + \" \\ n \" ) ; <nl> } <nl> <nl> - failedTests . push ( test ) ; <nl> testList . notifyFailed ( test , failure ) ; <nl> } else { <nl> Console . error ( <nl> export function runTests ( options ) { <nl> <nl> Console . error ( testList . generateSkipReport ( ) ) ; <nl> <nl> - if ( testList . filteredTests . length = = = 0 ) { <nl> + const failureCount = testList . failedTests . length ; <nl> + <nl> + if ( ! totalRun ) { <nl> Console . error ( \" No tests run . \" ) ; <nl> return 0 ; <nl> - } else if ( failedTests . length = = = 0 ) { <nl> + } else if ( ! failureCount ) { <nl> let disclaimers = ' ' ; <nl> - if ( testList . filteredTests . length < testList . allTests . length ) { <nl> + if ( totalRun < testList . allTests . length ) { <nl> disclaimers + = \" other \" ; <nl> } <nl> Console . error ( \" All \" + disclaimers + \" tests passed . \" ) ; <nl> return 0 ; <nl> } else { <nl> - const failureCount = failedTests . length ; <nl> Console . error ( failureCount + \" failure \" + <nl> ( failureCount > 1 ? \" s \" : \" \" ) + \" : \" ) ; <nl> - failedTests . forEach ( ( test ) = > { <nl> + testList . failedTests . forEach ( ( test ) = > { <nl> Console . rawError ( \" - \" + test . file + \" : \" + test . name + \" \\ n \" ) ; <nl> } ) ; <nl> return 1 ; <nl>\n", "msg": "Change ` failedTests ` to live on the ` testList ` .\n", "score": 1}
{"diff_id": 16207, "repo": "photonstorm/phaser\n", "sha": "29c77e10d76411ad50cda63a895a2625038801a9\n", "time": "2016-07-21T05:12:46Z\n", "diff": "mmm a / src / tilemap / TilemapLayerGL . js <nl> ppp b / src / tilemap / TilemapLayerGL . js <nl> Phaser . TilemapLayerGL = function ( game , tilemap , index , width , height ) { <nl> <nl> this . game = game ; <nl> <nl> - width | = 0 ; <nl> - height | = 0 ; <nl> - <nl> / * * <nl> * The Tilemap to which this layer is bound . <nl> * @ property { Phaser . Tilemap } map <nl> Phaser . TilemapLayerGL = function ( game , tilemap , index , width , height ) { <nl> / / get PIXI textures for each tileset source image <nl> var baseTexture = new PIXI . BaseTexture ( tileset . image ) ; <nl> <nl> - PIXI . Tilemap . call ( this , new PIXI . Texture ( baseTexture ) , this . map . width , this . map . height , this . _mc . tileset . tileWidth , this . _mc . tileset . tileHeight , this . layer ) ; <nl> + PIXI . Tilemap . call ( this , new PIXI . Texture ( baseTexture ) , width | 0 , height | 0 , this . map . width , this . map . height , this . _mc . tileset . tileWidth , this . _mc . tileset . tileHeight , this . layer ) ; <nl> <nl> Phaser . Component . Core . init . call ( this , game , 0 , 0 , null , null ) ; <nl> <nl> Phaser . TilemapLayerGL . prototype . destroy = function ( ) { <nl> * / <nl> Phaser . TilemapLayerGL . prototype . resize = function ( width , height ) { <nl> <nl> - this . texture . frame . resize ( width , height ) ; <nl> - <nl> - this . texture . width = width ; <nl> - this . texture . height = height ; <nl> - <nl> - this . texture . crop . width = width ; <nl> - this . texture . crop . height = height ; <nl> - <nl> - this . texture . baseTexture . width = width ; <nl> - this . texture . baseTexture . height = height ; <nl> - <nl> - this . texture . baseTexture . dirty ( ) ; <nl> - this . texture . requiresUpdate = true ; <nl> - <nl> - this . texture . _updateUvs ( ) ; <nl> - <nl> + this . displayWidth = width ; <nl> + this . displayHeight = height ; <nl> this . dirty = true ; <nl> - <nl> } ; <nl> <nl> / * * <nl>\n", "msg": "Send layer width / height to PIXI . Tilemap ( previously these were ignored and forgotten after the c ' tor ) .\n", "score": 1}
{"diff_id": 16214, "repo": "meteor/meteor\n", "sha": "be81dbdc3d1a42aa85f3fff878589b6d3b4a3cb5\n", "time": "2015-08-13T00:22:59Z\n", "diff": "mmm a / packages / meteor / dynamics_nodejs . js <nl> ppp b / packages / meteor / dynamics_nodejs . js <nl> Meteor . bindEnvironment = function ( func , onException , _this ) { <nl> / / note : callback - hook currently relies on the fact that if onException <nl> / / throws and you were originally calling the wrapped callback from <nl> / / within a Fiber , the wrapped call throws . <nl> - onException ( e ) ; <nl> + onException ( e . stack | | e . message ) ; <nl> } finally { <nl> Fiber . current . _meteor_dynamics = savedValues ; <nl> } <nl>\n", "msg": "Improved error reporting by adding stack trace to output\n", "score": 1}
{"diff_id": 16433, "repo": "meteor/meteor\n", "sha": "b7267b76a199ba651c3029b5ae7e30fba2f52d4f\n", "time": "2018-10-10T20:40:19Z\n", "diff": "mmm a / packages / standard - minifier - css / plugin / minify - css . js <nl> ppp b / packages / standard - minifier - css / plugin / minify - css . js <nl> var mergeCss = Profile ( \" mergeCss \" , function ( css ) { <nl> / / Add the contents of the input files to the source map of the new file <nl> stringifiedCss . map . sourcesContent = <nl> stringifiedCss . map . sources . map ( function ( filename ) { <nl> - return originals [ filename ] . getContentsAsString ( ) ; <nl> + const file = originals [ filename ] | | null ; <nl> + return file & & file . getContentsAsString ( ) ; <nl> } ) ; <nl> <nl> / / Compose the concatenated file ' s source map with source maps from the <nl>\n", "msg": "Use null for sourcesContent [ i ] if sources [ i ] unrecognized .\n", "score": 1}
{"diff_id": 16453, "repo": "mozilla/pdf.js\n", "sha": "f5a617a3341285b84655fe6cab8fa35acf12748e\n", "time": "2020-01-28T13:23:58Z\n", "diff": "mmm a / src / core / jpg . js <nl> ppp b / src / core / jpg . js <nl> var JpegImage = ( function JpegImageClosure ( ) { <nl> var node = tree ; <nl> while ( true ) { <nl> node = node [ readBit ( ) ] ; <nl> - if ( typeof node = = = \" number \" ) { <nl> - return node ; <nl> - } <nl> - if ( typeof node ! = = \" object \" ) { <nl> - throw new JpegError ( \" invalid huffman sequence \" ) ; <nl> + switch ( typeof node ) { <nl> + case \" number \" : <nl> + return node ; <nl> + case \" object \" : <nl> + continue ; <nl> } <nl> + throw new JpegError ( \" invalid huffman sequence \" ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Make the ` decodeHuffman ` function , in ` src / core / jpg . js ` , slightly more efficient\n", "score": 1}
{"diff_id": 16547, "repo": "Leaflet/Leaflet\n", "sha": "1f45ef73488612a941fb27e43305631b4407e529\n", "time": "2011-12-23T17:56:56Z\n", "diff": "mmm a / src / layer / tile / TileLayer . js <nl> ppp b / src / layer / tile / TileLayer . js <nl> L . TileLayer = L . Class . extend ( { <nl> continuousWorld : false , <nl> noWrap : false , <nl> zoomOffset : 0 , <nl> + zoomReverse : false , <nl> <nl> unloadInvisibleTiles : L . Browser . mobile , <nl> updateWhenIdle : L . Browser . mobile <nl> L . TileLayer = L . Class . extend ( { <nl> var tilePos = this . _getTilePos ( tilePoint ) , <nl> zoom = this . _map . getZoom ( ) , <nl> key = tilePoint . x + ' : ' + tilePoint . y , <nl> - tileLimit = Math . pow ( 2 , ( zoom + this . options . zoomOffset ) ) ; <nl> + tileLimit = Math . pow ( 2 , this . _getOffsetZoom ( zoom ) ) ; <nl> <nl> / / wrap tile coordinates <nl> if ( ! this . options . continuousWorld ) { <nl> L . TileLayer = L . Class . extend ( { <nl> <nl> container . appendChild ( tile ) ; <nl> } , <nl> + <nl> + _getOffsetZoom : function ( zoom ) { <nl> + if ( this . options . zoomReverse ) { <nl> + return ( this . options . maxZoom - zoom ) + this . options . zoomOffset ; <nl> + } else { <nl> + return zoom + this . options . zoomOffset ; <nl> + } <nl> + } , <nl> <nl> _getTilePos : function ( tilePoint ) { <nl> var origin = this . _map . getPixelOrigin ( ) , <nl> L . TileLayer = L . Class . extend ( { <nl> <nl> return L . Util . template ( this . _url , L . Util . extend ( { <nl> s : s , <nl> - z : zoom + this . options . zoomOffset , <nl> + z : this . _getOffsetZoom ( zoom ) , <nl> x : tilePoint . x , <nl> y : tilePoint . y <nl> } , this . _urlParams ) ) ; <nl>\n", "msg": "Added zoomInvert option to reverse the order in which zooms are numbered .\n", "score": 1}
{"diff_id": 16558, "repo": "balderdashy/sails\n", "sha": "7ef406915ff4b0655567a181ce76269cc2ea558b\n", "time": "2015-01-05T09:04:11Z\n", "diff": "mmm a / lib / hooks / views / consolidate . js <nl> ppp b / lib / hooks / views / consolidate . js <nl> module . exports = function ( sailsAppPath ) { <nl> if ( ! engine ) { <nl> var ECT = require ( sailsAppPath + ' / ect ' ) ; <nl> engine = requires . ect = new ECT ( { <nl> - root : sailsAppPath + \" / . . / views \" , <nl> + root : sails . config . paths . views , <nl> ext : \" . ect \" <nl> } ) ; <nl> } <nl>\n", "msg": "More correct root path for ect template engine .\n", "score": 1}
{"diff_id": 16590, "repo": "photonstorm/phaser\n", "sha": "7212945beacdc4bc23795688b1cc74b30e6acb92\n", "time": "2019-10-02T11:13:07Z\n", "diff": "mmm a / src / structs / ProcessQueue . js <nl> ppp b / src / structs / ProcessQueue . js <nl> <nl> * / <nl> <nl> var Class = require ( ' . . / utils / Class ' ) ; <nl> + var EventEmitter = require ( ' eventemitter3 ' ) ; <nl> + var Events = require ( ' . / events ' ) ; <nl> <nl> / * * <nl> * @ classdesc <nl> var Class = require ( ' . . / utils / Class ' ) ; <nl> * time , rather than at the time of the request from the API . <nl> * <nl> * @ class ProcessQueue <nl> + * @ extends Phaser . Events . EventEmitter <nl> * @ memberof Phaser . Structs <nl> * @ constructor <nl> * @ since 3 . 0 . 0 <nl> var Class = require ( ' . . / utils / Class ' ) ; <nl> * / <nl> var ProcessQueue = new Class ( { <nl> <nl> + Extends : EventEmitter , <nl> + <nl> initialize : <nl> <nl> function ProcessQueue ( ) <nl> { <nl> + EventEmitter . call ( this ) ; <nl> + <nl> / * * <nl> * The ` pending ` list is a selection of items which are due to be made ' active ' in the next update . <nl> * <nl> var ProcessQueue = new Class ( { <nl> <nl> / * * <nl> * Adds a new item to the Process Queue . <nl> + * <nl> * The item is added to the pending list and made active in the next update . <nl> * <nl> * @ method Phaser . Structs . ProcessQueue # add <nl> var ProcessQueue = new Class ( { <nl> * <nl> * @ param { * } item - The item to add to the queue . <nl> * <nl> - * @ return { Phaser . Structs . ProcessQueue } This Process Queue object . <nl> + * @ return { * } The item that was added . <nl> * / <nl> add : function ( item ) <nl> { <nl> var ProcessQueue = new Class ( { <nl> <nl> this . _toProcess + + ; <nl> <nl> - return this ; <nl> + return item ; <nl> } , <nl> <nl> / * * <nl> * Removes an item from the Process Queue . <nl> + * <nl> * The item is added to the pending destroy and fully removed in the next update . <nl> * <nl> * @ method Phaser . Structs . ProcessQueue # remove <nl> var ProcessQueue = new Class ( { <nl> * <nl> * @ param { * } item - The item to be removed from the queue . <nl> * <nl> - * @ return { Phaser . Structs . ProcessQueue } This Process Queue object . <nl> + * @ return { * } The item that was removed . <nl> * / <nl> remove : function ( item ) <nl> { <nl> var ProcessQueue = new Class ( { <nl> <nl> this . _toProcess + + ; <nl> <nl> + return item ; <nl> + } , <nl> + <nl> + / * * <nl> + * Removes all active items from this Process Queue . <nl> + * <nl> + * All the items are marked as ' pending destroy ' and fully removed in the next update . <nl> + * <nl> + * @ method Phaser . Structs . ProcessQueue # removeAll <nl> + * @ since 3 . 20 . 0 <nl> + * <nl> + * @ return { this } This Process Queue object . <nl> + * / <nl> + removeAll : function ( ) <nl> + { <nl> + var list = this . _active ; <nl> + var destroy = this . _destroy ; <nl> + var i = list . length ; <nl> + <nl> + while ( i - - ) <nl> + { <nl> + destroy . push ( list [ i ] ) ; <nl> + <nl> + this . _toProcess + + ; <nl> + } <nl> + <nl> return this ; <nl> } , <nl> <nl> var ProcessQueue = new Class ( { <nl> if ( idx ! = = - 1 ) <nl> { <nl> active . splice ( idx , 1 ) ; <nl> + <nl> + this . emit ( Events . REMOVE , item ) ; <nl> } <nl> } <nl> <nl> var ProcessQueue = new Class ( { <nl> item = list [ i ] ; <nl> <nl> this . _active . push ( item ) ; <nl> + <nl> + this . emit ( Events . ADD , item ) ; <nl> } <nl> <nl> list . length = 0 ; <nl> var ProcessQueue = new Class ( { <nl> <nl> / * * <nl> * Returns the current list of active items . <nl> + * <nl> + * This method returns a reference to the active list array , not a copy of it . <nl> + * Therefore , be careful to not modify this array outside of the ProcessQueue . <nl> * <nl> * @ method Phaser . Structs . ProcessQueue # getActive <nl> * @ since 3 . 0 . 0 <nl> var ProcessQueue = new Class ( { <nl> return this . _active ; <nl> } , <nl> <nl> + / * * <nl> + * The number of entries in the active list . <nl> + * <nl> + * @ name Phaser . Structs . ProcessQueue # length <nl> + * @ type { integer } <nl> + * @ readonly <nl> + * @ since 3 . 20 . 0 <nl> + * / <nl> + length : { <nl> + <nl> + get : function ( ) <nl> + { <nl> + return this . _active . length ; <nl> + } <nl> + <nl> + } , <nl> + <nl> / * * <nl> * Immediately destroys this process queue , clearing all of its internal arrays and resetting the process totals . <nl> * <nl>\n", "msg": "ProcessQueue now extends Event Emitter . Also added removeAll method and length getter .\n", "score": 1}
{"diff_id": 16655, "repo": "meteor/meteor\n", "sha": "58c3a355e4f5a5f7c4c076d66fa96b50296fc871\n", "time": "2014-10-07T22:55:50Z\n", "diff": "mmm a / tools / commands - packages . js <nl> ppp b / tools / commands - packages . js <nl> main . registerCommand ( { <nl> options : { <nl> maintainer : { type : String , required : false } , <nl> \" show - old \" : { type : Boolean , required : false } , <nl> - \" show - rcs \" : { type : Boolean , required : false } <nl> + \" show - rcs \" : { type : Boolean , required : false } , <nl> + / / Undocumented debug - only option for Velocity . <nl> + \" debug - only \" : { type : Boolean , required : false } <nl> } <nl> } , function ( options ) { <nl> <nl> main . registerCommand ( { <nl> var filterBroken = function ( match , isRelease , name ) { <nl> / / If the package does not match , or it is not a package at all or if we <nl> / / don ' t want to filter anyway , we do not care . <nl> - if ( ! match | | isRelease | | options [ \" show - old \" ] ) <nl> + if ( ! match | | isRelease ) <nl> return match ; <nl> var vr ; <nl> doOrDie ( function ( ) { <nl> main . registerCommand ( { <nl> vr = catalog . official . getLatestVersion ( name ) ; <nl> } <nl> } ) ; <nl> - return vr & & ! vr . unmigrated ; <nl> + if ( ! vr ) { <nl> + return false ; <nl> + } <nl> + / / If we did NOT ask for unmigrated packages and this package is unmigrated , <nl> + / / we don ' t care . <nl> + if ( ! options [ \" show - old \" ] & & vr . unmigrated ) { <nl> + return false ; <nl> + } <nl> + / / If we asked for debug - only packages and this package is NOT debug only , <nl> + / / we don ' t care . <nl> + if ( options [ \" debug - only \" ] & & ! vr . debugOnly ) { <nl> + return false ; <nl> + } <nl> + return true ; <nl> } ; <nl> <nl> if ( options . maintainer ) { <nl>\n", "msg": "allow velocity to search for debug - only packages\n", "score": 1}
{"diff_id": 16804, "repo": "adobe/brackets\n", "sha": "29a627bfefb276e5ceb68e9cdd481f40fa7898ee\n", "time": "2013-01-15T20:32:16Z\n", "diff": "mmm a / src / editor / MultiRangeInlineEditor . js <nl> ppp b / src / editor / MultiRangeInlineEditor . js <nl> define ( function ( require , exports , module ) { <nl> <nl> MultiRangeInlineEditor . prototype . $ editorsDiv = null ; <nl> MultiRangeInlineEditor . prototype . $ relatedContainer = null ; <nl> + MultiRangeInlineEditor . prototype . $ related = null ; <nl> MultiRangeInlineEditor . prototype . $ selectedMarker = null ; <nl> <nl> / * * @ type { Array . < SearchResultItem > } * / <nl> define ( function ( require , exports , module ) { <nl> / / Container to hold all editors <nl> var self = this ; <nl> <nl> - / / Bind event handlers <nl> - this . _ensureCursorVisible = this . _ensureCursorVisible . bind ( this ) ; <nl> - this . _onClick = this . _onClick . bind ( this ) ; <nl> - <nl> / / Create DOM to hold editors and related list <nl> this . $ editorsDiv = $ ( window . document . createElement ( \" div \" ) ) . addClass ( \" inlineEditorHolder \" ) ; <nl> <nl> / / Prevent touch scroll events from bubbling up to the parent editor . <nl> - this . $ editorsDiv . on ( \" mousewheel \" , function ( e ) { <nl> + this . $ editorsDiv . on ( \" mousewheel . MultiRangeInlineEditor \" , function ( e ) { <nl> e . stopPropagation ( ) ; <nl> } ) ; <nl> <nl> define ( function ( require , exports , module ) { <nl> this . $ selectedMarker = $ ( window . document . createElement ( \" div \" ) ) . appendTo ( this . $ relatedContainer ) . addClass ( \" selection \" ) ; <nl> <nl> / / Inner container <nl> - var $ related = $ ( window . document . createElement ( \" div \" ) ) . appendTo ( this . $ relatedContainer ) . addClass ( \" related \" ) ; <nl> + this . $ related = $ ( window . document . createElement ( \" div \" ) ) . appendTo ( this . $ relatedContainer ) . addClass ( \" related \" ) ; <nl> <nl> / / Range list <nl> - var $ rangeList = $ ( window . document . createElement ( \" ul \" ) ) . appendTo ( $ related ) ; <nl> + var $ rangeList = $ ( window . document . createElement ( \" ul \" ) ) . appendTo ( this . $ related ) ; <nl> <nl> / / create range list & add listeners for range textrange changes <nl> var rangeItemText ; <nl> define ( function ( require , exports , module ) { <nl> this . $ htmlContent . append ( this . $ relatedContainer ) . append ( this . $ editorsDiv ) ; <nl> <nl> / / Listen for clicks directly on us , so we can set focus back to the editor <nl> - this . $ htmlContent . on ( \" click \" , this . _onClick ) ; <nl> + this . $ htmlContent . on ( \" click . MultiRangeInlineEditor \" , this . _onClick . bind ( this ) ) ; <nl> } ; <nl> <nl> / * * <nl> * @ override <nl> * / <nl> MultiRangeInlineEditor . prototype . onAdded = function ( ) { <nl> + / / Before setting the inline widget height , force a height on the <nl> + / / floating related - container in order for CodeMirror to layout and <nl> + / / compute scrollbars <nl> + this . $ relatedContainer . height ( this . $ related . height ( ) ) ; <nl> + <nl> + / / Call super <nl> MultiRangeInlineEditor . prototype . parentClass . onAdded . apply ( this , arguments ) ; <nl> + <nl> + / / Editor must be at least as tall as the related list <nl> this . _updateEditorMinHeight ( ) ; <nl> + <nl> + / / Resize the widget when scrollbars are added <nl> + var _updateSize = this . _updateSize . bind ( this ) ; <nl> + $ ( window ) . on ( \" resize . MultiRangeInlineEditor \" , _updateSize ) ; <nl> + <nl> + / / Kick the layout again to redraw scrollbars after the related list <nl> + / / is floated . This is necessary because the related list may overlap <nl> + / / the editor ( s ) after the list is laid out by in sequence by ( 1 ) the <nl> + / / float within the inline - widget container and ( 2 ) by the host <nl> + / / editor ' s vertical scroll bar . <nl> + window . setTimeout ( _updateSize , 0 ) ; <nl> } ; <nl> <nl> / * * <nl> define ( function ( require , exports , module ) { <nl> * @ param { ! number } index The index of the range to select . <nl> * / <nl> MultiRangeInlineEditor . prototype . setSelectedIndex = function ( index ) { <nl> - var newIndex = Math . min ( Math . max ( 0 , index ) , this . _ranges . length - 1 ) ; <nl> + var newIndex = Math . min ( Math . max ( 0 , index ) , this . _ranges . length - 1 ) , <nl> + self = this ; <nl> <nl> if ( newIndex = = = this . _selectedRangeIndex ) { <nl> return ; <nl> define ( function ( require , exports , module ) { <nl> <nl> / / Remove previous editors <nl> this . editors . forEach ( function ( editor ) { <nl> + $ ( self . editors [ 0 ] ) . off ( \" . MultiRangeInlineEditor \" ) ; <nl> editor . destroy ( ) ; / / release ref on Document <nl> } ) ; <nl> <nl> define ( function ( require , exports , module ) { <nl> this . editors [ 0 ] . refresh ( ) ; <nl> <nl> / / Ensure the cursor position is visible in the host editor as the user is arrowing around . <nl> - $ ( this . editors [ 0 ] ) . on ( \" cursorActivity \" , this . _ensureCursorVisible ) ; <nl> + $ ( this . editors [ 0 ] ) . on ( \" cursorActivity . MultiRangeInlineEditor \" , this . _ensureCursorVisible . bind ( this ) ) ; <nl> <nl> / / ensureVisibility is set to false because we don ' t want to scroll the main editor when the user selects a view <nl> this . sizeInlineWidgetToContents ( true , false ) ; <nl> <nl> this . _updateSelectedMarker ( ) ; <nl> } ; <nl> + <nl> + / * * <nl> + * Resize the widget to handle adding / removing scrollbars <nl> + * / <nl> + MultiRangeInlineEditor . prototype . _updateSize = function ( ) { <nl> + this . sizeInlineWidgetToContents ( ) ; <nl> + } <nl> <nl> / * * <nl> * Ensures that the editor ' s min - height is set so it never gets shorter than the rule list . <nl> define ( function ( require , exports , module ) { <nl> MultiRangeInlineEditor . prototype . _updateEditorMinHeight = function ( ) { <nl> / / Set the scroller ' s min - height to the natural height of the rule list , so the editor <nl> / / always stays at least as tall as the rule list . <nl> - var ruleListNaturalHeight = $ ( \" ul \" , this . $ relatedContainer ) . outerHeight ( ) , <nl> + var ruleListNaturalHeight = this . $ related . outerHeight ( ) , <nl> headerHeight = $ ( \" . inline - editor - header \" , this . $ htmlContent ) . outerHeight ( ) ; <nl> <nl> / / If the widget isn ' t fully loaded yet , bail - - we ' ll get called again in onAdded ( ) . <nl> define ( function ( require , exports , module ) { <nl> MultiRangeInlineEditor . prototype . onClosed = function ( ) { <nl> / / Superclass onClosed ( ) destroys editor <nl> MultiRangeInlineEditor . prototype . parentClass . onClosed . apply ( this , arguments ) ; <nl> - <nl> - / / Remove event handlers <nl> - $ ( this . editors [ 0 ] ) . off ( \" cursorActivity \" , this . _ensureCursorVisible ) ; <nl> - <nl> + <nl> / / de - ref all the Documents in the search results <nl> this . _ranges . forEach ( function ( searchResult ) { <nl> searchResult . textRange . dispose ( ) ; <nl> } ) ; <nl> + <nl> + / / Remove event handlers <nl> + $ ( window ) . off ( \" . MultiRangeInlineEditor \" ) ; <nl> + this . $ htmlContent . off ( \" . MultiRangeInlineEditor \" ) ; <nl> + this . $ editorsDiv . off ( \" . MultiRangeInlineEditor \" ) ; <nl> } ; <nl> <nl> / * * <nl> define ( function ( require , exports , module ) { <nl> MultiRangeInlineEditor . prototype . parentClass . sizeInlineWidgetToContents . call ( this , force ) ; <nl> <nl> / / Size the widget height to the max between the editor content and the related ranges list <nl> - var widgetHeight = Math . max ( this . $ relatedContainer . find ( \" . related \" ) . height ( ) , this . $ editorsDiv . height ( ) ) ; <nl> - this . hostEditor . setInlineWidgetHeight ( this , widgetHeight , ensureVisibility ) ; <nl> + var widgetHeight = Math . max ( this . $ related . height ( ) , this . $ editorsDiv . height ( ) ) ; <nl> + <nl> + if ( widgetHeight ) { <nl> + this . hostEditor . setInlineWidgetHeight ( this , widgetHeight , ensureVisibility ) ; <nl> + } <nl> } ; <nl> <nl> / * * <nl>\n", "msg": "Kick the inline widget layout to render scrollbars when added\n", "score": 1}
{"diff_id": 16906, "repo": "photonstorm/phaser\n", "sha": "77ad6c66fe344b93bff76e79461555216679c45f\n", "time": "2019-12-08T23:23:15Z\n", "diff": "mmm a / src / tilemaps / mapdata / LayerData . js <nl> ppp b / src / tilemaps / mapdata / LayerData . js <nl> var LayerData = new Class ( { <nl> * An array of the tile indexes <nl> * <nl> * @ name Phaser . Tilemaps . LayerData # data <nl> - * @ type { ( number [ ] ) } <nl> + * @ type { Array . < Array . < Phaser . Tilemaps . Tile > > } <nl> * @ since 3 . 0 . 0 <nl> * / <nl> this . data = GetFastValue ( config , ' data ' , [ ] ) ; <nl>\n", "msg": "Correct type for Phaser . Tilemaps . LayerData # data\n", "score": 1}
{"diff_id": 17418, "repo": "codemirror/CodeMirror\n", "sha": "f55cf1888af6e1ccaf9fdf5cf659399bb36e18f4\n", "time": "2014-01-23T14:13:58Z\n", "diff": "mmm a / lib / codemirror . js <nl> ppp b / lib / codemirror . js <nl> window . CodeMirror = ( function ( ) { <nl> / / Used for measuring wheel scrolling granularity <nl> d . wheelDX = d . wheelDY = d . wheelStartX = d . wheelStartY = null ; <nl> <nl> + d . shift = false ; <nl> + <nl> return d ; <nl> } <nl> <nl> window . CodeMirror = ( function ( ) { <nl> <nl> var withOp = ! cm . curOp ; <nl> if ( withOp ) startOperation ( cm ) ; <nl> - sel . shift = false ; <nl> + cm . display . shift = false ; <nl> var same = 0 , l = Math . min ( prevInput . length , text . length ) ; <nl> while ( same < l & & prevInput . charCodeAt ( same ) = = text . charCodeAt ( same ) ) + + same ; <nl> var from = sel . from , to = sel . to ; <nl> window . CodeMirror = ( function ( ) { <nl> <nl> on ( d . input , \" keyup \" , operation ( cm , function ( e ) { <nl> if ( signalDOMEvent ( cm , e ) | | cm . options . onKeyEvent & & cm . options . onKeyEvent ( cm , addStop ( e ) ) ) return ; <nl> - if ( e . keyCode = = 16 ) cm . doc . sel . shift = false ; <nl> + if ( e . keyCode = = 16 ) cm . display . shift = false ; <nl> } ) ) ; <nl> on ( d . input , \" input \" , function ( ) { <nl> if ( ie & & ! ie_lt9 & & cm . display . inputHasSelection ) cm . display . inputHasSelection = null ; <nl> window . CodeMirror = ( function ( ) { <nl> function onMouseDown ( e ) { <nl> if ( signalDOMEvent ( this , e ) ) return ; <nl> var cm = this , display = cm . display , doc = cm . doc , sel = doc . sel ; <nl> - sel . shift = e . shiftKey ; <nl> + display . shift = e . shiftKey ; <nl> <nl> if ( eventInWidget ( display , e ) ) { <nl> if ( ! webkit ) { <nl> window . CodeMirror = ( function ( ) { <nl> / / Ensure previous input has been read , so that the handler sees a <nl> / / consistent view of the document <nl> if ( cm . display . pollingFast & & readInput ( cm ) ) cm . display . pollingFast = false ; <nl> - var doc = cm . doc , prevShift = doc . sel . shift , done = false ; <nl> + var prevShift = cm . display . shift , done = false ; <nl> try { <nl> if ( isReadOnly ( cm ) ) cm . state . suppressEdits = true ; <nl> - if ( dropShift ) doc . sel . shift = false ; <nl> + if ( dropShift ) cm . display . shift = false ; <nl> done = bound ( cm ) ! = Pass ; <nl> } finally { <nl> - doc . sel . shift = prevShift ; <nl> + cm . display . shift = prevShift ; <nl> cm . state . suppressEdits = false ; <nl> } <nl> return done ; <nl> window . CodeMirror = ( function ( ) { <nl> if ( old_ie & & e . keyCode = = 27 ) e . returnValue = false ; <nl> var code = e . keyCode ; <nl> / / IE does strange things with escape . <nl> - cm . doc . sel . shift = code = = 16 | | e . shiftKey ; <nl> + cm . display . shift = code = = 16 | | e . shiftKey ; <nl> / / First give onKeyEvent option a chance to handle this . <nl> var handled = handleKeyBinding ( cm , e ) ; <nl> if ( opera ) { <nl> window . CodeMirror = ( function ( ) { <nl> cm . display . wrapper . className = cm . display . wrapper . className . replace ( \" CodeMirror - focused \" , \" \" ) ; <nl> } <nl> clearInterval ( cm . display . blinker ) ; <nl> - setTimeout ( function ( ) { if ( ! cm . state . focused ) cm . doc . sel . shift = false ; } , 150 ) ; <nl> + setTimeout ( function ( ) { if ( ! cm . state . focused ) cm . display . shift = false ; } , 150 ) ; <nl> } <nl> <nl> var detectingSelectAll ; <nl> window . CodeMirror = ( function ( ) { <nl> / / If shift is held , this will move the selection anchor . Otherwise , <nl> / / it ' ll set the whole selection . <nl> function extendSelection ( doc , pos , other , bias ) { <nl> - if ( doc . sel . shift | | doc . sel . extend ) { <nl> + if ( doc . cm & & doc . cm . display . shift | | doc . extend ) { <nl> var anchor = doc . sel . anchor ; <nl> if ( other ) { <nl> var posBefore = posLess ( pos , anchor ) ; <nl> window . CodeMirror = ( function ( ) { <nl> <nl> moveH : operation ( null , function ( dir , unit ) { <nl> var sel = this . doc . sel , pos ; <nl> - if ( sel . shift | | sel . extend | | posEq ( sel . from , sel . to ) ) <nl> + if ( this . shift | | this . doc . extend | | posEq ( sel . from , sel . to ) ) <nl> pos = findPosH ( this . doc , sel . head , dir , unit , this . options . rtlMoveVisually ) ; <nl> else <nl> pos = dir < 0 ? sel . from : sel . to ; <nl> window . CodeMirror = ( function ( ) { <nl> this . cleanGeneration = 1 ; <nl> this . frontier = firstLine ; <nl> var start = Pos ( firstLine , 0 ) ; <nl> - this . sel = { from : start , to : start , head : start , anchor : start , shift : false , extend : false , goalColumn : null } ; <nl> + this . sel = { from : start , to : start , head : start , anchor : start , goalColumn : null } ; <nl> this . id = + + nextDocId ; <nl> this . modeOption = mode ; <nl> <nl> window . CodeMirror = ( function ( ) { <nl> undo : docOperation ( function ( ) { makeChangeFromHistory ( this , \" undo \" ) ; } ) , <nl> redo : docOperation ( function ( ) { makeChangeFromHistory ( this , \" redo \" ) ; } ) , <nl> <nl> - setExtending : function ( val ) { this . sel . extend = val ; } , <nl> + setExtending : function ( val ) { this . extend = val ; } , <nl> <nl> historySize : function ( ) { <nl> var hist = this . history ; <nl> window . CodeMirror = ( function ( ) { <nl> var doc = new Doc ( getLines ( this , this . first , this . first + this . size ) , this . modeOption , this . first ) ; <nl> doc . scrollTop = this . scrollTop ; doc . scrollLeft = this . scrollLeft ; <nl> doc . sel = { from : this . sel . from , to : this . sel . to , head : this . sel . head , anchor : this . sel . anchor , <nl> - shift : this . sel . shift , extend : false , goalColumn : this . sel . goalColumn } ; <nl> + goalColumn : this . sel . goalColumn } ; <nl> + doc . extend = false ; <nl> if ( copyHistory ) { <nl> doc . history . undoDepth = this . history . undoDepth ; <nl> doc . setHistory ( this . getHistory ( ) ) ; <nl>\n", "msg": "Move extend and shift flags out of selection objects\n", "score": 1}
{"diff_id": 17525, "repo": "vuejs/vue\n", "sha": "d237aabc263110ab1eb89c5f9b4a64f8633620d3\n", "time": "2016-06-02T18:53:38Z\n", "diff": "mmm a / src / platforms / web / runtime / modules / transition . js <nl> ppp b / src / platforms / web / runtime / modules / transition . js <nl> export function enter ( vnode : VNodeWithData ) { <nl> } <nl> <nl> const { <nl> + css , <nl> enterClass , <nl> enterActiveClass , <nl> beforeEnter , <nl> export function enter ( vnode : VNodeWithData ) { <nl> enterCancelled <nl> } = resolveTransition ( data . definition , vnode . context ) <nl> <nl> + const expectsCSS = css ! = = false <nl> const userWantsControl = enter & & enter . length > 1 <nl> const cb = el . _enterCb = once ( ( ) = > { <nl> if ( enterActiveClass ) { <nl> export function enter ( vnode : VNodeWithData ) { <nl> } ) <nl> <nl> beforeEnter & & beforeEnter ( el ) <nl> - if ( enterClass ) { <nl> + if ( enterClass & & expectsCSS ) { <nl> addTransitionClass ( el , enterClass ) <nl> nextFrame ( ( ) = > { <nl> removeTransitionClass ( el , enterClass ) <nl> } ) <nl> } <nl> - if ( enterActiveClass ) { <nl> + if ( enterActiveClass & & expectsCSS ) { <nl> nextFrame ( ( ) = > { <nl> if ( ! cb . cancelled ) { <nl> addTransitionClass ( el , enterActiveClass ) <nl> export function enter ( vnode : VNodeWithData ) { <nl> } ) <nl> } <nl> enter & & enter ( el , cb ) <nl> - if ( ! enterActiveClass & & ! userWantsControl ) { <nl> + if ( ( ! expectsCSS | | ! enterActiveClass ) & & ! userWantsControl ) { <nl> cb ( ) <nl> } <nl> } <nl> export function leave ( vnode : VNodeWithData , rm : Function ) { <nl> } <nl> <nl> const { <nl> + css , <nl> leaveClass , <nl> leaveActiveClass , <nl> beforeLeave , <nl> export function leave ( vnode : VNodeWithData , rm : Function ) { <nl> leaveCancelled <nl> } = resolveTransition ( data . definition , vnode . context ) <nl> <nl> + const expectsCSS = css ! = = false <nl> const userWantsControl = leave & & leave . length > 1 <nl> const cb = el . _leaveCb = once ( ( ) = > { <nl> if ( leaveActiveClass ) { <nl> export function leave ( vnode : VNodeWithData , rm : Function ) { <nl> } ) <nl> <nl> beforeLeave & & beforeLeave ( el ) <nl> - if ( leaveClass ) { <nl> + if ( leaveClass & & expectsCSS ) { <nl> addTransitionClass ( el , leaveClass ) <nl> nextFrame ( ( ) = > { <nl> removeTransitionClass ( el , leaveClass ) <nl> } ) <nl> } <nl> - if ( leaveActiveClass ) { <nl> + if ( leaveActiveClass & & expectsCSS ) { <nl> nextFrame ( ( ) = > { <nl> if ( ! cb . cancelled ) { <nl> addTransitionClass ( el , leaveActiveClass ) <nl> export function leave ( vnode : VNodeWithData , rm : Function ) { <nl> } ) <nl> } <nl> leave & & leave ( el , cb ) <nl> - if ( ! leaveActiveClass & & ! userWantsControl ) { <nl> + if ( ( ! expectsCSS | | ! leaveActiveClass ) & & ! userWantsControl ) { <nl> cb ( ) <nl> } <nl> } <nl>\n", "msg": "do not add css classes if a transition has css : false\n", "score": 1}
{"diff_id": 17596, "repo": "request/request\n", "sha": "6f5801702eba45897cfa8ffc540b2ea724a318de\n", "time": "2014-10-01T16:50:34Z\n", "diff": "mmm a / request . js <nl> ppp b / request . js <nl> Request . prototype . multipart = function ( multipart ) { <nl> <nl> multipart . forEach ( function ( part ) { <nl> var body = part . body <nl> - if ( typeof body = = = ' undefined ' ) throw Error ( ' Body attribute missing in multipart . ' ) <nl> + if ( typeof body = = = ' undefined ' ) throw new Error ( ' Body attribute missing in multipart . ' ) <nl> delete part . body <nl> var preamble = ' - - ' + self . boundary + ' \\ r \\ n ' <nl> Object . keys ( part ) . forEach ( function ( key ) { <nl> Request . defaultProxyHeaderWhiteList = <nl> defaultProxyHeaderWhiteList . slice ( ) <nl> <nl> <nl> - module . exports = Request <nl> \\ No newline at end of file <nl> + module . exports = Request <nl>\n", "msg": "Missing ` new ` operator when creating and throwing a new error\n", "score": 1}
{"diff_id": 17678, "repo": "balderdashy/sails\n", "sha": "b88c3ba787129ac690b9c81c93a3d49482adcdfd\n", "time": "2017-11-04T19:57:22Z\n", "diff": "mmm a / lib / app / lift . js <nl> ppp b / lib / app / lift . js <nl> module . exports = function lift ( configOverride , done ) { <nl> done = done | | function defaultCallback ( err ) { <nl> if ( err ) { <nl> sails . log . error ( ' Failed to lift app : ' , err ) ; <nl> - sails . log . error ( ' ( You are seeing the above error message because no custom callback was programmatically provided to ` . lift ( ) ` . ) ' ) ; <nl> + sails . log . silly ( ' ( You are seeing the above error message because no custom callback was programmatically provided to ` . lift ( ) ` . ) ' ) ; <nl> return ; <nl> } <nl> <nl>\n", "msg": "Change ' lift failed ' message suffix to only log in ' silly ' mode , to avoid confusion\n", "score": 1}
{"diff_id": 17694, "repo": "photonstorm/phaser\n", "sha": "0c5438038dc4ef77c737969cde9a7ccf4fe9d77f\n", "time": "2014-10-10T19:35:50Z\n", "diff": "mmm a / src / core / ScaleManager . js <nl> ppp b / src / core / ScaleManager . js <nl> Phaser . ScaleManager . prototype = { <nl> else if ( this . _scaleMode = = = Phaser . ScaleManager . EXACT_FIT | | this . _scaleMode = = = Phaser . ScaleManager . SHOW_ALL ) <nl> { <nl> this . refresh ( ) ; <nl> - this . checkOrientationState ( ) ; <nl> <nl> if ( this . onResize ) <nl> { <nl> Phaser . ScaleManager . prototype = { <nl> } <nl> } <nl> <nl> + this . checkOrientationState ( ) ; <nl> + <nl> } , <nl> <nl> / * * <nl>\n", "msg": "Allowed the orientation checks to still work when using RESIZE scale mode .\n", "score": 1}
{"diff_id": 17875, "repo": "TryGhost/Ghost\n", "sha": "208b710677c633cc6a84304c858d215613a84c03\n", "time": "2019-11-13T10:36:19Z\n", "diff": "mmm a / core / server / services / bulk - email / index . js <nl> ppp b / core / server / services / bulk - email / index . js <nl> module . exports = { <nl> from : fromAddress , <nl> ' recipient - variables ' : recipientData <nl> } ) ; <nl> + <nl> + if ( config . mailgun . tag ) { <nl> + Object . assign ( messageData , { <nl> + ' o : tag ' : config . mailgun . tag <nl> + } ) ; <nl> + } <nl> + <nl> await mailgunInstance . messages ( ) . send ( messageData ) ; <nl> } catch ( err ) { <nl> common . logging . error ( { err } ) ; <nl>\n", "msg": "Added tagging support to bul email service ( )\n", "score": 1}
{"diff_id": 17949, "repo": "preactjs/preact\n", "sha": "960116d2d357e7d9eb96aac71d66b3842fa7f6ca\n", "time": "2016-02-12T01:29:48Z\n", "diff": "mmm a / src / component . js <nl> ppp b / src / component . js <nl> export default function Component ( props , context ) { <nl> / * * @ private * / <nl> this . _renderCallbacks = [ ] ; <nl> / * * @ public * / <nl> - this . prevState = this . prevProps = this . prevContext = this . base = null ; <nl> + this . prevState = this . prevProps = this . prevContext = this . base = this . _parentComponent = this . _component = null ; <nl> / * * @ public * / <nl> this . context = context | | null ; <nl> / * * @ type { object } * / <nl>\n", "msg": "Avoid shape mutation by adding ref properties to Component in the constructor\n", "score": 1}
{"diff_id": 18088, "repo": "photonstorm/phaser\n", "sha": "5c118a3a94764fda517945367e5cf25bed5bcddc\n", "time": "2018-01-17T13:10:03Z\n", "diff": "mmm a / src / loader / filetypes / HTML5AudioFile . js <nl> ppp b / src / loader / filetypes / HTML5AudioFile . js <nl> var HTML5AudioFile = new Class ( { <nl> for ( var i = 0 ; i < instances ; i + + ) <nl> { <nl> var audio = new Audio ( ) ; <nl> - audio . name = this . key + ( ' 0 ' + i ) . slice ( - 2 ) ; / / Useful for debugging <nl> + audio . dataset . name = this . key + ( ' 0 ' + i ) . slice ( - 2 ) ; / / Useful for debugging <nl> audio . dataset . used = ' false ' ; <nl> <nl> if ( ! touchLocked ) <nl>\n", "msg": "audio tag does not support name attribute so setting that value to dataset\n", "score": 1}
{"diff_id": 18168, "repo": "meteor/meteor\n", "sha": "567e620a867a5e34188024d3175d4cc9dedaff3b\n", "time": "2018-04-19T14:12:23Z\n", "diff": "mmm a / packages / mongo / mongo_driver . js <nl> ppp b / packages / mongo / mongo_driver . js <nl> MongoConnection = function ( url , options ) { <nl> <nl> / / Use the internal ` s ` object to get the database name from the <nl> / / connection URL ( parsed by the driver ) . <nl> - var db = client . db ( client . s . options . dbName ) ; <nl> + var db = client . db ( <nl> + client . s . databaseName | | <nl> + / / An older way of getting the name , supported as a fallback . <nl> + client . s . options . dbName <nl> + ) ; <nl> <nl> / / First , figure out what the current primary is , if any . <nl> if ( db . serverConfig . isMasterDoc ) { <nl>\n", "msg": "Prefer client . s . databaseName over client . s . options . dbName .\n", "score": 1}
{"diff_id": 18231, "repo": "ajaxorg/ace\n", "sha": "142fc79c97e1f711ce73d82fe12fa74f9fe5bce6\n", "time": "2014-01-23T17:43:39Z\n", "diff": "mmm a / lib / ace / mode / behaviour / coldfusion . js <nl> ppp b / lib / ace / mode / behaviour / coldfusion . js <nl> var CfmlBehaviour = function ( ) { <nl> var iterator = new TokenIterator ( session , position . row , position . column ) ; <nl> var token = iterator . getCurrentToken ( ) ; <nl> <nl> - if ( token & & hasType ( token , ' meta . tag . name ' ) & & token . value . match ( / cfelse | cfset | cfapplication | cfabort | cfdump | cfargument | cfproperty | cfinvokeargument | cfqueryparam | cfprocparam / gi ) ! = = null ) <nl> + if ( token & & hasType ( token , ' meta . tag . name ' ) & & token . value . match ( / cfabort | cfapplication | cfargument | cfassociate | cfbreak | cfcache | cfcollection | cfcookie | cfdbinfo | cfdirectory | cfdump | cfelse | cfelseif | cferror | cfexchangecalendar | cfexchangeconnection | cfexchangecontact | cfexchangefilter | cfexchangetask | cfexit | cffeed | cffile | cfflush | cfftp | cfheader | cfhtmlhead | cfhttpparam | cfimage | cfimport | cfinclude | cfindex | cfinsert | cfinvokeargument | cflocation | cflog | cfmailparam | cfNTauthenticate | cfobject | cfobjectcache | cfparam | cfpdfformparam | cfprint | cfprocparam | cfprocresult | cfproperty | cfqueryparam | cfregistry | cfreportparam | cfrethrow | cfreturn | cfschedule | cfsearch | cfset | cfsetting | cfthrow | cfzipparam / gi ) ! = = null ) <nl> return ; <nl> if ( hasType ( token , ' string ' ) & & iterator . getCurrentTokenColumn ( ) + token . value . length > position . column ) <nl> return ; <nl> var CfmlBehaviour = function ( ) { <nl> } else { <nl> atCursor = true ; <nl> } <nl> - if ( ! token | | ! hasType ( token , ' meta . tag - name ' ) | | iterator . stepBackward ( ) . value . match ( ' / ' ) ) { <nl> + if ( ! token | | ! hasType ( token , ' meta . tag . name ' ) | | iterator . stepBackward ( ) . value . match ( ' / ' ) ) { <nl> return <nl> } <nl> var element = token . value ; <nl>\n", "msg": "Fixed token name and added to self - closing tags list\n", "score": 1}
{"diff_id": 18263, "repo": "preactjs/preact\n", "sha": "1c76091304c455986d08cfd006fae15861118cad\n", "time": "2016-06-06T02:49:33Z\n", "diff": "mmm a / src / vdom / component . js <nl> ppp b / src / vdom / component . js <nl> export function renderComponent ( component , opts , mountAll ) { <nl> * / <nl> export function buildComponentFromVNode ( dom , vnode , context , mountAll ) { <nl> let c = dom & & dom . _component , <nl> - oldDom = dom ; <nl> - <nl> - let isOwner = c & & dom . _componentConstructor = = = vnode . nodeName ; <nl> + oldDom = dom , <nl> + isDirectOwner = c & & dom . _componentConstructor = = = vnode . nodeName , <nl> + isOwner = isDirectOwner ; <nl> while ( c & & ! isOwner & & ( c = c . _parentComponent ) ) { <nl> isOwner = c . constructor = = = vnode . nodeName ; <nl> } <nl> export function buildComponentFromVNode ( dom , vnode , context , mountAll ) { <nl> dom = c . base ; <nl> } <nl> else { <nl> - if ( c ) { <nl> + if ( c & & ! isDirectOwner ) { <nl> unmountComponent ( c , true ) ; <nl> dom = oldDom = null ; <nl> } <nl>\n", "msg": "Check nesting ownership when attempting to unmount HOC ' s . / cc @ kruczy @ zhenkunou\n", "score": 1}
{"diff_id": 18587, "repo": "emberjs/ember.js\n", "sha": "d1f6e712d929b14da07b5f88d305797dc43a0bf6\n", "time": "2017-03-23T21:46:35Z\n", "diff": "mmm a / packages / ember / tests / homepage_example_test . js <nl> ppp b / packages / ember / tests / homepage_example_test . js <nl> <nl> import { Route } from ' ember - routing ' ; <nl> - import { run , computed } from ' ember - metal ' ; <nl> - import { Application } from ' ember - application ' ; <nl> + import { computed } from ' ember - metal ' ; <nl> import { Object as EmberObject , A as emberA } from ' ember - runtime ' ; <nl> - import { compile } from ' ember - template - compiler ' ; <nl> - import { jQuery } from ' ember - views ' ; <nl> - import { setTemplates , setTemplate } from ' ember - glimmer ' ; <nl> <nl> - let App , $ fixture ; <nl> + import { moduleFor , ApplicationTestCase } from ' internal - test - helpers ' ; <nl> <nl> - function setupExample ( ) { <nl> - / / setup templates <nl> - setTemplate ( ' application ' , compile ( ' { { outlet } } ' ) ) ; <nl> - setTemplate ( ' index ' , compile ( ' < h1 > People < / h1 > < ul > { { # each model as | person | } } < li > Hello , < b > { { person . fullName } } < / b > ! < / li > { { / each } } < / ul > ' ) ) ; <nl> + moduleFor ( ' The example renders correctly ' , class extends ApplicationTestCase { <nl> + [ ' @ test Render index template into application outlet ' ] ( assert ) { <nl> + this . addTemplate ( ' application ' , ' { { outlet } } ' ) ; <nl> + this . addTemplate ( ' index ' , ' < h1 > People < / h1 > < ul > { { # each model as | person | } } < li > Hello , < b > { { person . fullName } } < / b > ! < / li > { { / each } } < / ul > ' ) ; <nl> <nl> - App . Person = EmberObject . extend ( { <nl> - firstName : null , <nl> - lastName : null , <nl> - <nl> - fullName : computed ( ' firstName ' , ' lastName ' , function ( ) { <nl> - return this . get ( ' firstName ' ) + ' ' + this . get ( ' lastName ' ) ; <nl> - } ) <nl> - } ) ; <nl> - <nl> - App . IndexRoute = Route . extend ( { <nl> - model ( ) { <nl> - let people = emberA ( [ <nl> - App . Person . create ( { <nl> - firstName : ' Tom ' , <nl> - lastName : ' Dale ' <nl> - } ) , <nl> - App . Person . create ( { <nl> - firstName : ' Yehuda ' , <nl> - lastName : ' Katz ' <nl> - } ) <nl> - ] ) ; <nl> - return people ; <nl> - } <nl> - } ) ; <nl> - } <nl> - <nl> - QUnit . module ( ' Homepage Example ' , { <nl> - setup ( ) { <nl> - run ( ( ) = > { <nl> - App = Application . create ( { <nl> - name : ' App ' , <nl> - rootElement : ' # qunit - fixture ' <nl> - } ) ; <nl> - App . deferReadiness ( ) ; <nl> - <nl> - App . Router . reopen ( { <nl> - location : ' none ' <nl> - } ) ; <nl> - <nl> - App . LoadingRoute = Route . extend ( ) ; <nl> + let Person = EmberObject . extend ( { <nl> + firstName : null , <nl> + lastName : null , <nl> + fullName : computed ( ' firstName ' , ' lastName ' , function ( ) { <nl> + return ` $ { this . get ( ' firstName ' ) } $ { this . get ( ' lastName ' ) } ` ; <nl> + } ) <nl> } ) ; <nl> <nl> - $ fixture = jQuery ( ' # qunit - fixture ' ) ; <nl> - setupExample ( ) ; <nl> - } , <nl> - <nl> - teardown ( ) { <nl> - run ( ( ) = > App . destroy ( ) ) ; <nl> - <nl> - App = null ; <nl> - <nl> - setTemplates ( { } ) ; <nl> + this . add ( ' route : index ' , Route . extend ( { <nl> + model ( ) { <nl> + return emberA ( [ <nl> + Person . create ( { firstName : ' Tom ' , lastName : ' Dale ' } ) , <nl> + Person . create ( { firstName : ' Yehuda ' , lastName : ' Katz ' } ) <nl> + ] ) ; <nl> + } <nl> + } ) ) ; <nl> + <nl> + return this . visit ( ' / ' ) . then ( ( ) = > { <nl> + let $ = this . $ ( ) ; <nl> + <nl> + assert . equal ( $ . find ( ' h1 : contains ( People ) ' ) . length , 1 ) ; <nl> + assert . equal ( $ . find ( ' li ' ) . length , 2 ) ; <nl> + assert . equal ( $ . find ( ' li : nth - of - type ( 1 ) ' ) . text ( ) , ' Hello , Tom Dale ! ' ) ; <nl> + assert . equal ( $ . find ( ' li : nth - of - type ( 2 ) ' ) . text ( ) , ' Hello , Yehuda Katz ! ' ) ; <nl> + } ) ; <nl> } <nl> } ) ; <nl> - <nl> - <nl> - QUnit . test ( ' The example renders correctly ' , function ( ) { <nl> - run ( App , ' advanceReadiness ' ) ; <nl> - <nl> - equal ( $ fixture . find ( ' h1 : contains ( People ) ' ) . length , 1 ) ; <nl> - equal ( $ fixture . find ( ' li ' ) . length , 2 ) ; <nl> - equal ( $ fixture . find ( ' li : nth - of - type ( 1 ) ' ) . text ( ) , ' Hello , Tom Dale ! ' ) ; <nl> - equal ( $ fixture . find ( ' li : nth - of - type ( 2 ) ' ) . text ( ) , ' Hello , Yehuda Katz ! ' ) ; <nl> - } ) ; <nl>\n", "msg": "Decouple test from the default resolver for homepage_example_test . js\n", "score": 1}
{"diff_id": 18588, "repo": "photonstorm/phaser\n", "sha": "e0f2b829f87567e3ccfb31bae17f12d802dddaf4\n", "time": "2019-03-07T12:32:32Z\n", "diff": "mmm a / src / scale / ScaleManager . js <nl> ppp b / src / scale / ScaleManager . js <nl> var ScaleManager = new Class ( { <nl> * <nl> * If the browser does not support this , a ` FULLSCREEN_UNSUPPORTED ` event will be emitted . <nl> * <nl> - * This method _must_ be called from a user - input gesture , such as ` pointerdown ` . You cannot launch <nl> + * This method _must_ be called from a user - input gesture , such as ` pointerup ` . You cannot launch <nl> * games fullscreen without this , as most browsers block it . Games within an iframe will also be blocked <nl> * from fullscreen unless the iframe has the ` allowfullscreen ` attribute . <nl> * <nl> + * On touch devices , such as Android and iOS Safari , you should always use ` pointerup ` and NOT ` pointerdown ` , <nl> + * otherwise the request will fail unless the document in which your game is embedded has already received <nl> + * some form of touch input , which you cannot guarantee . Activating fullscreen via ` pointerup ` circumvents <nl> + * this issue . <nl> + * <nl> * Performing an action that navigates to another page , or opens another tab , will automatically cancel <nl> - * fullscreen mode , as will the user pressing the ESC key . To cancel fullscreen mode from your game , i . e . <nl> - * from clicking an icon , call the ` stopFullscreen ` method . <nl> + * fullscreen mode , as will the user pressing the ESC key . To cancel fullscreen mode directly from your game , <nl> + * i . e . by clicking an icon , call the ` stopFullscreen ` method . <nl> * <nl> * A browser can only send one DOM element into fullscreen . You can control which element this is by <nl> * setting the ` fullscreenTarget ` property in your game config , or changing the property in the Scale Manager . <nl> var ScaleManager = new Class ( { <nl> * <nl> * @ method Phaser . Scale . ScaleManager # startFullscreen <nl> * @ fires Phaser . Scale . Events # ENTER_FULLSCREEN <nl> + * @ fires Phaser . Scale . Events # FULLSCREEN_FAILED <nl> * @ fires Phaser . Scale . Events # FULLSCREEN_UNSUPPORTED <nl> * @ fires Phaser . Scale . Events # RESIZE <nl> * @ since 3 . 16 . 0 <nl> var ScaleManager = new Class ( { <nl> var fsTarget = this . getFullscreenTarget ( ) ; <nl> <nl> this . _requestedFullscreenChange = true ; <nl> - <nl> - if ( fullscreen . keyboard ) <nl> + <nl> + if ( typeof Promise ! = = ' undefined ' ) <nl> { <nl> - fsTarget [ fullscreen . request ] ( Element . ALLOW_KEYBOARD_INPUT ) ; <nl> + if ( fullscreen . keyboard ) <nl> + { <nl> + / / eslint - disable - next - line es5 / no - arrow - functions <nl> + fsTarget [ fullscreen . request ] ( Element . ALLOW_KEYBOARD_INPUT ) . then ( ( ) = > this . fullscreenSuccessHandler ( ) ) . catch ( ( error ) = > this . fullscreenErrorHandler ( error ) ) ; <nl> + } <nl> + else <nl> + { <nl> + / / eslint - disable - next - line es5 / no - arrow - functions <nl> + fsTarget [ fullscreen . request ] ( fullscreenOptions ) . then ( ( ) = > this . fullscreenSuccessHandler ( ) ) . catch ( ( error ) = > this . fullscreenErrorHandler ( error ) ) ; <nl> + } <nl> } <nl> else <nl> { <nl> - fsTarget [ fullscreen . request ] ( fullscreenOptions ) ; <nl> + if ( fullscreen . keyboard ) <nl> + { <nl> + fsTarget [ fullscreen . request ] ( Element . ALLOW_KEYBOARD_INPUT ) ; <nl> + } <nl> + else <nl> + { <nl> + fsTarget [ fullscreen . request ] ( fullscreenOptions ) ; <nl> + } <nl> + <nl> + if ( fullscreen . active ) <nl> + { <nl> + this . fullscreenSuccessHandler ( ) ; <nl> + } <nl> + else <nl> + { <nl> + this . fullscreenErrorHandler ( ) ; <nl> + } <nl> } <nl> + } <nl> + } , <nl> <nl> - this . getParentBounds ( ) ; <nl> + / * * <nl> + * The browser has successfully entered fullscreen mode . <nl> + * <nl> + * @ method Phaser . Scale . ScaleManager # fullscreenSuccessHandler <nl> + * @ private <nl> + * @ fires Phaser . Scale . Events # ENTER_FULLSCREEN <nl> + * @ fires Phaser . Scale . Events # RESIZE <nl> + * @ since 3 . 17 . 0 <nl> + * / <nl> + fullscreenSuccessHandler : function ( ) <nl> + { <nl> + this . getParentBounds ( ) ; <nl> <nl> - this . refresh ( ) ; <nl> + this . refresh ( ) ; <nl> <nl> - this . emit ( Events . ENTER_FULLSCREEN ) ; <nl> - } <nl> + this . emit ( Events . ENTER_FULLSCREEN ) ; <nl> + } , <nl> + <nl> + / * * <nl> + * The browser failed to enter fullscreen mode . <nl> + * <nl> + * @ method Phaser . Scale . ScaleManager # fullscreenErrorHandler <nl> + * @ private <nl> + * @ fires Phaser . Scale . Events # FULLSCREEN_FAILED <nl> + * @ fires Phaser . Scale . Events # RESIZE <nl> + * @ since 3 . 17 . 0 <nl> + * <nl> + * @ param { any } error - The DOM error event . <nl> + * / <nl> + fullscreenErrorHandler : function ( error ) <nl> + { <nl> + this . removeFullscreenTarget ( ) ; <nl> + <nl> + this . emit ( Events . FULLSCREEN_FAILED , error ) ; <nl> } , <nl> <nl> / * * <nl> var ScaleManager = new Class ( { <nl> return this . fullscreenTarget ; <nl> } , <nl> <nl> + / * * <nl> + * Removes the fullscreen target that was added to the DOM . <nl> + * <nl> + * @ method Phaser . Scale . ScaleManager # removeFullscreenTarget <nl> + * @ since 3 . 17 . 0 <nl> + * / <nl> + removeFullscreenTarget : function ( ) <nl> + { <nl> + if ( this . _createdFullscreenTarget ) <nl> + { <nl> + var fsTarget = this . fullscreenTarget ; <nl> + <nl> + if ( fsTarget & & fsTarget . parentNode ) <nl> + { <nl> + var parent = fsTarget . parentNode ; <nl> + <nl> + parent . insertBefore ( this . canvas , fsTarget ) ; <nl> + <nl> + parent . removeChild ( fsTarget ) ; <nl> + } <nl> + } <nl> + } , <nl> + <nl> / * * <nl> * Calling this method will cancel fullscreen mode , if the browser has entered it . <nl> * <nl> var ScaleManager = new Class ( { <nl> document [ fullscreen . cancel ] ( ) ; <nl> } <nl> <nl> - if ( this . _createdFullscreenTarget ) <nl> - { <nl> - var fsTarget = this . fullscreenTarget ; <nl> - <nl> - if ( fsTarget & & fsTarget . parentNode ) <nl> - { <nl> - var parent = fsTarget . parentNode ; <nl> - <nl> - parent . insertBefore ( this . canvas , fsTarget ) ; <nl> - <nl> - parent . removeChild ( fsTarget ) ; <nl> - } <nl> - } <nl> + this . removeFullscreenTarget ( ) ; <nl> <nl> / / Get the parent size again as it will have changed <nl> this . getParentBounds ( ) ; <nl> var ScaleManager = new Class ( { <nl> * / <nl> onFullScreenError : function ( ) <nl> { <nl> + this . removeFullscreenTarget ( ) ; <nl> } , <nl> <nl> / * * <nl>\n", "msg": "startFullscreen now uses a Promise internally , if it can do so , to resolve and handle the request .\n", "score": 1}
{"diff_id": 18894, "repo": "TryGhost/Ghost\n", "sha": "73bc3ec3884532332a17e43a5b0a823038320a23\n", "time": "2019-09-17T03:05:06Z\n", "diff": "mmm a / core / server / web / site / app . js <nl> ppp b / core / server / web / site / app . js <nl> module . exports = function setupSiteApp ( options = { } ) { <nl> next ( ) ; <nl> } ) ; <nl> } ) ; <nl> + siteApp . use ( async function ( req , res , next ) { <nl> + if ( ! labsService . isSet ( ' members ' ) ) { <nl> + return next ( ) ; <nl> + } <nl> + if ( ! req . url . includes ( ' token = ' ) ) { <nl> + return next ( ) ; <nl> + } <nl> + try { <nl> + const member = await membersService . ssr . exchangeTokenForSession ( req , res ) ; <nl> + req . member = member ; <nl> + next ( ) ; <nl> + } catch ( err ) { <nl> + common . logging . warn ( err . message ) ; <nl> + return next ( ) ; <nl> + } <nl> + } ) ; <nl> siteApp . use ( function ( req , res , next ) { <nl> res . locals . member = req . member ; <nl> next ( ) ; <nl>\n", "msg": "Added a middleware to handle signin via a GET\n", "score": 1}
{"diff_id": 19069, "repo": "meteor/meteor\n", "sha": "89aeac562362d69e2768d131ac6a864d7e092a31\n", "time": "2016-07-05T23:05:22Z\n", "diff": "mmm a / packages / minifier - css / minifier . js <nl> ppp b / packages / minifier - css / minifier . js <nl> var rewriteRules = function ( rules , mergedCssPath ) { <nl> / / merged CSS , leaving to the browser the responsibility to calculate <nl> / / the final resource links ( by adding the application deployment <nl> / / prefix , here ` myapp / ` , if applicable ) . <nl> - relativeToMergedCss = path . relative ( mergedCssPath , absolutePath ) ; <nl> + relativeToMergedCss = pathRelative ( mergedCssPath , absolutePath ) ; <nl> newCssUrl = \" url ( \" + quote + relativeToMergedCss + quote + \" ) \" ; <nl> value = value . replace ( oldCssUrl , newCssUrl ) ; <nl> } <nl> var pathDirname = function ( p ) { <nl> return toStandardPath ( path . dirname ( toOSPath ( p ) ) ) ; <nl> } ; <nl> <nl> + var pathRelative = function ( p1 , p2 ) { <nl> + return toStandardPath ( path . relative ( toOSPath ( p1 ) , toOSPath ( p2 ) ) ) ; <nl> + } ; <nl>\n", "msg": "Use a reproduced ` pathRelative ` in css minifier\n", "score": 1}
{"diff_id": 19668, "repo": "RocketChat/Rocket.Chat\n", "sha": "ffff8c711fd2334a677190764cbd64c486719794\n", "time": "2017-01-11T16:06:16Z\n", "diff": "mmm a / packages / rocketchat - api / server / v1 / channels . js <nl> ppp b / packages / rocketchat - api / server / v1 / channels . js <nl> RocketChat . API . v1 . addRoute ( ' channels . list . joined ' , { authRequired : true } , { <nl> } <nl> } ) ; <nl> <nl> + RocketChat . API . v1 . addRoute ( ' channels . online ' , { authRequired : true } , { <nl> + get : function ( ) { <nl> + const room = findChannelById ( this . queryParams . roomId ) ; <nl> + <nl> + if ( room . statusCode ) { <nl> + return room ; <nl> + } <nl> + <nl> + const online = RocketChat . models . Users . findUsersNotOffline ( { <nl> + fields : { <nl> + username : 1 , <nl> + status : 1 <nl> + } <nl> + } ) . fetch ( ) ; <nl> + <nl> + let onlineInRoom = [ ] ; <nl> + online . forEach ( user = > { <nl> + if ( room . usernames . indexOf ( user . username ) ! = - 1 ) { <nl> + onlineInRoom . push ( user . username ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + return RocketChat . API . v1 . success ( { <nl> + online : onlineInRoom <nl> + } ) ; <nl> + } <nl> + } ) ; <nl> + <nl> RocketChat . API . v1 . addRoute ( ' channels . open ' , { authRequired : true } , { <nl> post : function ( ) { <nl> const findResult = findChannelById ( { roomId : this . bodyParams . roomId , checkedArchived : false } ) ; <nl>\n", "msg": "Add REST API method to list online users in a room\n", "score": 1}
{"diff_id": 19953, "repo": "codemirror/CodeMirror\n", "sha": "1b4d5eea9371d1680f9ccf6bebdbf5c59083e915\n", "time": "2013-01-25T12:54:37Z\n", "diff": "mmm a / lib / codemirror . js <nl> ppp b / lib / codemirror . js <nl> window . CodeMirror = ( function ( ) { <nl> if ( ! cm . state . focused ) { <nl> signal ( cm , \" focus \" , cm ) ; <nl> cm . state . focused = true ; <nl> - if ( cm . display . scroller . className . search ( / \\ bCodeMirror - focused \\ b / ) = = - 1 ) <nl> - cm . display . scroller . className + = \" CodeMirror - focused \" ; <nl> + if ( cm . display . wrapper . className . search ( / \\ bCodeMirror - focused \\ b / ) = = - 1 ) <nl> + cm . display . wrapper . className + = \" CodeMirror - focused \" ; <nl> resetInput ( cm , true ) ; <nl> } <nl> slowPoll ( cm ) ; <nl> window . CodeMirror = ( function ( ) { <nl> if ( cm . state . focused ) { <nl> signal ( cm , \" blur \" , cm ) ; <nl> cm . state . focused = false ; <nl> - cm . display . scroller . className = cm . display . scroller . className . replace ( \" CodeMirror - focused \" , \" \" ) ; <nl> + cm . display . wrapper . className = cm . display . wrapper . className . replace ( \" CodeMirror - focused \" , \" \" ) ; <nl> } <nl> clearInterval ( cm . display . blinker ) ; <nl> setTimeout ( function ( ) { if ( ! cm . state . focused ) cm . doc . sel . shift = false ; } , 150 ) ; <nl>\n", "msg": "Apply CodeMirror - focused class to wrapper , not scroller\n", "score": 1}
{"diff_id": 20064, "repo": "meteor/meteor\n", "sha": "565c4254f190c96b3cf51d762e721731aae061a0\n", "time": "2020-01-13T15:52:56Z\n", "diff": "mmm a / packages / webapp / package . js <nl> ppp b / packages / webapp / package . js <nl> Npm . strip ( { <nl> Cordova . depends ( { <nl> ' cordova - plugin - whitelist ' : ' 1 . 3 . 3 ' , <nl> ' cordova - plugin - wkwebview - engine ' : ' 1 . 1 . 4 ' , <nl> - ' cordova - plugin - meteor - webapp ' : ' 1 . 7 . 1 - beta . 0 ' <nl> + ' cordova - plugin - meteor - webapp ' : ' 1 . 7 . 1 - beta . 1 ' <nl> } ) ; <nl> <nl> Package . onUse ( function ( api ) { <nl>\n", "msg": "Update cordova - plugin - meteor - webapp to 1 . 7 . 1 - beta . 1 .\n", "score": 1}
{"diff_id": 20114, "repo": "meteor/meteor\n", "sha": "255e136c9a5957811c0161905ad06e1e1aba148d\n", "time": "2017-05-19T01:14:41Z\n", "diff": "mmm a / packages / email / email . js <nl> ppp b / packages / email / email . js <nl> var makeTransport = function ( mailUrlString ) { <nl> mailUrlString + \" ) must be ' smtp ' or ' smtps ' \" ) ; <nl> } <nl> <nl> + if ( mailUrl . protocol = = = ' smtp : ' & & mailUrl . port = = = ' 465 ' ) { <nl> + Meteor . _debug ( \" $ MAIL_URL is of the form smtp : / / . . . : 465 - - did you mean smtps : / / . . . : 465 ? ( Note added ' s ' to enable SSL . ) \" ) ; <nl> + } <nl> + <nl> / / Allow overriding pool setting , but default to true . <nl> if ( ! mailUrl . query ) { <nl> mailUrl . query = { } ; <nl>\n", "msg": "Add warning when using smtp : / / . . . : 465\n", "score": 1}
{"diff_id": 20399, "repo": "emberjs/ember.js\n", "sha": "98269f82f9a4aa58cbc91b508b4967688fda77ee\n", "time": "2016-08-04T17:52:09Z\n", "diff": "mmm a / packages / ember - htmlbars / lib / keywords / partial . js <nl> ppp b / packages / ember - htmlbars / lib / keywords / partial . js <nl> import { internal } from ' htmlbars - runtime ' ; <nl> ` ` ` <nl> <nl> The above example template will render a template named <nl> - \" _nav \" , which has the same context as the parent template <nl> - it ' s rendered into , so if the \" _nav \" template also referenced <nl> + \" - nav \" , which has the same context as the parent template <nl> + it ' s rendered into , so if the \" - nav \" template also referenced <nl> ` { { foo } } ` , it would print the same thing as the ` { { foo } } ` <nl> in the above example . <nl> <nl> - If a \" _nav \" template isn ' t found , the ` partial ` helper will <nl> + If a \" - nav \" template isn ' t found , the ` partial ` helper will <nl> fall back to a template named \" nav \" . <nl> <nl> # # # Bound template names <nl>\n", "msg": "[ DOC release ] Use dash for partial naming\n", "score": 1}
{"diff_id": 20764, "repo": "emberjs/ember.js\n", "sha": "2892e46b0f8eaeb7836bcaf34778816bef569e1f\n", "time": "2013-03-24T18:55:44Z\n", "diff": "mmm a / packages / ember - application / lib / system / application . js <nl> ppp b / packages / ember - application / lib / system / application . js <nl> var Application = Ember . Application = Ember . Namespace . extend ( { <nl> @ method scheduleInitialize <nl> * / <nl> scheduleInitialize : function ( ) { <nl> - var self = this ; <nl> - this . $ ( ) . ready ( function ( ) { <nl> - if ( self . isDestroyed | | self . isInitialized ) { return ; } <nl> - Ember . run . schedule ( ' actions ' , self , ' initialize ' ) ; <nl> - } ) ; <nl> + if ( ! this . $ | | this . $ . isReady ) { <nl> + Ember . run . schedule ( ' actions ' , this , ' initialize ' ) ; <nl> + } else { <nl> + var self = this ; <nl> + this . $ ( ) . ready ( function ( ) { <nl> + if ( self . isDestroyed | | self . isInitialized ) { return ; } <nl> + Ember . run ( self , ' initialize ' ) ; <nl> + } ) ; <nl> + } <nl> } , <nl> <nl> / * * <nl>\n", "msg": "ensure that wrapping Application . create in a run\n", "score": 1}
{"diff_id": 20896, "repo": "facebook/react\n", "sha": "7ae5ed0e7b087a202a8cfa24d7b4b5cde7c913e1\n", "time": "2017-09-30T14:54:20Z\n", "diff": "mmm a / www / src / prism - styles . js <nl> ppp b / www / src / prism - styles . js <nl> const prismColors = { <nl> char : ' # D8DEE9 ' , <nl> comment : ' # 999999 ' , <nl> keyword : ' # c5a5c5 ' , <nl> - lineHighlight : ' # 393d45 ' , <nl> + lineHighlight : ' # 14161a ' , <nl> primitive : ' # 5a9bcf ' , <nl> string : ' # 8dc891 ' , <nl> variable : ' # d7deea ' , <nl>\n", "msg": "[ Gatsby ] Darkened line - highlight to increase contrast ( )\n", "score": 1}
{"diff_id": 21122, "repo": "emberjs/ember.js\n", "sha": "5190c0d67fa16fc916b8aa2215fe54db60a35c6f\n", "time": "2014-12-23T16:38:18Z\n", "diff": "mmm a / tests / node / template - compiler - test . js <nl> ppp b / tests / node / template - compiler - test . js <nl> test ( ' uses plugins with precompile ' , function ( ) { <nl> templateOutput = templateCompiler . precompile ( ' { { # with foo as bar } } { { / with } } ' ) ; <nl> ok ( templateOutput . match ( / set \\ ( context , \" bar \" , blockArguments \\ [ 0 \\ ] \\ ) ; / ) , ' transform with as to block params ' ) ; <nl> } ) ; <nl> + <nl> + test ( ' allows enabling of features ' , function ( ) { <nl> + var templateOutput ; <nl> + var templateCompiler = require ( path . join ( distPath , ' ember - template - compiler ' ) ) ; <nl> + <nl> + templateCompiler . _Ember . FEATURES [ ' ember - htmlbars - component - generation ' ] = true ; <nl> + <nl> + templateOutput = templateCompiler . precompile ( ' < some - thing > < / some - thing > ' ) ; <nl> + ok ( templateOutput . match ( / component \\ ( morph0 , \" some - thing \" / ) , ' component generation can be enabled ' ) ; <nl> + } ) ; <nl>\n", "msg": "Add template - compiler tests for feature enabling in node - land .\n", "score": 1}
{"diff_id": 21444, "repo": "nylas/nylas-mail\n", "sha": "874cddba06ad97a171416776c7ad77c57a750cfb\n", "time": "2016-12-21T00:46:58Z\n", "diff": "mmm a / packages / local - sync / src / local - sync - worker / sync - worker . js <nl> ppp b / packages / local - sync / src / local - sync - worker / sync - worker . js <nl> const SyncMetricsReporter = require ( ' . / sync - metrics - reporter ' ) ; <nl> const { NylasAPI , N1CloudAPI , NylasAPIRequest , NylasAPIHelpers } = require ( ' nylas - exports ' ) ; <nl> <nl> <nl> - <nl> const RESTART_THRESHOLD = 10 <nl> <nl> class SyncWorker { <nl> class SyncWorker { <nl> } <nl> <nl> _onConnectionIdleUpdate ( ) { <nl> - this . syncNow ( { reason : ' IMAP IDLE Fired ' } ) ; <nl> + this . syncNow ( { reason : \" You ' ve got mail ! \" } ) ; <nl> } <nl> <nl> async _getAccount ( ) { <nl> class SyncWorker { <nl> this . _interrupted | | <nl> this . _syncAttemptsWhileInProgress > 0 <nl> ) <nl> - const reason = this . _interrupted ? ' Sync interrupted for restart ' : ' Scheduled ' <nl> + <nl> + let reason = \" Idle scheduled \" <nl> + if ( moreToSync ) { <nl> + reason = \" More to sync \" <nl> + } else if ( this . _interrupted ) { <nl> + reason = \" Sync interrupted by high priority task \" <nl> + } else if ( this . _syncAttemptsWhileInProgress > 0 ) { <nl> + reason = \" Sync requested while in progress \" <nl> + } <nl> const interval = shouldSyncImmediately ? 1 : intervals . active ; <nl> const nextSyncIn = Math . max ( 1 , this . _lastSyncTime + interval - Date . now ( ) ) <nl> <nl>\n", "msg": "[ local - sync ] : better sync reasons\n", "score": 1}
{"diff_id": 21582, "repo": "ReactTraining/react-router\n", "sha": "275c5a457b8fb89bf53c0a6b9d2241ba7ef8a513\n", "time": "2017-01-24T06:22:28Z\n", "diff": "mmm a / packages / react - router / modules / StaticRouter . js <nl> ppp b / packages / react - router / modules / StaticRouter . js <nl> const staticHandler = ( methodName ) = > ( ) = > { <nl> ) <nl> } <nl> <nl> + const noop = ( ) = > { } <nl> + <nl> / * * <nl> * The public top - level API for a \" static \" < Router > , so - called because it <nl> * can ' t actually change the current location . Instead , it just records <nl> class StaticRouter extends React . Component { <nl> context . url = createURL ( location ) <nl> } <nl> <nl> + handleListen = ( ) = > <nl> + noop <nl> + <nl> render ( ) { <nl> const { context , location , . . . props } = this . props / / eslint - disable - line no - unused - vars <nl> <nl> class StaticRouter extends React . Component { <nl> go : staticHandler ( ' go ' ) , <nl> goBack : staticHandler ( ' goBack ' ) , <nl> goForward : staticHandler ( ' goForward ' ) , <nl> - listen : staticHandler ( ' listen ' ) <nl> + listen : this . handleListen <nl> } <nl> <nl> return < Router { . . . props } history = { history } / > <nl>\n", "msg": "Allow < StaticRouter > to render < Route > s\n", "score": 1}
{"diff_id": 21591, "repo": "meteor/meteor\n", "sha": "715b96bed8593e1e48a8b4590957b22343a6c364\n", "time": "2018-04-29T13:06:17Z\n", "diff": "mmm a / packages / test - helpers / package . js <nl> ppp b / packages / test - helpers / package . js <nl> Package . describe ( { <nl> } ) ; <nl> <nl> Package . onUse ( function ( api ) { <nl> - api . use ( [ ' underscore ' , ' tracker ' , ' ejson ' , ' tinytest ' , ' random ' , ' blaze ' ] ) ; <nl> - api . use ( [ ' jquery @ 1 . 12 . 1 ' ] , ' client ' ) ; <nl> + api . use ( [ <nl> + ' ecmascript ' , <nl> + ' underscore ' , <nl> + ' tracker ' , <nl> + ' ejson ' , <nl> + ' tinytest ' , <nl> + ' random ' , <nl> + ' blaze ' , <nl> + ] ) ; <nl> + <nl> + api . use ( [ ' jquery @ 1 . 11 . 1 ' ] , ' client ' ) ; <nl> <nl> / / XXX for connection . js . Not sure this really belongs in <nl> / / test - helpers . It probably would be better off in livedata . But it ' s <nl>\n", "msg": "Use ecmascript in test - helpers and downgrade to latest published jquery .\n", "score": 1}
{"diff_id": 21594, "repo": "moment/moment\n", "sha": "68aeaab01e9b7f5b61dfaddf79e19ee53a0992df\n", "time": "2014-01-21T15:31:42Z\n", "diff": "mmm a / lang / pt . js <nl> ppp b / lang / pt . js <nl> <nl> } , <nl> relativeTime : { <nl> future : \" em % s \" , <nl> - past : \" % s atrs \" , <nl> + past : \" h % s \" , <nl> s : \" segundos \" , <nl> m : \" um minuto \" , <nl> mm : \" % d minutos \" , <nl>\n", "msg": "More natural \" time ago \" expression for PT locale\n", "score": 1}
{"diff_id": 21676, "repo": "gorhill/uBlock\n", "sha": "987c9c1a21732a0b296efb049a81741c0462c9d2\n", "time": "2019-11-01T18:01:30Z\n", "diff": "mmm a / src / js / scriptlets / dom - survey - elements . js <nl> ppp b / src / js / scriptlets / dom - survey - elements . js <nl> <nl> surveyResults . hiddenElementCount = ( ( ) = > { <nl> if ( vAPI . domFilterer instanceof Object = = = false ) { return 0 ; } <nl> const details = vAPI . domFilterer . getAllSelectors_ ( true ) ; <nl> - if ( Array . isArray ( details . declarative ) = = = false ) { return 0 ; } <nl> + if ( <nl> + Array . isArray ( details . declarative ) = = = false | | <nl> + details . declarative . length = = = 0 <nl> + ) { <nl> + return 0 ; <nl> + } <nl> const selectors = details . declarative . map ( entry = > entry [ 0 ] ) ; <nl> const simple = [ ] , complex = [ ] ; <nl> for ( const selectorStr of selectors ) { <nl> <nl> document . body , <nl> NodeFilter . SHOW_ELEMENT <nl> ) ; <nl> - const matched = new Set ( ) ; <nl> + const candidates = new Set ( ) ; <nl> for ( ; ; ) { <nl> const node = nodeIter . nextNode ( ) ; <nl> if ( node = = = null ) { break ; } <nl> - if ( node . offsetParent ! = = null ) { continue ; } <nl> - if ( <nl> - node . matches ( simpleStr ) = = = false & & <nl> - node . closest ( complexStr ) ! = = node <nl> - ) { <nl> - continue ; <nl> + if ( node . offsetParent = = = null ) { <nl> + candidates . add ( node ) ; <nl> + } <nl> + } <nl> + const matched = new Set ( ) ; <nl> + if ( simpleStr ! = = ' ' ) { <nl> + for ( const node of candidates ) { <nl> + if ( node . matches ( simpleStr ) = = = false ) { continue ; } <nl> + candidates . delete ( node ) ; <nl> + matched . add ( node ) ; <nl> + if ( matched . size = = = 99 ) { break ; } <nl> + } <nl> + } <nl> + if ( matched . size < 99 & & complexStr ! = = ' ' ) { <nl> + for ( const node of candidates ) { <nl> + if ( node . closest ( complexStr ) ! = = node ) { continue ; } <nl> + matched . add ( node ) ; <nl> + if ( matched . size = = = 99 ) { break ; } <nl> } <nl> - matched . add ( node ) ; <nl> - if ( matched . size = = = 99 ) { break ; } <nl> } <nl> return matched . size ; <nl> } ) ( ) ; <nl>\n", "msg": "Fix on - demand no - cosmetic - filtering badge when generichide in use\n", "score": 1}
{"diff_id": 21741, "repo": "meteor/meteor\n", "sha": "5d67910ce82e9de384b82ee6867bcf1d2af94e6d\n", "time": "2014-05-12T23:24:04Z\n", "diff": "mmm a / tools / service - connection . js <nl> ppp b / tools / service - connection . js <nl> <nl> var Future = require ( \" fibers / future \" ) ; <nl> var _ = require ( \" underscore \" ) ; <nl> + var uniload = require ( \" . / uniload . js \" ) ; <nl> + <nl> + var TIMEOUT_SEC = 15 ; <nl> <nl> / / Wrapper to manage a connection to a DDP service . Provides failing <nl> / / method calls and subscriptions if , after 10 seconds , we ' re not <nl> var _ = require ( \" underscore \" ) ; <nl> var ServiceConnection = function ( Package , endpointUrl , headers ) { <nl> var self = this ; <nl> self . Package = Package ; <nl> + ensureConnectionTimeoutErrorDefined ( Package . meteor . Meteor ) ; <nl> <nl> var options = { } ; <nl> if ( headers ) { <nl> var ServiceConnection = function ( Package , endpointUrl , headers ) { <nl> } ) ; <nl> self . connectionTimeoutCallbacks = [ ] ; <nl> } <nl> - } , 10 * 1000 ) ; <nl> + } , TIMEOUT_SEC * 1000 ) ; <nl> + } ; <nl> + <nl> + / / can ' t run this at the top - level since we ' re not in a fiber <nl> + ensureConnectionTimeoutErrorDefined = function ( Meteor ) { <nl> + if ( ! ServiceConnection . ConnectionTimeoutError ) { <nl> + ServiceConnection . ConnectionTimeoutError = Meteor . makeErrorType ( <nl> + \" ServiceConnection . ConnectionTimeoutError \" , / * name * / <nl> + function ( ) { <nl> + this . message = \" ServiceConnection : Timeout after \" <nl> + + TIMEOUT_SEC + \" seconds \" ; <nl> + } / * constructor * / ) ; <nl> + } <nl> } ; <nl> <nl> _ . extend ( ServiceConnection . prototype , { <nl> _ . extend ( ServiceConnection . prototype , { <nl> } <nl> } ) ; <nl> <nl> - ServiceConnection . ConnectionTimeoutError = function ( ) { } ; <nl> - <nl> module . exports = ServiceConnection ; <nl>\n", "msg": "Reveal error name on ServiceConnection . ConnectionTimeoutError stack traces\n", "score": 1}
{"diff_id": 21773, "repo": "lodash/lodash\n", "sha": "57f0a4c6d71ffea605c8f98fb42be1f634d3d378\n", "time": "2016-06-07T03:00:15Z\n", "diff": "mmm a / fp / _mapping . js <nl> ppp b / fp / _mapping . js <nl> exports . aryMethod = { <nl> ' 2 ' : [ <nl> ' add ' , ' after ' , ' ary ' , ' assign ' , ' assignAllWith ' , ' assignIn ' , ' assignInAllWith ' , <nl> ' at ' , ' before ' , ' bind ' , ' bindAll ' , ' bindKey ' , ' chunk ' , ' cloneDeepWith ' , <nl> - ' cloneWith ' , ' concat ' , ' countBy ' , ' curryN ' , ' curryRightN ' , ' debounce ' , <nl> - ' defaults ' , ' defaultsDeep ' , ' defaultTo ' , ' delay ' , ' difference ' , ' divide ' , <nl> - ' drop ' , ' dropRight ' , ' dropRightWhile ' , ' dropWhile ' , ' endsWith ' , ' eq ' , ' every ' , <nl> - ' filter ' , ' find ' , ' findIndex ' , ' findKey ' , ' findLast ' , ' findLastIndex ' , <nl> + ' cloneWith ' , ' concat ' , ' conformsTo ' , ' countBy ' , ' curryN ' , ' curryRightN ' , <nl> + ' debounce ' , ' defaults ' , ' defaultsDeep ' , ' defaultTo ' , ' delay ' , ' difference ' , <nl> + ' divide ' , ' drop ' , ' dropRight ' , ' dropRightWhile ' , ' dropWhile ' , ' endsWith ' , ' eq ' , <nl> + ' every ' , ' filter ' , ' find ' , ' findIndex ' , ' findKey ' , ' findLast ' , ' findLastIndex ' , <nl> ' findLastKey ' , ' flatMap ' , ' flatMapDeep ' , ' flattenDepth ' , ' forEach ' , <nl> ' forEachRight ' , ' forIn ' , ' forInRight ' , ' forOwn ' , ' forOwnRight ' , ' get ' , <nl> ' groupBy ' , ' gt ' , ' gte ' , ' has ' , ' hasIn ' , ' includes ' , ' indexOf ' , ' intersection ' , <nl>\n", "msg": "Add ` conformsTo ` to fp ` aryMethod ` mapping .\n", "score": 1}
{"diff_id": 22007, "repo": "balderdashy/sails\n", "sha": "f1da2849d496e60ef789aaae95911e7e58bb4efd\n", "time": "2013-04-07T01:06:02Z\n", "diff": "mmm a / lib / waterline / adapter / sync . js <nl> ppp b / lib / waterline / adapter / sync . js <nl> <nl> var _ = require ( ' underscore ' ) ; <nl> - <nl> + var augmentAttributes = require ( ' . . / augmentAttributes ' ) ; <nl> <nl> / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> / / Sync strategies <nl> module . exports = function ( adapterDef ) { <nl> else if ( ! attrs ) return self . define ( collection . identity , collection , cb ) ; <nl> <nl> / / Otherwise , if it * DOES * exist , we ' ll try and guess what changes need to be made <nl> - else self . alter ( collection . identity , require ( ' . / augmentAttributes ' ) ( collection . attributes , collection ) , cb ) ; <nl> + else self . alter ( collection . identity , augmentAttributes ( collection . attributes , collection ) , cb ) ; <nl> } ) ; <nl> } , <nl> <nl>\n", "msg": "Fixed one more require path in waterline / adapter / sync . js\n", "score": 1}
{"diff_id": 22048, "repo": "photonstorm/phaser\n", "sha": "50ecafe4a504c9056b1ef72dc8c28fb260b5e031\n", "time": "2017-08-01T23:42:44Z\n", "diff": "mmm a / v3 / src / plugins / CameraManager . js <nl> ppp b / v3 / src / plugins / CameraManager . js <nl> var CameraManager = new Class ( { <nl> return this ; <nl> } , <nl> <nl> - add : function ( x , y , width , height ) <nl> + add : function ( x , y , width , height , makeMain ) <nl> { <nl> if ( x = = = undefined ) { x = 0 ; } <nl> if ( y = = = undefined ) { y = 0 ; } <nl> if ( width = = = undefined ) { width = this . scene . sys . game . config . width ; } <nl> if ( height = = = undefined ) { height = this . scene . sys . game . config . height ; } <nl> + if ( makeMain = = = undefined ) { makeMain = false ; } <nl> <nl> var camera = null ; <nl> <nl> var CameraManager = new Class ( { <nl> <nl> this . cameras . push ( camera ) ; <nl> <nl> + if ( makeMain ) <nl> + { <nl> + this . main = camera ; <nl> + } <nl> + <nl> return camera ; <nl> } , <nl> <nl> var CameraManager = new Class ( { <nl> { <nl> var cameraIndex = this . cameras . indexOf ( camera ) ; <nl> <nl> - if ( cameraIndex > = 0 ) <nl> + if ( cameraIndex > = 0 & & this . cameras . length > 1 ) <nl> { <nl> this . cameraPool . push ( this . cameras [ cameraIndex ] ) ; <nl> this . cameras . splice ( cameraIndex , 1 ) ; <nl> + <nl> + if ( this . main = = = camera ) <nl> + { <nl> + this . main = this . cameras [ 0 ] ; <nl> + } <nl> } <nl> } , <nl> <nl> var CameraManager = new Class ( { <nl> } <nl> <nl> this . main = this . add ( ) ; <nl> + <nl> + return this . main ; <nl> } , <nl> <nl> update : function ( timestep , delta ) <nl>\n", "msg": "Cannot delete all cameras from a Scene . Added ' makeMain ' argument to add camera .\n", "score": 1}
{"diff_id": 22052, "repo": "redux-saga/redux-saga\n", "sha": "2aecdb310db8760ddd2c2513bf1cce7174c289d9\n", "time": "2018-10-02T14:18:28Z\n", "diff": "mmm a / packages / core / src / internal / channel . js <nl> ppp b / packages / core / src / internal / channel . js <nl> export function eventChannel ( subscribe , buffer = buffers . none ( ) ) { <nl> <nl> const chan = channel ( buffer ) <nl> const close = ( ) = > { <nl> + if ( closed ) { <nl> + return <nl> + } <nl> + <nl> + closed = true <nl> + <nl> if ( is . func ( unsubscribe ) ) { <nl> unsubscribe ( ) <nl> } <nl> export function eventChannel ( subscribe , buffer = buffers . none ( ) ) { <nl> <nl> unsubscribe = subscribe ( input = > { <nl> if ( isEnd ( input ) ) { <nl> - closed = true <nl> close ( ) <nl> return <nl> } <nl>\n", "msg": "Move setting closed var to close method in eventChannel ( followup to )\n", "score": 1}
{"diff_id": 22085, "repo": "photonstorm/phaser\n", "sha": "8b1e736418b12c83612113011ef7e9201cb270ef\n", "time": "2014-05-09T15:39:45Z\n", "diff": "mmm a / src / gameobjects / BitmapData . js <nl> ppp b / src / gameobjects / BitmapData . js <nl> Phaser . BitmapData . prototype = { <nl> <nl> } , <nl> <nl> + / * * <nl> + * Draws a filled Rectangle to the BitmapData at the given x , y coordinates and width / height in size . <nl> + * <nl> + * @ method Phaser . BitmapData # rect <nl> + * @ param { number } x - The x coordinate of the top - left of the Rectangle . <nl> + * @ param { number } y - The y coordinate of the top - left of the Rectangle . <nl> + * @ param { number } width - The width of the Rectangle . <nl> + * @ param { number } height - The height of the Rectangle . <nl> + * @ param { string } [ fillStyle ] - If set the context fillStyle will be set to this value before the rect is drawn . <nl> + * / <nl> + rect : function ( x , y , width , height , fillStyle ) { <nl> + <nl> + if ( typeof fillStyle ! = = ' undefined ' ) <nl> + { <nl> + this . context . fillStyle = fillStyle ; <nl> + } <nl> + <nl> + this . context . fillRect ( x , y , width , height ) ; <nl> + this . context . fill ( ) ; <nl> + <nl> + } , <nl> + <nl> / * * <nl> * Draws a filled Circle to the BitmapData at the given x , y coordinates and radius in size . <nl> * <nl>\n", "msg": "BitmapData . rect provides a quick way to draw a Rectangle to a BitmapData .\n", "score": 1}
{"diff_id": 22316, "repo": "lodash/lodash\n", "sha": "7a4ddca64d88350a5d8610154f00a02516b6675a\n", "time": "2010-08-26T06:01:24Z\n", "diff": "mmm a / underscore . js <nl> ppp b / underscore . js <nl> <nl> var c = _ . templateSettings ; <nl> var endMatch = new RegExp ( \" ' ( ? = [ ^ \" + c . end . substr ( 0 , 1 ) + \" ] * \" + escapeRegExp ( c . end ) + \" ) \" , \" g \" ) ; <nl> var fn = new Function ( ' obj ' , <nl> - ' var p = [ ] ; ' + <nl> + ' var p = [ ] , print = function ( ) { p . push . apply ( p , arguments ) ; } ; ' + <nl> ' with ( obj | | { } ) { p . push ( \\ ' ' + <nl> str . replace ( / \\ r / g , ' \\ \\ r ' ) <nl> . replace ( / \\ n / g , ' \\ \\ n ' ) <nl> <nl> . replace ( endMatch , \"  \" ) <nl> . split ( \" ' \" ) . join ( \" \\ \\ ' \" ) <nl> . split ( \"  \" ) . join ( \" ' \" ) <nl> - . replace ( c . interpolate , \" ' + $ 1 + ' \" ) <nl> + . replace ( c . interpolate , \" ' , $ 1 , ' \" ) <nl> . split ( c . start ) . join ( \" ' ) ; \" ) <nl> . split ( c . end ) . join ( \" p . push ( ' \" ) <nl> + \" ' ) ; } return p . join ( ' ' ) ; \" ) ; <nl>\n", "msg": "Revert \" slight speedup to _ . template \"\n", "score": 1}
{"diff_id": 22565, "repo": "adobe/brackets\n", "sha": "c3df4c9686ef8120a2715630c927dc7fdc895602\n", "time": "2013-07-05T19:49:22Z\n", "diff": "mmm a / src / extensions / default / JSLint / main . js <nl> ppp b / src / extensions / default / JSLint / main . js <nl> define ( function ( require , exports , module ) { <nl> DocumentManager = brackets . getModule ( \" document / DocumentManager \" ) , <nl> EditorManager = brackets . getModule ( \" editor / EditorManager \" ) , <nl> LanguageManager = brackets . getModule ( \" language / LanguageManager \" ) , <nl> - NativeFileSystem = brackets . getModule ( \" file / NativeFileSystem \" ) . NativeFileSystem , <nl> PreferencesManager = brackets . getModule ( \" preferences / PreferencesManager \" ) , <nl> PerfUtils = brackets . getModule ( \" utils / PerfUtils \" ) , <nl> - ProjectManager = brackets . getModule ( \" project / ProjectManager \" ) , <nl> Strings = brackets . getModule ( \" strings \" ) , <nl> StringUtils = brackets . getModule ( \" utils / StringUtils \" ) , <nl> AppInit = brackets . getModule ( \" utils / AppInit \" ) , <nl> define ( function ( require , exports , module ) { <nl> * @ type { boolean } <nl> * / <nl> var _gotoEnabled = false ; <nl> - <nl> - / * * <nl> - * @ private <nl> - * @ type { string } <nl> - * / <nl> - var _configFileName = \" . jslint . json \" ; <nl> - <nl> - / * * <nl> - * @ private <nl> - * @ type { object } <nl> - * / <nl> - var _jsLintConfig = null ; <nl> - <nl> + <nl> / * * <nl> * Enable or disable the \" Go to First JSLint Error \" command <nl> * @ param { boolean } gotoEnabled Whether it is enabled . <nl> define ( function ( require , exports , module ) { <nl> CommandManager . get ( GOTO_FIRST_ERROR ) . setEnabled ( gotoEnabled ) ; <nl> _gotoEnabled = gotoEnabled ; <nl> } <nl> - <nl> - / * * <nl> - * Load project - wide JSLint configuration . <nl> - * <nl> - * Brackets JSLint configuration should be in JSON format , with all the <nl> - * JSLint options specified according to JSLint documentation . <nl> - * <nl> - * JSLint project file should be located at < Project Root > / . jslint . json . It <nl> - * is loaded each time project is changed or the configuration file is <nl> - * modified . <nl> - * <nl> - * @ return Promise to return JSLint configuration object . <nl> - * <nl> - * @ see < a href = \" http : / / www . jslint . com / lint . html # options \" > JSLint option <nl> - * reference < / a > . <nl> - * / <nl> - function _loadProjectConfig ( ) { <nl> - <nl> - var projectRootEntry = ProjectManager . getProjectRoot ( ) , <nl> - result = new $ . Deferred ( ) , <nl> - config ; <nl> - <nl> - projectRootEntry . getFile ( _configFileName , <nl> - { create : false } , <nl> - function ( configFileEntry ) { <nl> - var reader = new NativeFileSystem . FileReader ( ) ; <nl> - configFileEntry . file ( function ( file ) { <nl> - reader . onload = function ( event ) { <nl> - try { <nl> - config = JSON . parse ( event . target . result ) ; <nl> - result . resolve ( config ) ; <nl> - } catch ( e ) { <nl> - result . reject ( e ) ; <nl> - } <nl> - } ; <nl> - reader . onerror = function ( event ) { <nl> - result . reject ( event . target . error ) ; <nl> - } ; <nl> - reader . readAsText ( file ) ; <nl> - } ) ; <nl> - } , <nl> - function ( err ) { <nl> - result . reject ( err ) ; <nl> - } ) ; <nl> - <nl> - return result . promise ( ) ; <nl> - <nl> - } <nl> <nl> / * * <nl> * Run JSLint on the current document . Reports results to the main UI . Displays <nl> define ( function ( require , exports , module ) { <nl> } <nl> text = arr . join ( \" \\ n \" ) ; <nl> <nl> - var result = JSLINT ( text , _jsLintConfig ) ; <nl> + var result = JSLINT ( text , null ) ; <nl> <nl> PerfUtils . addMeasurement ( perfTimerLint ) ; <nl> perfTimerDOM = PerfUtils . markStart ( \" JSLint DOM : \\ t \" + ( ! currentDoc | | currentDoc . file . fullPath ) ) ; <nl> define ( function ( require , exports , module ) { <nl> setGotoEnabled ( false ) ; <nl> } <nl> } <nl> - <nl> + <nl> / * * <nl> - * Update DocumentManager and ProjectManager listeners . <nl> + * Update DocumentManager listeners . <nl> * / <nl> function updateListeners ( ) { <nl> if ( _enabled ) { <nl> define ( function ( require , exports , module ) { <nl> run ( ) ; <nl> } ) <nl> . on ( \" documentSaved . jslint documentRefreshed . jslint \" , function ( event , document ) { <nl> - / / if this project ' s JSLint config has been updated , reload <nl> - if ( document . file . fullPath = = = <nl> - ProjectManager . getProjectRoot ( ) . fullPath + _configFileName ) { <nl> - _loadProjectConfig ( ) <nl> - . done ( function ( config ) { <nl> - _jsLintConfig = config ; <nl> - } ) <nl> - . fail ( function ( ) { <nl> - _jsLintConfig = null ; <nl> - } ) ; <nl> - } <nl> if ( document = = = DocumentManager . getCurrentDocument ( ) ) { <nl> run ( ) ; <nl> } <nl> } ) ; <nl> - $ ( ProjectManager ) <nl> - . on ( \" projectOpen . jslint \" , function ( ) { <nl> - _loadProjectConfig ( ) <nl> - . done ( function ( config ) { <nl> - _jsLintConfig = config ; <nl> - } ) <nl> - . fail ( function ( ) { <nl> - _jsLintConfig = null ; <nl> - } ) ; <nl> - } ) ; <nl> } else { <nl> $ ( DocumentManager ) . off ( \" . jslint \" ) ; <nl> - $ ( ProjectManager ) . off ( \" . jslint \" ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Revert \" Add support for project - wide JSLint config . \"\n", "score": 1}
{"diff_id": 22710, "repo": "facebook/react-native\n", "sha": "254d4551036abbd61eb1b809d7640d5adb863ba3\n", "time": "2020-10-09T22:52:21Z\n", "diff": "mmm a / Libraries / StyleSheet / splitLayoutProps . js <nl> ppp b / Libraries / StyleSheet / splitLayoutProps . js <nl> function splitLayoutProps ( <nl> const inner = { } ; <nl> const outer = { } ; <nl> if ( props ) { <nl> - Object . keys ( props ) . forEach ( k = > { <nl> - const value : $ ElementType < DangerouslyImpreciseStyle , typeof k > = props [ k ] ; <nl> + Object . keys ( props ) . forEach ( ( k : string ) = > { <nl> + const value = props [ k ] ; <nl> if ( OUTER_PROPS [ k ] ) { <nl> outer [ k ] = value ; <nl> } else { <nl>\n", "msg": "Add type annotations to prevent issues with planned Flow changes\n", "score": 1}
{"diff_id": 22922, "repo": "TryGhost/Ghost\n", "sha": "13f8cc61eb65ce4ab4f8965de83a94209da195e6\n", "time": "2014-10-17T12:41:36Z\n", "diff": "mmm a / core / client / mixins / shortcuts - route . js <nl> ppp b / core / client / mixins / shortcuts - route . js <nl> <nl> - / * global key , console * / <nl> + / * global key * / <nl> <nl> / / Configure KeyMaster to respond to all shortcuts , <nl> / / even inside of <nl> key . setScope ( ' default ' ) ; <nl> * and implement a ` shortcuts ` hash . <nl> * In this hash , keys are shortcut combinations and values are route action names . <nl> * ( see [ keymaster docs ] ( https : / / github . com / madrobby / keymaster / blob / master / README . markdown ) ) , <nl> - * <nl> + * <nl> * ` ` ` javascript <nl> * shortcuts : { <nl> * ' ctrl + s , command + s ' : ' save ' , <nl> var ShortcutsRoute = Ember . Mixin . create ( { <nl> activate : function ( ) { <nl> this . _super ( ) ; <nl> if ( ! this . shortcuts ) { <nl> - console . error ( ' Shortcuts not found on route ' ) ; <nl> return ; <nl> } <nl> this . registerShortcuts ( ) ; <nl>\n", "msg": "Remove console . error from shortcuts - route mixing\n", "score": 1}
{"diff_id": 22944, "repo": "transloadit/uppy\n", "sha": "1abe4b13083f8bd81456c931efc429afd0e8d93c\n", "time": "2018-03-11T02:22:32Z\n", "diff": "mmm a / src / plugins / Dashboard / FileItem . js <nl> ppp b / src / plugins / Dashboard / FileItem . js <nl> module . exports = function fileItem ( props ) { <nl> return < li class = { dashboardItemClass } id = { ` uppy_ $ { file . id } ` } title = { file . meta . name } > <nl> < div class = \" uppy - DashboardItem - preview \" > <nl> < div class = \" uppy - DashboardItem - previewInnerWrap \" style = { { backgroundColor : getFileTypeIcon ( file . type ) . color } } > <nl> + { props . showLinkToFileUploadResult & & file . uploadURL <nl> + ? < a class = \" uppy - DashboardItem - previewLink \" href = { file . uploadURL } target = \" _blank \" / > <nl> + : null <nl> + } <nl> { file . preview <nl> ? < img alt = { file . name } src = { file . preview } / > <nl> : < div class = \" uppy - DashboardItem - previewIconWrap \" > <nl> < span class = \" uppy - DashboardItem - previewIcon \" style = { { color : getFileTypeIcon ( file . type ) . color } } > { getFileTypeIcon ( file . type ) . icon } < / span > <nl> + < span class = \" uppy - DashboardItem - previewType \" > { file . extension } < / span > <nl> < svg class = \" uppy - DashboardItem - previewIconBg \" width = \" 72 \" height = \" 93 \" viewBox = \" 0 0 72 93 \" > < g > < path d = \" M24 . 08 5h38 . 922A2 . 997 2 . 997 0 0 1 66 8 . 003v74 . 994A2 . 997 2 . 997 0 0 1 63 . 004 86H8 . 996A2 . 998 2 . 998 0 0 1 6 83 . 01V22 . 234L24 . 08 5z \" fill = \" # FFF \" / > < path d = \" M24 5L6 22 . 248h15 . 007A2 . 995 2 . 995 0 0 0 24 19 . 244V5z \" fill = \" # E4E4E4 \" / > < / g > < / svg > <nl> < / div > <nl> } <nl> module . exports = function fileItem ( props ) { <nl> < / div > <nl> } <nl> < / div > <nl> - { ! uploadInProgressOrComplete & & <nl> - < button class = \" uppy - DashboardItem - edit \" <nl> + { ( ! uploadInProgressOrComplete & & props . metaFields & & props . metaFields . length ) <nl> + ? < button class = \" uppy - DashboardItem - edit \" <nl> type = \" button \" <nl> aria - label = { props . i18n ( ' editFile ' ) } <nl> title = { props . i18n ( ' editFile ' ) } <nl> - onclick = { ( e ) = > props . showFileCard ( file . id ) } > <nl> + onclick = { ( e ) = > props . toggleFileCard ( file . id ) } > <nl> { iconEdit ( ) } <nl> < / button > <nl> + : null <nl> } <nl> { file . uploadURL & & <nl> < button class = \" uppy - DashboardItem - copyLink \" <nl>\n", "msg": "Options to disable showLinkToFileUploadResult and meta editing if metaFields is not provided\n", "score": 1}
{"diff_id": 22960, "repo": "serverless/serverless\n", "sha": "2fabfcc6f0f1f2e3a126855e7bba33062adf3c51\n", "time": "2016-09-06T22:57:57Z\n", "diff": "mmm a / tests / classes / PluginManager . js <nl> ppp b / tests / classes / PluginManager . js <nl> describe ( ' PluginManager ' , ( ) = > { <nl> describe ( ' Plugin / CLI integration ' , ( ) = > { <nl> const serverlessInstance = new Serverless ( ) ; <nl> serverlessInstance . init ( ) ; <nl> - const serverlessExec = path . join ( serverlessInstance . config . serverlessPath , <nl> - ' . . ' , ' bin ' , ' serverless ' ) ; <nl> + <nl> + / / Cannot rely on shebang in severless . js to invoke script using NodeJS on Windows . Add ' node ' to command . <nl> + const execPrefix = os . platform ( ) = = = ' win32 ' ? ' node ' : null ; <nl> + const serverlessExec = execPrefix + path . join ( serverlessInstance . config . serverlessPath , <nl> + ' . . ' , ' bin ' , ' serverless ' ) ; <nl> const tmpDir = testUtils . getTmpDirPath ( ) ; <nl> fse . mkdirSync ( tmpDir ) ; <nl> const cwd = process . cwd ( ) ; <nl>\n", "msg": "Add explicit ' node ' prefix to command used to invoke serverless on Windows in unit tests .\n", "score": 1}
{"diff_id": 23100, "repo": "meteor/meteor\n", "sha": "21180a20e9e7c2fa21b814f216805ad935e2ae56\n", "time": "2013-10-10T22:32:58Z\n", "diff": "mmm a / packages / ui / fields . js <nl> ppp b / packages / ui / fields . js <nl> _extend ( UI . Component , { <nl> } <nl> <nl> return function ( / * arguments * / ) { <nl> - var data = getComponentData ( self ) ; <nl> - if ( typeof result = = = ' function ' ) <nl> + if ( typeof result = = = ' function ' ) { <nl> + var data = getComponentData ( self ) ; <nl> return result . apply ( data , arguments ) ; <nl> + } <nl> return result ; <nl> } ; <nl> } , <nl>\n", "msg": "only access data if needed in comp . lookup\n", "score": 1}
{"diff_id": 23299, "repo": "Automattic/mongoose\n", "sha": "79d16ea9f91cacbe99eab725562b2c5c6cd865d1\n", "time": "2013-07-16T19:00:44Z\n", "diff": "mmm a / lib / model . js <nl> ppp b / lib / model . js <nl> function handleSave ( promise , self ) { <nl> * # # # # Example : <nl> * <nl> * product . sold = Date . now ( ) ; <nl> - * product . save ( function ( err , product ) { <nl> + * product . save ( function ( err , product , numberAffected ) { <nl> * if ( err ) . . <nl> * } ) <nl> * <nl> + * The callback will receive three parameters , ` err ` if an error occurred , ` product ` which is the saved ` product ` , and ` numberAffected ` which will be 1 when the document was found and updated in the database , otherwise 0 . <nl> + * <nl> * The ` fn ` callback is optional . If no ` fn ` is passed and validation fails , the validation error will be emitted on the connection used to create this model . <nl> * <nl> * var db = mongoose . createConnection ( . . ) ; <nl>\n", "msg": "docs ; document third param to document . save callback\n", "score": 1}
{"diff_id": 23336, "repo": "facebook/react-native\n", "sha": "c82893be8abf6726b2e69b020f8248bffff88511\n", "time": "2015-03-31T23:07:17Z\n", "diff": "mmm a / Libraries / JavaScriptAppEngine / Initialization / InitializeJavaScriptAppEngine . js <nl> ppp b / Libraries / JavaScriptAppEngine / Initialization / InitializeJavaScriptAppEngine . js <nl> function setupDocumentShim ( ) { <nl> if ( GLOBAL . document ) { <nl> GLOBAL . document . createElement = null ; <nl> } <nl> + <nl> + / / There is no DOM so MutationObserver doesn ' t make sense . It is used <nl> + / / as feature detection in Bluebird Promise implementation <nl> + GLOBAL . MutationObserver = undefined ; <nl> } <nl> <nl> function handleErrorWithRedBox ( e ) { <nl>\n", "msg": "[ ReactNative ] Remove global MutationObserver to fix Bluebird feature detection\n", "score": 1}
{"diff_id": 23371, "repo": "emberjs/ember.js\n", "sha": "7541db25af1a0a5b3e3e4300321d616e14a3027e\n", "time": "2018-12-06T23:08:59Z\n", "diff": "mmm a / packages / internal - test - helpers / lib / module - for . js <nl> ppp b / packages / internal - test - helpers / lib / module - for . js <nl> import { all } from ' rsvp ' ; <nl> <nl> export default function moduleFor ( description , TestClass , . . . mixins ) { <nl> QUnit . module ( description , { <nl> - beforeEach : function ( . . . args ) { <nl> - let instance = new TestClass ( . . . args ) ; <nl> + beforeEach : function ( assert ) { <nl> + let instance = new TestClass ( assert ) ; <nl> this . instance = instance ; <nl> if ( instance . beforeEach ) { <nl> - return instance . beforeEach ( . . . args ) ; <nl> + return instance . beforeEach ( assert ) ; <nl> } <nl> } , <nl> <nl>\n", "msg": "Refactor ` new Thing ( . . . args ) ` to avoid ` construct ` babel helper .\n", "score": 1}
{"diff_id": 23419, "repo": "balderdashy/sails\n", "sha": "223e22052f48aa1ec36854c08db64e8289fc94c3\n", "time": "2012-07-31T07:37:27Z\n", "diff": "mmm a / lib / router . js <nl> ppp b / lib / router . js <nl> var urlMappings = { <nl> } ; <nl> <nl> / / Extend mappings from main file <nl> - urlMappings = _ . extend ( mappings , config . urlMappings | | { } ) ; <nl> + urlMappings = _ . extend ( urlMappings , config . urlMappings | | { } ) ; <nl> <nl> / / Extend mappings from config directory ( legacy method ) <nl> if ( path . existsSync ( config . appPath + ' / config / mappings . js ' ) ) { <nl> - urlMappings = _ . extend ( mappings , require ( config . appPath + ' / config / mappings ' ) . customMappings ( ) ) ; <nl> + urlMappings = _ . extend ( urlMappings , require ( config . appPath + ' / config / mappings ' ) . customMappings ( ) ) ; <nl> } <nl> <nl> <nl>\n", "msg": "Added support for mappings specified in main driver file ( while maintaining support for legacy method )\n", "score": 1}
{"diff_id": 23512, "repo": "facebook/react-native\n", "sha": "550db2fda09b6a152dc104d89cd054d09dedf927\n", "time": "2016-06-27T17:58:31Z\n", "diff": "mmm a / website / core / WebPlayer . js <nl> ppp b / website / core / WebPlayer . js <nl> var WebPlayer = React . createClass ( { <nl> style = { { marginTop : 4 } } <nl> width = ' 880 ' <nl> height = { this . parseParams ( this . props . params ) . platform = = = ' android ' ? ' 425 ' : ' 420 ' } <nl> - data - src = { ` / / cdn . rawgit . com / dabbott / react - native - web - player / v0 . 1 . 3 / index . html $ { hash } ` } <nl> + data - src = { ` / / npmcdn . com / react - native - web - player @ 1 . 0 . 0 / index . html $ { hash } ` } <nl> frameBorder = ' 0 ' <nl> / > <nl> < / div > <nl>\n", "msg": "Use npmcdn in docs instead of rawgit for web player\n", "score": 1}
{"diff_id": 23597, "repo": "balderdashy/sails\n", "sha": "4211ce46b15a7dc422579f5a35ec07ec4ce02d0c\n", "time": "2012-12-13T03:02:18Z\n", "diff": "mmm a / test / MySQLAdapter . test . js <nl> ppp b / test / MySQLAdapter . test . js <nl> <nl> / / Test MySQLAdapter <nl> - var mysql = require ( ' . / adapters / MySQLAdapter . js ' ) ; <nl> - require ( ' . / crud . test . js ' ) ( mysql ) ; <nl> \\ No newline at end of file <nl> + require ( ' . / crud . test . js ' ) ( require ( ' . / adapters / MySQLAdapter . js ' ) ) ; <nl> \\ No newline at end of file <nl>\n", "msg": "Set up better unit testing interface for existing code and newly added adapters .\n", "score": 1}
{"diff_id": 23737, "repo": "serverless/serverless\n", "sha": "b732a33998374b5111b49b5d40900112943790e8\n", "time": "2015-10-06T14:14:18Z\n", "diff": "mmm a / lib / commands / deploy_lambda . js <nl> ppp b / lib / commands / deploy_lambda . js <nl> Packager . prototype . _browserifyBundle = Promise . method ( function ( ) { <nl> b . transform ( babelify ) <nl> } <nl> <nl> + if ( _this . _awsmJson . lambda . package . optimize . transform ) { <nl> + b . transform ( _this . _awsmJson . lambda . package . optimize . transform ) ; <nl> + } <nl> + <nl> / / optimize . exclude <nl> _this . _awsmJson . lambda . package . optimize . exclude . forEach ( function ( file ) { <nl> b . exclude ( file ) ; <nl>\n", "msg": "Added support for ' transform ' option in browserify , necessary for supporting non - babel transformers like coffeeify .\n", "score": 1}
{"diff_id": 23793, "repo": "ajaxorg/ace\n", "sha": "6bc991d551d7fb30e64e6cc1b6947b80845f6609\n", "time": "2015-09-01T11:57:09Z\n", "diff": "mmm a / Makefile . dryice . js <nl> ppp b / Makefile . dryice . js <nl> function buildAceModuleInternal ( opts , callback ) { <nl> filters . push ( exportAce ( ns , opts . require [ 0 ] , <nl> opts . noconflict ? ns : \" \" , projectType = = \" ext \" ) ) ; <nl> } <nl> - <nl> + <nl> + filters . push ( normalizeLineEndings ) ; <nl> + <nl> filters . forEach ( function ( f ) { code = f ( code ) ; } ) ; <nl> <nl> build . writeToFile ( { code : code } , { <nl> function getLoadedFileList ( options , callback , result ) { <nl> } <nl> <nl> function normalizeLineEndings ( module ) { <nl> - module . source = module . source . replace ( / \\ r \\ n / g , \" \\ n \" ) ; <nl> + if ( typeof module = = \" string \" ) <nl> + module = { source : module } ; <nl> + return module . source = module . source . replace ( / \\ r \\ n / g , \" \\ n \" ) ; <nl> } <nl> <nl> function optimizeTextModules ( sources ) { <nl> function namespace ( ns ) { <nl> text = text <nl> . toString ( ) <nl> . replace ( / ACE_NAMESPACE \\ s * = \\ s * \" \" / , ' ACE_NAMESPACE = \" ' + ns + ' \" ' ) <nl> - . replace ( / ( \\ . define ) | \\ bdefine \\ ( / g , function ( _ , a ) { <nl> - return a | | ns + \" . define ( \" ; <nl> + . replace ( / \\ bdefine \\ ( / g , function ( def , index , source ) { <nl> + if ( / ( ^ | [ ; } ) ] ) \\ s * $ / . test ( source . slice ( 0 , index ) ) ) <nl> + return ns + \" . \" + def ; <nl> + return def ; <nl> } ) ; <nl> <nl> return text ; <nl>\n", "msg": "better handling of windows new lines in build script\n", "score": 1}
{"diff_id": 23968, "repo": "meteor/meteor\n", "sha": "ec69e6d9997189b76f63cac94d40e64aad23afdd\n", "time": "2016-12-19T17:36:48Z\n", "diff": "mmm a / tools / isobuild / import - scanner . js <nl> ppp b / tools / isobuild / import - scanner . js <nl> export default class ImportScanner { <nl> } <nl> <nl> if ( oldFile [ name ] ! = = newFile [ name ] ) { <nl> + const fuzzyCase = <nl> + oldFile . sourcePath . toLowerCase ( ) = = = newFile . sourcePath . toLowerCase ( ) ; <nl> + <nl> throw new Error ( <nl> - \" Attempting to combine different files : \\ n \" + <nl> + \" Attempting to combine different files \" + <nl> + ( fuzzyCase ? \" ( is the filename case slightly different ? ) \" : \" \" ) + <nl> + \" : \\ n \" + <nl> inspect ( omit ( oldFile , \" dataString \" ) ) + \" \\ n \" + <nl> inspect ( omit ( newFile , \" dataString \" ) ) + \" \\ n \" <nl> ) ; <nl>\n", "msg": "Improve helpfulness of error message when combining different files\n", "score": 1}
{"diff_id": 24176, "repo": "codemirror/CodeMirror\n", "sha": "1221eef59e0e13171238ca2418f9bf20b3d5f311\n", "time": "2014-02-14T11:56:12Z\n", "diff": "mmm a / lib / codemirror . js <nl> ppp b / lib / codemirror . js <nl> window . CodeMirror = ( function ( ) { <nl> / / Self - resetting timeout for the poller <nl> d . poll = new Delayed ( ) ; <nl> <nl> - d . cachedCharWidth = d . cachedTextHeight = null ; <nl> + d . cachedCharWidth = d . cachedTextHeight = d . cachedPaddingH = null ; <nl> d . measureLineCache = [ ] ; <nl> d . measureLineCachePos = 0 ; <nl> <nl> window . CodeMirror = ( function ( ) { <nl> function updateSelectionRange ( cm ) { <nl> var display = cm . display , doc = cm . doc , sel = cm . doc . sel ; <nl> var fragment = document . createDocumentFragment ( ) ; <nl> - var clientWidth = display . lineSpace . offsetWidth , pl = paddingLeft ( cm . display ) ; <nl> + var padding = paddingH ( cm . display ) , leftSide = padding . left , rightSide = display . lineSpace . offsetWidth - padding . right ; <nl> <nl> function add ( left , top , width , bottom ) { <nl> if ( top < 0 ) top = 0 ; <nl> fragment . appendChild ( elt ( \" div \" , null , \" CodeMirror - selected \" , \" position : absolute ; left : \" + left + <nl> - \" px ; top : \" + top + \" px ; width : \" + ( width = = null ? clientWidth - left : width ) + <nl> + \" px ; top : \" + top + \" px ; width : \" + ( width = = null ? rightSide - left : width ) + <nl> \" px ; height : \" + ( bottom - top ) + \" px \" ) ) ; <nl> } <nl> <nl> window . CodeMirror = ( function ( ) { <nl> left = leftPos . left ; <nl> right = rightPos . right ; <nl> } <nl> - if ( fromArg = = null & & from = = 0 ) left = pl ; <nl> + if ( fromArg = = null & & from = = 0 ) left = leftSide ; <nl> if ( rightPos . top - leftPos . top > 3 ) { / / Different lines , draw top part <nl> add ( left , leftPos . top , null , leftPos . bottom ) ; <nl> - left = pl ; <nl> + left = leftSide ; <nl> if ( leftPos . bottom < rightPos . top ) add ( left , leftPos . bottom , null , rightPos . top ) ; <nl> } <nl> - if ( toArg = = null & & to = = lineLen ) right = clientWidth ; <nl> + if ( toArg = = null & & to = = lineLen ) right = rightSide ; <nl> if ( ! start | | leftPos . top < start . top | | leftPos . top = = start . top & & leftPos . left < start . left ) <nl> start = leftPos ; <nl> if ( ! end | | rightPos . bottom > end . bottom | | rightPos . bottom = = end . bottom & & rightPos . right > end . right ) <nl> end = rightPos ; <nl> - if ( left < pl + 1 ) left = pl ; <nl> + if ( left < leftSide + 1 ) left = leftSide ; <nl> add ( left , rightPos . top , right - left , rightPos . bottom ) ; <nl> } ) ; <nl> return { start : start , end : end } ; <nl> window . CodeMirror = ( function ( ) { <nl> if ( singleVLine ) { <nl> if ( leftEnd . top < rightStart . top - 2 ) { <nl> add ( leftEnd . right , leftEnd . top , null , leftEnd . bottom ) ; <nl> - add ( pl , rightStart . top , rightStart . left , rightStart . bottom ) ; <nl> + add ( leftSide , rightStart . top , rightStart . left , rightStart . bottom ) ; <nl> } else { <nl> add ( leftEnd . right , leftEnd . top , rightStart . left - leftEnd . right , leftEnd . bottom ) ; <nl> } <nl> } <nl> if ( leftEnd . bottom < rightStart . top ) <nl> - add ( pl , leftEnd . bottom , null , rightStart . top ) ; <nl> + add ( leftSide , leftEnd . bottom , null , rightStart . top ) ; <nl> } <nl> <nl> removeChildrenAndAdd ( display . selectionDiv , fragment ) ; <nl> window . CodeMirror = ( function ( ) { <nl> <nl> function paddingTop ( display ) { return display . lineSpace . offsetTop ; } <nl> function paddingVert ( display ) { return display . mover . offsetHeight - display . lineSpace . offsetHeight ; } <nl> - function paddingLeft ( display ) { <nl> - var e = removeChildrenAndAdd ( display . measure , elt ( \" pre \" , null , null , \" text - align : left \" ) ) . appendChild ( elt ( \" span \" , \" x \" ) ) ; <nl> - return e . offsetLeft ; <nl> + function paddingH ( display ) { <nl> + if ( display . cachedPaddingH ) return display . cachedPaddingH ; <nl> + var e = removeChildrenAndAdd ( display . measure , elt ( \" pre \" , \" x \" ) ) ; <nl> + var style = window . getComputedStyle ? window . getComputedStyle ( e ) : e . currentStyle ; <nl> + return display . cachedPaddingH = { left : parseInt ( style . paddingLeft ) , <nl> + right : parseInt ( style . paddingRight ) } ; <nl> } <nl> <nl> function measureChar ( cm , line , ch , data , bias ) { <nl> window . CodeMirror = ( function ( ) { <nl> <nl> function clearCaches ( cm ) { <nl> cm . display . measureLineCache . length = cm . display . measureLineCachePos = 0 ; <nl> - cm . display . cachedCharWidth = cm . display . cachedTextHeight = null ; <nl> + cm . display . cachedCharWidth = cm . display . cachedTextHeight = cm . display . cachedPaddingH = null ; <nl> if ( ! cm . options . lineWrapping ) cm . display . maxLineChanged = true ; <nl> cm . display . lineNumChars = null ; <nl> } <nl> window . CodeMirror = ( function ( ) { <nl> if ( resizeTimer = = null ) resizeTimer = setTimeout ( function ( ) { <nl> resizeTimer = null ; <nl> / / Might be a text scaling operation , clear size caches . <nl> - d . cachedCharWidth = d . cachedTextHeight = knownScrollbarWidth = null ; <nl> + d . cachedCharWidth = d . cachedTextHeight = d . cachedPaddingH = knownScrollbarWidth = null ; <nl> clearCaches ( cm ) ; <nl> runInOp ( cm , bind ( regChange , cm ) ) ; <nl> } , 100 ) ; <nl>\n", "msg": "Use a saner ( and cheaper ) way to pad the selection\n", "score": 1}
{"diff_id": 24610, "repo": "meteor/meteor\n", "sha": "b216de95550aadd9781538a737df5ba8fa98cc77\n", "time": "2014-03-07T20:36:45Z\n", "diff": "mmm a / tools / commands . js <nl> ppp b / tools / commands . js <nl> main . registerCommand ( { <nl> } , function ( options ) { <nl> <nl> var cat = release . current . catalog ; <nl> + var failed = false ; <nl> <nl> / / Read in existing package dependencies . <nl> var usingDirectly = project . getDepsAsObj ( project . getDirectDependencies ( options . appDir ) ) ; <nl> main . registerCommand ( { <nl> / / solver and add the right stuff to . meteor / package and <nl> / / . meteor / versions files . <nl> _ . each ( options . args , function ( packageReq ) { <nl> + if ( failed ) <nl> + return ; <nl> <nl> var constraint = project . processPackageConstraint ( packageReq ) ; <nl> <nl> if ( ! cat . getPackage ( constraint . packageName ) ) { <nl> process . stderr . write ( constraint . packageName + \" : no such package \\ n \" ) ; <nl> - process . exit ( 1 ) ; <nl> + failed = true ; <nl> + return ; <nl> } <nl> var versionInfo = cat . getVersion ( <nl> constraint . packageName , <nl> main . registerCommand ( { <nl> if ( ! versionInfo ) { <nl> process . stderr . write ( <nl> constraint . packageName + \" @ \" + constraint . versionConstraint + \" : no such version \\ n \" ) ; <nl> - process . exit ( 1 ) ; <nl> + failed = true ; <nl> + return ; <nl> } <nl> <nl> if ( _ . has ( usingDirectly , constraint . packageName ) ) { <nl> if ( usingDirectly [ constraint . packageName ] = = = constraint . versionConstraint ) { <nl> process . stderr . write ( constraint . packageName + \" @ \" + constraint . versionConstraint + \" : already added \\ n \" ) ; <nl> - process . exit ( 1 ) ; <nl> + failed = true ; <nl> + return ; <nl> } else if ( ! constraint . versionConstraint & & ( usingDirectly [ constraint . packageName ] = = = \" none \" ) ) { <nl> process . stderr . write ( constraint . packageName + \" : already added \\ n \" ) ; <nl> - process . exit ( 1 ) ; <nl> + failed = true ; <nl> + return ; <nl> } <nl> } else { <nl> / / Add the package to the list of packages that we use directly . <nl> constraint . packageName + \" @ \" + constraint . versionConstraint + \" : no such versio <nl> usingIndirectly , <nl> { optionsGoHere : false } ) ; <nl> _ . forEach ( newVersions , function ( version , packageName ) { <nl> + if ( failed ) <nl> + return ; <nl> + <nl> / / Find the build . <nl> / / XXX : Find the one with the right architecture . <nl> var versionInfo = cat . getVersion ( packageName , version ) ; <nl> constraint . packageName + \" @ \" + constraint . versionConstraint + \" : no such versio <nl> / / constraint solver is doing something it shouldn ' t . <nl> if ( ! versionInfo ) { <nl> process . stderr . write ( \" This package has no version at this version \" ) ; <nl> - process . exit ( 1 ) ; <nl> + failed = true ; <nl> + return ; <nl> } <nl> <nl> / / Make sure we have enough builds of the package downloaded such that <nl> constraint . packageName + \" @ \" + constraint . versionConstraint + \" : no such versio <nl> process . stderr . write ( \" Package \" + packageName + <nl> \" has no compatible build for version \" + <nl> version ) ; <nl> - process . exit ( 1 ) ; <nl> + failed = true ; <nl> + return ; <nl> } <nl> <nl> - <nl> + / / XXX shouldn ' t log a message yet as we could still fail <nl> process . stdout . write ( \" Added : \" + packageName + \" at \" + version + \" \\ n \" ) ; <nl> } ) ; <nl> <nl> + if ( failed ) <nl> + return ; <nl> + <nl> / / Write the new indirect dependencies file . <nl> project . rewriteIndirectDependencies ( options . appDir , newVersions ) ; <nl> <nl> constraint . packageName + \" @ \" + constraint . versionConstraint + \" : no such versio <nl> process . stdout . write ( constraint . packageName + \" : \" + note + \" \\ n \" ) ; <nl> } <nl> } ) ; <nl> + <nl> + return failed ? 1 : 0 ; <nl> } ) ; <nl> <nl> <nl>\n", "msg": "return cleanly from add - package rather than call process . exit\n", "score": 1}
{"diff_id": 24643, "repo": "Leaflet/Leaflet\n", "sha": "53f57cb45fb005038433252d34d86957c125d438\n", "time": "2012-10-03T21:12:57Z\n", "diff": "mmm a / src / layer / vector / Path . SVG . js <nl> ppp b / src / layer / vector / Path . SVG . js <nl> L . Path = L . Path . extend ( { <nl> } <nl> <nl> this . _fireMouseEvent ( e ) ; <nl> + <nl> + if ( this . hasEventListeners ( e . type ) ) { <nl> + L . DomEvent . stopPropagation ( e ) ; <nl> + } <nl> } , <nl> <nl> _fireMouseEvent : function ( e ) { <nl>\n", "msg": "Allow click events on Path . SVG elements to fall through if they are not handled .\n", "score": 1}
{"diff_id": 25309, "repo": "vercel/next.js\n", "sha": "4f0592a58426e7ef7cb30e8c85f5eeb43e1faa33\n", "time": "2017-07-30T20:22:38Z\n", "diff": "mmm a / examples / with - material - ui - next / components / withRoot . js <nl> ppp b / examples / with - material - ui - next / components / withRoot . js <nl> function withRoot ( BaseComponent ) { <nl> < JssProvider registry = { context . sheetsRegistry } jss = { context . jss } > <nl> < MuiThemeProvider theme = { context . theme } sheetsManager = { context . sheetsManager } > <nl> < AppWrapper > <nl> - < BaseComponent / > <nl> + < BaseComponent { . . . this . props } / > <nl> < / AppWrapper > <nl> < / MuiThemeProvider > <nl> < / JssProvider > <nl>\n", "msg": "Material - UI example : Pass through unrelated props to wrapped component ( )\n", "score": 1}
{"diff_id": 25410, "repo": "balderdashy/sails\n", "sha": "7fbda9274fa33b9c1605a890bf1320ca53789923\n", "time": "2013-03-16T04:16:32Z\n", "diff": "mmm a / lib / policies . js <nl> ppp b / lib / policies . js <nl> module . exports = runPolicy ; <nl> function runPolicy ( controllerName , actionName , req , res , next ) { <nl> <nl> / / TODO : move this to configuration . js so the server won ' t be allowed to start w / invalid policies <nl> - if ( ! sails . config . policies | | ! _ . isObject ( sails . config . policies ) | | ! sails . config . policies [ ' * ' ] ) { <nl> + if ( ! sails . config . policies | | ! _ . isObject ( sails . config . policies ) | | _ . isUndefined ( sails . config . policies [ ' * ' ] ) ) { <nl> sails . log . error ( ' Invalid policy configuration : Missing default * policy ! ' ) ; <nl> console . log ( sails . config . policies ) ; <nl> process . exit ( 1 ) ; <nl>\n", "msg": "Allow default ' * ' policy to be set to false ( switched config validity check to look for undefined , not just falsy values . )\n", "score": 1}
{"diff_id": 25513, "repo": "mui-org/material-ui\n", "sha": "616efbcb5064e7f9b43726758f872634fe102886\n", "time": "2018-08-20T18:31:20Z\n", "diff": "mmm a / docs / scripts / buildApi . js <nl> ppp b / docs / scripts / buildApi . js <nl> function buildDocs ( options ) { <nl> / * * <nl> * Collect classes comments from the source <nl> * / <nl> - const stylesRegexp = / export const styles . * \\ n ( . * \\ n ) * } ; \\ n \\ n / ; <nl> - const styleRegexp = / \\ / \\ * ( . * ) \\ * \\ / \\ n \\ s * ( \\ w * ) / g ; <nl> + const stylesRegexp = / export const styles . * [ \\ r \\ n ] ( . * [ \\ r \\ n ] ) * } ; [ \\ r \\ n ] [ \\ r \\ n ] / ; <nl> + const styleRegexp = / \\ / \\ * ( . * ) \\ * \\ / [ \\ r \\ n ] \\ s * ( \\ w * ) / g ; <nl> / / Extract the styles section from the source <nl> const stylesSrc = stylesRegexp . exec ( styleSrc ) ; <nl> if ( stylesSrc ) { <nl>\n", "msg": "[ core ] Better Windows support for the API generation ( )\n", "score": 1}
{"diff_id": 25643, "repo": "facebook/create-react-app\n", "sha": "1dcb3db3edb809e64208c0540a7de0d41fc9f6ce\n", "time": "2018-03-20T11:27:23Z\n", "diff": "mmm a / packages / eslint - config - react - app / index . js <nl> ppp b / packages / eslint - config - react - app / index . js <nl> module . exports = { <nl> ' no - unused - vars ' : [ <nl> ' warn ' , <nl> { <nl> - args : ' none ' , <nl> + args : ' all ' , <nl> ignoreRestSiblings : true , <nl> } , <nl> ] , <nl>\n", "msg": "Change no - unused - vars ' args ' from none to all to show warning on destructured objects\n", "score": 1}
{"diff_id": 25684, "repo": "photonstorm/phaser\n", "sha": "d28a928663902f6873628b3bf5c21dad88132587\n", "time": "2018-05-04T13:34:19Z\n", "diff": "mmm a / src / loader / filetypes / MultiAtlasFile . js <nl> ppp b / src / loader / filetypes / MultiAtlasFile . js <nl> var MultiAtlasFile = new Class ( { <nl> this . addToMultiFile ( image ) ; <nl> <nl> loader . addFile ( image ) ; <nl> + <nl> + / / \" normalMap \" : \" texture - packer - multi - atlas - 0_n . png \" , <nl> + if ( textures [ i ] . normalMap ) <nl> + { <nl> + var normalMap = new ImageFile ( loader , key , textures [ i ] . normalMap , textureXhrSettings ) ; <nl> + <nl> + normalMap . type = ' normalMap ' ; <nl> + <nl> + image . setLink ( normalMap ) ; <nl> + <nl> + this . addToMultiFile ( normalMap ) ; <nl> + <nl> + loader . addFile ( normalMap ) ; <nl> + } <nl> } <nl> <nl> / / Reset the loader settings <nl> var MultiAtlasFile = new Class ( { <nl> <nl> var data = [ ] ; <nl> var images = [ ] ; <nl> + var normalMaps = [ ] ; <nl> <nl> for ( var i = 1 ; i < this . files . length ; i + + ) <nl> { <nl> - var key = this . files [ i ] . key . substr ( 4 ) ; <nl> - var image = this . files [ i ] . data ; <nl> + var file = this . files [ i ] ; <nl> + <nl> + if ( file . type = = = ' normalMap ' ) <nl> + { <nl> + continue ; <nl> + } <nl> + <nl> + var key = file . key . substr ( 4 ) ; <nl> + var image = file . data ; <nl> <nl> / / Now we need to find out which json entry this mapped to <nl> for ( var t = 0 ; t < fileJSON . data . textures . length ; t + + ) <nl> var MultiAtlasFile = new Class ( { <nl> if ( item . image = = = key ) <nl> { <nl> images . push ( image ) ; <nl> + <nl> data . push ( item ) ; <nl> + <nl> + if ( file . linkFile ) <nl> + { <nl> + normalMaps . push ( file . linkFile . data ) ; <nl> + } <nl> + <nl> break ; <nl> } <nl> } <nl> } <nl> <nl> - this . loader . textureManager . addAtlasJSONArray ( this . key , images , data ) ; <nl> + if ( normalMaps . length = = = 0 ) <nl> + { <nl> + normalMaps = undefined ; <nl> + } <nl> + <nl> + this . loader . textureManager . addAtlasJSONArray ( this . key , images , data , normalMaps ) ; <nl> <nl> this . complete = true ; <nl> <nl>\n", "msg": "Added normal map support for multi - atlas parsing\n", "score": 1}
{"diff_id": 25919, "repo": "meteor/meteor\n", "sha": "c2b2deb0d60f88d1cf9407b43f32567b25593fd5\n", "time": "2013-10-05T01:19:57Z\n", "diff": "mmm a / examples / parties / client / client . js <nl> ppp b / examples / parties / client / client . js <nl> <nl> Meteor . subscribe ( \" directory \" ) ; <nl> Meteor . subscribe ( \" parties \" ) ; <nl> <nl> - / / If no party selected , select one . <nl> + / / If no party selected , or if the selected party was deleted , select one . <nl> Meteor . startup ( function ( ) { <nl> Deps . autorun ( function ( ) { <nl> - if ( ! Session . get ( \" selected \" ) ) { <nl> + var selected = Session . get ( \" selected \" ) ; <nl> + if ( ! selected | | ! Parties . findOne ( selected ) ) { <nl> var party = Parties . findOne ( ) ; <nl> if ( party ) <nl> Session . set ( \" selected \" , party . _id ) ; <nl> + else <nl> + Session . set ( \" selected \" , null ) ; <nl> } <nl> } ) ; <nl> } ) ; <nl>\n", "msg": "parties example : force selection to an actually - existing party .\n", "score": 1}
{"diff_id": 26531, "repo": "photonstorm/phaser\n", "sha": "c6493b59c33995169ef74912c7cae99eb1e6dc2e\n", "time": "2014-09-01T01:44:35Z\n", "diff": "mmm a / src / core / ScaleManager . js <nl> ppp b / src / core / ScaleManager . js <nl> Phaser . ScaleManager = function ( game , width , height ) { <nl> * / <nl> this . _scaleMode = Phaser . ScaleManager . NO_SCALE ; <nl> <nl> - / * * <nl> - * @ property { number } _startHeight - Internal cache var . Stage height when starting the game . <nl> - * @ private <nl> - * / <nl> - this . _startHeight = 0 ; <nl> - <nl> / * * <nl> * @ property { number } _width - Cached stage width for full screen mode . <nl> * @ private <nl> Phaser . ScaleManager . prototype = { <nl> / / We can ' t do anything about the status bars in iPads , web apps or desktops <nl> if ( ! this . game . device . iPad & & ! this . game . device . webApp & & ! this . game . device . desktop ) <nl> { <nl> - / / TODO - Test this <nl> - / / this . _startHeight = window . innerHeight ; <nl> - <nl> if ( this . game . device . android & & ! this . game . device . chrome ) <nl> { <nl> window . scrollTo ( 0 , 1 ) ; <nl> Phaser . ScaleManager . prototype = { <nl> <nl> this . _iterations - - ; <nl> <nl> - if ( force | | window . innerHeight > this . _startHeight | | this . _iterations < 0 ) <nl> + if ( force | | this . _iterations < 0 ) <nl> { <nl> / / Set minimum height of content to new window height <nl> document . documentElement [ ' style ' ] . minHeight = window . innerHeight + ' px ' ; <nl>\n", "msg": "Removed use of _startHeight , left over from the Phaser v1 days that ' s no longer required .\n", "score": 1}
{"diff_id": 26875, "repo": "photonstorm/phaser\n", "sha": "ecc85b447ce0ff46dacff3994d951aa87ff5f41c\n", "time": "2018-10-09T17:14:25Z\n", "diff": "mmm a / src / dom / ScaleManager . js <nl> ppp b / src / dom / ScaleManager . js <nl> <nl> * @ license { @ link https : / / github . com / photonstorm / phaser / blob / master / license . txt | MIT License } <nl> * / <nl> <nl> - var CONST = require ( ' . / const ' ) ; <nl> - var Class = require ( ' . . / utils / Class ' ) ; <nl> var Clamp = require ( ' . . / math / Clamp ' ) ; <nl> + var Class = require ( ' . . / utils / Class ' ) ; <nl> + var CONST = require ( ' . / const ' ) ; <nl> + var GetOffset = require ( ' . / GetOffset ' ) ; <nl> + var GetScreenOrientation = require ( ' . / GetScreenOrientation ' ) ; <nl> + var LayoutBounds = require ( ' . / LayoutBounds ' ) ; <nl> var Rectangle = require ( ' . . / geom / rectangle / Rectangle ' ) ; <nl> var SameDimensions = require ( ' . . / geom / rectangle / SameDimensions ' ) ; <nl> var Vec2 = require ( ' . . / math / Vector2 ' ) ; <nl> + var VisualBounds = require ( ' . / VisualBounds ' ) ; <nl> <nl> / * * <nl> * @ classdesc <nl> var ScaleManager = new Class ( { <nl> <nl> this . _createdFullScreenTarget = null ; <nl> <nl> - this . screenOrientation = ' portrait - primary ' ; <nl> - / / this . screenOrientation = this . dom . getScreenOrientation ( ) ; <nl> + this . screenOrientation ; <nl> <nl> this . scaleFactor = new Vec2 ( 1 , 1 ) ; <nl> <nl> var ScaleManager = new Class ( { <nl> <nl> this . onResizeContext = null ; <nl> <nl> - this . _pendingScaleMode = null ; <nl> + this . _pendingScaleMode = game . config . scaleMode ; <nl> <nl> this . _fullScreenRestore = null ; <nl> <nl> var ScaleManager = new Class ( { <nl> <nl> boot : function ( ) <nl> { <nl> - / / this . _innerHeight = this . getInnerHeight ( ) ; <nl> - / / var gameWidth = this . config . width ; <nl> - / / var gameHeight = this . config . height ; <nl> - <nl> / / Configure device - dependent compatibility <nl> <nl> var game = this . game ; <nl> var ScaleManager = new Class ( { <nl> compat . clickTrampoline = ' ' ; <nl> } <nl> <nl> - / / Configure event listeners <nl> + / / Configure event listeners <nl> <nl> var _this = this ; <nl> <nl> var ScaleManager = new Class ( { <nl> return _this . windowResize ( event ) ; <nl> } ; <nl> <nl> - / / This does not appear to be on the standards track <nl> window . addEventListener ( ' orientationchange ' , this . _orientationChange , false ) ; <nl> window . addEventListener ( ' resize ' , this . _windowResize , false ) ; <nl> <nl> - if ( this . compatibility . supportsFullScreen ) <nl> + if ( compat . supportsFullScreen ) <nl> { <nl> this . _fullScreenChange = function ( event ) <nl> { <nl> var ScaleManager = new Class ( { <nl> document . addEventListener ( ' MSFullscreenError ' , this . _fullScreenError , false ) ; <nl> } <nl> <nl> - this . game . events . on ( ' resume ' , this . gameResumed , this ) ; <nl> + game . events . on ( ' resume ' , this . gameResumed , this ) ; <nl> <nl> / / Initialize core bounds <nl> <nl> - / / this . dom . getOffset ( this . game . canvas , this . offset ) ; <nl> + / / Set - up the Bounds <nl> + var isDesktop = os . desktop & & ( document . documentElement . clientWidth < = window . innerWidth ) & & ( document . documentElement . clientHeight < = window . innerHeight ) ; <nl> + <nl> + VisualBounds . init ( isDesktop ) ; <nl> + LayoutBounds . init ( isDesktop ) ; <nl> + <nl> + GetOffset ( game . canvas , this . offset ) ; <nl> <nl> this . bounds . setTo ( this . offset . x , this . offset . y , this . width , this . height ) ; <nl> <nl> - this . setGameSize ( this . game . width , this . game . height ) ; <nl> + console . log ( this . offset . x , this . offset . y , this . width , this . height ) ; <nl> + <nl> + this . setGameSize ( game . config . width , game . config . height ) ; <nl> <nl> / / Don ' t use updateOrientationState so events are not fired <nl> - / / this . screenOrientation = this . dom . getScreenOrientation ( this . compatibility . orientationFallback ) ; <nl> + this . screenOrientation = GetScreenOrientation ( compat . orientationFallback ) ; <nl> <nl> this . _booted = true ; <nl> <nl> if ( this . _pendingScaleMode ! = = null ) <nl> { <nl> this . scaleMode = this . _pendingScaleMode ; <nl> + <nl> this . _pendingScaleMode = null ; <nl> } <nl> <nl> game . events . on ( ' prestep ' , this . step , this ) ; <nl> + <nl> + this . setupScale ( game . config . width , game . config . height ) ; <nl> } , <nl> <nl> setupScale : function ( width , height ) <nl> var ScaleManager = new Class ( { <nl> } <nl> else if ( parent & & parent . nodeType = = = 1 ) <nl> { <nl> - / / Quick test for a HTMLelement <nl> + / / Quick test for a HTMLElement <nl> target = parent ; <nl> } <nl> } <nl> <nl> - / / Fallback , covers an invalid ID and a non HTMLelement object <nl> + / / Fallback , covers an invalid ID and a non HTMLElement object <nl> if ( ! target ) <nl> { <nl> / / Use the full window <nl> this . parentNode = null ; <nl> this . parentIsWindow = true ; <nl> <nl> - rect . width = this . dom . visualBounds . width ; <nl> - rect . height = this . dom . visualBounds . height ; <nl> + rect . width = VisualBounds . width ; <nl> + rect . height = VisualBounds . height ; <nl> <nl> this . offset . set ( 0 , 0 ) ; <nl> } <nl> var ScaleManager = new Class ( { <nl> this . _gameSize . setTo ( 0 , 0 , newWidth , newHeight ) ; <nl> <nl> this . updateDimensions ( newWidth , newHeight , false ) ; <nl> + <nl> + console . log ( ' setupscale ' , this . _parentBounds ) ; <nl> } , <nl> <nl> gameResumed : function ( ) <nl> var ScaleManager = new Class ( { <nl> } <nl> <nl> var prevThrottle = this . _updateThrottle ; <nl> + <nl> this . _updateThrottleReset = ( prevThrottle > = 400 ) ? 0 : 100 ; <nl> <nl> - / / this . dom . getOffset ( this . game . canvas , this . offset ) ; <nl> + GetOffset ( this . game . canvas , this . offset ) ; <nl> <nl> var prevWidth = this . _parentBounds . width ; <nl> var prevHeight = this . _parentBounds . height ; <nl> var ScaleManager = new Class ( { <nl> <nl> updateScalingAndBounds : function ( ) <nl> { <nl> + var game = this . game ; <nl> var config = this . config ; <nl> <nl> - this . scaleFactor . x = this . config . width / this . width ; <nl> - this . scaleFactor . y = this . config . height / this . height ; <nl> + this . scaleFactor . x = config . width / this . width ; <nl> + this . scaleFactor . y = config . height / this . height ; <nl> <nl> - this . scaleFactorInversed . x = this . width / this . config . width ; <nl> - this . scaleFactorInversed . y = this . height / this . config . height ; <nl> + this . scaleFactorInversed . x = this . width / config . width ; <nl> + this . scaleFactorInversed . y = this . height / config . height ; <nl> <nl> this . aspectRatio = this . width / this . height ; <nl> <nl> / / This can be invoked in boot pre - canvas <nl> - if ( this . game . canvas ) <nl> + if ( game . canvas ) <nl> { <nl> - / / this . dom . getOffset ( this . game . canvas , this . offset ) ; <nl> + GetOffset ( game . canvas , this . offset ) ; <nl> } <nl> <nl> this . bounds . setTo ( this . offset . x , this . offset . y , this . width , this . height ) ; <nl> <nl> / / Can be invoked in boot pre - input <nl> - if ( this . game . input & & this . game . input . scale ) <nl> + if ( game . input & & game . input . scale ) <nl> { <nl> - / / this . game . input . scale . setTo ( this . scaleFactor . x , this . scaleFactor . y ) ; <nl> + / / game . input . scale . setTo ( this . scaleFactor . x , this . scaleFactor . y ) ; <nl> } <nl> } , <nl> <nl> var ScaleManager = new Class ( { <nl> var previousOrientation = this . screenOrientation ; <nl> var previouslyIncorrect = this . incorrectOrientation ; <nl> <nl> - / / this . screenOrientation = this . dom . getScreenOrientation ( this . compatibility . orientationFallback ) ; <nl> + this . screenOrientation = GetScreenOrientation ( this . compatibility . orientationFallback ) ; <nl> <nl> this . incorrectOrientation = ( this . forceLandscape & & ! this . isLandscape ) | | ( this . forcePortrait & & ! this . isPortrait ) ; <nl> <nl> var ScaleManager = new Class ( { <nl> if ( bounds = = = undefined ) { bounds = new Rectangle ( ) ; } <nl> if ( parentNode = = = undefined ) { parentNode = this . boundingParent ; } <nl> <nl> - var visualBounds = this . dom . visualBounds ; <nl> - var layoutBounds = this . dom . layoutBounds ; <nl> + var visualBounds = VisualBounds ; <nl> + var layoutBounds = LayoutBounds ; <nl> <nl> if ( ! parentNode ) <nl> { <nl> var ScaleManager = new Class ( { <nl> <nl> setMaximum : function ( ) <nl> { <nl> - this . width = this . dom . visualBounds . width ; <nl> - this . height = this . dom . visualBounds . height ; <nl> + this . width = VisualBounds . width ; <nl> + this . height = VisualBounds . height ; <nl> } , <nl> <nl> setShowAll : function ( expanding ) <nl>\n", "msg": "Updated to use DOM components and hook into game flow\n", "score": 1}
{"diff_id": 26950, "repo": "balderdashy/sails\n", "sha": "a9650ad497b3b77c4a3bafd80c129863b90383a8\n", "time": "2017-12-19T23:09:36Z\n", "diff": "mmm a / lib / hooks / helpers / index . js <nl> ppp b / lib / hooks / helpers / index . js <nl> var iterateHelpers = require ( ' . / private / iterate - helpers ' ) ; <nl> <nl> module . exports = function ( sails ) { <nl> <nl> + / / Private variable used below to keep track of whether a compatibility <nl> + / / warning message might need to be displayed . <nl> + var _prereleaseCompatWarning ; <nl> + <nl> return { <nl> <nl> <nl> module . exports = function ( sails ) { <nl> configure : function ( ) { <nl> <nl> / / Check SVR of the ` sails ` dep in this app ' s package . json file . <nl> + / / <nl> / / If it points at a 1 . 0 prerelease less than ` 1 . 0 . 0 - 44 ` , then log a warning <nl> / / explaining what ' s going on with helpers ( we needed to make a breaking <nl> / / change in a prerelease ) , and that the old way can be achieved through <nl> module . exports = function ( sails ) { <nl> if ( isMinSVRPointedAtSensitiveV1Prerelease ) { <nl> sails . config . helpers . usageOpts . arginStyle = ' named ' ; <nl> sails . config . helpers . usageOpts . execStyle = ' deferred ' ; <nl> - sails . log . warn ( <nl> - ' Based on its package . json file , it looks like this app was generated using the Sails beta , ' + <nl> - ' but with a version prior to v1 . 0 . 0 - 44 . ( It depends on sails @ ' + localSailsSVR + ' . ) ' + <nl> - ' But in the 1 . 0 . 0 - 44 prerelease , a change was introduced that makes helpers support standard , ' + <nl> - ' serial usage like ` . changePassword ( \\ ' abc123 \\ ' ) , rather than always being forced to use named ' + <nl> - ' parameters like ` . changePassword ( { password : \\ ' abc123 \\ ' } ) ` . \\ n ' + <nl> - ' To avoid breaking this app , backwards - compatible settings have been set automatically for ' + <nl> - ' you this time to keep your helpers compatible . ( But be sure to resolve this as soon as possible , ' + <nl> - ' or you might lift one day soon and realize your helpers don \\ ' t work ! ) \\ n ' + <nl> - ' To resolve this , either : \\ n ' + <nl> - '  ( A ) configure ` sails . config . helpers . usageOpts . arginStyle ` as \" named \" and also ' + <nl> - ' ` sails . config . helpers . usageOpts . execStyle ` as \" deferred \" ` , which will make everything ' + <nl> - ' work the way it did before . \\ n ' + <nl> - '  or ( B ) change any code in this app that invokes helpers . You \\ ' ll need to either take ' + <nl> - ' advantage of serial usage in your app , configure the aforementioned usage opts , or tack on ' + <nl> - ' ` . with ( ) ` every time you call a helper to continue using named parameters . Then update the ' + <nl> - ' ` sails ` dependency in your package . json file so that it satisfies ^ 1 . 0 . 0 - 44 . \\ n ' + <nl> - ' ( This warning will continue to display until this has been solved one way or the other . ) \\ n ' + <nl> - ' [ ? ] If you \\ ' re unsure , visit https : / / sailsjs . com / support \\ n ' <nl> - ) ; <nl> + <nl> + / / Note that we don ' t actually log the warning right now - - we won ' t do that <nl> + / / until a bit later , in . initialize ( ) . Even then , we ' ll only actually log <nl> + / / the warning if there are helpers defined in the app . ( Because if there <nl> + / / aren ' t any helpers , logging a warning would just be annoying ! ) <nl> + _prereleaseCompatWarning = <nl> + ' mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm \\ n ' + <nl> + ' Based on its package . json file , it looks like this app was generated \\ n ' + <nl> + ' using the Sails beta , but with a version prior to v1 . 0 . 0 - 44 . \\ n ' + <nl> + ' ( This app depends on sails @ ' + localSailsSVR + ' . ) \\ n ' + <nl> + ' \\ n ' + <nl> + ' But in the 1 . 0 . 0 - 44 prerelease , a change was introduced . By default , \\ n ' + <nl> + ' helpers now expect serial arguments instead of a dictionary of named \\ n ' + <nl> + ' parameters . In other words , you \\ ' d now call : \\ n ' + <nl> + ' await sails . helpers . passwords . changePassword ( \\ ' abc123 \\ ' ) \\ n ' + <nl> + ' Instead of : \\ n ' + <nl> + ' await sails . helpers . passwords . changePassword ( { password : \\ ' abc123 \\ ' } ) \\ n ' + <nl> + ' \\ n ' + <nl> + ' To avoid breaking this app , some special settings that make Sails \\ n ' + <nl> + ' backwards - compatible have been set automatically for you . But please \\ n ' + <nl> + ' be sure to take the steps below to resolve this as soon as possible . \\ n ' + <nl> + ' ( What if you forgot about this and changed your package . json file ? \\ n ' + <nl> + ' You might inadvertently remove this compatibility check . . . And if \\ n ' + <nl> + ' that were to happen , the next time you tried to lift your app , your \\ n ' + <nl> + ' helpers would no longer work ! ) \\ n ' + <nl> + ' \\ n ' + <nl> + ' To resolve this , use one of the following solutions : \\ n ' + <nl> + ' \\ n ' + <nl> + ' ( A ) < < < < Quick & dirty > > > > \\ n ' + <nl> + ' If you need a quick fix , nestle this in your . sailsrc file : \\ n ' + <nl> + ' \" helpers \" : { \\ n ' + <nl> + ' \" usageOpts \" : { \\ n ' + <nl> + ' \" arginStyle \" : \" named \" , \\ n ' + <nl> + ' \" execStyle \" : \" deferred \" \\ n ' + <nl> + ' } \\ n ' + <nl> + ' } \\ n ' + <nl> + ' ( This will make everything work exactly the way it did before . ) \\ n ' + <nl> + ' \\ n ' + <nl> + ' ( B ) < < < < Recommended > > > > \\ n ' + <nl> + ' Change any relevant code in this app ( e . g . ` sails . helpers .  ( {  } ) ` ) \\ n ' + <nl> + ' so that it takes advantage of serial usage or . with ( ) . Then update \\ n ' + <nl> + ' the ` sails ` dependency in your package . json file so that it \\ n ' + <nl> + ' satisfies ^ 1 . 0 . 0 - 44 or higher . \\ n ' + <nl> + ' \\ n ' + <nl> + ' Note that , if you go with this solution , then you can still use \\ n ' + <nl> + ' . with ( ) to call helpers with named parameters on a one - off basis . \\ n ' + <nl> + ' For example : \\ n ' + <nl> + ' await sails . helpers . changePassword . with ( { password : \\ ' abc123 \\ ' } ) ; \\ n ' + <nl> + ' \\ n ' + <nl> + ' \\ n ' + <nl> + ' ( This warning will continue to display until this has been solved \\ n ' + <nl> + ' one way or the other . To hide this message , use one of the solutions \\ n ' + <nl> + ' suggested above . ) \\ n ' + <nl> + ' \\ n ' + <nl> + ' [ ? ] If you \\ ' re unsure , visit https : / / sailsjs . com / support \\ n ' + <nl> + ' mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm \\ n ' ; <nl> } / /  <nl> } / /  <nl> <nl> module . exports = function ( sails ) { <nl> initialize : function ( done ) { <nl> <nl> / / Load helpers from the appropriate folder . <nl> - loadHelpers ( sails , done ) ; <nl> + loadHelpers ( sails , function ( err ) { <nl> + if ( err ) { return done ( err ) ; } <nl> + <nl> + / / If deemed relevant , log the prerelease compatibility warning that <nl> + / / we built above . ( Then clear it out , since we don ' t want to ever <nl> + / / display it again during this \" lift \" cycle - - even if the experimental <nl> + / / . reload ( ) method is in use . ) <nl> + if ( _prereleaseCompatWarning & & _ . keys ( sails . helpers ) . length > 0 ) { <nl> + sails . log . warn ( _prereleaseCompatWarning ) ; <nl> + _prereleaseCompatWarning = ' ' ; <nl> + } <nl> + <nl> + return done ( ) ; <nl> + } ) ; / / _  _ <nl> <nl> } , <nl> <nl>\n", "msg": "Don ' t log prerelease compat . warning unless there are actually any helpers . Also , improve the warning message a bit .\n", "score": 1}
{"diff_id": 27293, "repo": "facebook/react-native\n", "sha": "38062cf8a7e17bbfa976f1b9332706d7cd032876\n", "time": "2020-09-03T13:46:09Z\n", "diff": "mmm a / Libraries / ReactNative / renderApplication . js <nl> ppp b / Libraries / ReactNative / renderApplication . js <nl> function renderApplication < Props : Object > ( <nl> ) { <nl> invariant ( rootTag , ' Expect to have a valid rootTag , instead got ' , rootTag ) ; <nl> <nl> + const performanceLogger = scopedPerformanceLogger ? ? GlobalPerformanceLogger ; <nl> + <nl> const renderable = ( <nl> - < PerformanceLoggerContext . Provider <nl> - value = { scopedPerformanceLogger ? ? GlobalPerformanceLogger } > <nl> + < PerformanceLoggerContext . Provider value = { performanceLogger } > <nl> < AppContainer <nl> rootTag = { rootTag } <nl> fabric = { fabric } <nl> function renderApplication < Props : Object > ( <nl> < / PerformanceLoggerContext . Provider > <nl> ) ; <nl> <nl> - GlobalPerformanceLogger . startTimespan ( ' renderApplication_React_render ' ) ; <nl> + performanceLogger . startTimespan ( ' renderApplication_React_render ' ) ; <nl> if ( fabric ) { <nl> require ( ' . . / Renderer / shims / ReactFabric ' ) . render ( renderable , rootTag ) ; <nl> } else { <nl> require ( ' . . / Renderer / shims / ReactNative ' ) . render ( renderable , rootTag ) ; <nl> } <nl> - GlobalPerformanceLogger . stopTimespan ( ' renderApplication_React_render ' ) ; <nl> + performanceLogger . stopTimespan ( ' renderApplication_React_render ' ) ; <nl> } <nl> <nl> module . exports = renderApplication ; <nl>\n", "msg": "Log renderApplication_React_render timespan to scoped performance logger if available\n", "score": 1}
{"diff_id": 27514, "repo": "meteor/meteor\n", "sha": "5b00fa1fac26466f3fce9bd71f5009ec605687b1\n", "time": "2015-08-26T17:26:52Z\n", "diff": "mmm a / tools / cli / commands - cordova . js <nl> ppp b / tools / cli / commands - cordova . js <nl> import files from ' . . / fs / files . js ' ; <nl> import * as cordova from ' . . / cordova ' ; <nl> import { CordovaProject } from ' . . / cordova / project . js ' ; <nl> <nl> + function displayNameForHostPlatform ( platform = process . platform ) { <nl> + switch ( platform ) { <nl> + case ' darwin ' : <nl> + return \" Mac \" ; <nl> + case ' linux ' : <nl> + return \" Linux \" ; <nl> + case ' win32 ' : <nl> + return \" Windows \" ; <nl> + } <nl> + } <nl> + <nl> function createProjectContext ( appDir ) { <nl> const projectContext = new ProjectContext ( { <nl> projectDir : appDir <nl> main . registerCommand ( { <nl> } , function ( options ) { <nl> Console . setVerbose ( ! ! options . verbose ) ; <nl> <nl> - var platform = options . args [ 0 ] ; <nl> - platform = platform . trim ( ) . toLowerCase ( ) ; <nl> + const platform = options . args [ 0 ] ; <nl> <nl> - if ( platform ! = \" android \" & & platform ! = \" ios \" ) { <nl> + if ( ! _ . contains ( cordova . AVAILABLE_PLATFORMS , platform ) ) { <nl> Console . warn ( ` Unknown platform : $ { platform } ` ) ; <nl> - Console . info ( \" Valid platforms are : android , ios \" ) ; <nl> + Console . info ( ` Valid platforms are : \\ <nl> + $ { cordova . AVAILABLE_PLATFORMS . join ( ' , ' ) } ` ) ; <nl> return 1 ; <nl> } <nl> <nl> - / / TODO <nl> + const hostPlatformName = displayNameForHostPlatform ( ) ; <nl> + <nl> + if ( hostPlatformName ) { <nl> + const page = ` Mobile - Dev - Install : - $ { cordova . displayNameForPlatform ( platform ) } - on - $ { hostPlatformName } ` ; <nl> + const url = ` https : / / github . com / meteor / meteor / wiki / $ { page } ` ; <nl> + Console . info ( \" Please follow the instructions here : \" ) ; <nl> + Console . info ( Console . url ( url ) ) ; <nl> + } else { <nl> + Console . info ( \" We don ' t have installation instructions for your platform \" ) ; <nl> + } <nl> <nl> return 0 ; <nl> } ) ; <nl>\n", "msg": "Print link to host and platform - specific Wiki page for install - sdk command\n", "score": 1}
{"diff_id": 28432, "repo": "meteor/meteor\n", "sha": "01518749b72ea7ae0925867dfd07b025ae4dd4dc\n", "time": "2015-02-03T03:28:00Z\n", "diff": "mmm a / tools / profile - require . js <nl> ppp b / tools / profile - require . js <nl> RequireInvocation . prototype . isOurCode = function ( ) { <nl> if ( ! self . name . match ( / \\ / / ) ) <nl> return false ; / / we always require our stuff via a path <nl> <nl> - var files = require ( ' . / files . js ' ) ; <nl> - var ourSource = files . pathResolve ( __dirname ) ; <nl> - var required = files . pathResolve ( files . pathDirname ( self . filename ) , self . name ) ; <nl> + / / it is OK to use path here and not files . js as we are just checking the path <nl> + var path = require ( ' path ' ) ; <nl> + var ourSource = path . resolve ( __dirname ) ; <nl> + var required = path . resolve ( path . dirname ( self . filename ) , self . name ) ; <nl> if ( ourSource . length > required . length ) <nl> return false ; <nl> return required . substr ( 0 , ourSource . length ) = = = ourSource ; <nl>\n", "msg": "make profile - require . js not to require files . js\n", "score": 1}
{"diff_id": 28681, "repo": "preactjs/preact\n", "sha": "ba1ae15ed6e7e70c4f4b55f84c6633e4cb28f0c6\n", "time": "2018-11-06T08:35:13Z\n", "diff": "mmm a / src / diff / children . js <nl> ppp b / src / diff / children . js <nl> import { coerceToVNode } from ' . . / create - element ' ; <nl> * Diff the children of a virtual node <nl> * @ param { import ( ' . . / internal ' ) . PreactElement } dom The DOM element whose <nl> * children are being diffed <nl> - * @ param { Array < import ( ' . . / internal ' ) . VNode > } newVNodeChildren The new virtual <nl> + * @ param { Array < import ( ' . . / internal ' ) . VNode > } children The new virtual <nl> * children <nl> - * @ param { Array < import ( ' . . / internal ' ) . VNode > } oldVNodeChildren The old virtual <nl> + * @ param { Array < import ( ' . . / internal ' ) . VNode > } oldChildren The old virtual <nl> * children <nl> * @ param { object } context The current context object <nl> * @ param { boolean } isSvg Whether or not this DOM node is an SVG node <nl> import { coerceToVNode } from ' . . / create - element ' ; <nl> * @ param { import ( ' . . / internal ' ) . VNode } parentVNode Used to set ` _lastDomChild ` <nl> * pointer to keep track of our current position <nl> * / <nl> - export function diffChildren ( dom , newVNodeChildren , oldVNodeChildren , context , isSvg , excessDomChildren , mounts , ancestorComponent , parentVNode ) { <nl> + export function diffChildren ( dom , children , oldChildren , context , isSvg , excessDomChildren , mounts , ancestorComponent , parentVNode ) { <nl> let childVNode , i , j , p , index , oldVNode , newDom , <nl> - oldChildrenLength = oldVNodeChildren . length , <nl> + oldChildrenLength = oldChildren . length , <nl> childDom = typeof parentVNode . type = = ' number ' ? parentVNode . _dom : dom . firstChild , <nl> nextDom , lastDom , sibDom ; <nl> <nl> - for ( i = 0 ; i < newVNodeChildren . length ; i + + ) { <nl> - childVNode = newVNodeChildren [ i ] = coerceToVNode ( newVNodeChildren [ i ] ) ; <nl> + for ( i = 0 ; i < children . length ; i + + ) { <nl> + childVNode = children [ i ] = coerceToVNode ( children [ i ] ) ; <nl> oldVNode = index = null ; <nl> <nl> / / Check if we find a corresponding element in oldChildren and store the <nl> / / index where the element was found . <nl> - p = oldVNodeChildren [ i ] ; <nl> + p = oldChildren [ i ] ; <nl> if ( p ! = null & & ( childVNode . key = = null & & p . key = = null ? ( childVNode . type = = = p . type ) : ( childVNode . key = = = p . key ) ) ) { <nl> index = i ; <nl> } <nl> else { <nl> for ( j = 0 ; j < oldChildrenLength ; j + + ) { <nl> - p = oldVNodeChildren [ j ] ; <nl> + p = oldChildren [ j ] ; <nl> if ( p ! = null ) { <nl> if ( childVNode . key = = null & & p . key = = null ? ( childVNode . type = = = p . type ) : ( childVNode . key = = = p . key ) ) { <nl> index = j ; <nl> export function diffChildren ( dom , newVNodeChildren , oldVNodeChildren , context , i <nl> / / and delete it from the array . That way the next iteration can skip this <nl> / / element . <nl> if ( index ! = null ) { <nl> - oldVNode = oldVNodeChildren [ index ] ; <nl> - oldVNodeChildren [ index ] = null ; <nl> + oldVNode = oldChildren [ index ] ; <nl> + oldChildren [ index ] = null ; <nl> } <nl> <nl> nextDom = childDom ! = null & & childDom . nextSibling ; <nl> export function diffChildren ( dom , newVNodeChildren , oldVNodeChildren , context , i <nl> j = 0 ; <nl> while ( ( sibDom = sibDom . nextSibling ) & & j + + < oldChildrenLength / 2 ) { <nl> if ( sibDom = = = newDom ) { <nl> - oldVNodeChildren [ index ] = childDom . _prevVNode ; <nl> + oldChildren [ index ] = childDom . _prevVNode ; <nl> break outer ; <nl> } <nl> } <nl> export function diffChildren ( dom , newVNodeChildren , oldVNodeChildren , context , i <nl> if ( excessDomChildren ! = null ) for ( i = excessDomChildren . length ; i - - ; ) excessDomChildren [ i ] . remove ( ) ; <nl> <nl> / / Remove remaining oldChildren if there are any . <nl> - for ( i = oldVNodeChildren . length ; i - - ; ) if ( oldVNodeChildren [ i ] ! = null ) unmount ( oldVNodeChildren [ i ] , ancestorComponent ) ; <nl> + for ( i = oldChildren . length ; i - - ; ) if ( oldChildren [ i ] ! = null ) unmount ( oldChildren [ i ] , ancestorComponent ) ; <nl> } <nl>\n", "msg": "Remove ` VNode ` specifier from some ` diffChildren ` args to reduce verboseness\n", "score": 1}
{"diff_id": 29006, "repo": "ajaxorg/ace\n", "sha": "a7025742a45fe6ce336eccde47e98cf316617c45\n", "time": "2012-04-09T18:50:33Z\n", "diff": "mmm a / lib / ace / mode / xml_highlight_rules . js <nl> ppp b / lib / ace / mode / xml_highlight_rules . js <nl> var XmlHighlightRules = function ( ) { <nl> token : \" text \" , <nl> regex : \" \\ \\ s + \" <nl> } , { <nl> - token : \" entity . reference \" , <nl> + token : \" constant . character . entity \" , <nl> regex : \" ( ? : & # [ 0 - 9 ] + ; ) | ( ? : & # x [ 0 - 9a - fA - F ] + ; ) | ( ? : & [ a - zA - Z0 - 9_ : \\ \\ . - ] + ; ) \" <nl> } , { <nl> token : \" text \" , <nl>\n", "msg": "Change entity . reference to constant . character . entity\n", "score": 1}
{"diff_id": 29146, "repo": "photonstorm/phaser\n", "sha": "ca795af457313e6b3d9d9af8a2b3e1d4ca340c94\n", "time": "2015-09-01T22:50:03Z\n", "diff": "mmm a / src / gameobjects / Text . js <nl> ppp b / src / gameobjects / Text . js <nl> Phaser . Text . prototype . updateText = function ( ) { <nl> { <nl> / / Simple layout ( no tabs ) <nl> var lineWidth = this . context . measureText ( lines [ i ] ) . width + this . style . strokeThickness + this . padding . x ; <nl> + <nl> + / / Adjust for wrapped text <nl> + if ( this . style . wordWrap ) <nl> + { <nl> + lineWidth - = this . context . measureText ( ' ' ) . width ; <nl> + } <nl> } <nl> else <nl> { <nl>\n", "msg": "adjust wrapped text that is centered to sprite via anchor\n", "score": 1}
{"diff_id": 29225, "repo": "atom/atom\n", "sha": "174672d00bade996f52b4681ab2e3d9a61fe2422\n", "time": "2018-01-16T05:34:43Z\n", "diff": "mmm a / src / project . js <nl> ppp b / src / project . js <nl> class Project extends Model { <nl> / / <nl> / / This method will be removed in 2 . 0 because it does synchronous I / O . <nl> / / Prefer the following , which evaluates to a { Promise } that resolves to an <nl> - / / { Array } of { Repository } objects : <nl> + / / { Array } of { GitRepository } objects : <nl> / / ` ` ` <nl> / / Promise . all ( atom . project . getDirectories ( ) . map ( <nl> / / atom . project . repositoryForDirectory . bind ( atom . project ) ) ) <nl> class Project extends Model { <nl> <nl> / / Public : Get the repository for a given directory asynchronously . <nl> / / <nl> - / / * ` directory ` { Directory } for which to get a { Repository } . <nl> + / / * ` directory ` { Directory } for which to get a { GitRepository } . <nl> / / <nl> / / Returns a { Promise } that resolves with either : <nl> - / / * { Repository } if a repository can be created for the given directory <nl> + / / * { GitRepository } if a repository can be created for the given directory <nl> / / * ` null ` if no repository can be created for the given directory . <nl> repositoryForDirectory ( directory ) { <nl> const pathForDirectory = directory . getRealPathSync ( ) <nl>\n", "msg": "Update all { Repository } to { GitRepository }\n", "score": 1}
{"diff_id": 29510, "repo": "emberjs/ember.js\n", "sha": "742cbaa9094361c7e9938bba969cbaf8be778853\n", "time": "2015-09-04T02:37:32Z\n", "diff": "mmm a / packages / ember - htmlbars / lib / hooks / create - fresh - scope . js <nl> ppp b / packages / ember - htmlbars / lib / hooks / create - fresh - scope . js <nl> import EmptyObject from ' ember - metal / empty_object ' ; <nl> * / <nl> <nl> function Scope ( parent ) { <nl> - this . _self = null ; <nl> - this . _blocks = null ; <nl> - this . _component = null ; <nl> - this . _view = null ; <nl> - this . _attrs = null ; <nl> - this . _locals = null ; <nl> - this . _localPresent = null ; <nl> - this . overrideController = null ; <nl> + this . _self = undefined ; <nl> + this . _blocks = undefined ; <nl> + this . _component = undefined ; <nl> + this . _view = undefined ; <nl> + this . _attrs = undefined ; <nl> + this . _locals = undefined ; <nl> + this . _localPresent = undefined ; <nl> + this . overrideController = undefined ; <nl> this . parent = parent ; <nl> } <nl> <nl> proto . bindLocal = function ( name , value ) { <nl> } ; <nl> <nl> const EMPTY = { <nl> + _self : undefined , <nl> + _blocks : undefined , <nl> + _component : undefined , <nl> + _view : undefined , <nl> + _attrs : undefined , <nl> + _locals : undefined , <nl> + _localPresent : undefined , <nl> + overrideController : undefined , <nl> + <nl> getSelf ( ) { return null ; } , <nl> bindSelf ( self ) { return null ; } , <nl> updateSelf ( self , key ) { return null ; } , <nl>\n", "msg": "Use ` undefined ` for Scope initial values .\n", "score": 1}
{"diff_id": 29768, "repo": "mozilla/pdf.js\n", "sha": "56eeeea1dca9b9a4ee4a43e74614e91e0a518695\n", "time": "2019-03-16T12:06:51Z\n", "diff": "mmm a / src / core / operator_list . js <nl> ppp b / src / core / operator_list . js <nl> var OperatorList = ( function OperatorListClosure ( ) { <nl> var CHUNK_SIZE = 1000 ; <nl> var CHUNK_SIZE_ABOUT = CHUNK_SIZE - 5 ; / / close to chunk size <nl> <nl> - function getTransfers ( queue ) { <nl> - var transfers = [ ] ; <nl> - var fnArray = queue . fnArray , argsArray = queue . argsArray ; <nl> - for ( var i = 0 , ii = queue . length ; i < ii ; i + + ) { <nl> - switch ( fnArray [ i ] ) { <nl> - case OPS . paintInlineImageXObject : <nl> - case OPS . paintInlineImageXObjectGroup : <nl> - case OPS . paintImageMaskXObject : <nl> - var arg = argsArray [ i ] [ 0 ] ; / / first param in imgData <nl> - <nl> - if ( typeof PDFJSDev = = = ' undefined ' | | <nl> - PDFJSDev . test ( ' ! PRODUCTION | | TESTING ' ) ) { <nl> - assert ( arg . data instanceof Uint8ClampedArray , <nl> - ' OperatorList - getTransfers : Unsupported \" arg . data \" type . ' ) ; <nl> - } <nl> - if ( ! arg . cached ) { <nl> - transfers . push ( arg . data . buffer ) ; <nl> - } <nl> - break ; <nl> - } <nl> - } <nl> - return transfers ; <nl> - } <nl> - <nl> function OperatorList ( intent , messageHandler , pageIndex ) { <nl> this . messageHandler = messageHandler ; <nl> this . fnArray = [ ] ; <nl> var OperatorList = ( function OperatorListClosure ( ) { <nl> } ; <nl> } , <nl> <nl> - flush ( lastChunk ) { <nl> + get _transfers ( ) { <nl> + const transfers = [ ] ; <nl> + const { fnArray , argsArray , length , } = this ; <nl> + for ( let i = 0 ; i < length ; i + + ) { <nl> + switch ( fnArray [ i ] ) { <nl> + case OPS . paintInlineImageXObject : <nl> + case OPS . paintInlineImageXObjectGroup : <nl> + case OPS . paintImageMaskXObject : <nl> + const arg = argsArray [ i ] [ 0 ] ; / / first param in imgData <nl> + <nl> + if ( typeof PDFJSDev = = = ' undefined ' | | <nl> + PDFJSDev . test ( ' ! PRODUCTION | | TESTING ' ) ) { <nl> + assert ( arg . data instanceof Uint8ClampedArray , <nl> + ' OperatorList . _transfers : Unsupported \" arg . data \" type . ' ) ; <nl> + } <nl> + if ( ! arg . cached ) { <nl> + transfers . push ( arg . data . buffer ) ; <nl> + } <nl> + break ; <nl> + } <nl> + } <nl> + return transfers ; <nl> + } , <nl> + <nl> + flush ( lastChunk = false ) { <nl> this . optimizer . flush ( ) ; <nl> - var transfers = getTransfers ( this ) ; <nl> - var length = this . length ; <nl> + const length = this . length ; <nl> this . _totalLength + = length ; <nl> <nl> this . messageHandler . send ( ' RenderPageChunk ' , { <nl> var OperatorList = ( function OperatorListClosure ( ) { <nl> } , <nl> pageIndex : this . pageIndex , <nl> intent : this . intent , <nl> - } , transfers ) ; <nl> + } , this . _transfers ) ; <nl> + <nl> this . dependencies = Object . create ( null ) ; <nl> this . fnArray . length = 0 ; <nl> this . argsArray . length = 0 ; <nl>\n", "msg": "Re - factor the ` getTransfers ` helper function into a \" private \" getter method on the ` OperatorList `\n", "score": 1}
{"diff_id": 30005, "repo": "facebook/react\n", "sha": "41d5cee44e65787a8121c70bab5f11ea71238d2b\n", "time": "2014-08-05T21:40:11Z\n", "diff": "mmm a / src / core / __tests__ / ReactMultiChildText - test . js <nl> ppp b / src / core / __tests__ / ReactMultiChildText - test . js <nl> var ReactTestUtils = require ( ' ReactTestUtils ' ) ; <nl> <nl> var reactComponentExpect = require ( ' reactComponentExpect ' ) ; <nl> <nl> - var assertNodeText = function ( instance , text ) { <nl> - expect ( instance . getDOMNode ( ) . childNodes . length ) . toBe ( 1 ) ; <nl> - expect ( instance . getDOMNode ( ) . innerHTML ) . toBe ( ' ' + text ) ; <nl> - } ; <nl> + / / Helpers <nl> + var testAllPermutations = function ( testCases ) { <nl> + for ( var i = 0 ; i < testCases . length ; i + = 2 ) { <nl> + var renderWithChildren = testCases [ i ] ; <nl> + var expectedResultAfterRender = testCases [ i + 1 ] ; <nl> <nl> - var assertEmptyNode = function ( instance ) { <nl> - expect ( instance . getDOMNode ( ) . childNodes . length ) . toBe ( 0 ) ; <nl> - } ; <nl> + for ( var j = 0 ; j < testCases . length ; j + = 2 ) { <nl> + var updateWithChildren = testCases [ j ] ; <nl> + var expectedResultAfterUpdate = testCases [ j + 1 ] ; <nl> <nl> - var assertMultiChild = function ( instance , textOne , textTwo ) { <nl> - expect ( instance . getDOMNode ( ) . childNodes . length ) . toBe ( 2 ) ; <nl> - var firstTextDOMNode = <nl> - reactComponentExpect ( instance ) <nl> - . expectRenderedChildAt ( 0 ) <nl> - . toBeTextComponent ( ) <nl> - . instance ( ) <nl> - . getDOMNode ( ) ; <nl> - expect ( firstTextDOMNode . childNodes . length ) . toBe ( textOne = = = ' ' ? 0 : 1 ) ; <nl> - expect ( firstTextDOMNode . innerHTML ) . toBe ( ' ' + textOne ) ; <nl> - <nl> - var secondTextDOMNode = <nl> - reactComponentExpect ( instance ) <nl> - . expectRenderedChildAt ( 1 ) <nl> - . toBeTextComponent ( ) <nl> - . instance ( ) <nl> - . getDOMNode ( ) ; <nl> - expect ( secondTextDOMNode . childNodes . length ) . toBe ( textTwo = = = ' ' ? 0 : 1 ) ; <nl> - expect ( secondTextDOMNode . innerHTML ) . toBe ( ' ' + textTwo ) ; <nl> - } ; <nl> + var d = renderChildren ( renderWithChildren ) ; <nl> + expectChildren ( d , expectedResultAfterRender ) ; <nl> <nl> - var assertSingleChild = function ( instance , text ) { <nl> - expect ( instance . getDOMNode ( ) . childNodes . length ) . toBe ( 1 ) ; <nl> - var textDOMNode = <nl> - reactComponentExpect ( instance ) <nl> - . expectRenderedChildAt ( 0 ) <nl> - . toBeTextComponent ( ) <nl> - . instance ( ) <nl> - . getDOMNode ( ) ; <nl> - expect ( textDOMNode . childNodes . length ) . toBe ( 1 ) ; <nl> - expect ( textDOMNode . innerHTML ) . toBe ( ' ' + text ) ; <nl> + updateChildren ( d , updateWithChildren ) ; <nl> + expectChildren ( d , expectedResultAfterUpdate ) ; <nl> + } <nl> + } <nl> } ; <nl> <nl> - / / Helpers <nl> - var renderSingleTextChild = function ( text ) { <nl> - var d = ReactTestUtils . renderIntoDocument ( < div > { text } < / div > ) ; <nl> - return d ; <nl> + var renderChildren = function ( children ) { <nl> + return ReactTestUtils . renderIntoDocument ( <nl> + React . DOM . div ( { children : children } ) <nl> + ) ; <nl> } ; <nl> - var renderMultipleTextChildren = function ( textOne , textTwo ) { <nl> - var d = ReactTestUtils . renderIntoDocument ( < div > { textOne } { textTwo } < / div > ) ; <nl> - return d ; <nl> + <nl> + var updateChildren = function ( d , children ) { <nl> + d . replaceProps ( { children : children } ) ; <nl> } ; <nl> <nl> - var TestCompositeComponent = React . createClass ( { <nl> - render : function ( ) { <nl> - return ( <nl> - < div > < / div > <nl> - ) ; <nl> + var expectChildren = function ( d , children ) { <nl> + if ( typeof children = = = ' string ' ) { <nl> + var textNode = d . getDOMNode ( ) . firstChild ; <nl> + <nl> + if ( children = = = ' ' ) { <nl> + expect ( textNode ! = null ) . toBe ( false ) ; <nl> + } else { <nl> + expect ( textNode ! = null ) . toBe ( true ) ; <nl> + expect ( textNode . nodeType ) . toBe ( 3 ) ; <nl> + expect ( textNode . data ) . toBe ( ' ' + children ) ; <nl> + } <nl> + } else { <nl> + expect ( d . getDOMNode ( ) . childNodes . length ) . toBe ( children . length ) ; <nl> + <nl> + for ( var i = 0 ; i < children . length ; i + + ) { <nl> + var child = children [ i ] ; <nl> + <nl> + if ( typeof child = = = ' string ' ) { <nl> + var textWrapperNode = <nl> + reactComponentExpect ( d ) <nl> + . expectRenderedChildAt ( i ) <nl> + . toBeTextComponent ( ) <nl> + . instance ( ) ; <nl> + <nl> + expectChildren ( textWrapperNode , child ) ; <nl> + } else { <nl> + var elementDOMNode = <nl> + reactComponentExpect ( d ) <nl> + . expectRenderedChildAt ( i ) <nl> + . toBeComponentOfType ( React . DOM . div ) <nl> + . instance ( ) <nl> + . getDOMNode ( ) ; <nl> + <nl> + expect ( elementDOMNode . tagName ) . toBe ( ' DIV ' ) ; <nl> + } <nl> + } <nl> } <nl> - } ) ; <nl> + } ; <nl> + <nl> <nl> / * * <nl> * ReactMultiChild DOM integration test . In ReactDOM components , we make sure <nl> var TestCompositeComponent = React . createClass ( { <nl> * faster to render and update . <nl> * / <nl> describe ( ' ReactMultiChildText ' , function ( ) { <nl> - it ( ' should render null as empty ' , function ( ) { <nl> - var d = renderSingleTextChild ( null ) ; <nl> - / / false should act exactly as a null child <nl> - assertEmptyNode ( d ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render undefined as empty ' , function ( ) { <nl> - var d = renderSingleTextChild ( undefined ) ; <nl> - / / false should act exactly as a null child <nl> - assertEmptyNode ( d ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render null as empty then switch to text node ' , function ( ) { <nl> - var d = renderSingleTextChild ( null ) ; <nl> - / / false should act exactly as a null child <nl> - assertEmptyNode ( d ) ; <nl> - d . replaceProps ( { children : ' hello ' } ) ; <nl> - assertNodeText ( d , ' hello ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render undefined as empty then switch to text node ' , function ( ) { <nl> - var d = renderSingleTextChild ( undefined ) ; <nl> - / / false should act exactly as a null child <nl> - assertEmptyNode ( d ) ; <nl> - d . replaceProps ( { children : ' hello ' } ) ; <nl> - assertNodeText ( d , ' hello ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render null as empty then switch to span children ' , function ( ) { <nl> - var d = renderSingleTextChild ( null ) ; <nl> - / / false should act exactly as a null child <nl> - assertEmptyNode ( d ) ; <nl> - d . replaceProps ( { children : [ ' hello ' , ' goodbye ' ] } ) ; <nl> - assertMultiChild ( d , ' hello ' , ' goodbye ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render null as empty then switch to span children ' , function ( ) { <nl> - var d = renderSingleTextChild ( undefined ) ; <nl> - / / false should act exactly as a null child <nl> - assertEmptyNode ( d ) ; <nl> - d . replaceProps ( { children : [ ' hello ' , ' goodbye ' ] } ) ; <nl> - assertMultiChild ( d , ' hello ' , ' goodbye ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render zero string as text node then switch to spans ' , function ( ) { <nl> - var d = renderSingleTextChild ( ' 0 ' ) ; <nl> - / / false should act exactly as a null child <nl> - assertNodeText ( d , ' 0 ' ) ; <nl> - d . replaceProps ( { children : [ ' hello ' , ' goodbye ' ] } ) ; <nl> - assertMultiChild ( d , ' hello ' , ' goodbye ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render zero number as text node then switch to spans ' , function ( ) { <nl> - var d = renderSingleTextChild ( 0 ) ; <nl> - / / false should act exactly as a null child <nl> - assertNodeText ( d , ' 0 ' ) ; <nl> - d . replaceProps ( { children : [ ' hello ' , ' goodbye ' ] } ) ; <nl> - assertMultiChild ( d , ' hello ' , ' goodbye ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render a single text child to a single text node ' , function ( ) { <nl> - var d = renderSingleTextChild ( ' hello ' ) ; <nl> - assertNodeText ( d , ' hello ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render two string children to two spans ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( ' hello ' , ' goodbye ' ) ; <nl> - assertMultiChild ( d , ' hello ' , ' goodbye ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render false as a null child ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( false , 234 . 2 ) ; <nl> - / / false should act exactly as a null child <nl> - assertSingleChild ( d , ' 234 . 2 ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render true as a null child ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( true , 234 . 2 ) ; <nl> - / / false should act exactly as a null child <nl> - assertSingleChild ( d , ' 234 . 2 ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render true as a null child ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( true , 234 . 2 ) ; <nl> - / / false should act exactly as a null child <nl> - assertSingleChild ( d , ' 234 . 2 ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render one true as no children ' , function ( ) { <nl> - var d = renderSingleTextChild ( true ) ; <nl> - assertEmptyNode ( d ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render one false as no children ' , function ( ) { <nl> - var d = renderSingleTextChild ( false ) ; <nl> - assertEmptyNode ( d ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render empty string as no children ' , function ( ) { <nl> - var d = renderSingleTextChild ( ' ' ) ; <nl> - assertEmptyNode ( d ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render two empty strings as two empty spans ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( ' ' , ' ' ) ; <nl> - assertMultiChild ( d , ' ' , ' ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render empty string and string as two spans ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( ' ' , ' yo ' ) ; <nl> - assertMultiChild ( d , ' ' , ' yo ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render child string zero as text node ' , function ( ) { <nl> - var d = renderSingleTextChild ( ' 0 ' ) ; <nl> - / / false should act exactly as a null child <nl> - assertNodeText ( d , ' 0 ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render child number zero as text node ' , function ( ) { <nl> - var d = renderSingleTextChild ( 0 ) ; <nl> - / / false should act exactly as a null child <nl> - assertNodeText ( d , ' 0 ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render content string zero as text node ' , function ( ) { <nl> - var d = renderSingleTextChild ( ' 0 ' ) ; <nl> - / / false should act exactly as a null child <nl> - assertNodeText ( d , ' 0 ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render zero string as string child ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( ' 0 ' , 234 . 2 ) ; <nl> - / / false should act exactly as a null child <nl> - assertMultiChild ( d , ' 0 ' , ' 234 . 2 ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render zero string as string child then text node ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( ' 0 ' , 234 . 2 ) ; <nl> - / / false should act exactly as a null child <nl> - assertMultiChild ( d , ' 0 ' , ' 234 . 2 ' ) ; <nl> - d . replaceProps ( { children : ' 0 ' } ) ; <nl> - assertNodeText ( d , ' 0 ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render zero number as string child then text node ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( 0 , 234 . 2 ) ; <nl> - / / false should act exactly as a null child <nl> - assertMultiChild ( d , ' 0 ' , ' 234 . 2 ' ) ; <nl> - d . replaceProps ( { children : 0 } ) ; <nl> - / / BELOW REVEALS A BUG IN JSDOM <nl> - / / assertNodeText ( d , ' 0 ' ) ; / / This works in the browser . <nl> - } ) ; <nl> - <nl> - it ( ' should render multiple children then switch to inline ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( ' hello ' , ' goodbye ' ) ; <nl> - assertMultiChild ( d , ' hello ' , ' goodbye ' ) ; <nl> - d . replaceProps ( { children : ' hello ' } ) ; <nl> - assertNodeText ( d , ' hello ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render multiple children then switch to inline child ' , function ( ) { <nl> - var d = renderMultipleTextChildren ( ' hello ' , ' goodbye ' ) ; <nl> - assertMultiChild ( d , ' hello ' , ' goodbye ' ) ; <nl> - / / Even when switching from content to a single child , it should render <nl> - / / that single child as inline content . <nl> - d . replaceProps ( { children : ' hello ' } ) ; <nl> - assertNodeText ( d , ' hello ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render inline child , then switch to text components ' , function ( ) { <nl> - var d = renderSingleTextChild ( ' hello ' ) ; <nl> - assertNodeText ( d , ' hello ' ) ; <nl> - d . replaceProps ( { children : [ ' hello ' , ' goodbye ' ] } ) ; <nl> - assertMultiChild ( d , ' hello ' , ' goodbye ' ) ; <nl> - } ) ; <nl> - <nl> - it ( ' should render inline child , then switch to composite ' , function ( ) { <nl> - var d = renderSingleTextChild ( ' hello ' ) ; <nl> - assertNodeText ( d , ' hello ' ) ; <nl> - d . replaceProps ( { children : < TestCompositeComponent / > } ) ; <nl> - reactComponentExpect ( d ) <nl> - . expectRenderedChildAt ( 0 ) <nl> - . toBeCompositeComponentWithType ( TestCompositeComponent ) ; <nl> + it ( ' should correctly handle all possible children for render and update ' , function ( ) { <nl> + testAllPermutations ( [ <nl> + / / basic values <nl> + undefined , [ ] , <nl> + null , [ ] , <nl> + false , [ ] , <nl> + true , [ ] , <nl> + 0 , ' 0 ' , <nl> + 1 . 2 , ' 1 . 2 ' , <nl> + ' ' , ' ' , <nl> + ' foo ' , ' foo ' , <nl> + <nl> + [ ] , [ ] , <nl> + [ undefined ] , [ ] , <nl> + [ null ] , [ ] , <nl> + [ false ] , [ ] , <nl> + [ true ] , [ ] , <nl> + [ 0 ] , [ ' 0 ' ] , <nl> + [ 1 . 2 ] , [ ' 1 . 2 ' ] , <nl> + [ ' ' ] , [ ' ' ] , <nl> + [ ' foo ' ] , [ ' foo ' ] , <nl> + [ < div / > ] , [ < div / > ] , <nl> + <nl> + / / two adjacent values <nl> + [ true , 0 ] , [ ' 0 ' ] , <nl> + [ 0 , 0 ] , [ ' 0 ' , ' 0 ' ] , <nl> + [ 1 . 2 , 0 ] , [ ' 1 . 2 ' , ' 0 ' ] , <nl> + [ 0 , ' ' ] , [ ' 0 ' , ' ' ] , <nl> + [ ' foo ' , 0 ] , [ ' foo ' , ' 0 ' ] , <nl> + [ 0 , < div / > ] , [ ' 0 ' , < div / > ] , <nl> + <nl> + [ true , 1 . 2 ] , [ ' 1 . 2 ' ] , <nl> + [ 1 . 2 , 0 ] , [ ' 1 . 2 ' , ' 0 ' ] , <nl> + [ 1 . 2 , 1 . 2 ] , [ ' 1 . 2 ' , ' 1 . 2 ' ] , <nl> + [ 1 . 2 , ' ' ] , [ ' 1 . 2 ' , ' ' ] , <nl> + [ ' foo ' , 1 . 2 ] , [ ' foo ' , ' 1 . 2 ' ] , <nl> + [ 1 . 2 , < div / > ] , [ ' 1 . 2 ' , < div / > ] , <nl> + <nl> + [ true , ' ' ] , [ ' ' ] , <nl> + [ ' ' , 0 ] , [ ' ' , ' 0 ' ] , <nl> + [ 1 . 2 , ' ' ] , [ ' 1 . 2 ' , ' ' ] , <nl> + [ ' ' , ' ' ] , [ ' ' , ' ' ] , <nl> + [ ' foo ' , ' ' ] , [ ' foo ' , ' ' ] , <nl> + [ ' ' , < div / > ] , [ ' ' , < div / > ] , <nl> + <nl> + [ true , ' foo ' ] , [ ' foo ' ] , <nl> + [ ' foo ' , 0 ] , [ ' foo ' , ' 0 ' ] , <nl> + [ 1 . 2 , ' foo ' ] , [ ' 1 . 2 ' , ' foo ' ] , <nl> + [ ' foo ' , ' ' ] , [ ' foo ' , ' ' ] , <nl> + [ ' foo ' , ' foo ' ] , [ ' foo ' , ' foo ' ] , <nl> + [ ' foo ' , < div / > ] , [ ' foo ' , < div / > ] , <nl> + <nl> + / / values separated by an element <nl> + [ true , < div / > , true ] , [ < div / > ] , <nl> + [ 1 . 2 , < div / > , 1 . 2 ] , [ ' 1 . 2 ' , < div / > , ' 1 . 2 ' ] , <nl> + [ ' ' , < div / > , ' ' ] , [ ' ' , < div / > , ' ' ] , <nl> + [ ' foo ' , < div / > , ' foo ' ] , [ ' foo ' , < div / > , ' foo ' ] , <nl> + <nl> + [ true , 1 . 2 , < div / > , ' ' , ' foo ' ] , [ ' 1 . 2 ' , < div / > , ' ' , ' foo ' ] , <nl> + [ 1 . 2 , ' ' , < div / > , ' foo ' , true ] , [ ' 1 . 2 ' , ' ' , < div / > , ' foo ' ] , <nl> + [ ' ' , ' foo ' , < div / > , true , 1 . 2 ] , [ ' ' , ' foo ' , < div / > , ' 1 . 2 ' ] , <nl> + <nl> + [ true , 1 . 2 , ' ' , < div / > , ' foo ' , true , 1 . 2 ] , [ ' 1 . 2 ' , ' ' , < div / > , ' foo ' , ' 1 . 2 ' ] , <nl> + [ ' ' , ' foo ' , true , < div / > , 1 . 2 , ' ' , ' foo ' ] , [ ' ' , ' foo ' , < div / > , ' 1 . 2 ' , ' ' , ' foo ' ] , <nl> + <nl> + / / values inside arrays <nl> + [ [ true ] , [ true ] ] , [ ] , <nl> + [ [ 1 . 2 ] , [ 1 . 2 ] ] , [ ' 1 . 2 ' , ' 1 . 2 ' ] , <nl> + [ [ ' ' ] , [ ' ' ] ] , [ ' ' , ' ' ] , <nl> + [ [ ' foo ' ] , [ ' foo ' ] ] , [ ' foo ' , ' foo ' ] , <nl> + [ [ < div / > ] , [ < div / > ] ] , [ < div / > , < div / > ] , <nl> + <nl> + [ [ true , 1 . 2 , < div / > ] , ' ' , ' foo ' ] , [ ' 1 . 2 ' , < div / > , ' ' , ' foo ' ] , <nl> + [ 1 . 2 , ' ' , [ < div / > , ' foo ' , true ] ] , [ ' 1 . 2 ' , ' ' , < div / > , ' foo ' ] , <nl> + [ ' ' , [ ' foo ' , < div / > , true ] , 1 . 2 ] , [ ' ' , ' foo ' , < div / > , ' 1 . 2 ' ] , <nl> + <nl> + [ true , [ 1 . 2 , ' ' , < div / > , ' foo ' ] , true , 1 . 2 ] , [ ' 1 . 2 ' , ' ' , < div / > , ' foo ' , ' 1 . 2 ' ] , <nl> + [ ' ' , ' foo ' , [ true , < div / > , 1 . 2 , ' ' ] , ' foo ' ] , [ ' ' , ' foo ' , < div / > , ' 1 . 2 ' , ' ' , ' foo ' ] , <nl> + <nl> + / / values inside objects <nl> + [ { a : true } , { a : true } ] , [ ] , <nl> + [ { a : 1 . 2 } , { a : 1 . 2 } ] , [ ' 1 . 2 ' , ' 1 . 2 ' ] , <nl> + [ { a : ' ' } , { a : ' ' } ] , [ ' ' , ' ' ] , <nl> + [ { a : ' foo ' } , { a : ' foo ' } ] , [ ' foo ' , ' foo ' ] , <nl> + [ { a : < div / > } , { a : < div / > } ] , [ < div / > , < div / > ] , <nl> + <nl> + [ { a : true , b : 1 . 2 , c : < div / > } , ' ' , ' foo ' ] , [ ' 1 . 2 ' , < div / > , ' ' , ' foo ' ] , <nl> + [ 1 . 2 , ' ' , { a : < div / > , b : ' foo ' , c : true } ] , [ ' 1 . 2 ' , ' ' , < div / > , ' foo ' ] , <nl> + [ ' ' , { a : ' foo ' , b : < div / > , c : true } , 1 . 2 ] , [ ' ' , ' foo ' , < div / > , ' 1 . 2 ' ] , <nl> + <nl> + [ true , { a : 1 . 2 , b : ' ' , c : < div / > , d : ' foo ' } , true , 1 . 2 ] , [ ' 1 . 2 ' , ' ' , < div / > , ' foo ' , ' 1 . 2 ' ] , <nl> + [ ' ' , ' foo ' , { a : true , b : < div / > , c : 1 . 2 , d : ' ' } , ' foo ' ] , [ ' ' , ' foo ' , < div / > , ' 1 . 2 ' , ' ' , ' foo ' ] , <nl> + <nl> + / / values inside elements <nl> + [ < div > { true } { 1 . 2 } { < div / > } < / div > , ' ' , ' foo ' ] , [ < div / > , ' ' , ' foo ' ] , <nl> + [ 1 . 2 , ' ' , < div > { < div / > } { ' foo ' } { true } < / div > ] , [ ' 1 . 2 ' , ' ' , < div / > ] , <nl> + [ ' ' , < div > { ' foo ' } { < div / > } { true } < / div > , 1 . 2 ] , [ ' ' , < div / > , ' 1 . 2 ' ] , <nl> + <nl> + [ true , < div > { 1 . 2 } { ' ' } { < div / > } { ' foo ' } < / div > , true , 1 . 2 ] , [ < div / > , ' 1 . 2 ' ] , <nl> + [ ' ' , ' foo ' , < div > { true } { < div / > } { 1 . 2 } { ' ' } < / div > , ' foo ' ] , [ ' ' , ' foo ' , < div / > , ' foo ' ] <nl> + ] ) ; <nl> } ) ; <nl> <nl> it ( ' should throw if rendering both HTML and children ' , function ( ) { <nl>\n", "msg": "Simplified and improved test - cases for ReactMultiChildText - test\n", "score": 1}
{"diff_id": 30240, "repo": "preactjs/preact\n", "sha": "8ccb6a5a980a085e04649b578b2327e46e63c53f\n", "time": "2015-10-16T02:21:53Z\n", "diff": "mmm a / src / preact . js <nl> ppp b / src / preact . js <nl> export function render ( component , parent ) { <nl> if ( c ) hook ( c , ' componentWillMount ' ) ; <nl> parent . appendChild ( built ) ; <nl> if ( c ) hook ( c , ' componentDidMount ' ) ; <nl> - return build ; <nl> + return built ; <nl> } <nl> <nl> <nl>\n", "msg": "Return a DOM node from ` render ( ) ` instead of for some reason returning ` build ( ) ` ( an internal method . . )\n", "score": 1}
{"diff_id": 30655, "repo": "select2/select2\n", "sha": "98976946d6e7fc07f6ad57f5b7f3c571e4c5d6a4\n", "time": "2012-09-24T16:22:36Z\n", "diff": "mmm a / select2 . js <nl> ppp b / select2 . js <nl> <nl> var selected = element . find ( \" : selected \" ) ; <nl> / / a single select box always has a value , no need to null check ' selected ' <nl> if ( $ . isFunction ( callback ) ) <nl> - callback ( { id : selected . attr ( \" value \" ) , text : selected . text ( ) } ) ; <nl> + callback ( { id : selected . attr ( \" value \" ) , text : selected . text ( ) , element : selected } ) ; <nl> } ; <nl> } <nl> <nl>\n", "msg": "pass element attr to initSelection for selects upon init\n", "score": 1}
{"diff_id": 30838, "repo": "moment/moment\n", "sha": "f3ba62f6adefd961047a8eef09b499b7d282d296\n", "time": "2011-12-13T08:25:35Z\n", "diff": "mmm a / moment . js <nl> ppp b / moment . js <nl> <nl> relativeDate : function ( ) { <nl> var format = ' YYYY DDDD ' , <nl> unixTimestamp = this . valueOf ( ) , <nl> - arrayKey , nextWeek , lastWeek ; <nl> + arrayKey , nextWeek , lastWeek , <nl> + relativeDateFormat ; <nl> <nl> switch ( this . format ( format ) ) { <nl> case moment ( ) . format ( format ) : <nl> <nl> } <nl> } <nl> <nl> - if ( arrayKey ) { <nl> - return moment . relativeDate [ arrayKey ] . replace ( ' % weekday ' , this . format ( ' dddd ' ) ) . replace ( ' % time ' , this . format ( ' LT ' ) ) ; <nl> + if ( arrayKey & & moment . relativeDate [ arrayKey ] ) { <nl> + relativeDateFormat = moment . relativeDate [ arrayKey ] ; <nl> + <nl> + if ( ' function ' = = = typeof relativeDateFormat ) { <nl> + relativeDateFormat = relativeDateFormat . call ( this ) ; <nl> + } <nl> + return relativeDateFormat . replace ( ' % weekday ' , this . format ( ' dddd ' ) ) . replace ( ' % time ' , this . format ( ' LT ' ) ) ; <nl> } <nl> <nl> return this . format ( moment . relativeDate . else | | ' L ' ) ; <nl>\n", "msg": "adds the possibility to return a function as a relativeDate format\n", "score": 1}
{"diff_id": 31446, "repo": "mozilla/pdf.js\n", "sha": "b2235ec9c46c1e7b5a47dd4d5034fcc856ab6fd3\n", "time": "2019-01-13T10:34:38Z\n", "diff": "mmm a / test / unit / ui_utils_spec . js <nl> ppp b / test / unit / ui_utils_spec . js <nl> describe ( ' ui_utils ' , function ( ) { <nl> scrollOverDocument ( pages , true ) ; <nl> } ) ; <nl> <nl> + it ( ' handles ` sortByVisibility ` correctly ' , function ( ) { <nl> + const scrollEl = { <nl> + scrollTop : 75 , <nl> + scrollLeft : 0 , <nl> + clientHeight : 750 , <nl> + clientWidth : 1500 , <nl> + } ; <nl> + const views = makePages ( [ <nl> + [ [ 100 , 150 ] ] , <nl> + [ [ 100 , 150 ] ] , <nl> + [ [ 100 , 150 ] ] , <nl> + ] ) ; <nl> + <nl> + const visible = getVisibleElements ( scrollEl , views ) ; <nl> + const visibleSorted = getVisibleElements ( scrollEl , views , <nl> + / * sortByVisibility = * / true ) ; <nl> + <nl> + const viewsOrder = [ ] , viewsSortedOrder = [ ] ; <nl> + for ( const view of visible . views ) { <nl> + viewsOrder . push ( view . id ) ; <nl> + } <nl> + for ( const view of visibleSorted . views ) { <nl> + viewsSortedOrder . push ( view . id ) ; <nl> + } <nl> + expect ( viewsOrder ) . toEqual ( [ 0 , 1 , 2 ] ) ; <nl> + expect ( viewsSortedOrder ) . toEqual ( [ 1 , 2 , 0 ] ) ; <nl> + } ) ; <nl> + <nl> it ( ' handles views being empty ' , function ( ) { <nl> const scrollEl = { <nl> scrollTop : 10 , <nl>\n", "msg": "Add a unit - test to check that the ` sortByVisibility ` parameter , in ` getVisibleElements ` , works correctly\n", "score": 1}
{"diff_id": 31556, "repo": "mozilla/pdf.js\n", "sha": "3a302fdb536c7ce1fdc624081dc75d37c6f83824\n", "time": "2017-04-11T15:01:35Z\n", "diff": "mmm a / src / shared / compatibility . js <nl> ppp b / src / shared / compatibility . js <nl> PDFJS . compatibilityChecked = true ; <nl> if ( ' requestAnimationFrame ' in window ) { <nl> return ; <nl> } <nl> - window . requestAnimationFrame = <nl> - window . mozRequestAnimationFrame | | <nl> - window . webkitRequestAnimationFrame ; <nl> - if ( ! ( ' requestAnimationFrame ' in window ) ) { <nl> - installFakeAnimationFrameFunctions ( ) ; <nl> + window . requestAnimationFrame = window . mozRequestAnimationFrame | | <nl> + window . webkitRequestAnimationFrame ; <nl> + if ( window . requestAnimationFrame ) { <nl> + return ; <nl> } <nl> + installFakeAnimationFrameFunctions ( ) ; <nl> } ) ( ) ; <nl> <nl> / / Support : Android , iOS <nl>\n", "msg": "Correctly detect if ` requestAnimationFrame ` is supported in ` compatibility . js ` ( issue 8272 )\n", "score": 1}
{"diff_id": 31636, "repo": "gorhill/uBlock\n", "sha": "7dc962281f0ed98d3fbdae2152927a0cde707076\n", "time": "2020-06-07T12:50:20Z\n", "diff": "mmm a / src / js / reverselookup . js <nl> ppp b / src / js / reverselookup . js <nl> const fromNetFilter = async function ( rawFilter ) { <nl> const b = Block ; <nl> const writer = new b . CompiledLineIO . Writer ( ) ; <nl> const parser = new vAPI . StaticFilteringParser ( ) ; <nl> + parser . setMaxTokenLength ( b . urlTokenizer . MAX_TOKEN_LENGTH ) ; <nl> parser . analyze ( rawFilter ) ; <nl> <nl> if ( b . staticNetFilteringEngine . compile ( parser , writer ) = = = false ) { <nl>\n", "msg": "Set max token length on parser for consistent compilation\n", "score": 1}
{"diff_id": 31702, "repo": "photonstorm/phaser\n", "sha": "727383d4f3ad9907a559f48ef2282768c13360a2\n", "time": "2020-10-08T09:44:02Z\n", "diff": "mmm a / src / loader / MultiFile . js <nl> ppp b / src / loader / MultiFile . js <nl> var Class = require ( ' . . / utils / Class ' ) ; <nl> * @ classdesc <nl> * A MultiFile is a special kind of parent that contains two , or more , Files as children and looks after <nl> * the loading and processing of them all . It is commonly extended and used as a base class for file types such as AtlasJSON or BitmapFont . <nl> - * <nl> + * <nl> * You shouldn ' t create an instance of a MultiFile directly , but should extend it with your own class , setting a custom type and processing methods . <nl> * <nl> * @ class MultiFile <nl> var MultiFile = new Class ( { <nl> <nl> function MultiFile ( loader , type , key , files ) <nl> { <nl> + var finalFiles = [ ] ; <nl> + <nl> + / / Clean out any potential ' null ' or ' undefined ' file entries <nl> + files . forEach ( function ( file ) <nl> + { <nl> + if ( file ) <nl> + { <nl> + finalFiles . push ( file ) ; <nl> + } <nl> + } ) ; <nl> + <nl> / * * <nl> * A reference to the Loader that is going to load this file . <nl> * <nl> var MultiFile = new Class ( { <nl> * @ type { Phaser . Loader . File [ ] } <nl> * @ since 3 . 7 . 0 <nl> * / <nl> - this . files = files ; <nl> + this . files = finalFiles ; <nl> <nl> / * * <nl> * The completion status of this MultiFile . <nl> var MultiFile = new Class ( { <nl> * @ since 3 . 7 . 0 <nl> * / <nl> <nl> - this . pending = files . length ; <nl> + this . pending = finalFiles . length ; <nl> <nl> / * * <nl> * The number of files that failed to load . <nl> var MultiFile = new Class ( { <nl> this . prefix = loader . prefix ; <nl> <nl> / / Link the files <nl> - for ( var i = 0 ; i < files . length ; i + + ) <nl> + for ( var i = 0 ; i < finalFiles . length ; i + + ) <nl> { <nl> - files [ i ] . multiFile = this ; <nl> + finalFiles [ i ] . multiFile = this ; <nl> } <nl> } , <nl> <nl>\n", "msg": "` Loader . MultiFile ` will now parse the given files array and only add valid entries into the file list , allowing multifiles to now have optional file entries .\n", "score": 1}
{"diff_id": 32022, "repo": "facebook/react-native\n", "sha": "79e498b7fbf19ab50bb73697602910fb827ff928\n", "time": "2017-08-24T21:26:24Z\n", "diff": "mmm a / local - cli / runAndroid / runAndroid . js <nl> ppp b / local - cli / runAndroid / runAndroid . js <nl> function runOnAllDevices ( args , cmd , packageNameWithSuffix , packageName , adbPath ) <nl> } <nl> <nl> function startServerInNewWindow ( ) { <nl> - const yargV = require ( ' yargs ' ) . argv ; <nl> const scriptFile = / ^ win / . test ( process . platform ) ? <nl> ' launchPackager . bat ' : <nl> ' launchPackager . command ' ; <nl> const scriptsDir = path . resolve ( __dirname , ' . . ' , ' . . ' , ' scripts ' ) ; <nl> const launchPackagerScript = path . resolve ( scriptsDir , scriptFile ) ; <nl> const procConfig = { cwd : scriptsDir } ; <nl> + const terminal = process . env . REACT_TERMINAL ; <nl> <nl> if ( process . platform = = = ' darwin ' ) { <nl> - if ( yargV . open ) { <nl> - return child_process . spawnSync ( ' open ' , [ ' - a ' , yargV . open , launchPackagerScript ] , procConfig ) ; <nl> + if ( terminal ) { <nl> + return child_process . spawnSync ( ' open ' , [ ' - a ' , terminal , launchPackagerScript ] , procConfig ) ; <nl> } <nl> return child_process . spawnSync ( ' open ' , [ launchPackagerScript ] , procConfig ) ; <nl> <nl> } else if ( process . platform = = = ' linux ' ) { <nl> procConfig . detached = true ; <nl> - if ( yargV . open ) { <nl> - return child_process . spawn ( yargV . open , [ ' - e ' , ' sh ' , launchPackagerScript ] , procConfig ) ; <nl> + if ( terminal ) { <nl> + return child_process . spawn ( terminal , [ ' - e ' , ' sh ' + launchPackagerScript ] , procConfig ) ; <nl> } <nl> return child_process . spawn ( ' sh ' , [ launchPackagerScript ] , procConfig ) ; <nl> <nl>\n", "msg": "Allow packager to be opened in specific terminal on Linux and Mac OS X\n", "score": 1}
{"diff_id": 32133, "repo": "codemirror/CodeMirror\n", "sha": "e546c8e4fffe67b918761617291e15ccae23544a\n", "time": "2014-04-16T10:34:44Z\n", "diff": "mmm a / lib / codemirror . js <nl> ppp b / lib / codemirror . js <nl> <nl> delayedCallbacks = null ; <nl> } <nl> / / Fire change events , and delayed event handlers <nl> - if ( op . changeObjs ) { <nl> - for ( var i = 0 ; i < op . changeObjs . length ; i + + ) <nl> - signal ( cm , \" change \" , cm , op . changeObjs [ i ] ) ; <nl> + if ( op . changeObjs ) <nl> signal ( cm , \" changes \" , cm , op . changeObjs ) ; <nl> - } <nl> if ( op . cursorActivity ) signal ( cm , \" cursorActivity \" , cm , op . origin ) ; <nl> if ( delayed ) for ( var i = 0 ; i < delayed . length ; + + i ) delayed [ i ] ( ) ; <nl> } <nl> <nl> else <nl> regChange ( cm , from . line , to . line + 1 , lendiff ) ; <nl> <nl> - if ( hasHandler ( cm , \" change \" ) | | hasHandler ( cm , \" changes \" ) ) <nl> - ( cm . curOp . changeObjs | | ( cm . curOp . changeObjs = [ ] ) ) . push ( { <nl> + var changesHandler = hasHandler ( cm , \" changes \" ) , changeHandler = hasHandler ( cm , \" change \" ) ; <nl> + if ( changeHandler | | changesHandler ) { <nl> + var obj = { <nl> from : from , to : to , <nl> text : change . text , <nl> removed : change . removed , <nl> origin : change . origin <nl> - } ) ; <nl> + } ; <nl> + if ( changeHandler ) signalLater ( cm , \" change \" , cm , obj ) ; <nl> + if ( changesHandler ) ( cm . curOp . changeObjs | | ( cm . curOp . changeObjs = [ ] ) ) . push ( obj ) ; <nl> + } <nl> } <nl> <nl> function replaceRange ( doc , code , from , to , origin ) { <nl>\n", "msg": "Be more accurate about which handlers to fire change events for\n", "score": 1}
{"diff_id": 32146, "repo": "emberjs/ember.js\n", "sha": "7ba081769c47c2a03f0d33671559c30495eef0ae\n", "time": "2013-01-05T04:45:52Z\n", "diff": "mmm a / packages / ember - routing / lib / helpers / render . js <nl> ppp b / packages / ember - routing / lib / helpers / render . js <nl> Ember . onLoad ( ' Ember . Handlebars ' , function ( Handlebars ) { <nl> container = options . data . keywords . controller . container ; <nl> router = container . lookup ( ' router : main ' ) ; <nl> <nl> - Ember . assert ( \" This view is alredy rendered \" , ! router | | ! router . _lookupActiveView ( name ) ) ; <nl> + Ember . assert ( \" This view is already rendered \" , ! router | | ! router . _lookupActiveView ( name ) ) ; <nl> <nl> view = container . lookup ( ' view : ' + name ) | | container . lookup ( ' view : default ' ) ; <nl> <nl>\n", "msg": "Correct spelling of ' already ' in assertion .\n", "score": 1}
{"diff_id": 32435, "repo": "Semantic-Org/Semantic-UI\n", "sha": "421fdadd7634be4b25d0ee536d0aa2fe8d93eb64\n", "time": "2015-05-14T19:08:52Z\n", "diff": "mmm a / src / definitions / behaviors / api . js <nl> ppp b / src / definitions / behaviors / api . js <nl> $ . api = $ . fn . api = function ( parameters ) { <nl> } <nl> } , <nl> <nl> + read : { <nl> + cachedResponse : function ( url ) { <nl> + var <nl> + response <nl> + ; <nl> + if ( ! module . cache ) { <nl> + module . create . cache ( ) ; <nl> + } <nl> + response = ( module . cache . response [ url ] ! = = undefined ) <nl> + ? module . cache . response [ url ] <nl> + : false <nl> + ; <nl> + module . debug ( ' Using cached response ' , url , response ) ; <nl> + return response ; <nl> + } <nl> + } , <nl> + write : { <nl> + cachedResponse : function ( url , response ) { <nl> + if ( ! module . cache ) { <nl> + module . create . cache ( ) ; <nl> + } <nl> + if ( response & & response = = = ' ' ) { <nl> + module . debug ( ' Response empty , not caching ' , response ) ; <nl> + return ; <nl> + } <nl> + module . verbose ( ' Storing cached response for url ' , url , response ) ; <nl> + module . cache . response [ url ] = response ; <nl> + } <nl> + } , <nl> + <nl> query : function ( ) { <nl> <nl> if ( module . is . disabled ( ) ) { <nl> $ . api = $ . fn . api = function ( parameters ) { <nl> module . verbose ( ' Using AJAX settings ' , ajaxSettings ) ; <nl> <nl> / / pull from cache <nl> - if ( settings . cache & & module . cache . response [ url ] ! = = undefined ) { <nl> - module . debug ( ' Pulling response from cache ' ) ; <nl> + if ( settings . cache = = = ' local ' & & module . read . cachedResponse ( url ) ) { <nl> module . request = module . create . request ( ) ; <nl> - module . request . resolveWith ( context , [ module . cache . response [ url ] ] ) ; <nl> + module . request . resolveWith ( context , [ module . read . cachedResponse ( url ) ] ) ; <nl> return ; <nl> } <nl> <nl> - if ( module . is . loading ( ) ) { <nl> - / / throttle additional requests <nl> + if ( ! module . is . loading ( ) ) { <nl> + module . request = module . create . request ( ) ; <nl> + module . xhr = module . create . xhr ( ) ; <nl> + settings . onRequest . call ( context , module . request , module . xhr ) ; <nl> + } <nl> + else { <nl> + / / throttle repeated api requests <nl> + module . debug ( ' Repeated request throttled ' , settings . throttle ) ; <nl> module . timer = setTimeout ( function ( ) { <nl> module . request = module . create . request ( ) ; <nl> module . xhr = module . create . xhr ( ) ; <nl> settings . onRequest . call ( context , module . request , module . xhr ) ; <nl> } , settings . throttle ) ; <nl> } <nl> - else { <nl> - / / immediately on first request <nl> - module . request = module . create . request ( ) ; <nl> - module . xhr = module . create . xhr ( ) ; <nl> - settings . onRequest . call ( context , module . request , module . xhr ) ; <nl> - } <nl> <nl> } , <nl> <nl> $ . api = $ . fn . api = function ( parameters ) { <nl> / / page triggers abort on navigation , dont show error <nl> setTimeout ( function ( ) { <nl> if ( xhr . readyState ! = = undefined & & xhr . readyState = = = 0 ) { <nl> - module . debug ( ' Request Aborted ( Most likely caused by page navigation or CORS Policy ) ' , status , httpMessage ) ; <nl> - settings . onAbort . call ( context , status , $ module ) ; <nl> - module . reset ( ) ; <nl> + module . request . rejectWith ( context , [ xhr , ' aborted ' , httpMessage ] ) ; <nl> } <nl> else { <nl> module . request . rejectWith ( context , [ xhr , status , httpMessage ] ) ; <nl> $ . api = $ . fn . api = function ( parameters ) { <nl> ; <nl> module . debug ( ' API Response Received ' , response ) ; <nl> <nl> - if ( settings . cache & & url ) { <nl> - module . cache . response [ url ] = response ; <nl> - module . debug ( ' Caching response for next lookup ' , module . cache ) ; <nl> + if ( settings . cache = = = ' local ' & & url ) { <nl> + module . write . cachedResponse ( url , response ) ; <nl> + module . debug ( ' Adding url to local cache ' , module . cache ) ; <nl> } <nl> <nl> if ( translatedResponse ) { <nl> $ . api = $ . fn . api = function ( parameters ) { <nl> settings . onSuccess . call ( context , response , $ module ) ; <nl> } <nl> } , <nl> - error : function ( xhr , status , httpMessage ) { <nl> + fail : function ( xhr , status , httpMessage ) { <nl> var <nl> errorMessage = ( settings . error [ status ] ! = = undefined ) <nl> ? settings . error [ status ] <nl> : httpMessage , <nl> response <nl> ; <nl> - / / let em know unless request aborted <nl> - if ( xhr ! = = undefined ) { <nl> <nl> + / / request aborted , don ' t show error state <nl> + if ( status = = ' aborted ' ) { <nl> + module . debug ( ' Request Aborted ( Most likely caused by page navigation or CORS Policy ) ' , status , httpMessage ) ; <nl> + module . reset ( ) ; <nl> + settings . onAbort . call ( context , status , $ module ) ; <nl> + return ; <nl> + } <nl> + <nl> + if ( xhr ! = = undefined ) { <nl> / / if http status code returned and json returned error , look for it <nl> if ( xhr . status ! = 200 & & httpMessage ! = = undefined & & httpMessage ! = = ' ' ) { <nl> module . error ( error . statusMessage + httpMessage , ajaxSettings . url ) ; <nl> $ . api = $ . fn . api = function ( parameters ) { <nl> } <nl> } <nl> module . remove . loading ( ) ; <nl> - / / show error state only for duration specified in settings <nl> + / / show error state if specified with length <nl> if ( settings . errorDuration ! = = false ) { <nl> module . set . error ( ) ; <nl> setTimeout ( module . remove . error , settings . errorDuration ) ; <nl> $ . api = $ . fn . api = function ( parameters ) { <nl> return $ . Deferred ( ) <nl> . always ( module . event . request . complete ) <nl> . done ( module . event . request . done ) <nl> - . fail ( module . event . request . error ) <nl> + . fail ( module . event . request . fail ) <nl> ; <nl> } , <nl> / / xhr promise <nl> $ . api . settings = { <nl> performance : true , <nl> <nl> / / cache <nl> - cache : false , <nl> + cache : ' local ' , <nl> <nl> / / event binding <nl> on : ' auto ' , <nl>\n", "msg": "Adjust cache type to be called local to allow for standard caching choices\n", "score": 1}
{"diff_id": 32596, "repo": "ajaxorg/ace\n", "sha": "b67caa11631f22450bc929c57036345a0074d12c\n", "time": "2014-04-05T21:31:20Z\n", "diff": "mmm a / lib / ace / autocomplete . js <nl> ppp b / lib / ace / autocomplete . js <nl> var Autocomplete = function ( ) { <nl> editor . completer . insertMatch ( ) ; <nl> } , <nl> \" Shift - Return \" : function ( editor ) { editor . completer . insertMatch ( true ) ; } , <nl> - \" Tab \" : function ( editor ) { editor . completer . insertMatch ( ) ; } , <nl> <nl> \" PageUp \" : function ( editor ) { editor . completer . popup . gotoPageUp ( ) ; } , <nl> \" PageDown \" : function ( editor ) { editor . completer . popup . gotoPageDown ( ) ; } <nl>\n", "msg": "Disable Tab command binding for autocomplete ( incompatible with live autocomplete )\n", "score": 1}
{"diff_id": 32983, "repo": "meteor/meteor\n", "sha": "5663d9efacf03da0312023d0c9f34cd7754e4ee5\n", "time": "2014-10-21T19:57:37Z\n", "diff": "mmm a / tools / console . js <nl> ppp b / tools / console . js <nl> _ . extend ( ProgressDisplayFull . prototype , { <nl> <nl> / / The cursor appears in position 0 ; we indent it a little to avoid this <nl> / / This also means it appears less important , which is good <nl> - var indentColumns = 4 ; <nl> + var indentColumns = 3 ; <nl> <nl> var streamColumns = this . _stream . columns ; <nl> var statusColumns ; <nl>\n", "msg": "Change progress message indent to 3 , so it lines up with ' = > Started . . . '\n", "score": 1}
{"diff_id": 33166, "repo": "balderdashy/sails\n", "sha": "ef51328d3f0d355ffefc2a59185400b41b3d9427\n", "time": "2014-05-12T19:03:45Z\n", "diff": "mmm a / lib / app / load . js <nl> ppp b / lib / app / load . js <nl> module . exports = function ( sails ) { <nl> configOverride . explicitHost = configOverride . host ; <nl> } <nl> <nl> + / / Optionally expose services , models , sails , _ , async , etc . as globals as soon as the <nl> + / / user config loads . <nl> + sails . on ( ' hook : userconfig : loaded ' , sails . exposeGlobals ) ; <nl> <nl> async . auto ( { <nl> <nl> module . exports = function ( sails ) { <nl> <nl> sails . log . verbose ( ' All hooks were loaded successfully . ' ) ; <nl> <nl> - / / Optionally expose services , models , sails , _ , async , etc . as globals <nl> - sails . exposeGlobals ( ) ; <nl> + / / If userconfig hook is turned off , still load globals . <nl> + if ( sails . config . hooks & & sails . config . hooks . userconfig = = = false | | <nl> + ( sails . config . loadHooks & & sails . config . loadHooks . indexOf ( ' userconfig ' ) = = - 1 ) ) { <nl> + sails . exposeGlobals ( ) ; <nl> + } <nl> + <nl> <nl> cb & & cb ( null , sails ) ; <nl> } <nl>\n", "msg": "Expose globals as soon as user config loads .\n", "score": 1}
{"diff_id": 33232, "repo": "juliangarnier/anime\n", "sha": "df81656741c26e00c2916156674f9714fa962d87\n", "time": "2019-02-28T14:20:31Z\n", "diff": "mmm a / src / index . js <nl> ppp b / src / index . js <nl> function anime ( params = { } ) { <nl> childrenLength = children . length ; <nl> for ( let i = childrenLength ; i - - ; ) instance . children [ i ] . reset ( ) ; <nl> if ( instance . reversed & & instance . loop ! = = true | | ( direction = = = ' alternate ' & & instance . loop = = = 1 ) ) instance . remaining + + ; <nl> - setAnimationsProgress ( 0 ) ; <nl> + setAnimationsProgress ( instance . reversed ? instance . duration : 0 ) ; <nl> } <nl> <nl> / / Set Value helper <nl>\n", "msg": "Set progress to duration instead of 0 when reversed\n", "score": 1}
{"diff_id": 33731, "repo": "meteor/meteor\n", "sha": "a0a9e5f3ae91718dd426ace64b4445c7eca84cb9\n", "time": "2019-12-13T02:02:02Z\n", "diff": "mmm a / packages / ejson / ejson . js <nl> ppp b / packages / ejson / ejson . js <nl> const EJSON = { } ; <nl> * @ instance <nl> * / <nl> <nl> - const customTypes = { } ; <nl> + const customTypes = new Map ( ) ; <nl> <nl> - const hasOwn = ( obj , prop ) = > ( { } ) . hasOwnProperty . call ( obj , prop ) ; <nl> + const isFunction = ( fn ) = > typeof fn = = = ' function ' ; <nl> + <nl> + const hasOwn = ( obj , prop ) = > Object . prototype . hasOwnProperty . call ( obj , prop ) ; <nl> + <nl> + const convertMapToObject = ( map ) = > Array . from ( map ) . reduce ( ( acc , [ key , value ] ) = > { <nl> + / / reassign to not create new object <nl> + acc [ key ] = value ; <nl> + return acc ; <nl> + } , { } ) ; <nl> <nl> const isArguments = obj = > obj ! = null & & hasOwn ( obj , ' callee ' ) ; <nl> <nl> - const isInfOrNan = <nl> + const isInfOrNaN = <nl> obj = > Number . isNaN ( obj ) | | obj = = = Infinity | | obj = = = - Infinity ; <nl> <nl> / / Add a custom type , using a method of your choice to get to and <nl> const isInfOrNan = <nl> * type ' s ` toJSONValue ` method . <nl> * / <nl> EJSON . addType = ( name , factory ) = > { <nl> - if ( hasOwn ( customTypes , name ) ) { <nl> + if ( customTypes . has ( name ) ) { <nl> throw new Error ( ` Type $ { name } already present ` ) ; <nl> } <nl> - customTypes [ name ] = factory ; <nl> + customTypes . set ( name , factory ) ; <nl> } ; <nl> <nl> const builtinConverters = [ <nl> const builtinConverters = [ <nl> matchJSONValue ( obj ) { <nl> return hasOwn ( obj , ' $ InfNaN ' ) & & Object . keys ( obj ) . length = = = 1 ; <nl> } , <nl> - matchObject : isInfOrNan , <nl> + matchObject : isInfOrNaN , <nl> toJSONValue ( obj ) { <nl> let sign ; <nl> if ( Number . isNaN ( obj ) ) { <nl> const builtinConverters = [ <nl> } , <nl> fromJSONValue ( obj ) { <nl> const typeName = obj . $ type ; <nl> - if ( ! hasOwn ( customTypes , typeName ) ) { <nl> + if ( ! customTypes . has ( typeName ) ) { <nl> throw new Error ( ` Custom EJSON type $ { typeName } is not defined ` ) ; <nl> } <nl> - const converter = customTypes [ typeName ] ; <nl> + const converter = customTypes . get ( typeName ) ; <nl> return Meteor . _noYieldsAllowed ( ( ) = > converter ( obj . $ value ) ) ; <nl> } , <nl> } , <nl> const builtinConverters = [ <nl> <nl> EJSON . _isCustomType = ( obj ) = > ( <nl> obj & & <nl> - typeof obj . toJSONValue = = = ' function ' & & <nl> - typeof obj . typeName = = = ' function ' & & <nl> - hasOwn ( customTypes , obj . typeName ( ) ) <nl> + isFunction ( obj . toJSONValue ) & & <nl> + isFunction ( obj . typeName ) & & <nl> + customTypes . has ( obj . typeName ( ) ) <nl> ) ; <nl> <nl> - EJSON . _getTypes = ( ) = > customTypes ; <nl> + EJSON . _getTypes = ( isOriginal = false ) = > ( isOriginal ? customTypes : convertMapToObject ( customTypes ) ) ; <nl> <nl> EJSON . _getConverters = ( ) = > builtinConverters ; <nl> <nl> const adjustTypesToJSONValue = obj = > { <nl> Object . keys ( obj ) . forEach ( key = > { <nl> const value = obj [ key ] ; <nl> if ( typeof value ! = = ' object ' & & value ! = = undefined & & <nl> - ! isInfOrNan ( value ) ) { <nl> + ! isInfOrNaN ( value ) ) { <nl> return ; / / continue <nl> } <nl> <nl> EJSON . equals = ( a , b , options ) = > { <nl> return true ; <nl> } <nl> <nl> - if ( typeof ( a . equals ) = = = ' function ' ) { <nl> + if ( isFunction ( a . equals ) ) { <nl> return a . equals ( b , options ) ; <nl> } <nl> <nl> - if ( typeof ( b . equals ) = = = ' function ' ) { <nl> + if ( isFunction ( b . equals ) ) { <nl> return b . equals ( a , options ) ; <nl> } <nl> <nl> EJSON . clone = v = > { <nl> } <nl> <nl> / / handle general user - defined typed Objects if they have a clone method <nl> - if ( typeof v . clone = = = ' function ' ) { <nl> + if ( isFunction ( v . clone ) ) { <nl> return v . clone ( ) ; <nl> } <nl> <nl>\n", "msg": "Use ` map ` instead of ` object ` for list custom type and add ` isFunction ` helper\n", "score": 1}
{"diff_id": 33735, "repo": "photonstorm/phaser\n", "sha": "137f97b325b5bdc0569e416a7d659a168a2c3bca\n", "time": "2018-05-22T14:55:22Z\n", "diff": "mmm a / src / gameobjects / rendertexture / RenderTexture . js <nl> ppp b / src / gameobjects / rendertexture / RenderTexture . js <nl> var RenderTexture = new Class ( { <nl> this . initPipeline ( ' TextureTintPipeline ' ) ; <nl> } , <nl> <nl> - / * * <nl> - * [ description ] <nl> - * <nl> - * @ method Phaser . GameObjects . RenderTexture # destroy <nl> - * @ since 3 . 2 . 0 <nl> - * / <nl> - destroy : function ( ) <nl> - { <nl> - GameObject . prototype . destroy . call ( this ) ; <nl> - <nl> - if ( this . renderer . type = = = CONST . WEBGL ) <nl> - { <nl> - this . renderer . deleteTexture ( this . texture ) ; <nl> - this . renderer . deleteFramebuffer ( this . framebuffer ) ; <nl> - } <nl> - } , <nl> - <nl> / * * <nl> * [ description ] <nl> * <nl> var RenderTexture = new Class ( { <nl> this . globalAlpha = alpha ; <nl> <nl> return this ; <nl> + } , <nl> + <nl> + / * * <nl> + * Internal destroy handler , called as part of the destroy process . <nl> + * <nl> + * @ method Phaser . GameObjects . RenderTexture # preDestroy <nl> + * @ protected <nl> + * @ since 3 . 9 . 0 <nl> + * / <nl> + preDestroy : function ( ) <nl> + { <nl> + if ( this . renderer & & this . renderer . gl ) <nl> + { <nl> + this . renderer . deleteTexture ( this . texture ) ; <nl> + this . renderer . deleteFramebuffer ( this . framebuffer ) ; <nl> + } <nl> } <nl> <nl> / * * <nl>\n", "msg": "RenderTexture . destroy has been renamed to ` preDestroy ` to take advantage of the preDestroy callback system .\n", "score": 1}
{"diff_id": 33779, "repo": "meteor/meteor\n", "sha": "aebb9a21aa7e5e260249bdefe6b0609c2e0d6e89\n", "time": "2012-05-23T19:59:47Z\n", "diff": "mmm a / packages / handlebars / evaluate . js <nl> ppp b / packages / handlebars / evaluate . js <nl> Handlebars . evaluate = function ( ast , data , options ) { <nl> if ( typeof ( id ) ! = = \" object \" ) <nl> return id ; <nl> if ( id . length = = = 2 & & id [ 0 ] = = = 0 & & ( id [ 1 ] in helpers ) ) <nl> - return helpers [ id [ 1 ] ] ; <nl> + return helpers [ id [ 1 ] ] ; / / found helper <nl> for ( var i = 0 ; i < id [ 0 ] ; i + + ) { <nl> if ( ! stack . parent ) <nl> throw new Error ( \" Too many ' . . ' segments \" ) ; <nl> Handlebars . evaluate = function ( ast , data , options ) { <nl> stack = stack . parent ; <nl> } <nl> var ret = stack . data ; <nl> + if ( id . length > 1 & & typeof ret ! = = ' object ' ) { <nl> + / / Fail with better error than \" can ' t read property of undefined \" . <nl> + / / Looking up id [ 1 ] as a property will fail , because <nl> + / / there is no data context object . Probably the developer <nl> + / / intended to use a helper that doesn ' t exist . <nl> + if ( typeof ( function ( ) { } ) [ id [ 1 ] ] ! = = ' undefined ' ) { <nl> + / / An even more specific case for a helpful error . <nl> + / / The developer probably tried to name a helper ' name ' , <nl> + / / ' length ' , or some other built - in function property . <nl> + / / Assignments to these properties are no - ops , so the <nl> + / / helper declaration is undetectable . <nl> + / / We can ' t always catch this mistake , because if there is any <nl> + / / object as data context , it ' s legal for the developer to <nl> + / / ask for { { name } } as a property of the object , perhaps an <nl> + / / optional one . But if there is no data context , we get <nl> + / / to be helpful . <nl> + throw new Error ( \" Can ' t call a helper ' \" + id [ 1 ] + \" ' because \" + <nl> + \" it is a built - in function property in JavaScript \" ) ; <nl> + } <nl> + throw new Error ( \" Unknown helper ' \" + id [ 1 ] + \" ' \" ) ; <nl> + } <nl> for ( var i = 1 ; i < id . length ; i + + ) <nl> / / XXX error ( and / or unknown key ) handling <nl> ret = ret [ id [ i ] ] ; <nl>\n", "msg": "better errors for unknown helper or reserved name ; fixes\n", "score": 1}
{"diff_id": 33808, "repo": "lodash/lodash\n", "sha": "2f369f8eca4add2e901ddc8f344c70665ba0a414\n", "time": "2011-01-18T21:34:33Z\n", "diff": "mmm a / underscore . js <nl> ppp b / underscore . js <nl> <nl> / / Retrieve the names of an object ' s properties . <nl> / / Delegates to * * ECMAScript 5 * * ' s native ` Object . keys ` <nl> _ . keys = nativeKeys | | function ( obj ) { <nl> - if ( _ . isArray ( obj ) ) return _ . range ( 0 , obj . length ) ; <nl> var keys = [ ] ; <nl> for ( var key in obj ) if ( hasOwnProperty . call ( obj , key ) ) keys [ keys . length ] = key ; <nl> return keys ; <nl>\n", "msg": "Fixing . . . Maloptimization of _ . keys for sparse arrays .\n", "score": 1}
{"diff_id": 34102, "repo": "photonstorm/phaser\n", "sha": "03a2db18cb5f69115a9913c5422ffc435c54d9c6\n", "time": "2015-02-25T06:06:40Z\n", "diff": "mmm a / src / physics / arcade / World . js <nl> ppp b / src / physics / arcade / World . js <nl> Phaser . Physics . Arcade = function ( game ) { <nl> * / <nl> this . quadTree = new Phaser . QuadTree ( this . game . world . bounds . x , this . game . world . bounds . y , this . game . world . bounds . width , this . game . world . bounds . height , this . maxObjects , this . maxLevels ) ; <nl> <nl> + / * * <nl> + * @ property { object } stats - Stats collected for each collision iteration . <nl> + * / <nl> + this . stats = { ' skipped ' : 0 , ' ignored ' : 0 , ' checked ' : 0 } ; <nl> + <nl> / * * <nl> * @ property { number } _total - Internal cache var . <nl> * @ private <nl> Phaser . Physics . Arcade . prototype = { <nl> <nl> } , <nl> <nl> + / * * <nl> + * This method will sort a Groups _hash array based on the sortDirection property . <nl> + * <nl> + * Each function should return - 1 if ` a > b ` , 1 if ` a < b ` or 0 if ` a = = = b ` . <nl> + * <nl> + * @ method sort <nl> + * @ protected <nl> + * @ param { Phaser . Group } group - The Group to sort . <nl> + * / <nl> sort : function ( group ) { <nl> <nl> if ( this . sortDirection = = = Phaser . Physics . Arcade . LEFT_RIGHT ) <nl> { <nl> / / Game world is say 2000x600 and you start at 0 <nl> group . _hash . sort ( function ( a , b ) { <nl> + <nl> + if ( ! a . body | | ! b . body ) <nl> + { <nl> + return - 1 ; <nl> + } <nl> + <nl> return a . body . x - b . body . x ; <nl> + <nl> } ) ; <nl> } <nl> else if ( this . sortDirection = = = Phaser . Physics . Arcade . RIGHT_LEFT ) <nl> { <nl> / / Game world is say 2000x600 and you start at 2000 <nl> group . _hash . sort ( function ( a , b ) { <nl> + <nl> + if ( ! a . body | | ! b . body ) <nl> + { <nl> + return - 1 ; <nl> + } <nl> + <nl> return b . body . x - a . body . x ; <nl> + <nl> } ) ; <nl> } <nl> else if ( this . sortDirection = = = Phaser . Physics . Arcade . TOP_BOTTOM ) <nl> { <nl> / / Game world is say 800x2000 and you start at 0 <nl> group . _hash . sort ( function ( a , b ) { <nl> + <nl> + if ( ! a . body | | ! b . body ) <nl> + { <nl> + return - 1 ; <nl> + } <nl> + <nl> return a . body . y - b . body . y ; <nl> + <nl> } ) ; <nl> } <nl> else if ( this . sortDirection = = = Phaser . Physics . Arcade . BOTTOM_TOP ) <nl> { <nl> / / Game world is say 800x2000 and you start at 2000 <nl> group . _hash . sort ( function ( a , b ) { <nl> + <nl> + if ( ! a . body | | ! b . body ) <nl> + { <nl> + return - 1 ; <nl> + } <nl> + <nl> return b . body . y - a . body . y ; <nl> + <nl> } ) ; <nl> } <nl> <nl> Phaser . Physics . Arcade . prototype = { <nl> <nl> if ( this . skipQuadTree | | sprite . body . skipQuadTree ) <nl> { <nl> - window . skipped = 0 ; <nl> - window . ignored = 0 ; <nl> - window . checked = 0 ; <nl> + this . stats . skipped = 0 ; <nl> + this . stats . ignored = 0 ; <nl> + this . stats . checked = 0 ; <nl> <nl> for ( var i = 0 ; i < group . _hash . length ; i + + ) <nl> { <nl> - / / Skip duff entries <nl> - if ( ! group . _hash [ i ] | | ! group . _hash [ i ] . exists ) <nl> + / / Skip duff entries - we can ' t check a non - existent sprite or one with no body <nl> + if ( ! group . _hash [ i ] | | ! group . _hash [ i ] . exists | | ! group . _hash [ i ] . body ) <nl> { <nl> continue ; <nl> } <nl> Phaser . Physics . Arcade . prototype = { <nl> { <nl> if ( group . _hash [ i ] . body . right < sprite . body . x ) <nl> { <nl> - window . ignored + + ; <nl> + this . stats . ignored + + ; <nl> continue ; <nl> } <nl> else if ( sprite . body . right < group . _hash [ i ] . body . x ) <nl> { <nl> - window . skipped = group . _hash . length - i ; <nl> + this . stats . skipped = group . _hash . length - i ; <nl> break ; <nl> } <nl> - else <nl> - { <nl> - window . checked + + ; <nl> - this . collideSpriteVsSprite ( sprite , group . _hash [ i ] , collideCallback , processCallback , callbackContext , overlapOnly ) ; <nl> - } <nl> } <nl> else if ( this . sortDirection = = = Phaser . Physics . Arcade . RIGHT_LEFT ) <nl> { <nl> if ( group . _hash [ i ] . body . x > sprite . body . right ) <nl> { <nl> - window . ignored + + ; <nl> + this . stats . ignored + + ; <nl> continue ; <nl> } <nl> else if ( sprite . body . x > group . _hash [ i ] . body . right ) <nl> { <nl> - window . skipped = group . _hash . length - i ; <nl> + this . stats . skipped = group . _hash . length - i ; <nl> break ; <nl> } <nl> - else <nl> - { <nl> - window . checked + + ; <nl> - this . collideSpriteVsSprite ( sprite , group . _hash [ i ] , collideCallback , processCallback , callbackContext , overlapOnly ) ; <nl> - } <nl> } <nl> else if ( this . sortDirection = = = Phaser . Physics . Arcade . TOP_BOTTOM ) <nl> { <nl> if ( group . _hash [ i ] . body . bottom < sprite . body . y ) <nl> { <nl> - window . ignored + + ; <nl> + this . stats . ignored + + ; <nl> continue ; <nl> } <nl> else if ( sprite . body . bottom < group . _hash [ i ] . body . y ) <nl> { <nl> - window . skipped = group . _hash . length - i ; <nl> + this . stats . skipped = group . _hash . length - i ; <nl> break ; <nl> } <nl> - else <nl> - { <nl> - window . checked + + ; <nl> - this . collideSpriteVsSprite ( sprite , group . _hash [ i ] , collideCallback , processCallback , callbackContext , overlapOnly ) ; <nl> - } <nl> } <nl> else if ( this . sortDirection = = = Phaser . Physics . Arcade . BOTTOM_TOP ) <nl> { <nl> if ( group . _hash [ i ] . body . y > sprite . body . bottom ) <nl> { <nl> - window . ignored + + ; <nl> + this . stats . ignored + + ; <nl> continue ; <nl> } <nl> else if ( sprite . body . y > group . _hash [ i ] . body . bottom ) <nl> { <nl> - window . skipped = group . _hash . length - i ; <nl> + this . stats . skipped = group . _hash . length - i ; <nl> break ; <nl> } <nl> - else <nl> - { <nl> - window . checked + + ; <nl> - this . collideSpriteVsSprite ( sprite , group . _hash [ i ] , collideCallback , processCallback , callbackContext , overlapOnly ) ; <nl> - } <nl> } <nl> + <nl> + this . stats . checked + + ; <nl> + this . collideSpriteVsSprite ( sprite , group . _hash [ i ] , collideCallback , processCallback , callbackContext , overlapOnly ) ; <nl> } <nl> } <nl> else <nl>\n", "msg": "Added extra protection in the case of mixed - type Groups .\n", "score": 1}
{"diff_id": 34366, "repo": "vercel/next.js\n", "sha": "e6ff476198dba8535049c2a6ed6e6ce47ede97f4\n", "time": "2018-06-07T11:19:53Z\n", "diff": "mmm a / server / utils . js <nl> ppp b / server / utils . js <nl> export function getAvailableChunks ( distDir ) { <nl> <nl> chunkFiles . forEach ( filename = > { <nl> if ( / \\ . js $ / . test ( filename ) ) { <nl> - const chunkName = filename . replace ( / - . * / , ' ' ) <nl> + const chunkName = filename . replace ( / - [ ^ - ] * / , ' ' ) <nl> chunksMap [ chunkName ] = filename <nl> } <nl> } ) <nl>\n", "msg": "Use a more appropriate regexp for removing hash from a filename ( )\n", "score": 1}
{"diff_id": 34445, "repo": "photonstorm/phaser\n", "sha": "f29126c482738f65e8798b45f762d338d9f886c9\n", "time": "2018-10-16T10:35:44Z\n", "diff": "mmm a / src / input / keyboard / KeyboardPlugin . js <nl> ppp b / src / input / keyboard / KeyboardPlugin . js <nl> var KeyboardPlugin = new Class ( { <nl> } , <nl> <nl> / * * <nl> - * Shuts the Keyboard Plugin down . <nl> - * All this does is remove any listeners bound to it . <nl> + * Resets all Key objects created by _this_ Keyboard Plugin back to their default un - pressed states . <nl> + * This can only reset keys created via the ` addKey ` , ` addKeys ` or ` createCursors ` methods . <nl> + * If you have created a Key object directly you ' ll need to reset it yourself . <nl> + * <nl> + * This method is called automatically when the Keyboard Plugin shuts down , but can be <nl> + * invoked directly at any time you require . <nl> + * <nl> + * @ method Phaser . Input . Keyboard . KeyboardPlugin # resetKeys <nl> + * @ since 3 . 15 . 0 <nl> + * / <nl> + resetKeys : function ( ) <nl> + { <nl> + var keys = this . keys ; <nl> + <nl> + for ( var i = 0 ; i < keys . length ; i + + ) <nl> + { <nl> + / / Because it ' s a sparsely populated array <nl> + if ( keys [ i ] ) <nl> + { <nl> + keys [ i ] . reset ( ) ; <nl> + } <nl> + } <nl> + <nl> + return this ; <nl> + } , <nl> + <nl> + / * * <nl> + * Shuts this Keyboard Plugin down . This performs the following tasks : <nl> + * <nl> + * 1 - Resets all keys created by this Keyboard plugin . <nl> + * 2 - Stops and removes the keyboard event listeners . <nl> + * 3 - Clears out any pending requests in the queue , without processing them . <nl> * <nl> * @ method Phaser . Input . Keyboard . KeyboardPlugin # shutdown <nl> * @ private <nl> var KeyboardPlugin = new Class ( { <nl> * / <nl> shutdown : function ( ) <nl> { <nl> + this . resetKeys ( ) ; <nl> + <nl> this . stopListeners ( ) ; <nl> <nl> this . removeAllListeners ( ) ; <nl> + <nl> + this . queue = [ ] ; <nl> } , <nl> <nl> / * * <nl>\n", "msg": "` KeyboardPlugin . resetKeys ` is a new method that will reset the state of any Key object created by a Scene ' s Keyboard Plugin .\n", "score": 1}
{"diff_id": 34495, "repo": "meteor/meteor\n", "sha": "a8201cc17e64f083bd35a4e53c05b9c4dff03c48\n", "time": "2013-12-03T03:17:29Z\n", "diff": "mmm a / packages / mongo - livedata / mongo_driver . js <nl> ppp b / packages / mongo - livedata / mongo_driver . js <nl> MongoConnection = function ( url , connectionOptions ) { <nl> / / settle a little before thinking too hard about this <nl> if ( process . env . XXX_OPLOG_URL & & ! connectionOptions . isOplog ) { <nl> var dbName = Npm . require ( ' url ' ) . parse ( url ) . pathname . substr ( 1 ) ; <nl> - / / Defer this , because it blocks . If we start observing cursors before the <nl> - / / oplog handle is ready , they just don ' t get to use the oplog . <nl> - Meteor . defer ( _ . bind ( self . _startOplogTailing , <nl> - self , process . env . XXX_OPLOG_URL , dbName ) ) ; <nl> + self . _startOplogTailing ( process . env . XXX_OPLOG_URL , dbName ) ; <nl> } <nl> } ; <nl> <nl> MongoConnection . prototype . _callWhenOplogProcessed = function ( callback ) { <nl> MongoConnection . prototype . _startOplogTailing = function ( oplogUrl , dbName ) { <nl> var self = this ; <nl> <nl> - var oplogConnection = new MongoConnection ( oplogUrl , { isOplog : true } ) ; <nl> - / / Find the last oplog entry . Blocks until the connection is ready . <nl> + var stopped = false ; <nl> + var tailHandle = null ; <nl> + var readyFuture = new Future ( ) ; <nl> + var nextId = 0 ; <nl> + var callbacksByCollection = { } ; <nl> <nl> - var lastOplogEntry = oplogConnection . findOne ( <nl> - OPLOG_COLLECTION , { } , { sort : { $ natural : - 1 } } ) ; <nl> + self . _oplogHandle = { <nl> + stop : function ( ) { <nl> + if ( stopped ) <nl> + return ; <nl> + stopped = true ; <nl> + if ( tailHandle ) <nl> + tailHandle . stop ( ) ; <nl> + } , <nl> <nl> - var oplogSelector = { <nl> - ns : new RegExp ( ' ^ ' + quotemeta ( dbName ) + ' \\ \\ . ' ) , <nl> - / / XXX also handle drop collection , etc <nl> - op : { $ in : [ ' i ' , ' u ' , ' d ' ] } <nl> - } ; <nl> - if ( lastOplogEntry ) <nl> - oplogSelector . ts = { $ gt : lastOplogEntry . ts } ; <nl> + onOplogEntry : function ( collectionName , callback ) { <nl> + if ( stopped ) <nl> + throw new Error ( \" Called onOplogEntry on stopped handle ! \" ) ; <nl> <nl> - var cursorDescription = new CursorDescription ( <nl> - OPLOG_COLLECTION , oplogSelector , { tailable : true } ) ; <nl> + / / Calling onOplogEntry requires us to wait for the tailing to be ready . <nl> + readyFuture . wait ( ) ; <nl> <nl> - var callbacksByCollection = { } ; <nl> - <nl> - var processSequence = function ( doc ) { <nl> - if ( doc . op ! = = ' i ' & & doc . op ! = = ' u ' ) <nl> - return ; <nl> - var serverId = ( doc . op = = = ' i ' ? doc . o . _id : doc . o2 . _id ) ; <nl> - if ( serverId ! = = myServerId ) <nl> - return ; <nl> - var sequenceId = <nl> - ( doc . op = = = ' i ' ? doc . o . sequence : ( doc . o . $ set & & doc . o . $ set . sequence ) ) ; <nl> - if ( typeof sequenceId ! = = ' number ' ) <nl> - return ; <nl> - / / Process all sequence points up to this point . <nl> - while ( ! _ . isEmpty ( pendingSequences ) <nl> - & & pendingSequences [ 0 ] . sequenceId < = sequenceId ) { <nl> - var sequence = pendingSequences . shift ( ) ; <nl> - sequence . callback ( ) ; <nl> + callback = Meteor . bindEnvironment ( callback , function ( err ) { <nl> + Meteor . _debug ( \" Error in oplog callback \" , err . stack ) ; <nl> + } ) ; <nl> + if ( ! _ . has ( callbacksByCollection , collectionName ) ) <nl> + callbacksByCollection [ collectionName ] = { } ; <nl> + var callbackId = nextId + + ; <nl> + callbacksByCollection [ collectionName ] [ callbackId ] = callback ; <nl> + return { <nl> + stop : function ( ) { <nl> + delete callbacksByCollection [ collectionName ] [ callbackId ] ; <nl> + } <nl> + } ; <nl> } <nl> } ; <nl> <nl> - self . _oplogHandle = oplogConnection . tail ( cursorDescription , function ( doc ) { <nl> - if ( ! doc . ns & & doc . ns . length > dbName . length + 1 & & <nl> - doc . ns . substr ( 0 , dbName . length + 1 ) = = = ( dbName + ' . ' ) ) <nl> - throw new Error ( \" Unexpected ns \" ) ; <nl> + / / Actually setting up the connection and tail blocks , so we do it \" later \" . <nl> + Meteor . defer ( function ( ) { <nl> + var oplogConnection = new MongoConnection ( oplogUrl , { isOplog : true } ) ; <nl> <nl> - var collectionName = doc . ns . substr ( dbName . length + 1 ) ; <nl> + / / Find the last oplog entry . Blocks until the connection is ready . <nl> + var lastOplogEntry = oplogConnection . findOne ( <nl> + OPLOG_COLLECTION , { } , { sort : { $ natural : - 1 } } ) ; <nl> <nl> - if ( collectionName = = = SEQUENCE_COLLECTION ) { <nl> - processSequence ( doc ) ; <nl> - return ; <nl> - } <nl> + var oplogSelector = { <nl> + ns : new RegExp ( ' ^ ' + quotemeta ( dbName ) + ' \\ \\ . ' ) , <nl> + / / XXX also handle drop collection , etc <nl> + op : { $ in : [ ' i ' , ' u ' , ' d ' ] } <nl> + } ; <nl> + if ( lastOplogEntry ) <nl> + oplogSelector . ts = { $ gt : lastOplogEntry . ts } ; <nl> <nl> - _ . each ( callbacksByCollection [ collectionName ] , function ( callback ) { <nl> - callback ( EJSON . clone ( doc ) ) ; <nl> - } ) ; <nl> - } ) ; <nl> + var cursorDescription = new CursorDescription ( <nl> + OPLOG_COLLECTION , oplogSelector , { tailable : true } ) ; <nl> <nl> - var nextId = 0 ; <nl> - self . _oplogHandle . onOplogEntry = function ( collectionName , callback ) { <nl> - callback = Meteor . bindEnvironment ( callback , function ( err ) { <nl> - Meteor . _debug ( \" Error in oplog callback \" , err . stack ) ; <nl> - } ) ; <nl> - if ( ! _ . has ( callbacksByCollection , collectionName ) ) <nl> - callbacksByCollection [ collectionName ] = { } ; <nl> - var callbackId = nextId + + ; <nl> - callbacksByCollection [ collectionName ] [ callbackId ] = callback ; <nl> - return { <nl> - stop : function ( ) { <nl> - delete callbacksByCollection [ collectionName ] [ callbackId ] ; <nl> + var processSequence = function ( doc ) { <nl> + if ( doc . op ! = = ' i ' & & doc . op ! = = ' u ' ) <nl> + return ; <nl> + var serverId = ( doc . op = = = ' i ' ? doc . o . _id : doc . o2 . _id ) ; <nl> + if ( serverId ! = = myServerId ) <nl> + return ; <nl> + var sequenceId = <nl> + ( doc . op = = = ' i ' ? doc . o . sequence : <nl> + ( doc . o . $ set & & doc . o . $ set . sequence ) ) ; <nl> + if ( typeof sequenceId ! = = ' number ' ) <nl> + return ; <nl> + / / Process all sequence points up to this point . <nl> + while ( ! _ . isEmpty ( pendingSequences ) <nl> + & & pendingSequences [ 0 ] . sequenceId < = sequenceId ) { <nl> + var sequence = pendingSequences . shift ( ) ; <nl> + sequence . callback ( ) ; <nl> } <nl> } ; <nl> - } ; <nl> + <nl> + tailHandle = oplogConnection . tail ( cursorDescription , function ( doc ) { <nl> + if ( ! doc . ns & & doc . ns . length > dbName . length + 1 & & <nl> + doc . ns . substr ( 0 , dbName . length + 1 ) = = = ( dbName + ' . ' ) ) <nl> + throw new Error ( \" Unexpected ns \" ) ; <nl> + <nl> + var collectionName = doc . ns . substr ( dbName . length + 1 ) ; <nl> + <nl> + if ( collectionName = = = SEQUENCE_COLLECTION ) { <nl> + processSequence ( doc ) ; <nl> + return ; <nl> + } <nl> + <nl> + _ . each ( callbacksByCollection [ collectionName ] , function ( callback ) { <nl> + callback ( EJSON . clone ( doc ) ) ; <nl> + } ) ; <nl> + } ) ; <nl> + readyFuture . return ( ) ; <nl> + } ) ; <nl> } ; <nl> <nl> <nl>\n", "msg": "Block on first call to observeChanges if there is an oplog handle that is still\n", "score": 1}
{"diff_id": 34810, "repo": "emberjs/ember.js\n", "sha": "859e7e490be61e12dc25556af54e35fe8fc71b61\n", "time": "2012-06-06T00:48:16Z\n", "diff": "mmm a / packages / ember - metal / lib / run_loop . js <nl> ppp b / packages / ember - metal / lib / run_loop . js <nl> function invokeLaterTimers ( ) { <nl> @ param { Number } wait <nl> Number of milliseconds to wait . <nl> <nl> - @ returns { Timer } an object you can use to cancel a timer at a later time . <nl> + @ returns { String } a string you can use to cancel the timer in Ember . run . cancel ( ) later . <nl> * / <nl> Ember . run . later = function ( target , method ) { <nl> var args , expires , timer , guid , wait ; <nl>\n", "msg": "Fixed return type docs for Ember . run . later\n", "score": 1}
{"diff_id": 34994, "repo": "photonstorm/phaser\n", "sha": "2537e3ff70126163ac2bd986ab1105cd40332849\n", "time": "2020-10-02T09:37:41Z\n", "diff": "new file mode 100644 <nl> index 0000000000 . . fc555cf004 <nl> mmm / dev / null <nl> ppp b / src / tilemaps / components / GetWorldToTileXFunction . js <nl> <nl> + / * * <nl> + * @ author Richard Davey < rich @ photonstorm . com > <nl> + * @ copyright 2020 Photon Storm Ltd . <nl> + * @ license { @ link https : / / opensource . org / licenses / MIT | MIT License } <nl> + * / <nl> + <nl> + var CONST = require ( ' . . / const ' ) ; <nl> + var NOOP = require ( ' . . / . . / utils / NOOP ' ) ; <nl> + var WorldToTileX = require ( ' . / WorldToTileX ' ) ; <nl> + <nl> + / * * <nl> + * Gets the correct function to use to translate tiles , based on the map orientation . <nl> + * <nl> + * @ function Phaser . Tilemaps . Components . GetWorldToTileXFunction <nl> + * @ since 3 . 50 . 0 <nl> + * <nl> + * @ param { number } orientation - The Tilemap orientation constant . <nl> + * <nl> + * @ return { Phaser . Tilemaps . Components . WorldToTileX ) } The function to use to translate tiles for the given map type . <nl> + * / <nl> + var GetWorldToTileXFunction = function ( orientation ) <nl> + { <nl> + if ( orientation = = = CONST . ORTHOGONAL ) <nl> + { <nl> + return WorldToTileX ; <nl> + } <nl> + else <nl> + { <nl> + return NOOP ; <nl> + } <nl> + } ; <nl> + <nl> + module . exports = GetWorldToTileXFunction ; <nl>\n", "msg": "` Tilemaps . Components . GetWorldToTileXFunction ` is a new function that returns the correct conversion function to use .\n", "score": 1}
{"diff_id": 35256, "repo": "photonstorm/phaser\n", "sha": "dfdba323fbd6a78be85feb2dc439cdde00e7f731\n", "time": "2019-06-11T13:31:43Z\n", "diff": "mmm a / src / sound / webaudio / WebAudioSoundManager . js <nl> ppp b / src / sound / webaudio / WebAudioSoundManager . js <nl> <nl> * @ license { @ link https : / / opensource . org / licenses / MIT | MIT License } <nl> * / <nl> <nl> + var Base64ToArrayBuffer = require ( ' . . / . . / utils / base64 / Base64ToArrayBuffer ' ) ; <nl> var BaseSoundManager = require ( ' . . / BaseSoundManager ' ) ; <nl> var Class = require ( ' . . / . . / utils / Class ' ) ; <nl> var Events = require ( ' . . / events ' ) ; <nl> var WebAudioSoundManager = new Class ( { <nl> return sound ; <nl> } , <nl> <nl> + / * * <nl> + * Decode audio data into a format ready for playback via Web Audio . <nl> + * <nl> + * The audio data can be a base64 encoded string , an audio media - type data uri , or an ArrayBuffer instance . <nl> + * <nl> + * The ` audioKey ` is the key that will be used to save the decoded audio to the audio cache . <nl> + * <nl> + * Instead of passing a single entry you can instead pass an array of ` Phaser . Types . Sound . DecodeAudioConfig ` <nl> + * objects as the first and only argument . <nl> + * <nl> + * Decoding is an async process , so be sure to listen for the events to know when decoding has completed . <nl> + * <nl> + * Once the audio has decoded it can be added to the Sound Manager or played via its key . <nl> + * <nl> + * @ method Phaser . Sound . WebAudioSoundManager # decodeAudio <nl> + * @ fires Phaser . Sound . Events # DECODED <nl> + * @ fires Phaser . Sound . Events # DECODED_ALL <nl> + * @ since 3 . 18 . 0 <nl> + * <nl> + * @ param { ( Phaser . Types . Sound . DecodeAudioConfig [ ] | string ) } [ audioKey ] - The string - based key to be used to reference the decoded audio in the audio cache , or an array of audio config objects . <nl> + * @ param { ( ArrayBuffer | string ) } [ audioData ] - The audio data , either a base64 encoded string , an audio media - type data uri , or an ArrayBuffer instance . <nl> + * / <nl> + decodeAudio : function ( audioKey , audioData ) <nl> + { <nl> + var audioFiles ; <nl> + <nl> + if ( ! Array . isArray ( audioKey ) ) <nl> + { <nl> + audioFiles = [ { key : audioKey , data : audioData } ] ; <nl> + } <nl> + else <nl> + { <nl> + audioFiles = audioKey ; <nl> + } <nl> + <nl> + var cache = this . game . cache . audio ; <nl> + var remaining = audioFiles . length ; <nl> + <nl> + for ( var i = 0 ; i < audioFiles . length ; i + + ) <nl> + { <nl> + var entry = audioFiles [ i ] ; <nl> + <nl> + var key = entry . key ; <nl> + var data = entry . data ; <nl> + <nl> + if ( typeof data = = = ' string ' ) <nl> + { <nl> + data = Base64ToArrayBuffer ( data ) ; <nl> + } <nl> + <nl> + var success = function ( key , audioBuffer ) <nl> + { <nl> + cache . add ( key , audioBuffer ) ; <nl> + <nl> + this . emit ( Events . DECODED , key ) ; <nl> + <nl> + remaining - - ; <nl> + <nl> + if ( remaining = = = 0 ) <nl> + { <nl> + this . emit ( Events . DECODED_ALL ) ; <nl> + } <nl> + } . bind ( this , key ) ; <nl> + <nl> + var failure = function ( key , error ) <nl> + { <nl> + / / eslint - disable - next - line no - console <nl> + console . error ( ' Error decoding audio : ' + key + ' - ' , error ? error . message : ' ' ) ; <nl> + <nl> + remaining - - ; <nl> + <nl> + if ( remaining = = = 0 ) <nl> + { <nl> + this . emit ( Events . DECODED_ALL ) ; <nl> + } <nl> + } . bind ( this , key ) ; <nl> + <nl> + this . context . decodeAudioData ( data , success , failure ) ; <nl> + } <nl> + } , <nl> + <nl> / * * <nl> * Unlocks Web Audio API on the initial input event . <nl> * <nl>\n", "msg": "New decodeAudio method for decoding base64 audio into webaudio\n", "score": 1}
{"diff_id": 35288, "repo": "photonstorm/phaser\n", "sha": "3367ddc1fe5763cea88c2922f36fce640b920b9c\n", "time": "2020-01-30T09:48:47Z\n", "diff": "mmm a / src / input / InputPlugin . js <nl> ppp b / src / input / InputPlugin . js <nl> var InputPlugin = new Class ( { <nl> * @ param { Phaser . Types . Input . HitAreaCallback } [ callback ] - The ' contains ' function to invoke to check if the pointer is within the hit area . <nl> * @ param { boolean } [ dropZone = false ] - Is this Game Object a drop zone or not ? <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This Input Plugin . <nl> + * @ return { this } This Input Plugin . <nl> * / <nl> enable : function ( gameObject , shape , callback , dropZone ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * <nl> * @ param { Phaser . GameObjects . GameObject } child - The Game Object to add . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> queueForInsertion : function ( child ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * <nl> * @ param { Phaser . GameObjects . GameObject } child - The Game Object to remove . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> queueForRemoval : function ( child ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ param { ( Phaser . GameObjects . GameObject | Phaser . GameObjects . GameObject [ ] ) } gameObjects - An array of Game Objects to change the draggable state on . <nl> * @ param { boolean } [ value = true ] - Set to ` true ` if the Game Objects should be made draggable , ` false ` if they should be unset . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setDraggable : function ( gameObjects , value ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ param { ( Phaser . Types . Input . InputConfiguration | any ) } [ shape ] - Either an input configuration object , or a geometric shape that defines the hit area for the Game Object . If not specified a Rectangle will be used . <nl> * @ param { Phaser . Types . Input . HitAreaCallback } [ callback ] - The ' contains ' function to invoke to check if the pointer is within the hit area . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setHitArea : function ( gameObjects , shape , callback ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ param { number } radius - The radius of the circle . <nl> * @ param { Phaser . Types . Input . HitAreaCallback } [ callback ] - The hit area callback . If undefined it uses Circle . Contains . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setHitAreaCircle : function ( gameObjects , x , y , radius , callback ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ param { number } height - The height of the ellipse . <nl> * @ param { Phaser . Types . Input . HitAreaCallback } [ callback ] - The hit area callback . If undefined it uses Ellipse . Contains . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setHitAreaEllipse : function ( gameObjects , x , y , width , height , callback ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ param { ( Phaser . GameObjects . GameObject | Phaser . GameObjects . GameObject [ ] ) } gameObjects - An array of Game Objects to set as having an ellipse hit area . <nl> * @ param { Phaser . Types . Input . HitAreaCallback } [ callback ] - The hit area callback . If undefined it uses Rectangle . Contains . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setHitAreaFromTexture : function ( gameObjects , callback ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ param { number } height - The height of the rectangle . <nl> * @ param { Phaser . Types . Input . HitAreaCallback } [ callback ] - The hit area callback . If undefined it uses Rectangle . Contains . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setHitAreaRectangle : function ( gameObjects , x , y , width , height , callback ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ param { number } y3 - The y coordinate of the third point of the triangle . <nl> * @ param { Phaser . Types . Input . HitAreaCallback } [ callback ] - The hit area callback . If undefined it uses Triangle . Contains . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setHitAreaTriangle : function ( gameObjects , x1 , y1 , x2 , y2 , x3 , y3 , callback ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ param { Phaser . GameObjects . GameObject } gameObject - The Game Object to create the input debug shape for . <nl> * @ param { number } [ color = 0x00ff00 ] - The outline color of the debug shape . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This Input Plugin . <nl> + * @ return { this } This Input Plugin . <nl> * / <nl> enableDebug : function ( gameObject , color ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * <nl> * @ param { Phaser . GameObjects . GameObject } gameObject - The Game Object to remove the input debug shape from . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This Input Plugin . <nl> + * @ return { this } This Input Plugin . <nl> * / <nl> removeDebug : function ( gameObject ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ method Phaser . Input . InputPlugin # setPollAlways <nl> * @ since 3 . 0 . 0 <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setPollAlways : function ( ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ method Phaser . Input . InputPlugin # setPollOnMove <nl> * @ since 3 . 0 . 0 <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setPollOnMove : function ( ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * <nl> * @ param { number } value - The amount of time , in ms , that should elapsed before re - polling the pointers . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setPollRate : function ( value ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * <nl> * @ param { boolean } value - Set to ` true ` to stop processing input events on the Scene that receives it , or ` false ` to let the event continue down the Scene list . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setGlobalTopOnly : function ( value ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * <nl> * @ param { boolean } value - ` true ` to only include the top - most Game Object , or ` false ` to include all Game Objects in a hit test . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> setTopOnly : function ( value ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * @ method Phaser . Input . InputPlugin # stopPropagation <nl> * @ since 3 . 0 . 0 <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This InputPlugin object . <nl> + * @ return { this } This InputPlugin object . <nl> * / <nl> stopPropagation : function ( ) <nl> { <nl> var InputPlugin = new Class ( { <nl> * <nl> * @ param { string } cursor - The CSS to be used when setting the default cursor . <nl> * <nl> - * @ return { Phaser . Input . InputPlugin } This Input instance . <nl> + * @ return { this } This Input instance . <nl> * / <nl> setDefaultCursor : function ( cursor ) <nl> { <nl>\n", "msg": "Fixed ` this ` return types for ` Phaser . Input . InputPlugin `\n", "score": 1}
{"diff_id": 35458, "repo": "facebook/react-native\n", "sha": "22e318fab0ce6647e5f5b985db178ac6611e9ad7\n", "time": "2020-04-08T00:39:21Z\n", "diff": "mmm a / Libraries / Image / Image . android . js <nl> ppp b / Libraries / Image / Image . android . js <nl> let Image = ( props : ImagePropsType , forwardedRef ) = > { <nl> return ( <nl> < ImageAnalyticsTagContext . Consumer > <nl> { analyticTag = > { <nl> - const nativePropsWithAnalytics = { <nl> - . . . nativeProps , <nl> - analyticTag : analyticTag , <nl> - } ; <nl> + const nativePropsWithAnalytics = <nl> + analyticTag ! = = null <nl> + ? { <nl> + . . . nativeProps , <nl> + analyticTag : analyticTag , <nl> + } <nl> + : nativeProps ; <nl> return ( <nl> < TextAncestor . Consumer > <nl> { hasTextAncestor = > <nl>\n", "msg": "Avoid passing analyticsTag prop to native if this is set to null\n", "score": 1}
{"diff_id": 35506, "repo": "balderdashy/sails\n", "sha": "79e2bb8e61c9f5689004bb403fb7a0328e8d24e3\n", "time": "2017-02-22T00:54:32Z\n", "diff": "mmm a / lib / hooks / session / index . js <nl> ppp b / lib / hooks / session / index . js <nl> module . exports = function ( app ) { <nl> / /                                                         <nl> / /                                                <nl> / /                                              <nl> - ( function setupAdapter ( setupMiddleware ) { <nl> + ( function setupAdapter ( proceed ) { <nl> <nl> / / If no adapter config was provided , skip down to creating the session middleware . <nl> - if ( ! _ . isObject ( app . config . session ) | | ! app . config . session . adapter ) { return setupMiddleware ( ) ; } <nl> + if ( ! _ . isObject ( app . config . session ) | | ! app . config . session . adapter ) { return proceed ( ) ; } <nl> <nl> / / ' memory ' is a special case <nl> if ( app . config . session . adapter = = = ' memory ' ) { <nl> var MemoryStore = require ( ' express - session ' ) . MemoryStore ; <nl> app . config . session . store = new MemoryStore ( ) ; <nl> - return setupMiddleware ( ) ; <nl> + return proceed ( ) ; <nl> } / /  <nl> / / For all other adapters , we ' ll try to require the module and do some setup . <nl> else { <nl> module . exports = function ( app ) { <nl> / /                                                 <nl> / /                                        <nl> / /                                        <nl> - ( function maybeConnectToRedis ( afterMaybeConnectToRedis ) { <nl> + ( function maybeConnectToRedis ( proceed ) { <nl> <nl> / / If the adapter isn ' t set to ` connect - redis ` , skip this part . <nl> if ( app . config . session . adapter ! = = ' connect - redis ' ) { <nl> - return afterMaybeConnectToRedis ( ) ; <nl> + return proceed ( ) ; <nl> } <nl> <nl> / / If a connection URL is provided , use that , otherwise construct one from the pieces <nl> module . exports = function ( app ) { <nl> } <nl> } <nl> } ) . exec ( function ( err , createManagerResult ) { <nl> - if ( err ) { return cb ( err ) ; } <nl> + if ( err ) { return proceed ( err ) ; } <nl> <nl> / / Use the manager to create a new Redis connection . <nl> Redis . getConnection ( { <nl> manager : createManagerResult . manager <nl> } ) . exec ( { <nl> - failed : function ( err ) { return cb ( err . error ) ; } , <nl> - error : cb , <nl> + error : function ( err ) { return proceed ( err ) ; } , <nl> + failed : function ( report ) { return proceed ( report . error ) ; } , <nl> success : function ( result ) { <nl> / / Save the connected client into the session config so that it can be used <nl> / / by the connect - redis module . <nl> app . config . session . client = result . connection ; <nl> - return afterMaybeConnectToRedis ( ) ; <nl> + return proceed ( ) ; <nl> } <nl> } ) ; <nl> <nl> } ) ; <nl> } ) <nl> - ( function afterMaybeConnectToRedis ( ) { <nl> + ( function afterMaybeConnectToRedis ( err ) { <nl> + if ( err ) { return proceed ( err ) ; } <nl> + <nl> / / If ` sails . config . session . adapter ` is a string , attempt to require the <nl> / / module identified by the string . <nl> if ( _ . isString ( app . config . session . adapter ) ) { <nl> module . exports = function ( app ) { <nl> <nl> / / If an error occurred while attempting to require ( ) the adapter , include <nl> / / some ( hopefully ) helpful instructions on installing the adapter . <nl> - return cb ( new Error ( <nl> + return proceed ( new Error ( <nl> / / ' Could not require ` ' + app . config . session . adapter + ' ` ( a session adapter ) . \\ n ' + <nl> ' Do you have ` ' + app . config . session . adapter + ' ` installed locally ? \\ n ' + <nl> ' If not , try running the following command in your app \\ ' s root directory : \\ n ' + <nl> module . exports = function ( app ) { <nl> } <nl> / / Otherwise bail , because sails . config . session . adapter is invalid . <nl> else { <nl> - return cb ( new Error ( ' If configured , ` sails . config . session . adapter ` should be a reference to an Express session adapter ! Instead got ` ' + util . inspect ( app . config . session . adapter ) ) ) ; <nl> + return proceed ( new Error ( ' If configured , ` sails . config . session . adapter ` should be a reference to an Express session adapter ! Instead got ` ' + util . inspect ( app . config . session . adapter ) ) ) ; <nl> } <nl> <nl> / / Okay , so now we have an adapter that we can call to create an <nl> module . exports = function ( app ) { <nl> catch ( rawSessionStoreCreationErr ) { <nl> <nl> / / Failed attempting to initialize adapter ; output a message w / error info <nl> - return cb ( new Error ( <nl> + return proceed ( new Error ( <nl> ' Encountered error attempting to instantiate a session store using the installed version of ` ' + app . config . session . adapter + ' ` ( a session adapter ) . \\ n ' + <nl> ' Raw error from the session adapter : \\ n ' + <nl> ' mmm \\ n ' + <nl> module . exports = function ( app ) { <nl> <nl> } / / < / catch : : failed to instantiate session adapter by passing in express - session > <nl> <nl> - return setupMiddleware ( ) ; <nl> - } ) ; <nl> - <nl> + return proceed ( ) ; <nl> + } ) ; / / < / self - calling function > <nl> <nl> } / / < / else ( if we ' re using a custom store and NOT the memory store ) > <nl> - } ) / / < / if sails . config . session . adapter is truthy > <nl> - / / > - <nl> - ( function setupMiddleware ( ) { <nl> + <nl> + } ) ( function afterSettingUpAdapter ( err ) { / / ~  %  <nl> + if ( err ) { return cb ( err ) ; } <nl> <nl> / / Expose hook as ` sails . session ` <nl> app . session = SessionHook ; <nl> module . exports = function ( app ) { <nl> <nl> return cb ( ) ; <nl> <nl> - } ) ; / / < / setupMiddleware ( ) > <nl> + } ) ; / / < / self - calling function that sets up adapter ) > <nl> <nl> } , / / < / initialize > <nl> <nl>\n", "msg": "Tweaks to avoid calling out - of - bounds outlets .\n", "score": 1}
{"diff_id": 35604, "repo": "meteor/meteor\n", "sha": "e0eacc62fd72da4d376507ae7e137b4bcefcdee1\n", "time": "2018-01-22T23:07:56Z\n", "diff": "mmm a / packages / meteor / cordova_environment . js <nl> ppp b / packages / meteor / cordova_environment . js <nl> Meteor . isCordova = true ; <nl> <nl> Meteor . isProduction = meteorEnv . NODE_ENV = = = \" production \" ; <nl> Meteor . isDevelopment = meteorEnv . NODE_ENV ! = = \" production \" ; <nl> + <nl> + / / For now , since we can ' t send different bundles to different Cordova <nl> + / / browsers at runtime , all Cordova clients must be regarded as legacy . <nl> + Meteor . isModern = false ; <nl>\n", "msg": "Set Meteor . isModern to false in Cordova environments .\n", "score": 1}
{"diff_id": 35614, "repo": "atom/atom\n", "sha": "51831b332d3296db2c8b31bc0a1d8f01b9e0b4e7\n", "time": "2016-03-28T18:50:04Z\n", "diff": "mmm a / src / git - repository - async . js <nl> ppp b / src / git - repository - async . js <nl> export default class GitRepositoryAsync { <nl> / / * ` added ` The { Number } of added lines . <nl> / / * ` deleted ` The { Number } of deleted lines . <nl> getDiffStats ( _path ) { <nl> - return this . getRepo ( ) <nl> + return this . getRepo ( _path ) <nl> . then ( repo = > Promise . all ( [ repo , repo . getHeadCommit ( ) ] ) ) <nl> . then ( ( [ repo , headCommit ] ) = > Promise . all ( [ repo , headCommit . getTree ( ) ] ) ) <nl> . then ( ( [ repo , tree ] ) = > { <nl> export default class GitRepositoryAsync { <nl> / / * ` newLines ` The { Number } of lines in the new hunk <nl> getLineDiffs ( _path , text ) { <nl> let relativePath = null <nl> - return this . getRepo ( ) <nl> + return this . getRepo ( _path ) <nl> . then ( repo = > { <nl> relativePath = this . relativize ( _path , repo . workdir ( ) ) <nl> return repo . getHeadCommit ( ) <nl> export default class GitRepositoryAsync { <nl> / / Returns a { Promise } that resolves or rejects depending on whether the <nl> / / method was successful . <nl> checkoutHead ( _path ) { <nl> - return this . getRepo ( ) <nl> + return this . getRepo ( _path ) <nl> . then ( repo = > { <nl> const checkoutOptions = new Git . CheckoutOptions ( ) <nl> checkoutOptions . paths = [ this . relativize ( _path , repo . workdir ( ) ) ] <nl>\n", "msg": "Take the submodule into account in more instances .\n", "score": 1}
{"diff_id": 35697, "repo": "photonstorm/phaser\n", "sha": "118d2057c0ea9db0b2ae96f910bd31e20875ec09\n", "time": "2016-07-26T02:43:19Z\n", "diff": "mmm a / src / animation / Animation . js <nl> ppp b / src / animation / Animation . js <nl> Object . defineProperty ( Phaser . Animation . prototype , ' frame ' , { <nl> <nl> / * * <nl> * @ name Phaser . Animation # speed <nl> - * @ property { number } speed - Gets or sets the current speed of the animation in frames per second . Changing this in a playing animation will take effect from the next frame . Minimum value is 1 . <nl> + * @ property { number } speed - Gets or sets the current speed of the animation in frames per second . Changing this in a playing animation will take effect from the next frame . Value must be greater than 0 . <nl> * / <nl> Object . defineProperty ( Phaser . Animation . prototype , ' speed ' , { <nl> <nl> get : function ( ) { <nl> <nl> - return Math . round ( 1000 / this . delay ) ; <nl> + return 1000 / this . delay ; <nl> <nl> } , <nl> <nl> set : function ( value ) { <nl> <nl> - if ( value > = 1 ) <nl> + if ( value > 0 ) <nl> { <nl> this . delay = 1000 / value ; <nl> } <nl>\n", "msg": "Allow animation speed greater than 0\n", "score": 1}
{"diff_id": 35723, "repo": "preactjs/preact\n", "sha": "5ca98cfd1f61daf60989ff95637b38edc60deed1\n", "time": "2016-05-21T15:43:27Z\n", "diff": "mmm a / src / vdom / diff . js <nl> ppp b / src / vdom / diff . js <nl> <nl> - import { ATTR_KEY , UNDEFINED_ELEMENT , EMPTY } from ' . . / constants ' ; <nl> - import { createObject , hasOwnProperty , toArray , empty , toLowerCase , isString , isFunction } from ' . . / util ' ; <nl> + import { ATTR_KEY } from ' . . / constants ' ; <nl> + import { createObject , hasOwnProperty , toArray , empty , isString , isFunction } from ' . . / util ' ; <nl> import { hook , deepHook } from ' . . / hooks ' ; <nl> - import { isSameNodeType } from ' . ' ; <nl> + import { isSameNodeType , isNamedNode } from ' . ' ; <nl> import { isFunctionalComponent , buildFunctionalComponent } from ' . / functional - component ' ; <nl> import { buildComponentFromVNode } from ' . / component ' ; <nl> - import { unmountComponent } from ' . / component ' ; <nl> import { removeNode , appendChildren , setAccessor , getNodeData , getRawNodeAttributes , getNodeType } from ' . . / dom ' ; <nl> import { createNode , collectNode } from ' . . / dom / recycler ' ; <nl> + import { unmountComponent } from ' . / component ' ; <nl> <nl> <nl> - function buildTextNode ( dom , str ) { <nl> - if ( dom ) { <nl> - let type = getNodeType ( dom ) ; <nl> - if ( type = = = 3 ) { <nl> - if ( dom . nodeValue ! = = str ) { <nl> - dom . nodeValue = str ; <nl> - } <nl> - return dom ; <nl> - } <nl> - if ( type = = = 1 ) collectNode ( dom ) ; <nl> - } <nl> - return document . createTextNode ( str ) ; <nl> - } <nl> <nl> <nl> / * * Apply differences in a given vnode ( and it ' s deep children ) to a real DOM Node . <nl> export default function diff ( dom , vnode , context , mountAll ) { <nl> } <nl> <nl> if ( isString ( vnode ) ) { <nl> - return buildTextNode ( dom , vnode ) ; <nl> + if ( dom ) { <nl> + if ( getNodeType ( dom ) = = = 3 ) { <nl> + if ( dom . nodeValue ! = = vnode ) { <nl> + dom . nodeValue = vnode ; <nl> + } <nl> + return dom ; <nl> + } <nl> + collectNode ( dom ) ; <nl> + } <nl> + return document . createTextNode ( vnode ) ; <nl> } <nl> <nl> / / return diffNode ( dom , vnode , context ) ; <nl> / / } <nl> + let out = dom , <nl> + nodeName = String ( vnode . nodeName ) ; <nl> <nl> <nl> - / * * Morph a DOM node to look like the given VNode . Creates DOM if it doesn ' t exist . * / <nl> - / / function diffNode ( dom , vnode , context ) { <nl> - let out = dom , <nl> - nodeName = vnode . nodeName | | UNDEFINED_ELEMENT ; <nl> <nl> if ( ! dom ) { <nl> out = createNode ( nodeName ) ; <nl> } <nl> - else if ( toLowerCase ( dom . nodeName ) ! = = nodeName ) { <nl> + else if ( ! isNamedNode ( dom , nodeName ) ) { <nl> out = createNode ( nodeName ) ; <nl> / / move children into the replacement node <nl> appendChildren ( out , toArray ( dom . childNodes ) ) ; <nl> export default function diff ( dom , vnode , context , mountAll ) { <nl> recollectNodeTree ( dom ) ; <nl> } <nl> <nl> - innerDiffNode ( out , vnode , context ) ; <nl> - diffAttributes ( out , vnode ) ; <nl> + diffNode ( out , vnode , context , mountAll ) ; <nl> <nl> if ( originalAttributes & & originalAttributes . ref ) { <nl> ( out [ ATTR_KEY ] . ref = originalAttributes . ref ) ( out ) ; <nl> export default function diff ( dom , vnode , context , mountAll ) { <nl> } <nl> <nl> <nl> + / * * Morph a DOM node to look like the given VNode . Creates DOM if it doesn ' t exist . * / <nl> + function diffNode ( dom , vnode , context , mountAll ) { <nl> + <nl> + let vchildren = vnode . children , <nl> + firstChild = dom . firstChild ; <nl> + if ( vchildren & & vchildren . length = = = 1 & & typeof vchildren [ 0 ] = = = ' string ' & & firstChild instanceof Text & & dom . childNodes . length = = = 1 ) { <nl> + firstChild . nodeValue = vchildren [ 0 ] ; <nl> + } <nl> + else if ( vchildren | | firstChild ) { <nl> + innerDiffNode ( dom , vchildren , context , mountAll ) ; <nl> + } <nl> + <nl> + diffAttributes ( dom , vnode ) ; <nl> + } <nl> + <nl> + <nl> + function getKey ( child ) { <nl> + let data = getNodeData ( child ) ; <nl> + if ( data & & ! empty ( data . key ) ) return data . key ; <nl> + } <nl> + <nl> + <nl> / * * Apply child and attribute changes between a VNode and a DOM Node to the DOM . * / <nl> - function innerDiffNode ( dom , vnode , context ) { <nl> - let children , <nl> + function innerDiffNode ( dom , vchildren , context , mountAll ) { <nl> + let originalChildren = dom . childNodes , <nl> + children , <nl> keyed , <nl> keyedLen = 0 , <nl> - len = dom . childNodes . length , <nl> + min = 0 , <nl> + vlen = vchildren & & vchildren . length , <nl> + len = originalChildren . length , <nl> childrenLen = 0 ; <nl> + <nl> if ( len ) { <nl> children = [ ] ; <nl> for ( let i = 0 ; i < len ; i + + ) { <nl> - let child = dom . childNodes [ i ] , <nl> - key = child . _component ? child . _component . __key : getAccessor ( child , ' key ' ) ; <nl> - if ( ! empty ( key ) ) { <nl> + let child = originalChildren [ i ] , <nl> + key = child . _component ? child . _component . __key : getKey ( child ) ; <nl> + if ( key | | key = = = 0 ) { <nl> if ( ! keyed ) keyed = createObject ( ) ; <nl> keyed [ key ] = child ; <nl> keyedLen + + ; <nl> function innerDiffNode ( dom , vnode , context ) { <nl> } <nl> } <nl> <nl> - <nl> - let vchildren = vnode . children , <nl> - vlen = vchildren & & vchildren . length , <nl> - min = 0 ; <nl> if ( vlen ) { <nl> for ( let i = 0 ; i < vlen ; i + + ) { <nl> let vchild = vchildren [ i ] , <nl> export function recollectNodeTree ( node , unmountOnly ) { <nl> <nl> / * * Apply differences in attributes from a VNode to the given DOM Node . * / <nl> function diffAttributes ( dom , vnode ) { <nl> - attrs = vnode . attributes | | EMPTY , <nl> - name , value ; <nl> let old = getNodeData ( dom ) | | getRawNodeAttributes ( dom ) , <nl> + attrs = vnode . attributes ; <nl> <nl> - / / removed <nl> - for ( name in old ) { <nl> - if ( empty ( attrs [ name ] ) ) { <nl> + / / removeAttributes ( dom , old , attrs | | EMPTY ) ; <nl> + for ( let name in old ) { <nl> + if ( ! attrs | | ! hasOwnProperty . call ( attrs , name ) ) { <nl> setAccessor ( dom , name , null ) ; <nl> } <nl> } <nl> <nl> / / new & updated <nl> - if ( attrs ! = = EMPTY ) { <nl> - for ( name in attrs ) { <nl> - if ( hasOwnProperty . call ( attrs , name ) ) { <nl> - value = attrs [ name ] ; <nl> - if ( ! empty ( value ) & & value ! = getAccessor ( dom , name ) ) { <nl> - setAccessor ( dom , name , value ) ; <nl> - } <nl> + if ( attrs ) { <nl> + for ( let name in attrs ) { <nl> + let value = attrs [ name ] = = = undefined ? null : attrs [ name ] ; <nl> + if ( value ! = old [ name ] ) { <nl> + setAccessor ( dom , name , value ) ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Diff optimizations ! Fairly major performance boost thanks to optimizing the fast case for single text nodes within a parent .\n", "score": 1}
{"diff_id": 35755, "repo": "meteor/meteor\n", "sha": "a94bb6d88310008bbd1c0c31f5a8b36f444f8909\n", "time": "2014-02-26T07:26:29Z\n", "diff": "mmm a / packages / mongo - livedata / oplog_observe_driver . js <nl> ppp b / packages / mongo - livedata / oplog_observe_driver . js <nl> _ . extend ( OplogObserveDriver . prototype , { <nl> if ( self . _unpublishedBuffer . size ( ) > self . _limit ) { <nl> var maxBufferedId = self . _unpublishedBuffer . maxElementId ( ) ; <nl> <nl> - if ( EJSON . equals ( maxBufferedId , id ) ) { <nl> - throw new Error ( \" The document just added to buffer is overflowing the buffer \" ) ; <nl> - } <nl> - <nl> self . _unpublishedBuffer . remove ( maxBufferedId ) ; <nl> <nl> / / Since something matching is removed from cache ( both published set and <nl> _ . extend ( OplogObserveDriver . prototype , { <nl> / / document would fit into published set pushing the maximum element out , <nl> / / then we need to publish the doc . <nl> var toPublish = ! limit | | self . _published . size ( ) < limit | | <nl> - comparator ( maxPublished , doc ) > 0 ; <nl> + comparator ( doc , maxPublished ) < 0 ; <nl> <nl> / / Otherwise we might need to buffer it ( only in case of limited query ) . <nl> / / Buffering is allowed if the buffer is not filled up yet and all matching <nl> _ . extend ( OplogObserveDriver . prototype , { <nl> / / Or if it is small enough to be safely inserted to the middle or the <nl> / / beginning of the buffer . <nl> var canInsertIntoBuffer = ! toPublish & & maxBuffered & & <nl> - comparator ( maxBuffered , doc ) > 0 ; <nl> + comparator ( doc , maxBuffered ) < = 0 ; <nl> <nl> var toBuffer = canAppendToBuffer | | canInsertIntoBuffer ; <nl> <nl> _ . extend ( OplogObserveDriver . prototype , { <nl> var maxBuffered = self . _unpublishedBuffer . get ( self . _unpublishedBuffer . maxElementId ( ) ) ; <nl> <nl> var toBuffer = self . _safeAppendToBuffer | | <nl> - ( maxBuffered & & comparator ( newDoc , maxBuffered ) < 0 ) ; <nl> + ( maxBuffered & & comparator ( newDoc , maxBuffered ) < = 0 ) ; <nl> <nl> if ( toBuffer ) { <nl> self . _addBuffered ( id , newDoc ) ; <nl> _ . extend ( OplogObserveDriver . prototype , { <nl> <nl> / / or stays in buffer even after the change <nl> var staysInBuffer = ( ! toPublish & & self . _safeAppendToBuffer ) | | <nl> - ( ! toPublish & & maxBuffered & & comparator ( newDoc , maxBuffered ) < 0 ) ; <nl> + ( ! toPublish & & maxBuffered & & comparator ( newDoc , maxBuffered ) < = 0 ) ; <nl> <nl> if ( toPublish ) { <nl> self . _addPublished ( id , newDoc ) ; <nl>\n", "msg": "Allow appending to buffer if new doc is equivalent to the greatest element\n", "score": 1}
{"diff_id": 35886, "repo": "meteor/meteor\n", "sha": "8c70716954f8fcdd02fc0c673a39da2b7186ce2b\n", "time": "2017-06-30T14:24:11Z\n", "diff": "mmm a / tools / fs / safe - watcher . js <nl> ppp b / tools / fs / safe - watcher . js <nl> const entries = Object . create ( null ) ; <nl> / / to deduplicate files by ino . <nl> const entriesByIno = new Map ; <nl> <nl> + / / Set of paths for which a change event has been fired , watched with <nl> + / / watchLibrary . watch if available . This could be an LRU cache , but in <nl> + / / practice it should never grow large enough for that to matter . <nl> + const recentlyChanged = new Set ; <nl> + <nl> function acquireWatcher ( absPath , callback ) { <nl> const entry = entries [ absPath ] | | ( <nl> entries [ absPath ] = startNewWatcher ( absPath ) ) ; <nl> function startNewWatcher ( absPath ) { <nl> const callbacks = new Set ; <nl> let watcherCleanupTimer = null ; <nl> let watcher ; <nl> - let pollingInterval ; <nl> + <nl> + function getPollingInterval ( ) { <nl> + if ( watcher ) { <nl> + return DEFAULT_POLLING_INTERVAL ; <nl> + } <nl> + <nl> + if ( recentlyChanged . has ( absPath ) ) { <nl> + return NO_WATCHER_POLLING_INTERVAL ; <nl> + } <nl> + <nl> + if ( WATCHER_ENABLED ) { <nl> + return DEFAULT_POLLING_INTERVAL ; <nl> + } <nl> + <nl> + return NO_WATCHER_POLLING_INTERVAL ; <nl> + } <nl> <nl> function fire ( event ) { <nl> if ( event ! = = \" change \" ) { <nl> function startNewWatcher ( absPath ) { <nl> / / \" delete \" or \" rename \" event , since it is now our only reliable <nl> / / source of file change notifications . <nl> lastWatcherEventTime = 0 ; <nl> + <nl> + } else { <nl> + recentlyChanged . add ( absPath ) ; <nl> + rewatch ( ) ; <nl> } <nl> <nl> callbacks . forEach ( cb = > cb . call ( this , event ) ) ; <nl> function startNewWatcher ( absPath ) { <nl> } <nl> <nl> function rewatch ( ) { <nl> - if ( watcher ) { <nl> - / / Already watching ; nothing to do . <nl> - return ; <nl> + if ( recentlyChanged . has ( absPath ) ) { <nl> + if ( watcher ) { <nl> + / / Already watching ; nothing to do . <nl> + return ; <nl> + } <nl> + watcher = watchLibraryWatch ( absPath , watchWrapper ) ; <nl> + } else if ( watcher ) { <nl> + safeUnwatch ( ) ; <nl> } <nl> <nl> - watcher = watchLibraryWatch ( absPath , watchWrapper ) ; <nl> - <nl> - pollingInterval = watcher <nl> - ? DEFAULT_POLLING_INTERVAL <nl> - : NO_WATCHER_POLLING_INTERVAL ; <nl> - <nl> / / This is a no - op if we ' re not watching the file . <nl> unwatchFile ( absPath , watchFileWrapper ) ; <nl> <nl> function startNewWatcher ( absPath ) { <nl> / / CPU cycles . <nl> watchFile ( absPath , { <nl> persistent : false , <nl> - interval : pollingInterval , <nl> + interval : getPollingInterval ( ) , <nl> } , watchFileWrapper ) ; <nl> } <nl> <nl> function startNewWatcher ( absPath ) { <nl> <nl> / / If a watcher event fired in the last polling interval , ignore <nl> / / this event . <nl> - if ( new Date - lastWatcherEventTime > pollingInterval ) { <nl> + if ( new Date - lastWatcherEventTime > getPollingInterval ( ) ) { <nl> fire . call ( this , \" change \" ) ; <nl> } <nl> } <nl> <nl> - rewatch ( ) ; <nl> - <nl> const entry = { <nl> callbacks , <nl> rewatch , <nl>\n", "msg": "Use native file watchers only to watch recently changed files .\n", "score": 1}
{"diff_id": 563, "repo": "meteor/meteor\n", "sha": "a646bdbbd4b988f1f25c86159972fb1b70c13ce9\n", "time": "2018-05-15T14:34:21Z\n", "diff": "mmm a / packages / dynamic - import / client . js <nl> ppp b / packages / dynamic - import / client . js <nl> exports . setSecretKey = function ( key ) { <nl> } ; <nl> <nl> var fetchURL = require ( \" . / common . js \" ) . fetchURL ; <nl> - var location = typeof window = = = \" object \" & & window . location ; <nl> <nl> function fetchMissing ( missingTree ) { <nl> return new Promise ( function ( resolve , reject ) { <nl> - / / In browsers , use \" / / \" + location . host to match the protocol and <nl> - / / origin of the current page . On the server ( where window . location is <nl> - / / not defined ) , use Meteor . absoluteUrl . In practice , dynamic modules <nl> - / / used on the server are typically just included in the initial JS <nl> - / / bundle , so the Meteor . absoluteUrl branch of this code is uncommon . <nl> - var url = location <nl> - ? \" / / \" + location . host + fetchURL <nl> - : Meteor . absoluteUrl ( fetchURL ) ; <nl> - <nl> - HTTP . call ( \" POST \" , url , { <nl> + / / If the hostname of the URL returned by Meteor . absoluteUrl differs <nl> + / / from location . host , then we ' ll be making a cross - origin request <nl> + / / here , but that ' s fine because the dynamic - import server sets <nl> + / / appropriate CORS headers to enable fetching dynamic modules from <nl> + / / any origin . Browsers that check CORS do so by sending an additional <nl> + / / preflight OPTIONS request , which may add latency to the first <nl> + / / dynamic import ( ) request , so it ' s a good idea for ROOT_URL to match <nl> + / / location . host if possible , though not strictly necessary . <nl> + HTTP . call ( \" POST \" , Meteor . absoluteUrl ( fetchURL ) , { <nl> query : secretKey ? \" key = \" + secretKey : void 0 , <nl> data : missingTree <nl> } , function ( error , result ) { <nl>\n", "msg": "Use only Meteor . absoluteUrl for dynamic import ( ) requests , again .\n", "score": 1}
{"diff_id": 642, "repo": "adam-p/markdown-here\n", "sha": "68637f157d1f0419b8421fb0899df37ad475d23c\n", "time": "2013-02-04T15:12:14Z\n", "diff": "mmm a / src / common / markdown - render . js <nl> ppp b / src / common / markdown - render . js <nl> <nl> / / Experimentation has shown some tags that need to be tweaked a little . <nl> preprocessInfo . html = <nl> preprocessInfo . html <nl> + . replace ( / ( < \\ / div > ) ( ( ? ! < div ) . + ? ) ( < div [ ^ > ] * > ) / ig , ' $ 1 < div > $ 2 < / div > $ 3 ' ) / / a raw text node without an enclosing < div > won ' t be handled properly , so add one <nl> + . replace ( / ( < \\ / div > ) < div [ ^ > ] * > < \\ / div > ( < div [ ^ > ] * > ) / ig , ' $ 1 $ 2 ' ) / / empty < div > between other < div > elems gets removed <nl> . replace ( / < div [ ^ > ] * > < br > < \\ / div > / ig , ' < br > ' ) / / < div > < br > < / div > - - > < br > <nl> . replace ( / ( < div [ ^ > ] * > ) + / ig , ' < br > ' ) / / opening < div > - - > < br > ( but nested < div > < div > just gets one < br > ) <nl> . replace ( / < \\ / div > / ig , ' ' ) / / closing < / div > - - > nothing <nl>\n", "msg": "Enablign GFM line breaks revealed some shortcomings in the HTML - to - text code . Added a couple more preprocessing rules to deal with DIVs .\n", "score": 1}
{"diff_id": 1778, "repo": "photonstorm/phaser\n", "sha": "19ec0fb7351dd2d2de0dcab410d0405ee18be530\n", "time": "2018-01-17T18:02:10Z\n", "diff": "mmm a / src / sound / html5 / HTML5AudioSoundManager . js <nl> ppp b / src / sound / html5 / HTML5AudioSoundManager . js <nl> var HTML5AudioSoundManager = new Class ( { <nl> * @ default [ ] <nl> * / <nl> this . onBlurPausedSounds = [ ] ; <nl> + / * * <nl> + * A queue of all actions performed on sound objects while audio was locked . <nl> + * Once the audio gets unlocked , after an explicit user interaction , <nl> + * all actions will be performed in chronological order . <nl> + * <nl> + * @ private <nl> + * @ property { { <nl> + * sound : Phaser . Sound . HTML5AudioSound , <nl> + * name : string , <nl> + * value ? : any , <nl> + * } [ ] } lockedActionsQueue <nl> + * @ default [ ] <nl> + * / <nl> + this . lockedActionsQueue = [ ] ; <nl> / * * <nl> * Property that actually holds the value of global mute <nl> * for HTML5 Audio sound manager implementation . <nl>\n", "msg": "Added lockedActionsQueue property to HTML5AudioSoundManager class for internal use\n", "score": 1}
{"diff_id": 3991, "repo": "atom/atom\n", "sha": "ba7275dc4fb6e21f44977bfe09c5432af868bd9e\n", "time": "2017-08-01T19:08:06Z\n", "diff": "mmm a / src / native - watcher - registry . js <nl> ppp b / src / native - watcher - registry . js <nl> class RegistryTree { <nl> return this . root <nl> } <nl> <nl> + print ( ) { <nl> + return this . root . print ( ) <nl> + } <nl> + <nl> } <nl> <nl> / / Private : Non - leaf node in a tree used by the { NativeWatcherRegistry } to cover the allocated { Watcher } instances with <nl> class RegistryNode { <nl> } <nl> return results <nl> } <nl> + <nl> + print ( indent = 0 ) { <nl> + let spaces = ' ' <nl> + for ( let i = 0 ; i < indent ; i + + ) { <nl> + spaces + = ' ' <nl> + } <nl> + <nl> + let result = ' ' <nl> + for ( const p of Object . keys ( this . children ) ) { <nl> + result + = ` $ { spaces } $ { p } \\ n $ { this . children [ p ] . print ( indent + 2 ) } ` <nl> + } <nl> + return result <nl> + } <nl> } <nl> <nl> / / Private : Leaf node within a { NativeWatcherRegistry } tree . Represents a directory that is covered by a <nl> class RegistryWatcherNode { <nl> leaves ( prefix ) { <nl> return [ { node : this , path : prefix } ] <nl> } <nl> + <nl> + print ( indent = 0 ) { <nl> + let result = ' ' <nl> + for ( let i = 0 ; i < indent ; i + + ) { <nl> + result + = ' ' <nl> + } <nl> + result + = ' [ watcher ' <nl> + if ( this . childPaths . size > 0 ) { <nl> + result + = ` + $ { this . childPaths . size } ` <nl> + } <nl> + result + = ' ] \\ n ' <nl> + <nl> + return result <nl> + } <nl> } <nl> <nl> / / Private : A { RegisteryNode } traversal result that ' s returned when neither a directory , its children , nor its parents <nl>\n", "msg": "Dump the tree structure to a string for debugging\n", "score": 1}
{"diff_id": 4644, "repo": "sahat/hackathon-starter\n", "sha": "1d9a53ca789bf24062f820854530946a6b7e234b\n", "time": "2014-06-01T15:52:28Z\n", "diff": "mmm a / app . js <nl> ppp b / app . js <nl> var app = express ( ) ; <nl> <nl> mongoose . connect ( secrets . db ) ; <nl> mongoose . connection . on ( ' error ' , function ( ) { <nl> - console . error ( '  MongoDB Connection Error . Please make sure MongoDB is running . ' ) ; <nl> + console . error ( ' MongoDB Connection Error . Make sure MongoDB is running . ' ) ; <nl> } ) ; <nl> <nl> var hour = 3600000 ; <nl> var day = hour * 24 ; <nl> var week = day * 7 ; <nl> <nl> / * * <nl> - * CSRF Whitelist <nl> + * CSRF whitelist . <nl> * / <nl> <nl> var whitelist = [ ' / url1 ' , ' / url2 ' ] ; <nl> app . use ( session ( { <nl> } ) ) ; <nl> app . use ( passport . initialize ( ) ) ; <nl> app . use ( passport . session ( ) ) ; <nl> + app . use ( flash ( ) ) ; <nl> app . use ( function ( req , res , next ) { <nl> + / / CSRF <nl> if ( whitelist . indexOf ( req . path ) ! = = - 1 ) next ( ) ; <nl> else csrf ( req , res , next ) ; <nl> } ) ; <nl> app . use ( function ( req , res , next ) { <nl> + / / Make current user available in templates <nl> res . locals . user = req . user ; <nl> next ( ) ; <nl> } ) ; <nl> - app . use ( flash ( ) ) ; <nl> - app . use ( express . static ( path . join ( __dirname , ' public ' ) , { maxAge : week } ) ) ; <nl> app . use ( function ( req , res , next ) { <nl> - / / Keep track of previous URL to redirect back to <nl> - / / original destination after a successful login . <nl> + / / Keep track of the previous URL so a user can redirect <nl> + / / back to the original destination after a successful login . <nl> if ( req . method ! = = ' GET ' ) return next ( ) ; <nl> var path = req . path . split ( ' / ' ) [ 1 ] ; <nl> if ( / ( auth | login | logout | signup ) $ / i . test ( path ) ) return next ( ) ; <nl> req . session . returnTo = req . path ; <nl> next ( ) ; <nl> } ) ; <nl> + app . use ( express . static ( path . join ( __dirname , ' public ' ) , { maxAge : week } ) ) ; <nl> <nl> / * * <nl> * Application routes . <nl> app . use ( errorHandler ( ) ) ; <nl> * / <nl> <nl> app . listen ( app . get ( ' port ' ) , function ( ) { <nl> - console . log ( \"  Express server listening on port % d in % s mode \" , app . get ( ' port ' ) , app . get ( ' env ' ) ) ; <nl> + console . log ( ' Express server listening on port % d in % s mode ' , app . get ( ' port ' ) , app . get ( ' env ' ) ) ; <nl> } ) ; <nl> <nl> module . exports = app ; <nl>\n", "msg": "Minor updates , added comments for custom express middleware\n", "score": 1}
{"diff_id": 5396, "repo": "facebook/react-native\n", "sha": "e173f14b525c41bd33b5256cc70e2e883d3d07e1\n", "time": "2016-11-05T03:28:30Z\n", "diff": "mmm a / Libraries / CustomComponents / NavigationExperimental / NavigationCardStackPanResponder . js <nl> ppp b / Libraries / CustomComponents / NavigationExperimental / NavigationCardStackPanResponder . js <nl> class NavigationCardStackPanResponder extends NavigationAbstractPanResponder { <nl> { <nl> toValue : props . navigationState . index , <nl> duration : ANIMATION_DURATION , <nl> + useNativeDriver : props . position . __isNative , <nl> } <nl> ) . start ( ) ; <nl> } <nl>\n", "msg": "Use native animations if the animated value is native in NavigationCardStackPanResponder\n", "score": 1}
{"diff_id": 5433, "repo": "moment/moment\n", "sha": "e5105e4462cb9238fbf1e54de17112e8e91fb27f\n", "time": "2020-04-24T18:09:29Z\n", "diff": "mmm a / src / lib / locale / locales . js <nl> ppp b / src / lib / locale / locales . js <nl> function loadLocale ( name ) { <nl> try { <nl> oldLocale = globalLocale . _abbr ; <nl> var aliasedRequire = require ; <nl> - aliasedRequire ( ' . / locale / ' + name ) ; <nl> + aliasedRequire ( ( typeof __dirname ! = = undefined ? __dirname : ' . ' ) + ' / locale / ' + name ) ; <nl> getSetGlobalLocale ( oldLocale ) ; <nl> } catch ( e ) { <nl> / / mark as not found to avoid repeating expensive file require call causing high CPU <nl>\n", "msg": "[ bugfix ] Use __dirname for locale import if available\n", "score": 1}
{"diff_id": 5913, "repo": "meteor/meteor\n", "sha": "4a8bbce814eff74881871e25a28e1a6b4670c802\n", "time": "2013-11-22T00:52:23Z\n", "diff": "mmm a / packages / autoupdate / package . js <nl> ppp b / packages / autoupdate / package . js <nl> Package . describe ( { <nl> <nl> Package . on_use ( function ( api ) { <nl> api . use ( ' webapp ' , ' server ' ) ; <nl> + api . use ( ' deps ' , ' client ' ) ; <nl> api . use ( [ ' livedata ' , ' mongo - livedata ' ] , [ ' client ' , ' server ' ] ) ; <nl> api . use ( ' reload ' , ' client ' , { weak : true } ) ; <nl> <nl>\n", "msg": "Oops , missed one . Add deps package to autoupdate dependencies .\n", "score": 1}
{"diff_id": 6316, "repo": "balderdashy/sails\n", "sha": "d8dd7df493766fb8ac0914bb7946bb5086acc720\n", "time": "2013-10-08T15:00:17Z\n", "diff": "mmm a / lib / hooks / orm / index . js <nl> ppp b / lib / hooks / orm / index . js <nl> module . exports = function ( sails ) { <nl> / / The set of working adapters waterline will use internally <nl> / / Adapters should be built using the proper adapter definition with config <nl> / / from the source connection mixed - in <nl> - adapters : _buildAdHocAdapterSet ( collection ) <nl> + adapters : _buildAdHocAdapterSet ( modelDefs ) <nl> } , cb ) ; <nl> } , <nl> <nl> module . exports = function ( sails ) { <nl> / / and plug them as a list of strings into ` Model . adapter ` <nl> / / modelDef . adapter = util . pluck ( modelDef . connections , ' adapter ' ) ; <nl> } ) ; <nl> + <nl> + return adHocAdapters ; <nl> } <nl> <nl> <nl> module . exports = function ( sails ) { <nl> with ( opts ) { <nl> var clonedAdapter = util . cloneDeep ( adapterDefs [ adapterID ] ) ; <nl> var clonedConnection = util . cloneDeep ( connection ) ; <nl> - clonedAdapter . config = util . merge ( clonedAdapter . config | | { } , clonedConnection ) ; <nl> + clonedAdapter . config = util . merge ( clonedAdapter . config | | { } , clonedConnection ) ; <nl> + sails . log . verbose ( <nl> + ' Cloned new ad - hoc adapter ' , ' \\ n ' , <nl> + ' \\ t : : source adapter : : ' , adapterID , ' \\ n ' , <nl> + ' \\ t : : source connection : : ' , connection , ' \\ n ' , <nl> + ' \\ t : : config : : ' , clonedAdapter . config , ' \\ n ' <nl> + ) ; <nl> return clonedAdapter ; <nl> } <nl> } <nl>\n", "msg": "Cleanup , added verbose logs for debugging\n", "score": 1}
{"diff_id": 6593, "repo": "transloadit/uppy\n", "sha": "16749b2608845841d0c908d65813dc39f2a8397a\n", "time": "2018-06-12T01:15:16Z\n", "diff": "mmm a / src / core / Core . js <nl> ppp b / src / core / Core . js <nl> class Uppy { <nl> } ) <nl> . catch ( ( err ) = > { <nl> const message = typeof err = = = ' object ' ? err . message : err <nl> - this . log ( message ) <nl> - this . info ( message , ' error ' , 4000 ) <nl> + const details = typeof err = = = ' object ' ? err . details : null <nl> + this . log ( ` $ { message } $ { details } ` ) <nl> + this . info ( { message : message , details : details } , ' error ' , 4000 ) <nl> return Promise . reject ( typeof err = = = ' object ' ? err : new Error ( err ) ) <nl> } ) <nl> } <nl>\n", "msg": "show error details when they are available\n", "score": 1}
{"diff_id": 7951, "repo": "jashkenas/backbone\n", "sha": "e398583d3813f7d04fd9c308d4d75b317cf78641\n", "time": "2011-02-04T04:25:12Z\n", "diff": "mmm a / backbone . js <nl> ppp b / backbone . js <nl> <nl> if ( success ) success ( model , resp ) ; <nl> } ; <nl> options . error = wrapError ( options . error , model , options ) ; <nl> - ( this . sync | | Backbone . sync ) ( ' read ' , this , options ) ; <nl> + ( this . sync | | Backbone . sync ) . call ( this , ' read ' , this , options ) ; <nl> return this ; <nl> } , <nl> <nl> <nl> } ; <nl> options . error = wrapError ( options . error , model , options ) ; <nl> var method = this . isNew ( ) ? ' create ' : ' update ' ; <nl> - ( this . sync | | Backbone . sync ) ( method , this , options ) ; <nl> + ( this . sync | | Backbone . sync ) . call ( this , method , this , options ) ; <nl> return this ; <nl> } , <nl> <nl> <nl> if ( success ) success ( model , resp ) ; <nl> } ; <nl> options . error = wrapError ( options . error , model , options ) ; <nl> - ( this . sync | | Backbone . sync ) ( ' delete ' , this , options ) ; <nl> + ( this . sync | | Backbone . sync ) . call ( this , ' delete ' , this , options ) ; <nl> return this ; <nl> } , <nl> <nl> <nl> if ( success ) success ( collection , resp ) ; <nl> } ; <nl> options . error = wrapError ( options . error , collection , options ) ; <nl> - ( this . sync | | Backbone . sync ) ( ' read ' , this , options ) ; <nl> + ( this . sync | | Backbone . sync ) . call ( this , ' read ' , this , options ) ; <nl> return this ; <nl> } , <nl> <nl>\n", "msg": "keep custom ` sync ` methods for a given model / collection scoped to ` this ` .\n", "score": 1}
{"diff_id": 8534, "repo": "photonstorm/phaser\n", "sha": "7f5e4d453830a6da58dc0a1049a8143dcfd0dd79\n", "time": "2020-08-24T18:21:01Z\n", "diff": "mmm a / src / structs / ProcessQueue . js <nl> ppp b / src / structs / ProcessQueue . js <nl> var ProcessQueue = new Class ( { <nl> * @ since 3 . 0 . 0 <nl> * / <nl> this . _toProcess = 0 ; <nl> + <nl> + / * * <nl> + * If ` true ` only unique objects will be allowed in the queue . <nl> + * <nl> + * @ name Phaser . Structs . ProcessQueue # checkQueue <nl> + * @ type { boolean } <nl> + * @ since 3 . 50 . 0 <nl> + * / <nl> + this . checkQueue = false ; <nl> } , <nl> <nl> / * * <nl> var ProcessQueue = new Class ( { <nl> { <nl> item = list [ i ] ; <nl> <nl> - this . _active . push ( item ) ; <nl> + if ( ! this . checkQueue | | ( this . checkQueue & & active . indexOf ( item ) = = = - 1 ) ) <nl> + { <nl> + active . push ( item ) ; <nl> <nl> - this . emit ( Events . PROCESS_QUEUE_ADD , item ) ; <nl> + this . emit ( Events . PROCESS_QUEUE_ADD , item ) ; <nl> + } <nl> } <nl> <nl> list . length = 0 ; <nl> var ProcessQueue = new Class ( { <nl> this . _toProcess = 0 ; <nl> <nl> / / The owner of this queue can now safely do whatever it needs to with the active list <nl> - return this . _active ; <nl> + return active ; <nl> } , <nl> <nl> / * * <nl>\n", "msg": "` ProcessQueue . checkQueue ` is a new boolean property that will make sure only unique objects are added to the Process Queue .\n", "score": 1}
{"diff_id": 9270, "repo": "TryGhost/Ghost\n", "sha": "f49073a8ec1d8fa8d2a3ef46fddb571f1f28cf6f\n", "time": "2018-08-16T10:13:24Z\n", "diff": "mmm a / core / server / services / routing / StaticRoutesRouter . js <nl> ppp b / core / server / services / routing / StaticRoutesRouter . js <nl> class StaticRoutesRouter extends ParentRouter { <nl> super ( ' StaticRoutesRouter ' ) ; <nl> <nl> this . route = { value : mainRoute } ; <nl> - this . templates = ( object . templates | | [ ] ) . reverse ( ) ; <nl> + this . templates = object . templates | | [ ] ; <nl> this . data = object . data | | { query : { } , router : { } } ; <nl> this . routerName = mainRoute = = = ' / ' ? ' index ' : mainRoute . replace ( / \\ / / g , ' ' ) ; <nl> <nl> debug ( this . route . value , this . templates ) ; <nl> <nl> if ( this . isChannel ( object ) ) { <nl> + this . templates = this . templates . reverse ( ) ; <nl> this . rss = object . rss ! = = false ; <nl> this . filter = object . filter ; <nl> this . limit = object . limit ; <nl>\n", "msg": " Dynamic Routing Beta : Fixed wrong template order for static routes\n", "score": 1}
{"diff_id": 9339, "repo": "parcel-bundler/parcel\n", "sha": "238be6f3a3b1cfcd55115beaa703d4aa2377d368\n", "time": "2017-08-06T03:23:52Z\n", "diff": "mmm a / packages / core / parcel - bundler / src / assets / JSAsset . js <nl> ppp b / packages / core / parcel - bundler / src / assets / JSAsset . js <nl> const Asset = require ( ' . . / Asset ' ) ; <nl> const babylon = require ( ' babylon ' ) ; <nl> <nl> class JSAsset extends Asset { <nl> + async getDependencies ( ) { <nl> + await this . loadIfNeeded ( ) ; <nl> + if ( ! / import | export [ ^ ; ] * from | require \\ s * \\ ( / . test ( this . contents ) ) { <nl> + / / console . log ( ' skip parse ! ' , this . name ) ; <nl> + return ; <nl> + } <nl> + <nl> + super . getDependencies ( ) ; <nl> + } <nl> + <nl> parse ( code ) { <nl> const options = { <nl> filename : this . name , <nl>\n", "msg": "Skip loading dependencies for assets that don  t have import / require\n", "score": 1}
{"diff_id": 9807, "repo": "balderdashy/sails\n", "sha": "a2919c6dcb3b45e17328ebbc7e84668336c6dc10\n", "time": "2014-02-07T00:35:13Z\n", "diff": "mmm a / lib / hooks / pubsub / index . js <nl> ppp b / lib / hooks / pubsub / index . js <nl> module . exports = function ( sails ) { <nl> var room = this . room ( id , \" message \" ) ; <nl> / / Create the payload <nl> var data = { <nl> - verb : \" message \" , <nl> + verb : \" messaged \" , <nl> id : id , <nl> data : message <nl> } ; <nl>\n", "msg": "Updated verb coming out of pubsub . message ( ) to be past - tense like all the other default pubsub methods .\n", "score": 1}
{"diff_id": 9967, "repo": "mozilla/pdf.js\n", "sha": "849d8cfa2440812e8deff61a93c72727e7d9e0d5\n", "time": "2017-06-19T19:52:39Z\n", "diff": "mmm a / examples / node / domstubs . js <nl> ppp b / examples / node / domstubs . js <nl> DOMElement . prototype = { <nl> } , <nl> <nl> toString : function DOMElement_toString ( ) { <nl> - var attrList = [ ] ; <nl> - for ( i in this . attributes ) { <nl> - attrList . push ( i + ' = \" ' + xmlEncode ( this . attributes [ i ] ) + ' \" ' ) ; <nl> + var buf = [ ] ; <nl> + buf . push ( ' < ' + this . nodeName ) ; <nl> + if ( this . nodeName = = = ' svg : svg ' ) { <nl> + buf . push ( ' xmlns : xlink = \" http : / / www . w3 . org / 1999 / xlink \" ' + <nl> + ' xmlns : svg = \" http : / / www . w3 . org / 2000 / svg \" ' ) ; <nl> } <nl> + for ( var i in this . attributes ) { <nl> + buf . push ( ' ' + i + ' = \" ' + xmlEncode ( this . attributes [ i ] ) + ' \" ' ) ; <nl> + } <nl> + <nl> + buf . push ( ' > ' ) ; <nl> <nl> if ( this . nodeName = = = ' svg : tspan ' | | this . nodeName = = = ' svg : style ' ) { <nl> - var encText = xmlEncode ( this . textContent ) ; <nl> - return ' < ' + this . nodeName + ' ' + attrList . join ( ' ' ) + ' > ' + <nl> - encText + ' < / ' + this . nodeName + ' > ' ; <nl> - } else if ( this . nodeName = = = ' svg : svg ' ) { <nl> - var ns = ' xmlns : xlink = \" http : / / www . w3 . org / 1999 / xlink \" ' + <nl> - ' xmlns : svg = \" http : / / www . w3 . org / 2000 / svg \" ' <nl> - return ' < ' + this . nodeName + ' ' + ns + ' ' + attrList . join ( ' ' ) + ' > ' + <nl> - this . childNodes . join ( ' ' ) + ' < / ' + this . nodeName + ' > ' ; <nl> + buf . push ( xmlEncode ( this . textContent ) ) ; <nl> } else { <nl> - return ' < ' + this . nodeName + ' ' + attrList . join ( ' ' ) + ' > ' + <nl> - this . childNodes . join ( ' ' ) + ' < / ' + this . nodeName + ' > ' ; <nl> + this . childNodes . forEach ( function ( childNode ) { <nl> + buf . push ( childNode . toString ( ) ) ; <nl> + } ) ; <nl> } <nl> + buf . push ( ' < / ' + this . nodeName + ' > ' ) ; <nl> + return buf . join ( ' ' ) ; <nl> } , <nl> <nl> cloneNode : function DOMElement_cloneNode ( ) { <nl>\n", "msg": "Improve memory - efficiency of DOMElement_toString in domstubs\n", "score": 1}
{"diff_id": 10218, "repo": "transloadit/uppy\n", "sha": "e23106ebe4ab67bf98809cfbf5e9c5cd9bb09043\n", "time": "2020-09-12T05:59:03Z\n", "diff": "mmm a / packages / @ uppy / transloadit / src / Client . js <nl> ppp b / packages / @ uppy / transloadit / src / Client . js <nl> module . exports = class Client { <nl> ? ` $ { err . message } ( $ { err . details } ) ` <nl> : err . message <nl> <nl> - return fetchWithNetworkError ( ' https : / / status . transloadit . com / client_error ' , { <nl> + return fetchWithNetworkError ( ' https : / / transloaditstatus . com / client_error ' , { <nl> method : ' post ' , <nl> body : JSON . stringify ( { <nl> endpoint , <nl>\n", "msg": "Change status . transloadit . com to the more isolated transloaditstatus . com\n", "score": 1}
{"diff_id": 10474, "repo": "gorhill/uBlock\n", "sha": "51a6c8beba264d5dcf40841615db88fa19c8fa2e\n", "time": "2015-02-13T23:59:51Z\n", "diff": "mmm a / src / js / static - net - filtering . js <nl> ppp b / src / js / static - net - filtering . js <nl> FilterParser . prototype . parse = function ( s ) { <nl> s = trimChar ( s , ' * ' ) ; <nl> } <nl> <nl> + / / nothing left ? <nl> + if ( s = = = ' ' ) { <nl> + this . unsupported = true ; <nl> + return this ; <nl> + } <nl> + <nl> / / plain hostname ? <nl> this . hostnamePure = this . hostnameAnchored & & reHostnameRule . test ( s ) ; <nl> <nl>\n", "msg": "trivial test to workaround potential bad filters\n", "score": 1}
{"diff_id": 10513, "repo": "serverless/serverless\n", "sha": "b66a26f31757392b10fcda9fd41d35e6a332c8fb\n", "time": "2018-07-03T14:44:01Z\n", "diff": "mmm a / lib / Serverless . js <nl> ppp b / lib / Serverless . js <nl> class Serverless { <nl> return BbPromise . resolve ( ) ; <nl> } <nl> <nl> - if ( ! this . service . tenant & & ! this . service . app ) { <nl> - this . cli . log ( ' WARNING : Missing \" tenant \" and \" app \" properties in serverless . yml . Without these properties , you can not publish the service to the Serverless Platform . ' ) ; / / eslint - disable - line <nl> - return BbPromise . resolve ( ) ; <nl> - } else if ( this . service . tenant & & ! this . service . app ) { <nl> - const errorMessage = [ ' Missing \" app \" property in serverless . yml ' ] . join ( ' ' ) ; <nl> - throw new this . classes . Error ( errorMessage ) ; <nl> - } else if ( ! this . service . tenant & & this . service . app ) { <nl> - const errorMessage = [ ' Missing \" tenant \" property in serverless . yml ' ] . join ( ' ' ) ; <nl> - throw new this . classes . Error ( errorMessage ) ; <nl> - } <nl> - <nl> let username = null ; <nl> let idToken = null ; <nl> if ( globalConfig <nl> class Serverless { <nl> return BbPromise . resolve ( ) ; <nl> } <nl> <nl> + if ( ! this . service . tenant & & ! this . service . app ) { <nl> + this . cli . log ( ' WARNING : Missing \" tenant \" and \" app \" properties in serverless . yml . Without these properties , you can not publish the service to the Serverless Platform . ' ) ; / / eslint - disable - line <nl> + return BbPromise . resolve ( ) ; <nl> + } else if ( this . service . tenant & & ! this . service . app ) { <nl> + const errorMessage = [ ' Missing \" app \" property in serverless . yml ' ] . join ( ' ' ) ; <nl> + throw new this . classes . Error ( errorMessage ) ; <nl> + } else if ( ! this . service . tenant & & this . service . app ) { <nl> + const errorMessage = [ ' Missing \" tenant \" property in serverless . yml ' ] . join ( ' ' ) ; <nl> + throw new this . classes . Error ( errorMessage ) ; <nl> + } <nl> + <nl> return platform . listTenants ( { idToken , username } ) . then ( ( tenants ) = > { <nl> const tenantsList = tenants . map ( tenant = > tenant . tenantName ) ; <nl> if ( ! tenantsList . includes ( this . service . tenant ) ) { <nl>\n", "msg": "don ' t show warnings for logged out users\n", "score": 1}
{"diff_id": 11034, "repo": "Modernizr/Modernizr\n", "sha": "479e424faabe92062292699102340346c82335b8\n", "time": "2012-11-19T09:28:07Z\n", "diff": "mmm a / feature - detects / history . js <nl> ppp b / feature - detects / history . js <nl> <nl> <nl> + / / Test for the history API <nl> / / http : / / dev . w3 . org / html5 / spec / history . html # the - history - interface <nl> + / / by Hay Kranen < http : / / github . com / hay > <nl> <nl> - Modernizr . addTest ( ' history ' , ! ! ( window . history & & history . pushState ) ) ; <nl> + Modernizr . addTest ( ' history ' , function ( ) { <nl> + / / Issue # 733 <nl> + / / The stock browser on Android < 3 . 0 returns positive on history support <nl> + / / Unfortunately support is really buggy and there is no clean way to detect <nl> + / / these bugs , so we fall back to a user agent sniff : ( <nl> + var ua = navigator . userAgent ; <nl> + var properCheck = ! ! ( window . history & & history . pushState ) ; <nl> + <nl> + if ( ua . indexOf ( \" Android \" ) = = = - 1 ) { <nl> + / / No Android , simply return the ' proper ' check <nl> + return properCheck ; <nl> + } else { <nl> + / / We need to check for the stock browser ( which identifies itself <nl> + / / as ' Mobile Safari ' ) , however , Chrome on Android gives the same <nl> + / / identifier ( and does support history properly ) , so check for that too <nl> + if ( ua . indexOf ( \" Mobile Safari \" ) ! = = - 1 & & ua . indexOf ( \" Chrome \" ) = = = - 1 ) { <nl> + / / Buggy implementation , always return false <nl> + return false ; <nl> + } else { <nl> + / / Chrome , return the proper check <nl> + return properCheck ; <nl> + } <nl> + } <nl> + } ) ; <nl> \\ No newline at end of file <nl>\n", "msg": ": adding UA sniff for history support\n", "score": 1}
{"diff_id": 11341, "repo": "adobe/brackets\n", "sha": "a41c6e4cd3696064ae10359db138310fa861956e\n", "time": "2013-03-28T23:00:09Z\n", "diff": "mmm a / src / extensions / default / StaticServer / node / StaticServerDomain . js <nl> ppp b / src / extensions / default / StaticServer / node / StaticServerDomain . js <nl> maxerr : 50 , node : true * / <nl> / / response data is optional <nl> if ( resData ) { <nl> / / TODO other headers ? <nl> - var type = mime . lookup ( path ) ; <nl> + var type = mime . lookup ( location . pathname ) ; <nl> var charset = mime . charsets . lookup ( type ) ; <nl> res . setHeader ( \" Content - Type \" , type + ( charset ? \" ; charset = \" + charset : \" \" ) ) ; <nl> res . end ( resData . body ) ; <nl>\n", "msg": "use request pathname for content - type and charset\n", "score": 1}
{"diff_id": 11387, "repo": "photonstorm/phaser\n", "sha": "47eca23e26c0fa50e265d902a898f480dfa0a0bb\n", "time": "2019-07-30T22:49:34Z\n", "diff": "mmm a / plugins / spine / src / gameobject / SpineGameObject . js <nl> ppp b / plugins / spine / src / gameobject / SpineGameObject . js <nl> var ComponentsTransform = require ( ' . . / . . / . . / . . / src / gameobjects / components / Transf <nl> var ComponentsVisible = require ( ' . . / . . / . . / . . / src / gameobjects / components / Visible ' ) ; <nl> var GameObject = require ( ' . . / . . / . . / . . / src / gameobjects / GameObject ' ) ; <nl> var SpineGameObjectRender = require ( ' . / SpineGameObjectRender ' ) ; <nl> + var CounterClockwise = require ( ' . . / . . / . . / . . / src / math / angle / CounterClockwise ' ) ; <nl> + var RadToDeg = require ( ' . . / . . / . . / . . / src / math / RadToDeg ' ) ; <nl> <nl> / * * <nl> * @ classdesc <nl> var SpineGameObject = new Class ( { <nl> <nl> this . root = this . getRootBone ( ) ; <nl> <nl> + if ( this . root ) <nl> + { <nl> + / / + 90 degrees to account for the difference in Spine vs . Phaser rotation <nl> + this . root . rotation = RadToDeg ( CounterClockwise ( this . rotation ) ) + 90 ; <nl> + } <nl> + <nl> + this . state . apply ( skeleton ) ; <nl> + <nl> + skeleton . updateCache ( ) ; <nl> + <nl> return this . updateSize ( ) ; <nl> } , <nl> <nl> + refresh : function ( ) <nl> + { <nl> + if ( this . root ) <nl> + { <nl> + / / + 90 degrees to account for the difference in Spine vs . Phaser rotation <nl> + this . root . rotation = RadToDeg ( CounterClockwise ( this . rotation ) ) + 90 ; <nl> + } <nl> + <nl> + this . updateSize ( ) ; <nl> + <nl> + this . skeleton . updateCache ( ) ; <nl> + <nl> + return this ; <nl> + } , <nl> + <nl> setSize : function ( width , height , offsetX , offsetY ) <nl> { <nl> var skeleton = this . skeleton ; <nl>\n", "msg": "Added refresh method and updated bones properly\n", "score": 1}
{"diff_id": 11541, "repo": "jashkenas/backbone\n", "sha": "b6ca71c594956ffa625e10eaeab547cb520dc3fc\n", "time": "2012-12-21T17:51:09Z\n", "diff": "mmm a / backbone . js <nl> ppp b / backbone . js <nl> <nl> if ( key = = null ) return this ; <nl> <nl> / / Handle both ` \" key \" , value ` and ` { key : value } ` - style arguments . <nl> - if ( typeof key = = = ' object ' ) { <nl> + if ( typeof key = = = ' string ' ) { <nl> + ( attrs = { } ) [ key ] = val ; <nl> + } else { <nl> attrs = key ; <nl> options = val ; <nl> - } else { <nl> - ( attrs = { } ) [ key ] = val ; <nl> } <nl> <nl> options | | ( options = { } ) ; <nl> <nl> var attrs , model , success , method , xhr , attributes = this . attributes ; <nl> <nl> / / Handle both ` \" key \" , value ` and ` { key : value } ` - style arguments . <nl> - if ( key = = = void 0 | | typeof key = = = ' object ' ) { <nl> + if ( typeof key = = = ' string ' ) { <nl> + ( attrs = { } ) [ key ] = val ; <nl> + } else { <nl> attrs = key ; <nl> options = val ; <nl> - } else if ( key ! = null ) { <nl> - ( attrs = { } ) [ key ] = val ; <nl> } <nl> <nl> / / If we ' re not waiting and attributes exist , save acts as ` set ( attr ) . save ( null , opts ) ` . <nl>\n", "msg": "Simplify argument juggling for set / save\n", "score": 1}
{"diff_id": 11881, "repo": "balderdashy/sails\n", "sha": "2bb640efd25e310fb3322003529d0260add05bc6\n", "time": "2012-12-18T15:30:39Z\n", "diff": "mmm a / lib / util . js <nl> ppp b / lib / util . js <nl> _ . recursive = { <nl> } <nl> } , <nl> <nl> - / / fn ( original , newOne , anotherNewOne , . . . ) <nl> - extend : function ( original , newObj ) { <nl> - / / TODO : make this work for more than one newObj <nl> - / / var newObjects = _ . toArray ( arguments ) . shift ( ) ; <nl> + / / copied from the jquery extend method <nl> + extend : function ( ) { <nl> + var options , name , src , copy , copyIsArray , clone , <nl> + target = arguments [ 0 ] | | { } , <nl> + i = 1 , <nl> + length = arguments . length , <nl> + deep = false ; <nl> <nl> - return _ . extend ( original , _ . objMap ( newObj , function ( newVal , key ) { <nl> - var oldVal = original [ key ] ; <nl> + / / Handle a deep copy situation <nl> + if ( typeof target = = = \" boolean \" ) { <nl> + deep = target ; <nl> + target = arguments [ 1 ] | | { } ; <nl> + / / skip the boolean and the target <nl> + i = 2 ; <nl> + } <nl> <nl> - / / If the new value is a non - object or array , <nl> - / / or the old value is a non - object or array , use it <nl> - if ( _ . isArray ( newVal ) | | ! _ . isObject ( newVal ) | | _ . isArray ( oldVal ) | | ! _ . isObject ( oldVal ) ) { <nl> - return ! _ . isUndefined ( newVal ) ? newVal : oldVal ; <nl> - } <nl> - / / Otherwise , we have to descend recursively <nl> - else { <nl> - return _ . recursive . extend ( oldVal , newVal ) ; <nl> - } <nl> - } ) ) ; <nl> + / / Handle case when target is a string or something ( possible in deep copy ) <nl> + if ( typeof target ! = = \" object \" & & ! jQuery . isFunction ( target ) ) { <nl> + target = { } ; <nl> + } <nl> + <nl> + / / extend jQuery itself if only one argument is passed <nl> + if ( length = = = i ) { <nl> + target = this ; <nl> + - - i ; <nl> + } <nl> + <nl> + for ( ; i < length ; i + + ) { <nl> + / / Only deal with non - null / undefined values <nl> + if ( ( options = arguments [ i ] ) ! = null ) { <nl> + / / Extend the base object <nl> + for ( name in options ) { <nl> + src = target [ name ] ; <nl> + copy = options [ name ] ; <nl> + <nl> + / / Prevent never - ending loop <nl> + if ( target = = = copy ) { <nl> + continue ; <nl> + } <nl> + <nl> + / / Recurse if we ' re merging plain objects or arrays <nl> + if ( deep & & copy & & ( jQuery . isPlainObject ( copy ) | | ( copyIsArray = jQuery . isArray ( copy ) ) ) ) { <nl> + if ( copyIsArray ) { <nl> + copyIsArray = false ; <nl> + clone = src & & jQuery . isArray ( src ) ? src : [ ] ; <nl> + <nl> + } else { <nl> + clone = src & & jQuery . isPlainObject ( src ) ? src : { } ; <nl> + } <nl> + <nl> + / / Never move original objects , clone them <nl> + target [ name ] = jQuery . extend ( deep , clone , copy ) ; <nl> + <nl> + / / Don ' t bring in undefined values <nl> + } else if ( copy ! = = undefined ) { <nl> + target [ name ] = copy ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> + <nl> + / / Return the modified object <nl> + return target ; <nl> } , <nl> <nl> / / fn ( original , newOne , anotherNewOne , . . . ) <nl> _ . recursive = { <nl> } <nl> } ) ) ; <nl> } <nl> - } ; <nl> \\ No newline at end of file <nl> + } ; <nl>\n", "msg": "Fixed issue with recursive extend function .\n", "score": 1}
{"diff_id": 12576, "repo": "twbs/bootstrap\n", "sha": "6e490628d1be1a165d95ecf9817fdc7070069947\n", "time": "2012-01-22T06:06:36Z\n", "diff": "mmm a / js / bootstrap - typeahead . js <nl> ppp b / js / bootstrap - typeahead . js <nl> <nl> <nl> , matcher : function ( item , query ) { <nl> / / ; _ ; http : / / jsperf . com / asdfdfasdfa <nl> - return ~ item . toLowerCase ( ) . indexOf ( query . toLowerCase ( ) ) <nl> + return ~ item . toLowerCase ( ) . indexOf ( query ) <nl> } <nl> <nl> , select : function ( ) { <nl> <nl> } <nl> <nl> , lookup : function ( event ) { <nl> - var query = this . $ element . val ( ) <nl> - , that = this <nl> + var that = this <nl> , items <nl> + , q <nl> + <nl> + this . query = this . $ element . val ( ) <nl> <nl> - if ( ! query ) { <nl> + if ( ! this . query ) { <nl> return this . shown ? this . hide ( ) : this <nl> } <nl> <nl> + q = this . query . toLowerCase ( ) <nl> + <nl> items = this . data . filter ( function ( item ) { <nl> - if ( that . matcher ( item , query ) ) return item <nl> + if ( that . matcher ( item , q ) ) return item <nl> } ) <nl> <nl> if ( ! items . length ) { <nl> <nl> <nl> , render : function ( items ) { <nl> var that = this <nl> + , QUERY = new RegExp ( ' ( ' + this . query + ' ) ' , ' ig ' ) <nl> <nl> items = $ ( items ) . map ( function ( i , item ) { <nl> i = $ ( that . options . item ) . attr ( ' data - value ' , item ) <nl> - i . find ( ' a ' ) . text ( item ) <nl> + <nl> + i . find ( ' a ' ) . html ( item . replace ( QUERY , function ( $ 1 , match ) { <nl> + return ' < strong > ' + match + ' < / strong > ' <nl> + } ) ) <nl> + <nl> return i [ 0 ] <nl> } ) <nl> <nl> <nl> prev . addClass ( ' active ' ) <nl> } <nl> <nl> + , listen : function ( ) { <nl> + this . $ element <nl> + . on ( ' blur ' , $ . proxy ( this . blur , this ) ) <nl> + . on ( ' keypress ' , $ . proxy ( this . keypress , this ) ) <nl> + . on ( ' keyup ' , $ . proxy ( this . keyup , this ) ) <nl> + <nl> + if ( $ . browser . webkit | | $ . browser . msie ) { <nl> + this . $ element . on ( ' keydown ' , $ . proxy ( this . keypress , this ) ) <nl> + } <nl> + <nl> + this . $ menu <nl> + . on ( ' click ' , $ . proxy ( this . click , this ) ) <nl> + . on ( ' mouseenter ' , ' li ' , $ . proxy ( this . mouseenter , this ) ) <nl> + } <nl> + <nl> , keyup : function ( e ) { <nl> e . stopPropagation ( ) <nl> e . preventDefault ( ) <nl> <nl> $ ( e . currentTarget ) . addClass ( ' active ' ) <nl> } <nl> <nl> - , listen : function ( ) { <nl> - this . $ element <nl> - . on ( ' blur ' , $ . proxy ( this . blur , this ) ) <nl> - . on ( ' keypress ' , $ . proxy ( this . keypress , this ) ) <nl> - . on ( ' keyup ' , $ . proxy ( this . keyup , this ) ) <nl> - <nl> - if ( $ . browser . webkit | | $ . browser . msie ) { <nl> - this . $ element . on ( ' keydown ' , $ . proxy ( this . keypress , this ) ) <nl> - } <nl> - <nl> - this . $ menu <nl> - . on ( ' click ' , $ . proxy ( this . click , this ) ) <nl> - . on ( ' mouseenter ' , ' li ' , $ . proxy ( this . mouseenter , this ) ) <nl> - } <nl> } <nl> <nl> <nl>\n", "msg": "more efficient matcher + bold matched query in item\n", "score": 1}
{"diff_id": 13132, "repo": "emberjs/ember.js\n", "sha": "7b2b0d6707bc7a47158fbae6b8460038337d03f6\n", "time": "2012-01-06T06:57:15Z\n", "diff": "mmm a / packages / ember - runtime / lib / mixins / array . js <nl> ppp b / packages / ember - runtime / lib / mixins / array . js <nl> Ember . Array = Ember . Mixin . create ( Ember . Enumerable , / * * @ scope Ember . Array . protot <nl> lastIndexOf : function ( object , startAt ) { <nl> var idx , len = get ( this , ' length ' ) ; <nl> <nl> - if ( startAt = = = undefined ) startAt = len - 1 ; <nl> + if ( startAt = = = undefined | | startAt > = len ) startAt = len - 1 ; <nl> if ( startAt < 0 ) startAt + = len ; <nl> <nl> for ( idx = startAt ; idx > = 0 ; idx - - ) { <nl>\n", "msg": "validate startAt location is greater than length in lastIndexOf array method\n", "score": 1}
{"diff_id": 13773, "repo": "codemirror/CodeMirror\n", "sha": "dd2b9d86ac30feb74c0bf0b999893382cd9f1e07\n", "time": "2014-11-22T21:30:21Z\n", "diff": "mmm a / lib / codemirror . js <nl> ppp b / lib / codemirror . js <nl> <nl> <nl> function lookupKeyForEditor ( cm , name , handle ) { <nl> for ( var i = 0 ; i < cm . state . keyMaps . length ; i + + ) { <nl> - var result = lookupKey ( name , cm . state . keyMaps [ i ] , handle ) ; <nl> + var result = lookupKey ( name , cm . state . keyMaps [ i ] , handle , cm ) ; <nl> if ( result ) return result ; <nl> } <nl> - return ( cm . options . extraKeys & & lookupKey ( name , cm . options . extraKeys , handle ) ) <nl> - | | lookupKey ( name , cm . options . keyMap , handle ) ; <nl> + return ( cm . options . extraKeys & & lookupKey ( name , cm . options . extraKeys , handle , cm ) ) <nl> + | | lookupKey ( name , cm . options . keyMap , handle , cm ) ; <nl> } <nl> <nl> var stopSeq = new Delayed ; <nl> <nl> return keymap ; <nl> } ; <nl> <nl> - var lookupKey = CodeMirror . lookupKey = function ( key , map , handle ) { <nl> + var lookupKey = CodeMirror . lookupKey = function ( key , map , handle , context ) { <nl> map = getKeyMap ( map ) ; <nl> - var found = map . call ? map . call ( key ) : map [ key ] ; <nl> + var found = map . call ? map . call ( key , context ) : map [ key ] ; <nl> if ( found = = = false ) return \" nothing \" ; <nl> if ( found = = = \" . . . \" ) return \" multi \" ; <nl> if ( found ! = null & & handle ( found ) ) return \" handled \" ; <nl> <nl> if ( map . fallthrough ) { <nl> if ( Object . prototype . toString . call ( map . fallthrough ) ! = \" [ object Array ] \" ) <nl> - return lookupKey ( key , map . fallthrough , handle ) ; <nl> + return lookupKey ( key , map . fallthrough , handle , context ) ; <nl> for ( var i = 0 ; i < map . fallthrough . length ; i + + ) { <nl> - var result = lookupKey ( key , map . fallthrough [ i ] , handle ) ; <nl> + var result = lookupKey ( key , map . fallthrough [ i ] , handle , context ) ; <nl> if ( result ) return result ; <nl> } <nl> } <nl>\n", "msg": "Pass a context ( the editor ) to keymaps with a call method\n", "score": 1}
{"diff_id": 14255, "repo": "photonstorm/phaser\n", "sha": "0d0df1900bcd46281378b1ee2c6d7d1cab938d10\n", "time": "2018-01-12T14:23:39Z\n", "diff": "mmm a / src / sound / html5 / HTML5AudioSound . js <nl> ppp b / src / sound / html5 / HTML5AudioSound . js <nl> var HTML5AudioSound = new Class ( { <nl> this . startTime = 0 ; <nl> this . audio . play ( ) ; <nl> } <nl> + return ; <nl> + } <nl> + / / handle looping <nl> + var startTime = ( this . currentMarker ? this . currentMarker . start : 0 ) ; <nl> + var endTime = startTime + this . duration ; <nl> + var currentTime = this . audio . currentTime ; <nl> + if ( currentTime > = endTime ) { <nl> + if ( this . currentConfig . loop ) { <nl> + this . audio . currentTime = startTime + ( currentTime - endTime ) ; <nl> + } <nl> } <nl> } <nl> } , <nl>\n", "msg": "Added logic for handling looping in update method\n", "score": 1}
{"diff_id": 14517, "repo": "alvarotrigo/fullPage.js\n", "sha": "c4e3936baabcc9802ac80f7f8109fef891614e54\n", "time": "2014-06-18T02:48:37Z\n", "diff": "mmm a / jquery . fullPage . js <nl> ppp b / jquery . fullPage . js <nl> <nl> / / flag to avoid very fast sliding for landscape sliders <nl> var slideMoving = false ; <nl> <nl> - var isTablet = navigator . userAgent . match ( / ( iPhone | iPod | iPad | Android | BlackBerry | Windows Phone | Tizen | Bada ) / ) ; <nl> + var isTablet = navigator . userAgent . match ( / ( iPhone | iPod | iPad | Android | BlackBerry | BB10 | Windows Phone | Tizen | Bada ) / ) ; <nl> var container = $ ( this ) ; / / for compatibity reasons for fullpage < v2 . 0 <nl> var windowsHeight = $ ( window ) . height ( ) ; <nl> var isMoving = false ; <nl>\n", "msg": "Added BB10 user agent for Blackberry OS 10 compatibility .\n", "score": 1}
{"diff_id": 14910, "repo": "request/request\n", "sha": "b09212f38fe736c2c92a1ee076cae9d0f4c612c3\n", "time": "2011-08-22T19:11:12Z\n", "diff": "mmm a / main . js <nl> ppp b / main . js <nl> Request . prototype . request = function ( ) { <nl> if ( options . ntick ) throw new Error ( \" You cannot pipe to this stream after the first nextTick ( ) after creation of the request stream . \" ) <nl> options . src = src <nl> if ( isReadStream ( src ) ) { <nl> - options . headers [ ' content - type ' ] = mimetypes . lookup ( src . path . slice ( src . path . lastIndexOf ( ' . ' ) + 1 ) ) <nl> + if ( ! options . headers [ ' content - type ' ] & & ! options . headers [ ' Content - Type ' ] ) <nl> + options . headers [ ' content - type ' ] = mimetypes . lookup ( src . path . slice ( src . path . lastIndexOf ( ' . ' ) + 1 ) ) <nl> } else { <nl> if ( src . headers ) { <nl> for ( i in src . headers ) { <nl>\n", "msg": "Do not overwrite established content - type headers for read stream deliveries .\n", "score": 1}
{"diff_id": 15135, "repo": "redux-saga/redux-saga\n", "sha": "aa8f2290a60039e738c6ee1c273ff696ced6ab94\n", "time": "2016-02-07T23:50:55Z\n", "diff": "mmm a / src / proc . js <nl> ppp b / src / proc . js <nl> import SagaCancellationException from ' . / SagaCancellationException ' <nl> <nl> <nl> export const NOT_ITERATOR_ERROR = ' proc first argument ( Saga function result ) must be an iterator ' <nl> + export const undefindInputError = name = > ` <nl> + $ { name } saga was provided with an undefined input action <nl> + Hints : <nl> + - check that your Action Creator returns a non undefined value <nl> + - if the Saga was started using runSaga , check that your subscribe source provides the action to its listeners <nl> + ` <nl> + <nl> export const CANCEL = Symbol ( ' @ @ redux - saga / cancelPromise ' ) <nl> export const PARALLEL_AUTO_CANCEL = ' PARALLEL_AUTO_CANCEL ' <nl> export const RACE_AUTO_CANCEL = ' RACE_AUTO_CANCEL ' <nl> export default function proc ( <nl> <nl> check ( iterator , is . iterator , NOT_ITERATOR_ERROR ) <nl> <nl> + const UNDEFINED_INPUT_ERROR = undefindInputError ( name ) <nl> + <nl> / / tracks the current ` take ` effects <nl> let deferredInputs = [ ] <nl> const canThrow = is . throw ( iterator ) <nl> export default function proc ( <nl> <nl> / / subscribe to input events , this will resolve the current ` take ` effects <nl> const unsubscribe = subscribe ( input = > { <nl> + if ( input = = = undefined ) <nl> + throw UNDEFINED_INPUT_ERROR <nl> + <nl> for ( let i = 0 ; i < deferredInputs . length ; i + + ) { <nl> const def = deferredInputs [ i ] <nl> if ( def . match ( input ) ) { <nl>\n", "msg": "added error message for undefined actions\n", "score": 1}
{"diff_id": 15960, "repo": "adobe/brackets\n", "sha": "02e8a03a90d541a0be07b3b5afca5ae631d96dda\n", "time": "2012-02-04T22:57:08Z\n", "diff": "mmm a / src / brackets . js <nl> ppp b / src / brackets . js <nl> define ( function ( require , exports , module ) { <nl> Commands = require ( \" Commands \" ) , <nl> CommandManager = require ( \" CommandManager \" ) ; <nl> <nl> - / / Define core brackets namespace <nl> - if ( ! window . brackets ) { <nl> - window . brackets = { } ; <nl> + / / Define core brackets namespace if it isn ' t already defined <nl> + / / <nl> + / / We can ' t simply refer do ' brackets = { } ' to define it in the global namespace because <nl> + / / we ' re in \" use strict \" mode . Most likely , ' window ' will always point to the global <nl> + / / object when this code is running . However , in case it isn ' t ( e . g . running inside <nl> + / / Node for CI testing ) we use this trick to get the global object . <nl> + / / <nl> + / / Taken from : <nl> + / / http : / / stackoverflow . com / questions / 3277182 / how - to - get - the - global - object - in - javascript <nl> + var Fn = Function , global = ( new Fn ( ' return this ' ) ) ( ) ; <nl> + if ( ! global . brackets ) { <nl> + global . brackets = { } ; <nl> } <nl> - var brackets = window . brackets ; <nl> <nl> / / TODO : Make sure the \" test \" object is not included in final builds <nl> / / All modules that need to be tested from the context of the application <nl>\n", "msg": "a new approach for adding to global namespace\n", "score": 1}
{"diff_id": 16589, "repo": "TryGhost/Ghost\n", "sha": "64840cf042aa06cc9797040fb2bb562c1d7b00c4\n", "time": "2014-02-22T19:13:51Z\n", "diff": "mmm a / core / client / views / debug . js <nl> ppp b / core / client / views / debug . js <nl> <nl> } <nl> } ) ; <nl> } , <nl> - text : \" Yes \" <nl> + text : \" Delete \" , <nl> + buttonClass : \" button - delete \" <nl> } , <nl> reject : { <nl> func : function ( ) { <nl> return true ; <nl> } , <nl> - text : \" No \" <nl> + text : \" Cancel \" , <nl> + buttonClass : \" button \" <nl> } <nl> } , <nl> type : \" action \" , <nl>\n", "msg": "Update delete all content button labels\n", "score": 1}
{"diff_id": 17593, "repo": "transloadit/uppy\n", "sha": "45f0f2d5987e0147a5d4ca6511c2f71f7b8871f7\n", "time": "2018-02-07T05:56:58Z\n", "diff": "mmm a / src / core / Core . js <nl> ppp b / src / core / Core . js <nl> class Uppy { <nl> this . upload = this . upload . bind ( this ) <nl> <nl> this . emitter = ee ( ) <nl> - this . on = this . emitter . on . bind ( this . emitter ) <nl> this . off = this . emitter . off . bind ( this . emitter ) <nl> this . once = this . emitter . once . bind ( this . emitter ) <nl> this . emit = this . emitter . emit . bind ( this . emitter ) <nl> class Uppy { <nl> } <nl> } <nl> <nl> + on ( event , callback ) { <nl> + this . emitter . on ( event , callback ) <nl> + return this <nl> + } <nl> + <nl> / * * <nl> * Iterate on all plugins and run ` update ` on them . <nl> * Called each time state changes . <nl>\n", "msg": "Add wrapper function for emitter . on that returns uppy instance for easy chaining\n", "score": 1}
{"diff_id": 18357, "repo": "emberjs/ember.js\n", "sha": "7ecf117216812a95d12712e89443f87aa7d7b27d\n", "time": "2014-09-04T21:35:12Z\n", "diff": "mmm a / packages / ember - runtime / lib / mixins / enumerable . js <nl> ppp b / packages / ember - runtime / lib / mixins / enumerable . js <nl> export default Mixin . create ( { <nl> - ` index ` is the current index in the iteration . <nl> - ` enumerable ` is the enumerable object itself . <nl> <nl> - It should return the ` true ` to include the item in the results , ` false ` <nl> + It should return ` true ` to include the item in the results , ` false ` <nl> otherwise . <nl> <nl> Note that in addition to a callback , you can also pass an optional target <nl>\n", "msg": "[ DOC ] Small grammar fix on enumerable filter method\n", "score": 1}
{"diff_id": 18777, "repo": "h5bp/html5-boilerplate\n", "sha": "7ef42605c2dd4c117dce8402d4a595cb31253a98\n", "time": "2011-04-05T13:09:18Z\n", "diff": "mmm a / build / tools / fulljslint . js <nl> ppp b / build / tools / fulljslint . js <nl> <nl> + / * global quit : false , readFile : false * / <nl> + <nl> / / Rhino Edition <nl> <nl> <nl>\n", "msg": "added some globals for rhino functions\n", "score": 1}
{"diff_id": 19090, "repo": "adobe/brackets\n", "sha": "fc71f3cc45b81e00a90c80846d420596b9ee7742\n", "time": "2012-08-10T16:04:08Z\n", "diff": "mmm a / test / spec / Menu - test . js <nl> ppp b / test / spec / Menu - test . js <nl> define ( function ( require , exports , module ) { <nl> <nl> it ( \" it should add menu to beginnging and end of menu section \" , function ( ) { <nl> / / set up test menu and menu items <nl> - CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" custom . command1 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 2 \" , \" custom . command2 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 3 \" , \" custom . command3 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 4 \" , \" custom . command4 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 5 \" , \" custom . command5 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 6 \" , \" custom . command6 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 7 \" , \" custom . command7 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 8 \" , \" custom . command8 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" Menu - test . command1 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 2 \" , \" Menu - test . command2 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 3 \" , \" Menu - test . command3 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 4 \" , \" Menu - test . command4 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 5 \" , \" Menu - test . command5 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 6 \" , \" Menu - test . command6 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 7 \" , \" Menu - test . command7 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 8 \" , \" Menu - test . command8 \" , function ( ) { } ) ; <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> - menu . addMenuItem ( \" custom . command0 \" ) ; <nl> - menu . addMenuItem ( \" custom . command1 \" ) ; <nl> + menu . addMenuItem ( \" Menu - test . command0 \" ) ; <nl> + menu . addMenuItem ( \" Menu - test . command1 \" ) ; <nl> menu . addMenuDivider ( ) ; <nl> - menu . addMenuItem ( \" custom . command2 \" ) ; <nl> - menu . addMenuItem ( \" custom . command3 \" ) ; <nl> + menu . addMenuItem ( \" Menu - test . command2 \" ) ; <nl> + menu . addMenuItem ( \" Menu - test . command3 \" ) ; <nl> <nl> / / create mock menu sections <nl> - var menuSectionCmd0 = { sectionMarker : \" custom . command0 \" } , <nl> - menuSectionCmd2 = { sectionMarker : \" custom . command2 \" } ; <nl> + var menuSectionCmd0 = { sectionMarker : \" Menu - test . command0 \" } , <nl> + menuSectionCmd2 = { sectionMarker : \" Menu - test . command2 \" } ; <nl> <nl> var listSelector = \" # menu - custom > ul \" ; <nl> <nl> / / Add new menu to END of menuSectionCmd0 <nl> - var menuItem = menu . addMenuItem ( \" custom . command4 \" , null , Menus . LAST_IN_SECTION , menuSectionCmd0 ) ; <nl> + var menuItem = menu . addMenuItem ( \" Menu - test . command4 \" , null , Menus . LAST_IN_SECTION , menuSectionCmd0 ) ; <nl> var $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> expect ( $ listItems . length ) . toBe ( 6 ) ; <nl> - expect ( $ ( $ listItems [ 2 ] ) . find ( \" a # menu - custom - custom \\ \\ . command4 \" ) . length ) . toBe ( 1 ) ; <nl> + expect ( $ ( $ listItems [ 2 ] ) . find ( \" a # menu - custom - Menu - test \\ \\ . command4 \" ) . length ) . toBe ( 1 ) ; <nl> <nl> / / Add new menu to END of menuSectionCmd2 <nl> - menuItem = menu . addMenuItem ( \" custom . command5 \" , null , Menus . LAST_IN_SECTION , menuSectionCmd2 ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command5 \" , null , Menus . LAST_IN_SECTION , menuSectionCmd2 ) ; <nl> $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> - expect ( $ ( $ listItems [ 6 ] ) . find ( \" a # menu - custom - custom \\ \\ . command5 \" ) . length ) . toBe ( 1 ) ; <nl> + expect ( $ ( $ listItems [ 6 ] ) . find ( \" a # menu - custom - Menu - test \\ \\ . command5 \" ) . length ) . toBe ( 1 ) ; <nl> <nl> / / Add new menu to BEGINNING of menuSectionCmd0 <nl> - menuItem = menu . addMenuItem ( \" custom . command6 \" , null , Menus . FIRST_IN_SECTION , menuSectionCmd0 ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command6 \" , null , Menus . FIRST_IN_SECTION , menuSectionCmd0 ) ; <nl> $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> - expect ( $ ( $ listItems [ 0 ] ) . find ( \" a # menu - custom - custom \\ \\ . command6 \" ) . length ) . toBe ( 1 ) ; <nl> + expect ( $ ( $ listItems [ 0 ] ) . find ( \" a # menu - custom - Menu - test \\ \\ . command6 \" ) . length ) . toBe ( 1 ) ; <nl> <nl> / / Add new menu to BEGINNING of menuSectionCmd2 <nl> - menuItem = menu . addMenuItem ( \" custom . command7 \" , null , Menus . FIRST_IN_SECTION , menuSectionCmd2 ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command7 \" , null , Menus . FIRST_IN_SECTION , menuSectionCmd2 ) ; <nl> $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> - expect ( $ ( $ listItems [ 0 ] ) . find ( \" a # menu - custom - custom \\ \\ . command6 \" ) . length ) . toBe ( 1 ) ; <nl> + expect ( $ ( $ listItems [ 0 ] ) . find ( \" a # menu - custom - Menu - test \\ \\ . command6 \" ) . length ) . toBe ( 1 ) ; <nl> <nl> } ) ; <nl> <nl> define ( function ( require , exports , module ) { <nl> <nl> it ( \" should add new menu item to empty menu \" , function ( ) { <nl> runs ( function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom \" , \" custom . command \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom \" , \" Menu - test . command \" , function ( ) { } ) ; <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> var $ listItems = testWindow . $ ( \" # menu - custom > ul \" ) . children ( ) ; <nl> expect ( $ listItems . length ) . toBe ( 0 ) ; <nl> <nl> / / Re - use commands that are already registered <nl> - var menuItem = menu . addMenuItem ( \" custom . command \" ) ; <nl> + var menuItem = menu . addMenuItem ( \" Menu - test . command \" ) ; <nl> expect ( menuItem ) . not . toBeNull ( ) ; <nl> expect ( menuItem ) . toBeDefined ( ) ; <nl> <nl> define ( function ( require , exports , module ) { <nl> <nl> / / Periods ( aka \" dots \" ) are allowed in HTML identifiers , but jQuery interprets <nl> / / them as the start of a class selector , so they need to be escaped <nl> - expect ( $ ( $ listItems [ 0 ] ) . find ( \" a # menu - custom - custom \\ \\ . command \" ) . length ) . toBe ( 1 ) ; <nl> + expect ( $ ( $ listItems [ 0 ] ) . find ( \" a # menu - custom - Menu - test \\ \\ . command \" ) . length ) . toBe ( 1 ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> it ( \" should add new menu item in first position of menu \" , function ( ) { <nl> runs ( function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" custom . command1 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" Menu - test . command1 \" , function ( ) { } ) ; <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> - var menuItem = menu . addMenuItem ( \" custom . command0 \" ) ; <nl> + var menuItem = menu . addMenuItem ( \" Menu - test . command0 \" ) ; <nl> <nl> var listSelector = \" # menu - custom > ul \" ; <nl> var $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> <nl> - menuItem = menu . addMenuItem ( \" custom . command1 \" , \" Ctrl - Alt - 0 \" , Menus . FIRST ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command1 \" , \" Ctrl - Alt - 0 \" , Menus . FIRST ) ; <nl> expect ( menuItem ) . not . toBeNull ( ) ; <nl> expect ( menuItem ) . toBeDefined ( ) ; <nl> <nl> $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> expect ( $ listItems . length ) . toBe ( 2 ) ; <nl> - expect ( $ ( $ listItems [ 0 ] ) . find ( \" a # menu - custom - custom \\ \\ . command1 \" ) . length ) . toBe ( 1 ) ; <nl> + expect ( $ ( $ listItems [ 0 ] ) . find ( \" a # menu - custom - Menu - test \\ \\ . command1 \" ) . length ) . toBe ( 1 ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> it ( \" should add new menu item in last position of menu \" , function ( ) { <nl> runs ( function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" custom . command1 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" Menu - test . command1 \" , function ( ) { } ) ; <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> - var menuItem = menu . addMenuItem ( \" custom . command0 \" ) ; <nl> + var menuItem = menu . addMenuItem ( \" Menu - test . command0 \" ) ; <nl> <nl> var listSelector = \" # menu - custom > ul \" ; <nl> var $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> <nl> - menuItem = menu . addMenuItem ( \" custom . command1 \" , Menus . LAST ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command1 \" , Menus . LAST ) ; <nl> expect ( menuItem ) . not . toBeNull ( ) ; <nl> expect ( menuItem ) . toBeDefined ( ) ; <nl> <nl> $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> expect ( $ listItems . length ) . toBe ( 2 ) ; <nl> - expect ( $ ( $ listItems [ 1 ] ) . find ( \" a # menu - custom - custom \\ \\ . command1 \" ) . length ) . toBe ( 1 ) ; <nl> + expect ( $ ( $ listItems [ 1 ] ) . find ( \" a # menu - custom - Menu - test \\ \\ . command1 \" ) . length ) . toBe ( 1 ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> - it ( \" should add new menu item in position after reference menu item \" , function ( ) { <nl> + it ( \" should add new menu item in position after reference command \" , function ( ) { <nl> runs ( function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" custom . command1 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 2 \" , \" custom . command2 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" Menu - test . command1 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 2 \" , \" Menu - test . command2 \" , function ( ) { } ) ; <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> - var menuItem = menu . addMenuItem ( \" custom . command0 \" , \" Ctrl - Alt - 0 \" ) ; <nl> - menuItem = menu . addMenuItem ( \" custom . command1 \" , \" Ctrl - Alt - 1 \" ) ; <nl> + var menuItem = menu . addMenuItem ( \" Menu - test . command0 \" , \" Ctrl - Alt - 0 \" ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command1 \" , \" Ctrl - Alt - 1 \" ) ; <nl> <nl> var listSelector = \" # menu - custom > ul \" ; <nl> var $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> <nl> - menuItem = menu . addMenuItem ( \" custom . command2 \" , \" Ctrl - Alt - 2 \" , Menus . AFTER , \" custom . command0 \" ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command2 \" , \" Ctrl - Alt - 2 \" , Menus . AFTER , \" Menu - test . command0 \" ) ; <nl> expect ( menuItem ) . not . toBeNull ( ) ; <nl> expect ( menuItem ) . toBeDefined ( ) ; <nl> <nl> $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> expect ( $ listItems . length ) . toBe ( 3 ) ; <nl> - expect ( $ ( $ listItems [ 1 ] ) . find ( \" a # menu - custom - custom \\ \\ . command2 \" ) . length ) . toBe ( 1 ) ; <nl> + expect ( $ ( $ listItems [ 1 ] ) . find ( \" a # menu - custom - Menu - test \\ \\ . command2 \" ) . length ) . toBe ( 1 ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> - it ( \" should add new menu item in position before reference menu item \" , function ( ) { <nl> + it ( \" should add new menu item in position before reference command \" , function ( ) { <nl> runs ( function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" custom . command1 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 2 \" , \" custom . command2 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" Menu - test . command1 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 2 \" , \" Menu - test . command2 \" , function ( ) { } ) ; <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> - var menuItem = menu . addMenuItem ( \" custom . command0 \" , \" Ctrl - Alt - 0 \" ) ; <nl> - menuItem = menu . addMenuItem ( \" custom . command1 \" , \" Ctrl - Alt - 1 \" ) ; <nl> + var menuItem = menu . addMenuItem ( \" Menu - test . command0 \" , \" Ctrl - Alt - 0 \" ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command1 \" , \" Ctrl - Alt - 1 \" ) ; <nl> <nl> var listSelector = \" # menu - custom > ul \" ; <nl> var $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> <nl> - menuItem = menu . addMenuItem ( \" custom . command2 \" , \" Ctrl - Alt - 2 \" , Menus . BEFORE , \" custom . command1 \" ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command2 \" , \" Ctrl - Alt - 2 \" , Menus . BEFORE , \" Menu - test . command1 \" ) ; <nl> expect ( menuItem ) . not . toBeNull ( ) ; <nl> expect ( menuItem ) . toBeDefined ( ) ; <nl> <nl> $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> expect ( $ listItems . length ) . toBe ( 3 ) ; <nl> - expect ( $ ( $ listItems [ 1 ] ) . find ( \" a # menu - custom - custom \\ \\ . command2 \" ) . length ) . toBe ( 1 ) ; <nl> + expect ( $ ( $ listItems [ 1 ] ) . find ( \" a # menu - custom - Menu - test \\ \\ . command2 \" ) . length ) . toBe ( 1 ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> - it ( \" should add new menu item in last position of menu if reference menu item doesn ' t exist \" , function ( ) { <nl> + it ( \" should add new menu item in last position of menu if reference command doesn ' t exist \" , function ( ) { <nl> runs ( function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" custom . command1 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 2 \" , \" custom . command2 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" Menu - test . command1 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 2 \" , \" Menu - test . command2 \" , function ( ) { } ) ; <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> - var menuItem = menu . addMenuItem ( \" custom . command0 \" , \" Ctrl - Alt - 0 \" ) ; <nl> - menuItem = menu . addMenuItem ( \" custom . command1 \" , \" Ctrl - Alt - 1 \" ) ; <nl> + var menuItem = menu . addMenuItem ( \" Menu - test . command0 \" , \" Ctrl - Alt - 0 \" ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command1 \" , \" Ctrl - Alt - 1 \" ) ; <nl> <nl> var listSelector = \" # menu - custom > ul \" ; <nl> var $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> <nl> - menuItem = menu . addMenuItem ( \" custom . command2 \" , \" Ctrl - Alt - 2 \" , Menus . BEFORE , \" NONEXISTANT \" ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command2 \" , \" Ctrl - Alt - 2 \" , Menus . BEFORE , \" NONEXISTANT \" ) ; <nl> expect ( menuItem ) . not . toBeNull ( ) ; <nl> expect ( menuItem ) . toBeDefined ( ) ; <nl> <nl> $ listItems = testWindow . $ ( listSelector ) . children ( ) ; <nl> expect ( $ listItems . length ) . toBe ( 3 ) ; <nl> - expect ( $ ( $ listItems [ 2 ] ) . find ( \" a # menu - custom - custom \\ \\ . command2 \" ) . length ) . toBe ( 1 ) ; <nl> + expect ( $ ( $ listItems [ 2 ] ) . find ( \" a # menu - custom - Menu - test \\ \\ . command2 \" ) . length ) . toBe ( 1 ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> it ( \" should not add menu item for duplicate command in a menu \" , function ( ) { <nl> runs ( function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> <nl> - var menuItem = menu . addMenuItem ( \" custom . command0 \" ) ; <nl> + var menuItem = menu . addMenuItem ( \" Menu - test . command0 \" ) ; <nl> <nl> var $ listItems = testWindow . $ ( \" # menu - custom > ul \" ) . children ( ) ; <nl> expect ( $ listItems . length ) . toBe ( 1 ) ; <nl> <nl> - menuItem = menu . addMenuItem ( \" custom . command0 \" ) ; <nl> + menuItem = menu . addMenuItem ( \" Menu - test . command0 \" ) ; <nl> expect ( menuItem ) . toBeFalsy ( ) ; <nl> <nl> <nl> define ( function ( require , exports , module ) { <nl> <nl> it ( \" should add new menu divider \" , function ( ) { <nl> runs ( function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> - CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" custom . command1 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" Menu - test . command1 \" , function ( ) { } ) ; <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> - menu . addMenuItem ( \" custom . command0 \" ) ; <nl> - menu . addMenuItem ( \" custom . command1 \" ) ; <nl> + menu . addMenuItem ( \" Menu - test . command0 \" ) ; <nl> + menu . addMenuItem ( \" Menu - test . command1 \" ) ; <nl> <nl> / / add positioned divider <nl> - menu . addMenuDivider ( Menus . AFTER , \" custom . command0 \" ) ; <nl> + menu . addMenuDivider ( Menus . AFTER , \" Menu - test . command0 \" ) ; <nl> var $ listItems = testWindow . $ ( \" # menu - custom > ul \" ) . children ( ) ; <nl> expect ( $ listItems . length ) . toBe ( 3 ) ; <nl> expect ( $ ( $ listItems [ 1 ] ) . find ( \" hr . divider \" ) . length ) . toBe ( 1 ) ; <nl> define ( function ( require , exports , module ) { <nl> <nl> it ( \" should have same checked state as command \" , function ( ) { <nl> runs ( function ( ) { <nl> - var cmd = CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> + var cmd = CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> expect ( cmd ) . not . toBeNull ( ) ; <nl> expect ( cmd ) . toBeDefined ( ) ; <nl> <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> - menu . addMenuItem ( \" custom . command0 \" ) ; <nl> - var menuSelector = \" # menu - custom - custom \\ \\ . command0 \" ; <nl> + menu . addMenuItem ( \" Menu - test . command0 \" ) ; <nl> + var menuSelector = \" # menu - custom - Menu - test \\ \\ . command0 \" ; <nl> <nl> / / Verify menu is synced with command <nl> var $ menuItem = testWindow . $ ( menuSelector ) ; <nl> define ( function ( require , exports , module ) { <nl> <nl> it ( \" should have same enabled state as command \" , function ( ) { <nl> runs ( function ( ) { <nl> - var cmd = CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> + var cmd = CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> expect ( cmd ) . not . toBeNull ( ) ; <nl> expect ( cmd ) . toBeDefined ( ) ; <nl> <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> - menu . addMenuItem ( \" custom . command0 \" ) ; <nl> - var menuSelector = \" # menu - custom - custom \\ \\ . command0 \" ; <nl> + menu . addMenuItem ( \" Menu - test . command0 \" ) ; <nl> + var menuSelector = \" # menu - custom - Menu - test \\ \\ . command0 \" ; <nl> <nl> / / Verify menu is synced with command <nl> var $ menuItem = testWindow . $ ( menuSelector ) ; <nl> define ( function ( require , exports , module ) { <nl> <nl> it ( \" should respond to key binding updates \" , function ( ) { <nl> runs ( function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" custom . command0 \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 0 \" , \" Menu - test . command0 \" , function ( ) { } ) ; <nl> var menu = Menus . addMenu ( \" Custom \" , \" menu - custom \" ) ; <nl> - menu . addMenuItem ( \" custom . command0 \" , \" Ctrl - 9 \" ) ; <nl> - var menuSelector = \" # menu - custom - custom \\ \\ . command0 \" ; <nl> + menu . addMenuItem ( \" Menu - test . command0 \" , \" Ctrl - 9 \" ) ; <nl> + var menuSelector = \" # menu - custom - Menu - test \\ \\ . command0 \" ; <nl> <nl> / / Verify menu is synced with command <nl> var $ menuItem = testWindow . $ ( menuSelector ) , <nl> define ( function ( require , exports , module ) { <nl> } <nl> <nl> / / change keyboard shortcut <nl> - KeyBindingManager . addBinding ( \" custom . command0 \" , \" Alt - 8 \" ) ; <nl> + KeyBindingManager . addBinding ( \" Menu - test . command0 \" , \" Alt - 8 \" ) ; <nl> <nl> / / verify updated keyboard shortcut <nl> expect ( $ shortcut . data ( \" key \" ) ) . toBe ( \" Alt - 8 \" ) ; <nl> define ( function ( require , exports , module ) { <nl> var cmenu = Menus . registerContextMenu ( \" test - cmenu \" ) ; <nl> <nl> / / Add menu item via command id <nl> - CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" custom . command1 \" , function ( ) { } ) ; <nl> - var menuItem = cmenu . addMenuItem ( \" custom . command1 \" ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom 1 \" , \" Menu - test . command1 \" , function ( ) { } ) ; <nl> + var menuItem = cmenu . addMenuItem ( \" Menu - test . command1 \" ) ; <nl> expect ( menuItem ) . toBeTruthy ( ) ; <nl> expect ( cmenu ) . toBeTruthy ( ) ; <nl> <nl> / / Add menu item via command object <nl> - var command = CommandManager . register ( \" Brackets Test Command Custom 2 \" , \" custom . command2 \" , function ( ) { } ) ; <nl> + var command = CommandManager . register ( \" Brackets Test Command Custom 2 \" , \" Menu - test . command2 \" , function ( ) { } ) ; <nl> menuItem = cmenu . addMenuItem ( command ) ; <nl> expect ( menuItem ) . toBeTruthy ( ) ; <nl> <nl> / / add positioned divider <nl> - menuItem = cmenu . addMenuDivider ( Menus . BEFORE , \" custom . command2 \" ) ; <nl> + menuItem = cmenu . addMenuDivider ( Menus . BEFORE , \" Menu - test . command2 \" ) ; <nl> var $ listItems = testWindow . $ ( \" # test - cmenu > ul \" ) . children ( ) ; <nl> expect ( $ listItems . length ) . toBe ( 3 ) ; <nl> expect ( $ ( $ listItems [ 1 ] ) . find ( \" hr . divider \" ) . length ) . toBe ( 1 ) ; <nl> define ( function ( require , exports , module ) { <nl> expect ( $ ( $ listItems [ 3 ] ) . find ( \" hr . divider \" ) . length ) . toBe ( 1 ) ; <nl> <nl> / / duplicate command in Menu <nl> - menuItem = cmenu . addMenuItem ( \" custom . command1 \" ) ; <nl> + menuItem = cmenu . addMenuItem ( \" Menu - test . command1 \" ) ; <nl> expect ( menuItem ) . toBeFalsy ( ) ; <nl> <nl> / / duplicate ids <nl> define ( function ( require , exports , module ) { <nl> it ( \" open a context menu \" , function ( ) { <nl> runs ( function ( ) { <nl> var openEvent = false ; <nl> - CommandManager . register ( \" Brackets Test Command Custom \" , \" custom . command \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom \" , \" Menu - test . command \" , function ( ) { } ) ; <nl> var cmenu = Menus . registerContextMenu ( \" test - cmenu \" ) ; <nl> - cmenu . addMenuItem ( \" custom . command \" ) ; <nl> + cmenu . addMenuItem ( \" Menu - test . command \" ) ; <nl> <nl> testWindow . $ ( cmenu ) . on ( \" beforeContextMenuOpen \" , function ( ) { <nl> openEvent = true ; <nl> define ( function ( require , exports , module ) { <nl> <nl> it ( \" context menu is not clipped \" , function ( ) { <nl> runs ( function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom \" , \" custom . command \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom \" , \" Menu - test . command \" , function ( ) { } ) ; <nl> var cmenu = Menus . registerContextMenu ( \" test - cmenu \" ) ; <nl> - cmenu . addMenuItem ( \" custom . command \" ) ; <nl> + cmenu . addMenuItem ( \" Menu - test . command \" ) ; <nl> var winWidth = $ ( testWindow ) . width ( ) ; <nl> var winHeight = $ ( testWindow ) . height ( ) ; <nl> <nl> define ( function ( require , exports , module ) { <nl> } ) ; <nl> <nl> it ( \" close context menu \" , function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom \" , \" custom . command \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom \" , \" Menu - test . command \" , function ( ) { } ) ; <nl> var cmenu = Menus . registerContextMenu ( \" test - cmenu \" ) ; <nl> - cmenu . addMenuItem ( \" custom . command \" ) ; <nl> + cmenu . addMenuItem ( \" Menu - test . command \" ) ; <nl> <nl> var closeEvent = false ; <nl> testWindow . $ ( cmenu ) . on ( \" contextMenuClose \" , function ( ) { <nl> define ( function ( require , exports , module ) { <nl> } ) ; <nl> <nl> it ( \" close context menu using Esc key \" , function ( ) { <nl> - CommandManager . register ( \" Brackets Test Command Custom \" , \" custom . command \" , function ( ) { } ) ; <nl> + CommandManager . register ( \" Brackets Test Command Custom \" , \" Menu - test . command \" , function ( ) { } ) ; <nl> var cmenu = Menus . registerContextMenu ( \" test - cmenu \" ) ; <nl> - cmenu . addMenuItem ( \" custom . command \" ) ; <nl> + cmenu . addMenuItem ( \" Menu - test . command \" ) ; <nl> <nl> var closeEvent = false ; <nl> testWindow . $ ( cmenu ) . on ( \" contextMenuClose \" , function ( ) { <nl>\n", "msg": "make command id ' s less generic . menu item refs are commands .\n", "score": 1}
{"diff_id": 19523, "repo": "styled-components/styled-components\n", "sha": "e4d2761da8424b4740fdebf351dee4477f5e6835\n", "time": "2017-08-14T04:48:29Z\n", "diff": "mmm a / src / models / BrowserStyleSheet . js <nl> ppp b / src / models / BrowserStyleSheet . js <nl> class BrowserTag implements Tag { <nl> if ( name ) { <nl> const existingNames = this . el . getAttribute ( SC_ATTR ) <nl> this . el . setAttribute ( SC_ATTR , existingNames ? ` $ { existingNames } $ { name } ` : name ) <nl> + } <nl> <nl> - if ( typeof window ! = = ' undefined ' & & window . __webpack_nonce__ ) { <nl> - this . el . setAttribute ( ' nonce ' , window . __webpack_nonce__ ) <nl> - } <nl> + if ( typeof window ! = = ' undefined ' & & window . __webpack_nonce__ ) { <nl> + this . el . setAttribute ( ' nonce ' , window . __webpack_nonce__ ) <nl> } <nl> } <nl> <nl>\n", "msg": "moves the nonce attribute attachement code outside of the name check\n", "score": 1}
{"diff_id": 19727, "repo": "codemirror/CodeMirror\n", "sha": "26b0bc8b32f61bc1220d48986d93ae67e5692051\n", "time": "2011-04-22T09:16:45Z\n", "diff": "mmm a / mode / python / python . js <nl> ppp b / mode / python / python . js <nl> CodeMirror . defineMode ( \" python \" , function ( conf ) { <nl> / / TODO - Can you have imaginary longs ? <nl> intLiteral = true ; <nl> } <nl> + / / Zero by itself with no other piece of number . <nl> + if ( stream . match ( / ^ 0 ( ? ! [ \\ dx ] ) / i ) ) { intLiteral = true ; } <nl> if ( intLiteral ) { <nl> / / Integer literals may be \" long \" <nl> stream . eat ( / L / i ) ; <nl>\n", "msg": "Fixed Python syntax highlighting of single ' 0 ' .\n", "score": 1}
{"diff_id": 20053, "repo": "balderdashy/sails\n", "sha": "92d44273a726891fae5ed6b17f9abe6b83b600c8\n", "time": "2016-11-21T16:33:23Z\n", "diff": "mmm a / lib / hooks / http / get - configured - http - middleware - fns . js <nl> ppp b / lib / hooks / http / get - configured - http - middleware - fns . js <nl> module . exports = function getBuiltInHttpMiddleware ( expressRouterMiddleware , sai <nl> return ; <nl> } <nl> / / Complain a bit louder if the session hook is enabled , but not configured . <nl> - if ( ! sails . config . session | | ! sails . config . session . store ) { <nl> - sails . log . error ( ' Cannot load default HTTP session middleware without ` sails . config . session . store ` configured ! ' ) ; <nl> + if ( ! sails . config . session ) { <nl> + sails . log . error ( ' Cannot load default HTTP session middleware without ` sails . config . session ` configured ! ' ) ; <nl> return ; <nl> } <nl> - if ( sails . config . session & & sails . config . session . store ) { <nl> <nl> - var configuredSessionMiddleware = sails . _privateSessionMiddleware ; <nl> + var configuredSessionMiddleware = sails . _privateSessionMiddleware ; <nl> <nl> - return function ( req , res , next ) { <nl> + return function ( req , res , next ) { <nl> + <nl> + / / - -  <nl> + / / Run the session middleware . <nl> + configuredSessionMiddleware ( req , res , function ( err ) { <nl> + if ( ! err ) { <nl> + return next ( ) ; <nl> + } <nl> + <nl> + var errMsg = ' Error occurred in session middleware : : ' + util . inspect ( ( err & & err . stack ) ? err . stack : err , false , null ) ; <nl> + sails . log . error ( errMsg ) ; <nl> + <nl> + / / If headers have already been sent ( e . g . because of timing issues in application - level code ) , <nl> + / / then don ' t attempt to send another response . <nl> + / / ( but still log a warning ) <nl> + if ( res . headersSent ) { <nl> + sails . log . warn ( ' The session middleware encountered an error and triggered its callback , but response headers have already been sent . Rather than attempting to send another response , failing silently . . . ' ) ; <nl> + return ; <nl> + } <nl> <nl> / / - -  <nl> - / / Run the session middleware . <nl> - configuredSessionMiddleware ( req , res , function ( err ) { <nl> - if ( ! err ) { <nl> - return next ( ) ; <nl> - } <nl> - <nl> - var errMsg = ' Error occurred in session middleware : : ' + util . inspect ( ( err & & err . stack ) ? err . stack : err , false , null ) ; <nl> - sails . log . error ( errMsg ) ; <nl> - <nl> - / / If headers have already been sent ( e . g . because of timing issues in application - level code ) , <nl> - / / then don ' t attempt to send another response . <nl> - / / ( but still log a warning ) <nl> - if ( res . headersSent ) { <nl> - sails . log . warn ( ' The session middleware encountered an error and triggered its callback , but response headers have already been sent . Rather than attempting to send another response , failing silently . . . ' ) ; <nl> - return ; <nl> - } <nl> - <nl> - / / - -  <nl> - / / Otherwise , we can go ahead and send a response . <nl> - return res . send ( 400 , errMsg ) ; <nl> - } ) ; <nl> - } ; <nl> - } <nl> + / / Otherwise , we can go ahead and send a response . <nl> + return res . send ( 400 , errMsg ) ; <nl> + } ) ; <nl> + } ; <nl> + <nl> } ) ( ) , <nl> <nl> <nl>\n", "msg": "Simplify logic around the http session middleware a bit .\n", "score": 1}
{"diff_id": 20472, "repo": "meteor/meteor\n", "sha": "3b225904c3577565eb0fcc2ac896175081b2ee36\n", "time": "2015-03-31T17:51:50Z\n", "diff": "mmm a / tools / main . js <nl> ppp b / tools / main . js <nl> Fiber ( function ( ) { <nl> / / ATTEMPT 2 : legacy release , on disk . ( And it ' s a \" real \" release , not a <nl> / / \" red pill \" release which has the same name as a modern release ! ) <nl> if ( warehouse . realReleaseExistsInWarehouse ( releaseName ) ) { <nl> + if ( process . platform = = = \" win32 \" ) { <nl> + Console . error ( \" Releases of Meteor before 1 . 1 are not supported on \" , <nl> + \" Windows . Please use a newer release . \" ) ; <nl> + process . exit ( 1 ) ; <nl> + } <nl> + <nl> var manifest = warehouse . ensureReleaseExistsAndReturnManifest ( <nl> releaseName ) ; <nl> oldSpringboard ( manifest . tools ) ; / / doesn ' t return <nl>\n", "msg": "Throw error on Windows if you try to springboard to a super old release\n", "score": 1}
{"diff_id": 21634, "repo": "meteor/meteor\n", "sha": "51819a6cb3e244bb16769eccf65f31037ba2a750\n", "time": "2016-11-01T22:23:35Z\n", "diff": "mmm a / tools / tool - testing / selftest . js <nl> ppp b / tools / tool - testing / selftest . js <nl> var newSelfTestCatalog = function ( ) { <nl> var Matcher = function ( run ) { <nl> var self = this ; <nl> self . buf = \" \" ; <nl> + self . fullBuffer = \" \" ; <nl> self . ended = false ; <nl> - self . matchPattern = null ; <nl> - self . matchPromise = null ; <nl> - self . matchStrict = null ; <nl> + self . resetMatch ( ) ; <nl> self . run = run ; / / used only to set a field on exceptions <nl> + self . endPromise = new Promise ( resolve = > { <nl> + self . resolveEndPromise = resolve ; <nl> + } ) ; <nl> } ; <nl> <nl> _ . extend ( Matcher . prototype , { <nl> write : function ( data ) { <nl> var self = this ; <nl> self . buf + = data ; <nl> + self . fullBuffer + = data ; <nl> self . _tryMatch ( ) ; <nl> } , <nl> <nl> - match : function ( pattern , timeout , strict ) { <nl> + resetMatch ( ) { <nl> + const mp = this . matchPromise ; <nl> + <nl> + this . matchPattern = null ; <nl> + this . matchPromise = null ; <nl> + this . matchStrict = null ; <nl> + this . matchFullBuffer = false ; <nl> + <nl> + return mp ; <nl> + } , <nl> + <nl> + rejectMatch ( error ) { <nl> + const mp = this . resetMatch ( ) ; <nl> + if ( mp ) { <nl> + mp . reject ( error ) ; <nl> + } else { <nl> + / / If this . matchPromise was not defined , we should not swallow this <nl> + / / error , so we must throw it instead . <nl> + throw error ; <nl> + } <nl> + } , <nl> + <nl> + resolveMatch ( value ) { <nl> + const mp = this . resetMatch ( ) ; <nl> + if ( mp ) { <nl> + mp . resolve ( value ) ; <nl> + } <nl> + } , <nl> + <nl> + match ( pattern , timeout , strict ) { <nl> + return this . matchAsync ( pattern , { timeout , strict } ) . await ( ) ; <nl> + } , <nl> + <nl> + / / Like match , but returns a Promise without calling . await ( ) . <nl> + matchAsync ( pattern , { <nl> + timeout = null , <nl> + strict = false , <nl> + matchFullBuffer = false , <nl> + } ) { <nl> var self = this ; <nl> if ( self . matchPromise ) { <nl> - throw new Error ( \" already have a match pending ? \" ) ; <nl> + return Promise . reject ( new Error ( \" already have a match pending ? \" ) ) ; <nl> } <nl> self . matchPattern = pattern ; <nl> self . matchStrict = strict ; <nl> + self . matchFullBuffer = matchFullBuffer ; <nl> var mp = self . matchPromise = fiberHelpers . makeFulfillablePromise ( ) ; <nl> self . _tryMatch ( ) ; / / could clear self . matchPromise <nl> <nl> var timer = null ; <nl> if ( timeout ) { <nl> timer = setTimeout ( function ( ) { <nl> - var pattern = self . matchPattern ; <nl> - self . matchPattern = null ; <nl> - self . matchStrict = null ; <nl> - self . matchPromise = null ; <nl> - mp . reject ( new TestFailure ( ' match - timeout ' , { <nl> + self . rejectMatch ( new TestFailure ( ' match - timeout ' , { <nl> run : self . run , <nl> - pattern : pattern <nl> + pattern : self . matchPattern <nl> } ) ) ; <nl> } , timeout * 1000 ) ; <nl> + } else { <nl> + return mp ; <nl> } <nl> <nl> - try { <nl> - return mp . await ( ) ; <nl> - } finally { <nl> - if ( timer ) { <nl> - clearTimeout ( timer ) ; <nl> - } <nl> - } <nl> + return mp . then ( result = > { <nl> + clearTimeout ( timer ) ; <nl> + return result ; <nl> + } , error = > { <nl> + clearTimeout ( timer ) ; <nl> + throw error ; <nl> + } ) ; <nl> } , <nl> <nl> - end : function ( ) { <nl> + matchBeforeEnd ( pattern , timeout ) { <nl> + return this . _beforeEnd ( ( ) = > this . matchAsync ( pattern , { <nl> + timeout : timeout | | 15 , <nl> + matchFullBuffer : true , <nl> + } ) ) ; <nl> + } , <nl> + <nl> + _beforeEnd ( promiseCallback ) { <nl> + return this . endPromise = this . endPromise . then ( promiseCallback ) ; <nl> + } , <nl> + <nl> + end ( ) { <nl> + return this . endAsync ( ) . await ( ) ; <nl> + } , <nl> + <nl> + endAsync ( ) { <nl> var self = this ; <nl> - self . ended = true ; <nl> - self . _tryMatch ( ) ; <nl> + self . resolveEndPromise ( ) ; <nl> + return self . _beforeEnd ( ( ) = > { <nl> + self . ended = true ; <nl> + self . _tryMatch ( ) ; <nl> + return self . matchPromise ; <nl> + } ) ; <nl> } , <nl> <nl> matchEmpty : function ( ) { <nl> _ . extend ( Matcher . prototype , { <nl> <nl> var ret = null ; <nl> <nl> - if ( self . matchPattern instanceof RegExp ) { <nl> + if ( self . matchFullBuffer ) { <nl> + / / Note : self . matchStrict is ignored if self . matchFullBuffer truthy . <nl> + if ( self . matchPattern instanceof RegExp ) { <nl> + ret = self . fullBuffer . match ( self . matchPattern ) ; <nl> + } else if ( self . fullBuffer . indexOf ( self . matchPattern ) > = 0 ) { <nl> + ret = self . matchPattern ; <nl> + } <nl> + <nl> + } else if ( self . matchPattern instanceof RegExp ) { <nl> var m = self . buf . match ( self . matchPattern ) ; <nl> if ( m ) { <nl> if ( self . matchStrict & & m . index ! = = 0 ) { <nl> - self . matchPromise = null ; <nl> - self . matchStrict = null ; <nl> - self . matchPattern = null ; <nl> Console . info ( \" Extra junk is : \" , self . buf . substr ( 0 , m . index ) ) ; <nl> - mp . reject ( new TestFailure ( ' junk - before ' , { <nl> + return self . rejectMatch ( new TestFailure ( ' junk - before ' , { <nl> run : self . run , <nl> pattern : self . matchPattern <nl> } ) ) ; <nl> - return ; <nl> } <nl> ret = m ; <nl> self . buf = self . buf . slice ( m . index + m [ 0 ] . length ) ; <nl> } <nl> + <nl> } else { <nl> var i = self . buf . indexOf ( self . matchPattern ) ; <nl> if ( i ! = = - 1 ) { <nl> if ( self . matchStrict & & i ! = = 0 ) { <nl> - self . matchPromise = null ; <nl> - self . matchStrict = null ; <nl> - self . matchPattern = null ; <nl> Console . info ( \" Extra junk is : \" , self . buf . substr ( 0 , i ) ) ; <nl> - mp . reject ( new TestFailure ( ' junk - before ' , { <nl> + return self . rejectMatch ( new TestFailure ( ' junk - before ' , { <nl> run : self . run , <nl> pattern : self . matchPattern <nl> } ) ) ; <nl> - return ; <nl> } <nl> ret = self . matchPattern ; <nl> self . buf = self . buf . slice ( i + self . matchPattern . length ) ; <nl> _ . extend ( Matcher . prototype , { <nl> } <nl> <nl> if ( ret ! = = null ) { <nl> - self . matchPromise = null ; <nl> - self . matchStrict = null ; <nl> - self . matchPattern = null ; <nl> - mp . resolve ( ret ) ; <nl> - return ; <nl> + return self . resolveMatch ( ret ) ; <nl> } <nl> <nl> if ( self . ended ) { <nl> - var failure = new TestFailure ( ' no - match ' , { run : self . run , <nl> - pattern : self . matchPattern } ) ; <nl> - self . matchPromise = null ; <nl> - self . matchStrict = null ; <nl> - self . matchPattern = null ; <nl> - mp . reject ( failure ) ; <nl> - return ; <nl> + return self . rejectMatch ( new TestFailure ( ' no - match ' , { <nl> + run : self . run , <nl> + pattern : self . matchPattern <nl> + } ) ) ; <nl> } <nl> } <nl> } ) ; <nl> var Run = function ( execPath , options ) { <nl> self . stderrMatcher = new Matcher ( self ) ; <nl> self . outputLog = new OutputLog ( self ) ; <nl> <nl> + self . matcherEndPromise = null ; <nl> + <nl> self . exitStatus = undefined ; / / ' null ' means failed rather than exited <nl> self . exitPromiseResolvers = [ ] ; <nl> var opts = options . args | | [ ] ; <nl> _ . extend ( Run . prototype , { <nl> self . client . connect ( ) ; <nl> } , <nl> <nl> + / / Useful for matching one - time patterns not sensitive to ordering . <nl> + matchBeforeExit : markStack ( function ( pattern ) { <nl> + return this . stdoutMatcher . matchBeforeEnd ( pattern ) ; <nl> + } ) , <nl> + <nl> + matchErrBeforeExit : markStack ( function ( pattern ) { <nl> + return this . stderrMatcher . matchBeforeEnd ( pattern ) ; <nl> + } ) , <nl> + <nl> _exited : function ( status ) { <nl> var self = this ; <nl> <nl> _ . extend ( Run . prototype , { <nl> resolve ( ) ; <nl> } ) ; <nl> <nl> - self . stdoutMatcher . end ( ) ; <nl> - self . stderrMatcher . end ( ) ; <nl> + self . _endMatchers ( ) ; <nl> + } , <nl> + <nl> + _endMatchers ( ) { <nl> + return this . matcherEndPromise = <nl> + this . matcherEndPromise | | Promise . all ( [ <nl> + this . stdoutMatcher . endAsync ( ) , <nl> + this . stderrMatcher . endAsync ( ) <nl> + ] ) ; <nl> } , <nl> <nl> _ensureStarted : function ( ) { <nl> _ . extend ( Run . prototype , { <nl> var self = this ; <nl> self . _ensureStarted ( ) ; <nl> <nl> + self . _endMatchers ( ) . await ( ) ; <nl> + <nl> if ( self . exitStatus = = = undefined ) { <nl> var timeout = self . baseTimeout + self . extraTime ; <nl> timeout * = utils . timeoutScaleFactor ; <nl>\n", "msg": "Implement Run # matchBeforeExit ( pattern ) for order - insensitive matching .\n", "score": 1}
{"diff_id": 21919, "repo": "remy/nodemon\n", "sha": "cc1470096106348b97ec6adfa41683d7f69d2a84\n", "time": "2012-05-04T08:52:09Z\n", "diff": "mmm a / nodemon . js <nl> ppp b / nodemon . js <nl> var fs = require ( ' fs ' ) , <nl> exec = childProcess . exec , <nl> flag = ' . / . monitor ' , <nl> program = getNodemonArgs ( ) , <nl> - child = null , <nl> + child = null , <nl> monitor = null , <nl> ignoreFilePath = ' . / . nodemonignore ' , <nl> oldIgnoreFilePath = ' . / nodemon - ignore ' , <nl> var fs = require ( ' fs ' ) , <nl> platform = process . platform , <nl> isWindows = platform = = = ' win32 ' , <nl> noWatch = ( platform ! = = ' win32 ' ) | | ! fs . watch , / / & & platform ! = = ' linux ' - removed linux fs . watch usage # 72 <nl> + watchFile = platform = = = ' darwin ' ? fs . watchFile : fs . watch , / / lame : ( <nl> + watchWorks = true , / / whether or not fs . watch actually works on this platform , tested and set later before starting <nl> / / create once , reuse as needed <nl> reEscComments = / \\ \\ # / g , <nl> reUnescapeComments = / \\ ^ \\ ^ / g , / / note that ' ^ ^ ' is used in place of escaped comments <nl> var fs = require ( ' fs ' ) , <nl> reEscapeChars = / [ . | \\ - [ \\ ] ( ) \\ \\ ] / g , <nl> reAsterisk = / \\ * / g ; <nl> <nl> + / / test to see if the version of find being run supports searching by seconds ( - mtime - 1s - print ) <nl> + if ( noWatch ) { <nl> + exec ( ' find - L / dev / null - type f - mtime - 1s - print ' , function ( error , stdout , stderr ) { <nl> + if ( error ) { <nl> + if ( ! fs . watch ) { <nl> + util . error ( ' \\ x1B [ 1 ; 31mThe version of node you are using combined with the version of find being used does not support watching files . Upgrade to a newer version of node , or install a version of find that supports search by seconds . \\ x1B [ 0m ' ) ; <nl> + process . exit ( 1 ) ; <nl> + } else { <nl> + noWatch = false ; <nl> + watchFileChecker . check ( function ( success ) { <nl> + watchWorks = success ; <nl> + startNode ( ) ; <nl> + } ) ; <nl> + } <nl> + } else { <nl> + / / Find is compatible with - 1s <nl> + startNode ( ) ; <nl> + } <nl> + } ) ; <nl> + } else { <nl> + watchFileChecker . check ( function ( success ) { <nl> + watchWorks = success ; <nl> + startNode ( ) ; <nl> + } ) ; <nl> + } <nl> + <nl> + / / This is a fallback function if fs . watch does not work <nl> + function changedSince ( time , dir , callback ) { <nl> + callback | | ( callback = dir ) ; <nl> + var changed = [ ] , <nl> + i = 0 , <nl> + j = 0 , <nl> + dir = dir & & typeof dir ! = = ' function ' ? [ dir ] : dirs , <nl> + dlen = dir . length , <nl> + todo = 0 , <nl> + flen = 0 , <nl> + done = function ( ) { <nl> + todo - - ; <nl> + if ( todo = = = 0 ) callback ( changed ) ; <nl> + } ; <nl> + <nl> + dir . forEach ( function ( dir ) { <nl> + todo + + ; <nl> + fs . readdir ( dir , function ( err , files ) { <nl> + if ( err ) return ; <nl> + <nl> + files . forEach ( function ( file ) { <nl> + if ( program . includeHidden = = true | | ! program . includeHidden & & file . indexOf ( ' . ' ) ! = = 0 ) { <nl> + todo + + ; <nl> + file = path . resolve ( dir + ' / ' + file ) ; <nl> + var stat = fs . stat ( file , function ( err , stat ) { <nl> + if ( stat ) { <nl> + if ( stat . isDirectory ( ) ) { <nl> + todo + + ; <nl> + changedSince ( time , file , function ( subChanged ) { <nl> + if ( subChanged . length ) changed = changed . concat ( subChanged ) ; <nl> + done ( ) ; <nl> + } ) ; <nl> + } else if ( stat . mtime > time ) { <nl> + changed . push ( file ) ; <nl> + } <nl> + } <nl> + done ( ) ; <nl> + } ) ; <nl> + } <nl> + } ) ; <nl> + done ( ) ; <nl> + } ) ; <nl> + } ) ; <nl> + } <nl> + <nl> + / / Attempts to see if fs . watch will work . On some platforms , it doesn ' t . <nl> + / / See : http : / / nodejs . org / api / fs . html # fs_caveats <nl> + / / Sends the callback true if fs . watch will work , false if it won ' t <nl> + / / <nl> + / / Caveats : <nl> + / / If there is no writable tmp directory , it will also return true , although <nl> + / / a warning message will be displayed . <nl> + / / <nl> + var watchFileChecker = { } ; <nl> + watchFileChecker . check = function ( cb ) { <nl> + var tmpdir <nl> + , seperator = ' / ' ; <nl> + <nl> + this . cb = cb ; <nl> + this . changeDetected = false ; <nl> + if ( isWindows ) { <nl> + seperator = ' \\ \\ ' ; <nl> + tmpdir = process . env . TEMP ; <nl> + } else if ( process . env . TMPDIR ) { <nl> + tmpdir = process . env . TMPDIR <nl> + } else { <nl> + tmpdir = ' / tmp ' ; <nl> + } <nl> + var watchFileName = tmpdir + seperator + ' nodemonCheckFsWatch ' <nl> + var watchFile = fs . openSync ( watchFileName , ' w ' ) ; <nl> + if ( ! watchFile ) { <nl> + util . log ( ' \\ x1B [ 32m [ nodemon ] Unable to write to temp directory . If you experience problems with file reloading , ensure ' + tmpdir + ' is writable . \\ x1B [ 0m ' ) ; <nl> + cb ( true ) ; <nl> + return ; <nl> + } <nl> + fs . writeSync ( watchFile , ' 1 ' ) ; <nl> + fs . watch ( watchFileName , function ( event , filename ) { <nl> + watchFileChecker . changeDetected = true ; <nl> + cb ( true ) ; <nl> + } ) ; <nl> + <nl> + / / This should trigger fs . watch , if it works <nl> + fs . unlinkSync ( watchFileName ) ; <nl> + <nl> + setTimeout ( function ( ) { watchFileChecker . verify ( ) } , 250 ) ; <nl> + } <nl> + <nl> + / / Verifies that fs . watch was not triggered and sends false to the callback <nl> + watchFileChecker . verify = function ( ) { <nl> + if ( ! this . changeDetected ) { <nl> + this . cb ( false ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + <nl> function startNode ( ) { <nl> util . log ( ' \\ x1B [ 32m [ nodemon ] starting ` ' + program . options . exec + ' ' + program . args . join ( ' ' ) + ' ` \\ x1B [ 0m ' ) ; <nl> <nl> function startNode ( ) { <nl> } ) ; <nl> <nl> child . stderr . on ( ' data ' , function ( data ) { <nl> - util . error ( data ) ; <nl> + process . stderr . write ( data ) ; <nl> } ) ; <nl> <nl> child . on ( ' exit ' , function ( code , signal ) { <nl> function startMonitor ( ) { <nl> callback ( files ) ; <nl> } ) ; <nl> } <nl> - } else { <nl> + } else if ( watchWorks ) { <nl> changeFunction = function ( lastStarted , callback ) { <nl> / / recursive watch - watch each directory and it ' s subdirectories , etc , etc <nl> var watch = function ( err , dir ) { <nl> try { <nl> fs . watch ( dir , { persistent : false } , function ( event , filename ) { <nl> - callback ( [ filename ] ) ; <nl> + var filepath = path . join ( dir , filename ) ; <nl> + callback ( [ filepath ] ) ; <nl> } ) ; <nl> <nl> fs . readdir ( dir , function ( err , files ) { <nl> if ( ! err ) { <nl> files . forEach ( function ( file ) { <nl> - var filename = dir + ' / ' + file ; <nl> + var filename = path . join ( dir , file ) ; <nl> fs . stat ( filename , function ( err , stat ) { <nl> if ( ! err & & stat ) { <nl> if ( stat . isDirectory ( ) ) { <nl> function startMonitor ( ) { <nl> } <nl> } ) ; <nl> } catch ( e ) { <nl> - / / ignoring this directory , likely it ' s \" My Music \" <nl> + / / ignoring this directory , likely it ' s \" My Music \" <nl> / / or some such windows fangled stuff <nl> } <nl> } <nl> dirs . forEach ( function ( dir ) { <nl> fs . realpath ( dir , watch ) ; <nl> } ) ; <nl> - } <nl> + } <nl> + } else { <nl> + / / changedSince , the fallback for when both the find method and fs . watch don ' t work , <nl> + / / is not compatible with the way changeFunction works . If we have reached this point , <nl> + / / changeFunction should not be called from herein out . <nl> + changeFunction = function ( ) { util . error ( \" Nodemon error : changeFunction called when it shouldn ' t be . \" ) } <nl> } <nl> <nl> - changeFunction ( lastStarted , function ( files ) { <nl> - if ( files . length ) { <nl> - / / filter ignored files <nl> - if ( ignoreFiles . length ) { <nl> - files = files . filter ( function ( file ) { <nl> - return ! reIgnoreFiles . test ( file ) ; <nl> - } ) ; <nl> - } <nl> <nl> + var isWindows = process . platform = = = ' win32 ' ; <nl> + if ( noWatch | | watchWorks ) { <nl> + changeFunction ( lastStarted , function ( files ) { <nl> + if ( files . length ) { <nl> + / / filter ignored files <nl> + if ( ignoreFiles . length ) { <nl> + files = files . filter ( function ( file ) { <nl> + / / If we are in a Windows machine <nl> + if ( isWindows ) { <nl> + / / Break up the file by slashes <nl> + var fileParts = file . split ( / \\ \\ / g ) ; <nl> + <nl> + / / Remove the first piece ( C : ) <nl> + fileParts . shift ( ) ; <nl> + <nl> + / / Join the parts together with Unix slashes <nl> + file = ' / ' + fileParts . join ( ' / ' ) ; <nl> + } <nl> + return ! reIgnoreFiles . test ( file ) ; <nl> + } ) ; <nl> + } <nl> <nl> + if ( files . length ) { <nl> + if ( restartTimer ! = = null ) clearTimeout ( restartTimer ) ; <nl> + restartTimer = setTimeout ( function ( ) { <nl> + if ( program . options . verbose ) util . log ( ' [ nodemon ] restarting due to changes . . . ' ) ; <nl> + files . forEach ( function ( file ) { <nl> + if ( program . options . verbose ) util . log ( ' [ nodemon ] ' + file ) ; <nl> + } ) ; <nl> + if ( program . options . verbose ) util . print ( ' \\ n \\ n ' ) ; <nl> + <nl> + if ( child ! = = null ) { <nl> + child . kill ( isWindows ? ' ' : ' SIGUSR2 ' ) ; <nl> + } else { <nl> + startNode ( ) ; <nl> + } <nl> + } , restartDelay ) ; <nl> + return ; <nl> + } <nl> + } <nl> + <nl> + if ( noWatch ) setTimeout ( startMonitor , timeout ) ; <nl> + } ) ; <nl> + } else { <nl> + / / Fallback for when both find and fs . watch don ' t work <nl> + changedSince ( lastStarted , function ( files ) { <nl> if ( files . length ) { <nl> - if ( restartTimer ! = = null ) clearTimeout ( restartTimer ) ; <nl> - restartTimer = setTimeout ( function ( ) { <nl> - if ( program . options . verbose ) util . log ( ' [ nodemon ] restarting due to changes . . . ' ) ; <nl> - files . forEach ( function ( file ) { <nl> - if ( program . options . verbose ) util . log ( ' [ nodemon ] ' + file ) ; <nl> + / / filter ignored files <nl> + if ( ignoreFiles . length ) { <nl> + files = files . filter ( function ( file ) { <nl> + return ! reIgnoreFiles . test ( file ) ; <nl> } ) ; <nl> - if ( program . options . verbose ) util . print ( ' \\ n \\ n ' ) ; <nl> - <nl> - if ( child ! = = null ) { <nl> - child . kill ( isWindows ? ' ' : ' SIGUSR2 ' ) ; <nl> - } else { <nl> - startNode ( ) ; <nl> - } <nl> - } , restartDelay ) ; <nl> - return ; <nl> + } <nl> + <nl> + if ( files . length ) { <nl> + if ( restartTimer ! = = null ) clearTimeout ( restartTimer ) ; <nl> + restartTimer = setTimeout ( function ( ) { <nl> + if ( program . options . verbose ) util . log ( ' [ nodemon ] restarting due to changes . . . ' ) ; <nl> + files . forEach ( function ( file ) { <nl> + if ( program . options . verbose ) util . log ( ' [ nodemon ] ' + file ) ; <nl> + } ) ; <nl> + if ( program . options . verbose ) util . print ( ' \\ n \\ n ' ) ; <nl> + <nl> + if ( child ! = = null ) { <nl> + child . kill ( isWindows ? ' ' : ' SIGUSR2 ' ) ; <nl> + } else { <nl> + startNode ( ) ; <nl> + } <nl> + } , restartDelay ) ; <nl> + return ; <nl> + } <nl> } <nl> - } <nl> - <nl> - if ( noWatch ) setTimeout ( startMonitor , timeout ) ; <nl> - } ) ; <nl> + <nl> + setTimeout ( startMonitor , timeout ) ; <nl> + } ) ; <nl> + } <nl> } <nl> <nl> function addIgnoreRule ( line , noEscape ) { <nl> function readIgnoreFile ( curr , prev ) { <nl> / / unless the ignore file was actually modified , do no re - read it <nl> if ( curr & & prev & & curr . mtime . valueOf ( ) = = = prev . mtime . valueOf ( ) ) return ; <nl> <nl> - fs . unwatchFile ( ignoreFilePath ) ; <nl> + if ( platform = = = ' darwin ' ) fs . unwatchFile ( ignoreFilePath ) ; <nl> <nl> / / Check if ignore file still exists . Vim tends to delete it before replacing with changed file <nl> exists ( ignoreFilePath , function ( exists ) { <nl> function readIgnoreFile ( curr , prev ) { <nl> <nl> / / ignoreFiles = ignoreFiles . concat ( [ flag , ignoreFilePath ] ) ; <nl> / / addIgnoreRule ( flag ) ; <nl> - addIgnoreRule ( ignoreFilePath ) ; <nl> + addIgnoreRule ( ignoreFilePath . substring ( 2 ) ) ; / / ignore the . / part of the filename <nl> fs . readFileSync ( ignoreFilePath ) . toString ( ) . split ( / \\ n / ) . forEach ( function ( rule , i ) { <nl> addIgnoreRule ( rule ) ; <nl> } ) ; <nl> - fs . watchFile ( ignoreFilePath , { persistent : false } , readIgnoreFile ) ; <nl> + <nl> + watchFile ( ignoreFilePath , { persistent : false } , readIgnoreFile ) ; <nl> } ) ; <nl> } <nl> <nl> function getNodemonArgs ( ) { <nl> app = null ; <nl> <nl> for ( ; i < len ; i + + ) { <nl> - if ( existsSync ( dir + ' / ' + args [ i ] ) ) { <nl> + if ( existsSync ( path . resolve ( dir , args [ i ] ) ) ) { <nl> / / double check we didn ' t use the - - watch or - w opt before this arg <nl> if ( args [ i - 1 ] & & ( args [ i - 1 ] = = ' - w ' | | args [ i - 1 ] = = ' - - watch ' ) ) { <nl> - / / ignore <nl> + / / ignore <nl> } else { <nl> indexOfApp = i ; <nl> break ; <nl> function getNodemonArgs ( ) { <nl> } <nl> } <nl> <nl> - if ( indexOfApp ! = = - 1 ) { <nl> + if ( indexOfApp ! = = - 1 ) { <nl> / / not found , so assume we ' re reading the package . json and thus swallow up all the args <nl> - / / indexOfApp = len ; <nl> + / / indexOfApp = len ; <nl> app = process . argv [ i ] ; <nl> indexOfApp + + ; <nl> } else { <nl> function getAppScript ( program ) { <nl> if ( ! program . args . length | | program . app = = = null ) { <nl> / / try to get the app from the package . json <nl> / / doing a try / catch because we can ' t use the path . exist callback pattern <nl> - / / or we could , but the code would get messy , so this will do exactly <nl> + / / or we could , but the code would get messy , so this will do exactly <nl> / / what we ' re after - if the file doesn ' t exist , it ' ll throw . <nl> try { <nl> / / note : this isn ' t nodemon ' s package , it ' s the user ' s cwd package <nl> function getAppScript ( program ) { <nl> program . args . unshift ( program . app ) ; <nl> hokeycokey = true ; <nl> } catch ( e ) { } <nl> - } <nl> + } <nl> <nl> if ( ! program . app ) { <nl> program . app = program . args [ 0 ] ; <nl> function help ( ) { <nl> <nl> / / this little bit of hoop jumping is because sometimes the file can ' t be <nl> / / touched properly , and it send nodemon in to a loop of restarting . <nl> - / / this way , the . monitor file is removed entirely , and recreated with <nl> + / / this way , the . monitor file is removed entirely , and recreated with <nl> / / permissions that anyone can remove it later ( i . e . if you run as root <nl> / / by accident and then try again later ) . <nl> / / if ( path . existsSync ( flag ) ) fs . unlinkSync ( flag ) ; <nl> dirs . forEach ( function ( dir ) { <nl> <nl> / / findStatOffset ( ) ; <nl> <nl> - startNode ( ) ; <nl> - <nl> exists ( ignoreFilePath , function ( exist ) { <nl> / / watch it : \" exist \" not to be confused with \" exists \" . . . . <nl> if ( ! exist ) { <nl> exists ( ignoreFilePath , function ( exist ) { <nl> } else { <nl> readIgnoreFile ( ) ; <nl> } <nl> - } ) ; <nl> + } ) ; <nl> \\ No newline at end of file <nl>\n", "msg": "Support for a third method of change detection , for when both find and fs . watch don ' t work\n", "score": 1}
{"diff_id": 22603, "repo": "gorhill/uBlock\n", "sha": "93d26f615986d0949b57a8ff2b429e3142d25a2a\n", "time": "2015-03-21T20:11:42Z\n", "diff": "mmm a / platform / safari / vapi - popup . js <nl> ppp b / platform / safari / vapi - popup . js <nl> var onLoaded = function ( ) { <nl> powerAndStatsPane = panes . children [ 0 ] , <nl> dfPane = panes . children [ 1 ] ; <nl> <nl> - body . style . setProperty ( \" width \" , \" 100 % \" ) ; <nl> - panes . style . setProperty ( \" width \" , \" 100 % \" ) ; <nl> - dfPane . style . setProperty ( \" display \" , \" inline - block \" , \" important \" ) ; <nl> - <nl> var updateSize = function ( ) { <nl> var dfEnabled = panes . classList . contains ( DF_ENABLED_CLASS ) ; <nl> popover . width = powerAndStatsPane . clientWidth + ( dfEnabled ? dfPane . clientWidth : 0 ) ; <nl> popover . height = body . clientHeight ; <nl> } ; <nl> - updateSize ( ) ; <nl> + <nl> + body . style . setProperty ( \" width \" , \" 100 % \" ) ; <nl> + panes . style . setProperty ( \" width \" , \" 100 % \" ) ; <nl> + dfPane . style . setProperty ( \" display \" , \" inline - block \" , \" important \" ) ; <nl> + setTimeout ( updateSize , 0 ) ; <nl> } ; <nl> window . addEventListener ( \" load \" , onLoaded ) ; <nl> } ) ( ) ; <nl>\n", "msg": "Safari : popup resizing fix for\n", "score": 1}
{"diff_id": 23340, "repo": "sahat/hackathon-starter\n", "sha": "5cc03de6b2154ce98752ca9de294e7630596e4c3\n", "time": "2019-04-30T08:41:15Z\n", "diff": "mmm a / controllers / api . js <nl> ppp b / controllers / api . js <nl> exports . getSteam = async ( req , res , next ) = > { <nl> const getPlayerAchievements = ( ) = > { <nl> const recentGamesURL = makeURL ( ' http : / / api . steampowered . com / IPlayerService / GetRecentlyPlayedGames / v0001 / ' , params ) ; <nl> return axios . get ( recentGamesURL ) <nl> - . then ( ( { status , data } ) = > { <nl> - if ( status = = = 401 ) { <nl> - throw new Error ( ' Missing or Invalid Steam API Key ' ) ; <nl> + . then ( ( { data } ) = > { <nl> + / / handle if player owns no games <nl> + if ( Object . keys ( data . response ) . length = = = 0 ) { <nl> + return null ; <nl> } <nl> + / / handle if there are no recently played games <nl> if ( data . response . total_count = = = 0 ) { <nl> - return { playerstats : null } ; <nl> + return null ; <nl> } <nl> params . appid = data . response . games [ 0 ] . appid ; <nl> const achievementsURL = makeURL ( ' http : / / api . steampowered . com / ISteamUserStats / GetPlayerAchievements / v0001 / ' , params ) ; <nl> return axios . get ( achievementsURL ) <nl> . then ( ( { data } ) = > { <nl> - if ( ! data . playerstats . success ) { <nl> - return { playerstats : null } <nl> + / / handle if there are no achievements for most recent game <nl> + if ( ! data . playerstats . achievements ) { <nl> + return null ; <nl> } <nl> + return data . playerstats ; <nl> } ) ; <nl> + } ) <nl> + . catch ( ( err ) = > { <nl> + if ( err . response ) { <nl> + / / handle private profile or invalid key <nl> + if ( err . response . status = = = 403 ) { <nl> + return null ; <nl> + } <nl> + } <nl> + return Promise . reject ( new Error ( ' There was an error while getting achievements ' ) ) ; <nl> } ) ; <nl> } ; <nl> const getPlayerSummaries = ( ) = > { <nl> params . steamids = steamId ; <nl> const url = makeURL ( ' http : / / api . steampowered . com / ISteamUser / GetPlayerSummaries / v0002 / ' , params ) ; <nl> return axios . get ( url ) <nl> - . then ( ( { status , data } ) = > { <nl> - if ( status = = = 401 ) { <nl> - throw Error ( ' Missing or Invalid Steam API Key ' ) ; <nl> - } <nl> - return data ; <nl> - } ) ; <nl> + . then ( ( { data } ) = > data ) <nl> + . catch ( ( ) = > Promise . reject ( new Error ( ' There was an error while getting player summary ' ) ) ) ; <nl> } ; <nl> const getOwnedGames = ( ) = > { <nl> params . include_appinfo = 1 ; <nl> params . include_played_free_games = 1 ; <nl> const url = makeURL ( ' http : / / api . steampowered . com / IPlayerService / GetOwnedGames / v0001 / ' , params ) ; <nl> return axios . get ( url ) <nl> - . then ( ( { status , data } ) = > { <nl> - if ( status = = = 401 ) { <nl> - throw new Error ( ' Missing or Invalid Steam API Key ' ) ; <nl> - } <nl> - return data ; <nl> - } ) ; <nl> + . then ( ( { data } ) = > data ) <nl> + . catch ( ( ) = > Promise . reject ( new Error ( ' There was an error while getting owned games ' ) ) ) ; <nl> } ; <nl> try { <nl> - const { playerstats } = await getPlayerAchievements ( ) ; <nl> + const playerstats = await getPlayerAchievements ( ) ; <nl> const playerSummaries = await getPlayerSummaries ( ) ; <nl> const ownedGames = await getOwnedGames ( ) ; <nl> res . render ( ' api / steam ' , { <nl>\n", "msg": "Catching edge cases for steam api\n", "score": 1}
{"diff_id": 24482, "repo": "photonstorm/phaser\n", "sha": "84cf835e83e1a8aa7c90b8d2c52eb3699c3492fd\n", "time": "2014-07-31T13:40:59Z\n", "diff": "mmm a / src / system / Device . js <nl> ppp b / src / system / Device . js <nl> Phaser . Device . prototype = { <nl> <nl> var ua = navigator . userAgent ; <nl> <nl> - if ( / Android / . test ( ua ) ) <nl> + if ( / Playstation Vita / . test ( ua ) ) <nl> + { <nl> + this . vita = true ; <nl> + } <nl> + else if ( / Kindle / . test ( ua ) | | / \\ bKF [ A - Z ] [ A - Z ] + / . test ( ua ) | | / Silk . * Mobile Safari / . test ( ua ) ) <nl> + { <nl> + this . kindle = true ; <nl> + / / This will NOT detect early generations of Kindle Fire , I think there is no reliable way . . . <nl> + / / E . g . \" Mozilla / 5 . 0 ( Macintosh ; U ; Intel Mac OS X 10_6_3 ; en - us ; Silk / 1 . 1 . 0 - 80 ) AppleWebKit / 533 . 16 ( KHTML , like Gecko ) Version / 5 . 0 Safari / 533 . 16 Silk - Accelerated = true \" <nl> + } <nl> + else if ( / Android / . test ( ua ) ) <nl> { <nl> this . android = true ; <nl> } <nl>\n", "msg": "Added a UA string test for Kindle\n", "score": 1}
{"diff_id": 24605, "repo": "TryGhost/Ghost\n", "sha": "822fda59cbf13670ba6e559650fcb31ab0168ef0\n", "time": "2020-04-30T12:03:27Z\n", "diff": "mmm a / core / frontend / services / routing / controllers / entry . js <nl> ppp b / core / frontend / services / routing / controllers / entry . js <nl> module . exports = function entryController ( req , res , next ) { <nl> } <nl> <nl> / / CASE : Add access property to entry for v3 + api <nl> + / / @ TODO : reconsider the location of this - it ' s part of members <nl> if ( res . locals . apiVersion ! = = ' v0 . 1 ' & & res . locals . apiVersion ! = = ' v2 ' ) { <nl> entry . access = ! ! entry . html ; <nl> } <nl>\n", "msg": "Added a TODO for members access code\n", "score": 1}
{"diff_id": 24705, "repo": "mui-org/material-ui\n", "sha": "039adb9d32608baba7f6b20b679025f3df5febb2\n", "time": "2018-03-26T22:22:31Z\n", "diff": "mmm a / docs / src / modules / components / AppFrame . js <nl> ppp b / docs / src / modules / components / AppFrame . js <nl> class AppFrame extends React . Component { <nl> mobileOpen : false , <nl> } ; <nl> <nl> - handleDrawerToggle = ( ) = > { <nl> - this . setState ( { mobileOpen : ! this . state . mobileOpen } ) ; <nl> + handleDrawerOpen = ( ) = > { <nl> + this . setState ( { mobileOpen : true } ) ; <nl> + } ; <nl> + <nl> + handleDrawerClose = ( ) = > { <nl> + this . setState ( { mobileOpen : false } ) ; <nl> } ; <nl> <nl> handleTogglePaletteType = ( ) = > { <nl> class AppFrame extends React . Component { <nl> < IconButton <nl> color = \" inherit \" <nl> aria - label = \" open drawer \" <nl> - onClick = { this . handleDrawerToggle } <nl> + onClick = { this . handleDrawerOpen } <nl> className = { navIconClassName } <nl> > <nl> < MenuIcon / > <nl> class AppFrame extends React . Component { <nl> < AppDrawer <nl> className = { classes . drawer } <nl> disablePermanent = { disablePermanent } <nl> - onClose = { this . handleDrawerToggle } <nl> - onOpen = { this . handleDrawerToggle } <nl> + onClose = { this . handleDrawerClose } <nl> + onOpen = { this . handleDrawerOpen } <nl> mobileOpen = { this . state . mobileOpen } <nl> / > <nl> { children } <nl>\n", "msg": "[ docs ] Prevent onClose to open the drawer ( )\n", "score": 1}
{"diff_id": 24725, "repo": "serverless/serverless\n", "sha": "f5b5c7f0f5ebc1f447ff72997053424b1020a33d\n", "time": "2017-07-19T08:06:23Z\n", "diff": "mmm a / lib / plugins / package / lib / zipService . js <nl> ppp b / lib / plugins / package / lib / zipService . js <nl> function excludeNodeDevDependencies ( servicePath ) { <nl> } ) <nl> . then ( ( ) = > fs . readFileAsync ( nodeDevDepFile ) ) <nl> . then ( ( fileContent ) = > { <nl> - const dependencies = _ . filter ( <nl> + const dependencies = _ . compact ( <nl> ( _ . uniq ( _ . split ( fileContent . toString ( ' utf8 ' ) , ' \\ n ' ) ) ) , <nl> elem = > elem . length > 0 <nl> ) ; <nl>\n", "msg": "Switch from _ . filter to _ . compact to remove falsey values\n", "score": 1}
{"diff_id": 25270, "repo": "TryGhost/Ghost\n", "sha": "b50cff8753755055fb658791b4568bf04d8bc15d\n", "time": "2019-04-16T09:19:17Z\n", "diff": "mmm a / core / server / data / importer / importers / data / settings . js <nl> ppp b / core / server / data / importer / importers / data / settings . js <nl> class SettingsImporter extends BaseImporter { <nl> help : this . modelName , <nl> context : JSON . stringify ( { activeApps , installedApps } ) <nl> } ) ; <nl> - <nl> - this . dataToImport = _ . filter ( this . dataToImport , ( data ) = > { <nl> - return data . key ! = = ' active_apps ' & & data . key ! = = ' installed_apps ' ; <nl> - } ) ; <nl> } <nl> <nl> + this . dataToImport = _ . filter ( this . dataToImport , ( data ) = > { <nl> + return data . key ! = = ' active_apps ' & & data . key ! = = ' installed_apps ' ; <nl> + } ) ; <nl> + <nl> const permalinks = _ . find ( this . dataToImport , { key : ' permalinks ' } ) ; <nl> <nl> if ( permalinks ) { <nl>\n", "msg": "Updated import to never use { active , instsalled } _apps\n", "score": 1}
{"diff_id": 25449, "repo": "hexojs/hexo\n", "sha": "44113f3d94436973562825e374b031cadeb4d5fe\n", "time": "2013-04-03T17:46:15Z\n", "diff": "mmm a / lib / render . js <nl> ppp b / lib / render . js <nl> var renderer = require ( ' . / extend ' ) . renderer . list ( ) , <nl> yfm = util . yfm , <nl> cache = { } ; <nl> <nl> - var isRenderable = exports . isRenderable = function ( ext ) { <nl> - return renderer . hasOwnProperty ( ext ) ; <nl> + var getExtname = function ( str ) { <nl> + var extname = path . extname ( str ) ; <nl> + if ( extname ) str = extname ; <nl> + <nl> + if ( str [ 0 ] = = = ' . ' ) str = str . substring ( 1 ) ; <nl> + <nl> + return str ; <nl> + } ; <nl> + <nl> + var isRenderable = exports . isRenderable = function ( str ) { <nl> + return renderer . hasOwnProperty ( getExtname ( str ) ) ; <nl> } ; <nl> <nl> var isRenderableSync = exports . isRenderableSync = function ( ext ) { <nl> - return rendererSync . hasOwnProperty ( ext ) ; <nl> + return rendererSync . hasOwnProperty ( getExtname ( str ) ) ; <nl> } ; <nl> <nl> - var getOutput = exports . getOutput = function ( ext ) { <nl> - return renderer [ ext ] . output ; <nl> + var getOutput = exports . getOutput = function ( str ) { <nl> + if ( isRenderable ( str ) ) return renderer [ getExtname ( str ) ] . output ; <nl> } ; <nl> <nl> var render = exports . render = function ( data , options , callback ) { <nl>\n", "msg": "Support for full file name , extension with dot prefix\n", "score": 1}
{"diff_id": 26682, "repo": "standard/standard\n", "sha": "22673fc7ac2dad0239e8a16660734ac4b1c50056\n", "time": "2018-02-18T23:40:28Z\n", "diff": "mmm a / test / clone . js <nl> ppp b / test / clone . js <nl> var argv = minimist ( process . argv . slice ( 2 ) , { <nl> ' disabled ' , <nl> ' offline ' , <nl> ' quick ' , <nl> - ' quiet ' <nl> + ' quiet ' , <nl> + ' fix ' <nl> ] <nl> } ) <nl> <nl> test ( ' test github repos that use ` standard ` ' , function ( t ) { <nl> var folder = path . join ( TMP , name ) <nl> return function ( cb ) { <nl> fs . access ( path . join ( TMP , name ) , fs . R_OK | fs . W_OK , function ( err ) { <nl> - if ( argv . offline ) { <nl> - if ( err ) { <nl> - t . pass ( ' SKIPPING ( offline ) : ' + name + ' ( ' + pkg . repo + ' ) ' ) <nl> - return cb ( null ) <nl> - } <nl> + if ( argv . offline & & err ) { <nl> + t . pass ( ' SKIPPING ( offline ) : ' + name + ' ( ' + pkg . repo + ' ) ' ) <nl> + cb ( null ) <nl> + } else if ( argv . offline ) { <nl> runStandard ( cb ) <nl> } else { <nl> + var downloadPackage = err ? gitClone : gitPull <nl> downloadPackage ( function ( err ) { <nl> if ( err ) return cb ( err ) <nl> runStandard ( cb ) <nl> } ) <nl> } <nl> <nl> - function downloadPackage ( cb ) { <nl> - if ( err ) gitClone ( cb ) <nl> - else gitPull ( cb ) <nl> - } <nl> - <nl> function gitClone ( cb ) { <nl> var args = [ ' clone ' , ' - - depth ' , 1 , url , path . join ( TMP , name ) ] <nl> spawn ( GIT , args , { stdio : ' ignore ' } , function ( err ) { <nl> test ( ' test github repos that use ` standard ` ' , function ( t ) { <nl> if ( pkg . args ) args . push . apply ( args , pkg . args ) <nl> spawn ( STANDARD , args , { cwd : folder } , function ( err ) { <nl> var str = name + ' ( ' + pkg . repo + ' ) ' <nl> - if ( err ) { <nl> - if ( err . message . indexOf ( ' ( indent ) ' ) | | err . message . indexOf ( ' ( no - multi - spaces ) ' ) | | err . message . indexOf ( ' ( space - unary - ops ) ' ) ) { <nl> - t . comment ( ' Attempting to fix eslint breaking changes for ' + str ) <nl> - runStandardFix ( cb ) <nl> - } else { <nl> - t . fail ( str ) <nl> - cb ( null ) <nl> - } <nl> + if ( err & & argv . fix ) { <nl> + t . comment ( ' Attempting - - fix on ' + str ) <nl> + runStandardFix ( cb ) <nl> + } else if ( err ) { <nl> + t . fail ( str ) <nl> + cb ( null ) <nl> } else { <nl> t . pass ( str ) <nl> cb ( null ) <nl> test ( ' test github repos that use ` standard ` ' , function ( t ) { <nl> var args = [ ' - - fix ' , ' - - verbose ' ] <nl> if ( pkg . args ) args . push . apply ( args , pkg . args ) <nl> spawn ( STANDARD , args , { cwd : folder } , function ( err ) { <nl> - var str = name + ' ( ' + pkg . repo + ' ) * * with - - fix ' <nl> + var str = name + ' ( ' + pkg . repo + ' ) * * with - - fix ' <nl> if ( err ) { t . fail ( str ) } else { t . pass ( str ) } <nl> runGitReset ( cb ) <nl> } ) <nl> test ( ' test github repos that use ` standard ` ' , function ( t ) { <nl> var args = [ ' reset ' , ' - - hard ' ] <nl> spawn ( GIT , args , { cwd : folder } , function ( err ) { <nl> if ( err ) err . message + = ' ( git reset ) ( ' + name + ' ) ' <nl> + / / Fatal error if can ' t git reset <nl> cb ( err ) <nl> } ) <nl> } <nl>\n", "msg": "test : add - - fix flag to attempt fixing packages before failing\n", "score": 1}
{"diff_id": 26761, "repo": "GoogleChrome/lighthouse\n", "sha": "b53a167c44bdfc2b16b06cebe5197fecbd9b2e4c\n", "time": "2019-03-21T01:01:54Z\n", "diff": "mmm a / lighthouse - cli / test / fixtures / static - server . js <nl> ppp b / lighthouse - cli / test / fixtures / static - server . js <nl> function requestHandler ( request , response ) { <nl> headers [ ' Content - Type ' ] = ' text / css ' ; <nl> } else if ( filePath . endsWith ( ' . svg ' ) ) { <nl> headers [ ' Content - Type ' ] = ' image / svg + xml ' ; <nl> + } else if ( filePath . endsWith ( ' . png ' ) ) { <nl> + headers [ ' Content - Type ' ] = ' image / png ' ; <nl> + } else if ( filePath . endsWith ( ' . gif ' ) ) { <nl> + headers [ ' Content - Type ' ] = ' image / gif ' ; <nl> + } else if ( filePath . endsWith ( ' . jpg ' ) | | filePath . endsWith ( ' . jpeg ' ) ) { <nl> + headers [ ' Content - Type ' ] = ' image / jpeg ' ; <nl> } <nl> <nl> let delay = 0 ; <nl>\n", "msg": "tests ( smokehouse ) : set Content - Type for images served by static - server . js ( )\n", "score": 1}
{"diff_id": 27232, "repo": "ReactTraining/react-router\n", "sha": "cc9f145ae162483b69029c5989ef084780f711e6\n", "time": "2014-09-25T06:27:14Z\n", "diff": "mmm a / modules / mixins / PathListener . js <nl> ppp b / modules / mixins / PathListener . js <nl> var PathListener = { <nl> <nl> componentWillMount : function ( ) { <nl> PathStore . setup ( this . getLocation ( ) ) ; <nl> + <nl> + if ( this . updatePath ) <nl> + this . updatePath ( PathStore . getCurrentPath ( ) ) ; <nl> } , <nl> <nl> componentDidMount : function ( ) { <nl>\n", "msg": "[ changed ] Give path listeners a chance to update state before mounting\n", "score": 1}
{"diff_id": 27275, "repo": "JedWatson/react-select\n", "sha": "5001083b93f922b8b6e5e42011a79138617b4c1b\n", "time": "2016-09-03T08:15:09Z\n", "diff": "mmm a / src / Select . js <nl> ppp b / src / Select . js <nl> const Select = React . createClass ( { <nl> if ( this . props . autofocus ) { <nl> this . focus ( ) ; <nl> } <nl> - <nl> - document . addEventListener ( ' touchstart ' , this . handleTouchOutside ) ; <nl> } , <nl> <nl> componentWillReceiveProps ( nextProps ) { <nl> const Select = React . createClass ( { <nl> <nl> componentWillUpdate ( nextProps , nextState ) { <nl> if ( nextState . isOpen ! = = this . state . isOpen ) { <nl> + this . toggleTouchOutsideEvent ( nextState . isOpen ) ; <nl> const handler = nextState . isOpen ? nextProps . onOpen : nextProps . onClose ; <nl> handler & & handler ( ) ; <nl> } <nl> const Select = React . createClass ( { <nl> } <nl> } , <nl> <nl> + componentWillUnmount ( ) { <nl> + document . removeEventListener ( ' touchstart ' , this . handleTouchOutside ) ; <nl> + } , <nl> + <nl> + toggleTouchOutsideEvent ( enabled ) { <nl> + if ( enabled ) { <nl> + document . addEventListener ( ' touchstart ' , this . handleTouchOutside ) ; <nl> + } else { <nl> + document . removeEventListener ( ' touchstart ' , this . handleTouchOutside ) ; <nl> + } <nl> + } , <nl> + <nl> handleTouchOutside ( event ) { <nl> / / handle touch outside on ios to dismiss menu <nl> if ( this . wrapper & & ! this . wrapper . contains ( event . target ) ) { <nl>\n", "msg": "Made it only trigger one event for multiple selects on the screen\n", "score": 1}
{"diff_id": 27501, "repo": "balderdashy/sails\n", "sha": "c7fea20b5d0c003f972683d8ed266d06dbd5dab9\n", "time": "2013-07-24T21:34:37Z\n", "diff": "mmm a / lib / express / index . js <nl> ppp b / lib / express / index . js <nl> module . exports = function ( sails ) { <nl> } <nl> <nl> / / Use CORES if set per route <nl> - var coresRoutes = [ ] ; <nl> - for ( var key in sails . config . routes ) { <nl> - var route = sails . config . routes [ key ] ; <nl> - if ( typeof route = = = ' object ' & & route . cores ) { <nl> - if ( typeof route . cores = = = ' boolean ' ) { <nl> - route . cores = ' * ' ; <nl> - } <nl> - coresRoutes . push ( { matcher : expresstUtils . pathRegexp ( key ) , origin : route . cores } ) ; <nl> - } <nl> - } <nl> - <nl> app . use ( function ( req , res , next ) { <nl> <nl> - / / Set CORES header based on route <nl> - for ( var key in coresRoutes ) { <nl> - var match = coresRoutes [ key ] . matcher . exec ( req . url ) ; <nl> - if ( match ) { <nl> - res . setHeader ( ' Access - Control - Allow - Origin ' , coresRoutes [ key ] . origin ) ; <nl> - return next ( ) ; <nl> + / / Match the url to a config route <nl> + for ( var key in sails . config . routes ) { <nl> + var route = sails . config . routes [ key ] ; <nl> + if ( typeof route = = = ' object ' & & route . cores ) { <nl> + if ( typeof route . cores = = = ' boolean ' ) { <nl> + route . cores = ' * ' ; <nl> + } <nl> + var match = expresstUtils . pathRegexp ( key ) . exec ( req . url ) ; <nl> + if ( match ) { <nl> + res . setHeader ( ' Access - Control - Allow - Origin ' , route . cores ) ; <nl> + / / Remove CSRF token if it exists <nl> + res . locals . _csrf = null ; <nl> + return next ( ) ; <nl> + } <nl> } <nl> - <nl> } <nl> - <nl> + <nl> next ( ) ; <nl> } ) ; <nl> <nl>\n", "msg": "fixed cores routing and removed CSRF token if cores\n", "score": 1}
{"diff_id": 28022, "repo": "meteor/meteor\n", "sha": "f6084927f9c8166301a46f065d6fb32615df8c9c\n", "time": "2014-06-17T02:22:10Z\n", "diff": "mmm a / tools / bundler . js <nl> ppp b / tools / bundler . js <nl> _ . extend ( JsImage . prototype , { <nl> } ; <nl> <nl> if ( item . sourceMap ) { <nl> - / / Reference the source map in the source . Looked up later by node - inspector . <nl> + / / Reference the source map in the source . Looked up later by <nl> + / / node - inspector . <nl> var sourceMapBaseName = item . targetPath + \" . map \" ; <nl> <nl> / / Write the source map . <nl> _ . extend ( JsImage . prototype , { <nl> ) ; <nl> <nl> var sourceMapFileName = path . basename ( loadItem . sourceMap ) ; <nl> - item . source = item . source . concat ( \" \\ n / / # sourceMappingURL = \" + sourceMapFileName + \" \\ n \" ) ; <nl> + item . source + = \" \\ n / / # sourceMappingURL = \" + sourceMapFileName + \" \\ n \" ; <nl> loadItem . sourceMapRoot = item . sourceMapRoot ; <nl> } <nl> <nl>\n", "msg": "Prefer + = operator for strings concatenation to String # concat\n", "score": 1}
{"diff_id": 28439, "repo": "prettier/prettier\n", "sha": "35fb28bef241ca581f4a4d6da195ba65df4d720c\n", "time": "2017-01-11T23:05:28Z\n", "diff": "mmm a / src / printer . js <nl> ppp b / src / printer . js <nl> function genericPrintNoParens ( path , options , print ) { <nl> case \" SpreadProperty \" : <nl> case \" SpreadPropertyPattern \" : <nl> case \" RestElement \" : <nl> - return concat ( [ \" . . . \" , path . call ( print , \" argument \" ) ] ) ; <nl> + return concat ( [ <nl> + \" . . . \" , <nl> + path . call ( print , \" argument \" ) , <nl> + path . call ( print , \" typeAnnotation \" ) <nl> + ] ) ; <nl> case \" FunctionDeclaration \" : <nl> case \" FunctionExpression \" : <nl> if ( n . async ) <nl>\n", "msg": "Support type annotation for rest argument on babylon parser\n", "score": 1}
{"diff_id": 29480, "repo": "hexojs/hexo\n", "sha": "e27e1612225444ef3810d02d5f7cffabdf8898a6\n", "time": "2013-12-26T05:42:19Z\n", "diff": "mmm a / lib / plugins / helper / list . js <nl> ppp b / lib / plugins / helper / list . js <nl> exports . list_categories = function ( categories , options ) { <nl> if ( style = = = ' list ' ) { <nl> html + = ' < li class = \" ' + className + ' - list - item \" > ' + <nl> ' < a class = \" ' + className + ' - list - link \" href = \" ' + root + cat . path + ' \" > ' + cat . name + ' < / a > ' + <nl> - ( showCount ? ' < span class = \" ' + className + ' - count \" > ' + cat . length + ' < / span > ' : ' ' ) ; <nl> + ( showCount ? ' < span class = \" ' + className + ' - list - count \" > ' + cat . length + ' < / span > ' : ' ' ) ; <nl> <nl> if ( depth = = 0 | | depth > i + 1 ) { <nl> var child = list ( i + 1 , cat . _id ) ; <nl> exports . list_archives = function ( options ) { <nl> if ( ! yearly . length ) continue ; <nl> <nl> if ( type = = = ' yearly ' ) { <nl> - item ( i , moment ( [ i ] ) . format ( format ) , yearly . length ) ; <nl> + item ( i , moment ( { y : i } ) . format ( format ) , yearly . length ) ; <nl> <nl> continue ; <nl> } <nl> exports . list_archives = function ( options ) { <nl> <nl> if ( ! monthly . length ) continue ; <nl> <nl> - item ( i + ' / ' + ( j < 10 ? ' 0 ' + j : j ) , moment ( [ i , j ] ) . format ( format ) , monthly . length ) ; <nl> + item ( i + ' / ' + ( j < 10 ? ' 0 ' + j : j ) , moment ( { y : i , m : j } ) . format ( format ) , monthly . length ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Fix list_archives helper . Modify class name of list_categories helper\n", "score": 1}
{"diff_id": 30026, "repo": "photonstorm/phaser\n", "sha": "54aebfc8421f18c0920291273c6d3847495bee4b\n", "time": "2020-01-27T15:15:19Z\n", "diff": "mmm a / src / gameobjects / rope / Rope . js <nl> ppp b / src / gameobjects / rope / Rope . js <nl> var Rope = new Class ( { <nl> } <nl> } , <nl> <nl> - / * * <nl> - * NOOP . Included to allow animations to play . <nl> - * <nl> - * @ method Phaser . GameObjects . Rope # updateDisplayOrigin <nl> - * @ private <nl> - * @ since 3 . 23 . 0 <nl> - * / <nl> - updateDisplayOrigin : function ( ) <nl> - { <nl> - / / NOOP <nl> - } , <nl> - <nl> / * * <nl> * Start playing the given animation . <nl> * <nl> var Rope = new Class ( { <nl> * the first Rope segment and on , until it runs out of values . This allows you to control the alpha values at all <nl> * vertices in the Rope . <nl> * <nl> - * Note this method is called ` setAlphas ` ( plural ) and not ` setAlpha ` , which is a NOOP . <nl> + * Note this method is called ` setAlphas ` ( plural ) and not ` setAlpha ` . <nl> * <nl> * @ method Phaser . GameObjects . Rope # setAlphas <nl> * @ since 3 . 23 . 0 <nl> var Rope = new Class ( { <nl> var u1 = this . frame . u1 ; <nl> var v1 = this . frame . v1 ; <nl> <nl> - var part = ( u1 - u0 ) / ( total - 1 ) ; <nl> + var partH = ( u1 - u0 ) / ( total - 1 ) ; <nl> + var partV = ( v1 - v0 ) / ( total - 1 ) ; <nl> <nl> for ( var i = 0 ; i < total ; i + + ) <nl> { <nl> var Rope = new Class ( { <nl> { <nl> if ( this . _flipX ) <nl> { <nl> - uv0 = u1 - ( i * part ) ; <nl> - uv2 = u1 - ( i * part ) ; <nl> + uv0 = u1 - ( i * partH ) ; <nl> + uv2 = u1 - ( i * partH ) ; <nl> } <nl> else <nl> { <nl> - uv0 = u0 + ( i * part ) ; <nl> - uv2 = u0 + ( i * part ) ; <nl> + uv0 = u0 + ( i * partH ) ; <nl> + uv2 = u0 + ( i * partH ) ; <nl> } <nl> <nl> if ( this . _flipY ) <nl> var Rope = new Class ( { <nl> <nl> if ( this . _flipY ) <nl> { <nl> - uv1 = v1 - ( i * part ) ; <nl> - uv3 = v1 - ( i * part ) ; <nl> + uv1 = v1 - ( i * partV ) ; <nl> + uv3 = v1 - ( i * partV ) ; <nl> } <nl> else <nl> { <nl> - uv1 = v0 + ( i * part ) ; <nl> - uv3 = v0 + ( i * part ) ; <nl> + uv1 = v0 + ( i * partV ) ; <nl> + uv3 = v0 + ( i * partV ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Removed NOOPs and fixed UV projection for vertical atlas frames\n", "score": 1}
{"diff_id": 30299, "repo": "meteor/meteor\n", "sha": "3faee05eede683dd14fa922464ef2ba0c081a051\n", "time": "2017-10-06T23:26:58Z\n", "diff": "mmm a / tools / isobuild / import - scanner . js <nl> ppp b / tools / isobuild / import - scanner . js <nl> export default class ImportScanner { <nl> file . data = Buffer . from ( file . dataString , \" utf8 \" ) ; <nl> } <nl> <nl> - / / Files that are not eagerly evaluated ( lazy ) will only be included <nl> - / / in the bundle if they are actually imported . Files that are <nl> - / / eagerly evaluated are effectively \" imported \" as entry points . <nl> - file . imported = ! file . lazy ; <nl> + / / This property can have values false , true , \" dynamic \" ( which <nl> + / / indicates that the file has been imported , but only dynamically ) , <nl> + / / or \" fake \" ( which indicates it is a temporary file that should <nl> + / / never be returned from getOutputFiles ) . <nl> + file . imported = false ; <nl> <nl> file . installPath = file . installPath | | this . _getInstallPath ( absPath ) ; <nl> <nl> export default class ImportScanner { <nl> <nl> scanImports ( ) { <nl> this . outputFiles . forEach ( file = > { <nl> - if ( ! file . lazy | | file . imported ) { <nl> - this . _scanFile ( file , file . imported = = = \" dynamic \" ) ; <nl> + if ( ! file . lazy ) { <nl> + this . _scanFile ( file ) ; <nl> } <nl> } ) ; <nl> <nl> export default class ImportScanner { <nl> } <nl> <nl> _scanFile ( file , forDynamicImport = false ) { <nl> + if ( file . imported = = = true ) { <nl> + / / If we ' ve already scanned this file non - dynamically , then we don ' t <nl> + / / need to scan it again . <nl> + return ; <nl> + } <nl> + <nl> + if ( forDynamicImport & & <nl> + file . imported = = = \" dynamic \" ) { <nl> + / / If we ' ve already scanned this file dynamically , then we don ' t <nl> + / / need to scan it dynamically again . <nl> + return ; <nl> + } <nl> + <nl> + / / Make sure file . imported is set to a truthy value , but allow values <nl> + / / other than \" dynamic \" or true ( e . g . \" fake \" ) . <nl> + file . imported = file . imported | | ( <nl> + forDynamicImport ? \" dynamic \" : true <nl> + ) ; <nl> + <nl> + if ( file . error ) { <nl> + / / Any errors reported to InputFile # error were saved but not <nl> + / / reported at compilation time . Now that we know the file has been <nl> + / / imported , it ' s time to report those errors . <nl> + buildmessage . error ( <nl> + depFile . error . message , <nl> + depFile . error . info <nl> + ) ; <nl> + return ; <nl> + } <nl> + <nl> const absPath = pathJoin ( this . sourceRoot , file . sourcePath ) ; <nl> <nl> try { <nl> export default class ImportScanner { <nl> } <nl> } <nl> <nl> - / / Avoid scanning files that we ' ve scanned before , but mark them <nl> - / / as imported so we know to include them in the bundle if they <nl> - / / are lazy . Eager files and files that we have imported before do <nl> - / / not need to be scanned again . Lazy files that we have not <nl> - / / imported before still need to be scanned , however . Note that <nl> - / / alreadyScanned will be \" dynamic \" ( which is truthy ) if the file <nl> - / / has only been scanned because of a dynamic import ( . . . ) . <nl> - const alreadyScanned = ! depFile . lazy | | depFile . imported ; <nl> - <nl> - / / Whether the file is eager or lazy , mark it as imported . For <nl> - / / lazy files , this makes the difference between being included in <nl> - / / or omitted from the bundle . For eager files , this just ensures <nl> - / / we won ' t scan them again . If this scan began from a dynamic <nl> - / / import ( . . . ) , we set depFile . imported = \" dynamic \" unless it ' s <nl> - / / already been set true . <nl> - depFile . imported = dynamic <nl> - ? depFile . imported | | \" dynamic \" <nl> - : true ; <nl> - <nl> - const needsToBeScanned = ! alreadyScanned | | <nl> - / / If the file has already been scanned , but only because of a <nl> - / / dynamic import ( . . . ) , then it needs to be scanned again , so that <nl> - / / we mark it and its dependencies as non - dynamic . This will be <nl> - / / cheaper than before because we ' ve already computed depFile . deps . <nl> - ( alreadyScanned = = = \" dynamic \" & & <nl> - depFile . imported = = = true ) ; <nl> - <nl> - if ( needsToBeScanned ) { <nl> - if ( depFile . error ) { <nl> - / / Since this file is lazy , it might never have been imported , <nl> - / / so any errors reported to InputFile # error were saved but <nl> - / / not reported at compilation time . Now that we know the file <nl> - / / has been imported , it ' s time to report those errors . <nl> - buildmessage . error ( depFile . error . message , <nl> - depFile . error . info ) ; <nl> - } else { <nl> - this . _scanFile ( depFile , dynamic ) ; <nl> - } <nl> - } <nl> + this . _scanFile ( depFile , dynamic ) ; <nl> <nl> return ; <nl> } <nl> export default class ImportScanner { <nl> depFile . installPath = installPath ; <nl> depFile . servePath = installPath ; <nl> depFile . lazy = true ; <nl> - depFile . imported = dynamic ? \" dynamic \" : true ; <nl> + depFile . imported = false ; <nl> <nl> / / Append this file to the output array and record its index . <nl> this . _addFile ( absImportedPath , depFile ) ; <nl> export default class ImportScanner { <nl> / / still evaluate this module natively on the server . What we <nl> / / really care about is watching the file for changes . <nl> ! shouldWatch ( absImportedPath ) ) { <nl> + / / Since we ' re not going to call this . _scanFile ( depFile , dynamic ) <nl> + / / below , this is our last chance to update depFile . imported . <nl> + depFile . imported = dynamic ? \" dynamic \" : true ; <nl> return ; <nl> } <nl> <nl>\n", "msg": "Simplify checking / setting file . imported in ImportScanner # _scanFile .\n", "score": 1}
{"diff_id": 31095, "repo": "meteor/meteor\n", "sha": "2dcef81a7c4d4834da3dcc04ae6afdd0384df1c1\n", "time": "2013-03-26T00:20:17Z\n", "diff": "mmm a / packages / mongo - livedata / mongo_driver . js <nl> ppp b / packages / mongo - livedata / mongo_driver . js <nl> _Mongo . prototype . update = function ( collection_name , selector , mod , options ) { <nl> throw e ; <nl> } <nl> <nl> + / / explicit safety check . null and undefined can crash the mongo <nl> + / / driver . Although the node driver and minimongo do ' support ' <nl> + / / non - object modifier in that they don ' t crash , they are not <nl> + / / meaningful operations and do not do anything . Defensively throw an <nl> + / / error here . <nl> + if ( ! mod | | typeof mod ! = = ' object ' ) <nl> + throw new Error ( \" Invalid modifier . Modifier must be an object . \" ) ; <nl> + <nl> var write = self . _maybeBeginWrite ( ) ; <nl> <nl> if ( ! options ) options = { } ; <nl>\n", "msg": "Add explicit safety check for non - object modifiers passed to update .\n", "score": 1}
{"diff_id": 32055, "repo": "mozilla/pdf.js\n", "sha": "e65590078565a9cdc2d7064b09f7a54768242924\n", "time": "2011-05-07T05:15:18Z\n", "diff": "mmm a / pdf . js <nl> ppp b / pdf . js <nl> var PDFDoc = ( function ( ) { <nl> } ) ( ) ; <nl> <nl> var Interpreter = ( function ( ) { <nl> - function constructor ( xref , resources , catalog , graphics ) { <nl> + function constructor ( xref , resources , catalog , gfx ) { <nl> this . xref = xref ; <nl> this . res = resources ; <nl> this . catalog = catalog ; <nl> - this . gfx = graphics ; <nl> + this . gfx = gfx ; <nl> + this . map = { <nl> + / / Graphics state <nl> + w : gfx . setLineWidth , <nl> + d : gfx . setDash , <nl> + q : gfx . save , <nl> + Q : gfx . restore , <nl> + cm : gfx . transform , <nl> + <nl> + / / Path <nl> + m : gfx . moveTo , <nl> + l : gfx . lineTo , <nl> + c : gfx . curveTo , <nl> + h : gfx . closePath , <nl> + re : gfx . rectangle , <nl> + S : gfx . stroke , <nl> + f : gfx . fill , <nl> + B : gfx . fillStroke , <nl> + b : gfx . closeFillStroke , <nl> + <nl> + / / Clipping <nl> + <nl> + / / Text <nl> + BT : gfx . beginText , <nl> + ET : gfx . endText , <nl> + Tf : gfx . setFont , <nl> + Td : gfx . moveText , <nl> + Tj : gfx . showText , <nl> + <nl> + / / Type3 fonts <nl> + <nl> + / / Color <nl> + g : gfx . setFillGray , <nl> + RG : gfx . setStrokeRGBColor , <nl> + rg : gfx . setFillRGBColor , <nl> + <nl> + / / Shading <nl> + / / Images <nl> + / / XObjects <nl> + / / Marked content <nl> + / / Compatibility <nl> + } ; <nl> } <nl> <nl> constructor . prototype = { <nl> var Interpreter = ( function ( ) { <nl> height : mediaBox [ 3 ] - mediaBox [ 1 ] } ) ; <nl> var args = [ ] ; <nl> var gfx = this . gfx ; <nl> + var map = this . map ; <nl> var obj ; <nl> while ( ! IsEOF ( obj = parser . getObj ( ) ) ) { <nl> if ( IsCmd ( obj ) ) { <nl> var cmd = obj . cmd ; <nl> - var fn = gfx [ cmd ] ; <nl> - if ( fn & & cmd [ 0 ] ! = \" $ \" ) { <nl> + var fn = map [ cmd ] ; <nl> + if ( fn ) { <nl> if ( fn . length ! = args . length ) <nl> this . error ( \" Invalid number of arguments ' \" + cmd + \" ' \" ) ; <nl> fn . apply ( gfx , args ) ; <nl> var EchoGraphics = ( function ( ) { <nl> } , <nl> <nl> / / Graphics state <nl> - w : function ( width ) { / / setLineWidth <nl> + setLineWidth : function ( width ) { <nl> this . printdentln ( width + \" w \" ) ; <nl> } , <nl> - d : function ( dashArray , dashPhase ) { / / setDash <nl> + setDash : function ( dashArray , dashPhase ) { <nl> this . printdentln ( \" \" + dashArray + \" \" + dashPhase + \" d \" ) ; <nl> } , <nl> - q : function ( ) { / / save <nl> + save : function ( ) { <nl> this . printdentln ( \" q \" ) ; <nl> } , <nl> - Q : function ( ) { / / restore <nl> + restore : function ( ) { <nl> this . printdentln ( \" Q \" ) ; <nl> } , <nl> - cm : function ( a , b , c , d , e , f ) { / / transform <nl> + transform : function ( a , b , c , d , e , f ) { <nl> this . printdentln ( \" \" + a + \" \" + b + \" \" + c + <nl> \" \" + d + \" \" + e + \" \" + f + \" cm \" ) ; <nl> } , <nl> <nl> / / Path <nl> - m : function ( x , y ) { / / moveTo <nl> + moveTo : function ( x , y ) { <nl> this . printdentln ( \" \" + x + \" \" + y + \" m \" ) ; <nl> } , <nl> - l : function ( x , y ) { / / lineTo <nl> + lineTo : function ( x , y ) { <nl> this . printdentln ( \" \" + x + \" \" + y + \" l \" ) ; <nl> } , <nl> - c : function ( x1 , y1 , x2 , y2 , x3 , y3 ) { / / curvoTo <nl> + curveTo : function ( x1 , y1 , x2 , y2 , x3 , y3 ) { <nl> this . printdentln ( \" \" + x1 + \" \" + y1 + <nl> \" \" + x2 + \" \" + y2 + <nl> \" \" + x3 + \" \" + y3 + \" c \" ) ; <nl> } , <nl> - h : function ( ) { / / closePath <nl> + closePath : function ( ) { <nl> this . printdentln ( \" h \" ) ; <nl> } , <nl> - re : function ( x , y , width , height ) { / / rectangle <nl> + rectangle : function ( x , y , width , height ) { <nl> this . printdentln ( \" \" + x + \" \" + y + \" \" + width + \" \" + height + \" re \" ) ; <nl> } , <nl> - S : function ( ) { / / stroke <nl> + stroke : function ( ) { <nl> this . printdentln ( \" S \" ) ; <nl> } , <nl> - f : function ( ) { / / fill <nl> + fill : function ( ) { <nl> this . printdentln ( \" f \" ) ; <nl> } , <nl> - B : function ( ) { / / fillStroke <nl> + fillStroke : function ( ) { <nl> this . printdentln ( \" B \" ) ; <nl> } , <nl> - b : function ( ) { / / closeFillStroke <nl> + closeFillStroke : function ( ) { <nl> this . printdentln ( \" b \" ) ; <nl> } , <nl> <nl> / / Clipping <nl> <nl> / / Text <nl> - BT : function ( ) { / / beginText <nl> + beginText : function ( ) { <nl> this . printdentln ( \" BT \" ) ; <nl> this . indent ( ) ; <nl> } , <nl> - ET : function ( ) { / / endText <nl> + endText : function ( ) { <nl> this . dedent ( ) ; <nl> this . printdentln ( \" ET \" ) ; <nl> } , <nl> - Tf : function ( font , size ) { / / setFont <nl> + setFont : function ( font , size ) { <nl> this . printdentln ( \" / \" + font . name + \" \" + size + \" Tf \" ) ; <nl> } , <nl> - Td : function ( x , y ) { / / moveText <nl> + moveText : function ( x , y ) { <nl> this . printdentln ( \" \" + x + \" \" + y + \" Td \" ) ; <nl> } , <nl> - Tj : function ( text ) { / / showText <nl> + showText : function ( text ) { <nl> this . printdentln ( \" ( \" + text + \" ) Tj \" ) ; <nl> } , <nl> <nl> / / Type3 fonts <nl> <nl> / / Color <nl> - g : function ( gray ) { / / setFillGray <nl> + setFillGray : function ( gray ) { <nl> this . printdentln ( \" \" + gray + \" g \" ) ; <nl> } , <nl> - RG : function ( r , g , b ) { / / setStrokeRGBColor <nl> + setStrokeRGBColor : function ( r , g , b ) { <nl> this . printdentln ( \" \" + r + \" \" + g + \" \" + b + \" RG \" ) ; <nl> } , <nl> - rg : function ( r , g , b ) { / / setFillRGBColor <nl> + setFillRGBColor : function ( r , g , b ) { <nl> this . printdentln ( \" \" + r + \" \" + g + \" \" + b + \" rg \" ) ; <nl> } , <nl> <nl> var CanvasGraphics = ( function ( ) { <nl> } , <nl> <nl> / / Graphics state <nl> - w : function ( width ) { / / setLineWidth <nl> + setLineWidth : function ( width ) { <nl> this . ctx . lineWidth = width ; <nl> } , <nl> - d : function ( dashArray , dashPhase ) { / / setDash <nl> + setDash : function ( dashArray , dashPhase ) { <nl> / / TODO <nl> } , <nl> - q : function ( ) { / / save <nl> + save : function ( ) { <nl> this . ctx . save ( ) ; <nl> this . stateStack . push ( this . current ) ; <nl> this . current = new CanvasExtraState ( ) ; <nl> } , <nl> - Q : function ( ) { / / restore <nl> + restore : function ( ) { <nl> this . current = this . stateStack . pop ( ) ; <nl> this . ctx . restore ( ) ; <nl> } , <nl> - cm : function ( a , b , c , d , e , f ) { / / transform <nl> + transform : function ( a , b , c , d , e , f ) { <nl> this . ctx . transform ( a , b , c , d , e , f ) ; <nl> } , <nl> <nl> / / Path <nl> - m : function ( x , y ) { / / moveTo <nl> + moveTo : function ( x , y ) { <nl> this . ctx . moveTo ( x , y ) ; <nl> } , <nl> - l : function ( x , y ) { / / lineTo <nl> + lineTo : function ( x , y ) { <nl> this . ctx . lineTo ( x , y ) ; <nl> } , <nl> - c : function ( x1 , y1 , x2 , y2 , x3 , y3 ) { / / curveTo <nl> + curveTo : function ( x1 , y1 , x2 , y2 , x3 , y3 ) { <nl> this . ctx . bezierCurveTo ( x1 , y1 , x2 , y2 , x3 , y3 ) ; <nl> } , <nl> - h : function ( ) { / / closePath <nl> + closePath : function ( ) { <nl> this . ctx . closePath ( ) ; <nl> } , <nl> - re : function ( x , y , width , height ) { / / rectangle <nl> + rectangle : function ( x , y , width , height ) { <nl> this . ctx . rect ( x , y , width , height ) ; <nl> } , <nl> - S : function ( ) { / / stroke <nl> + stroke : function ( ) { <nl> this . ctx . stroke ( ) ; <nl> - this . $ consumePath ( ) ; <nl> + this . consumePath ( ) ; <nl> } , <nl> - f : function ( ) { / / fill <nl> + fill : function ( ) { <nl> this . ctx . fill ( ) ; <nl> - this . $ consumePath ( ) ; <nl> + this . consumePath ( ) ; <nl> } , <nl> - B : function ( ) { / / fillStroke <nl> + fillStroke : function ( ) { <nl> this . ctx . fill ( ) ; <nl> this . ctx . stroke ( ) ; <nl> - this . $ consumePath ( ) ; <nl> + this . consumePath ( ) ; <nl> } , <nl> - b : function ( ) { / / closeFillStroke <nl> - return this . B ( ) ; / / fillStroke <nl> + closeFillStroke : function ( ) { <nl> + return this . fillStroke ( ) ; <nl> } , <nl> <nl> / / Clipping <nl> <nl> / / Text <nl> - BT : function ( ) { / / beginText <nl> + beginText : function ( ) { <nl> / / TODO <nl> } , <nl> - ET : function ( ) { / / endText <nl> + endText : function ( ) { <nl> / / TODO <nl> } , <nl> - Tf : function ( font , size ) { / / setFont <nl> + setFont : function ( font , size ) { <nl> this . ctx . font = size + ' px ' + font . BaseFont ; <nl> } , <nl> - Td : function ( x , y ) { / / moveText <nl> + moveText : function ( x , y ) { <nl> this . current . lineX = x ; <nl> this . current . lineY = y ; <nl> } , <nl> - Tj : function ( text ) { / / showText <nl> + showText : function ( text ) { <nl> this . ctx . save ( ) ; <nl> this . ctx . translate ( 0 , 2 * this . current . lineY ) ; <nl> this . ctx . scale ( 1 , - 1 ) ; <nl> var CanvasGraphics = ( function ( ) { <nl> / / Type3 fonts <nl> <nl> / / Color <nl> - g : function ( gray ) { / / setFillGray <nl> - this . rg ( gray , gray , gray ) ; / / setFillRGBColor <nl> + setFillGray : function ( gray ) { <nl> + this . setFillRGBColor ( gray , gray , gray ) ; <nl> } , <nl> - RG : function ( r , g , b ) { / / setStrokeRGBColor <nl> - this . ctx . strokeStyle = this . $ makeCssRgb ( r , g , b ) ; <nl> + setStrokeRGBColor : function ( r , g , b ) { <nl> + this . ctx . strokeStyle = this . makeCssRgb ( r , g , b ) ; <nl> } , <nl> - rg : function ( r , g , b ) { / / setFillRGBColor <nl> - this . ctx . fillStyle = this . $ makeCssRgb ( r , g , b ) ; <nl> + setFillRGBColor : function ( r , g , b ) { <nl> + this . ctx . fillStyle = this . makeCssRgb ( r , g , b ) ; <nl> } , <nl> <nl> - / / Helper functions that are not allowed to be called directly . <nl> + / / Helper functions <nl> <nl> - $ consumePath : function ( ) { <nl> + consumePath : function ( ) { <nl> this . ctx . beginPath ( ) ; <nl> } , <nl> - $ makeCssRgb : function ( r , g , b ) { <nl> + makeCssRgb : function ( r , g , b ) { <nl> var ri = ( 255 * r ) | 0 , gi = ( 255 * g ) | 0 , bi = ( 255 * b ) | 0 ; <nl> return \" rgb ( \" + ri + \" , \" + gi + \" , \" + bi + \" ) \" ; <nl> } , <nl>\n", "msg": "restore long - form function names and a mapping table\n", "score": 1}
{"diff_id": 32774, "repo": "meteor/meteor\n", "sha": "7dbbc87fef8b7370f547aa681662e35e07a259cf\n", "time": "2014-06-10T00:00:47Z\n", "diff": "mmm a / tools / commands . js <nl> ppp b / tools / commands . js <nl> var packageCache = require ( ' . / package - cache . js ' ) ; <nl> var PackageLoader = require ( ' . / package - loader . js ' ) ; <nl> var PackageSource = require ( ' . / package - source . js ' ) ; <nl> var compiler = require ( ' . / compiler . js ' ) ; <nl> - var catalogs = require ( ' . / catalog . js ' ) ; <nl> + var catalog = require ( ' . / catalog . js ' ) ; <nl> var stats = require ( ' . / stats . js ' ) ; <nl> var unipackage = require ( ' . / unipackage . js ' ) ; <nl> <nl> - / / Reminder : we have two catalogs . The complete catalog contains local packages , <nl> - / / and uses them to override the server data . The official catalog only knows <nl> - / / about server packages . All query operations on package server contents should <nl> - / / refer to the / official / catalog . <nl> - var catalog = catalogs . complete ; <nl> - var officialCatalog = catalogs . official ; <nl> - <nl> / / Given a site name passed on the command line ( eg , ' mysite ' ) , return <nl> / / a fully - qualified hostname ( ' mysite . meteor . com ' ) . <nl> / / <nl> var hostedWithGalaxy = function ( site ) { <nl> var getLocalPackages = function ( ) { <nl> var ret = { } ; <nl> <nl> - var names = catalog . getAllPackageNames ( ) ; <nl> + var names = catalog . complete . getAllPackageNames ( ) ; <nl> _ . each ( names , function ( name ) { <nl> - if ( catalog . isLocalPackage ( name ) ) { <nl> - ret [ name ] = catalog . getLatestVersion ( name ) ; <nl> + if ( catalog . complete . isLocalPackage ( name ) ) { <nl> + ret [ name ] = catalog . complete . getLatestVersion ( name ) ; <nl> } <nl> } ) ; <nl> <nl> main . registerCommand ( { <nl> var couldNotContactServer = false ; <nl> <nl> / / Refresh the catalog , cacheing the remote package data on the server . <nl> - officialCatalog . refresh ( true ) ; <nl> + catalog . official . refresh ( true ) ; <nl> <nl> if ( options . packages ) { <nl> var versions = project . getVersions ( ) ; <nl> var allPackages = project . getCurrentCombinedConstraints ( ) ; <nl> - var newVersions = catalog . resolveConstraints ( allPackages , { <nl> + var newVersions = catalog . complete . resolveConstraints ( allPackages , { <nl> previousSolution : versions , <nl> breaking : ! options . minor , <nl> upgrade : true <nl> main . registerCommand ( { <nl> process . exit ( 1 ) ; <nl> } <nl> var r = appRelease . split ( ' @ ' ) ; <nl> - var record = officialCatalog . getReleaseVersion ( r [ 0 ] , r [ 1 ] ) ; <nl> + var record = catalog . official . getReleaseVersion ( r [ 0 ] , r [ 1 ] ) ; <nl> var updateTo = record . patchReleaseVersion ; <nl> if ( ! updateTo ) { <nl> console . log ( <nl> main . registerCommand ( { <nl> releaseVersionsToTry = [ release . current . getReleaseVersion ( ) ] ; <nl> } else { <nl> / / XXX clean up all this splitty stuff <nl> - var appReleaseInfo = catalog . getReleaseVersion ( <nl> + var appReleaseInfo = catalog . complete . getReleaseVersion ( <nl> appRelease . split ( ' @ ' ) [ 0 ] , appRelease . split ( ' @ ' ) [ 1 ] ) ; <nl> var appOrderKey = ( appReleaseInfo & & appReleaseInfo . orderKey ) | | null ; <nl> - releaseVersionsToTry = catalog . getSortedRecommendedReleaseVersions ( <nl> + releaseVersionsToTry = catalog . complete . getSortedRecommendedReleaseVersions ( <nl> releaseTrack , appOrderKey ) ; <nl> if ( ! releaseVersionsToTry . length ) { <nl> / / XXX make error better , and make sure that the \" already there \" error <nl> main . registerCommand ( { <nl> var directDependencies = project . getConstraints ( ) ; <nl> var previousVersions = project . getVersions ( ) ; <nl> var solutionReleaseVersion = _ . find ( releaseVersionsToTry , function ( versionToTry ) { <nl> - var releaseRecord = catalog . getReleaseVersion ( releaseTrack , versionToTry ) ; <nl> + var releaseRecord = catalog . complete . getReleaseVersion ( releaseTrack , versionToTry ) ; <nl> if ( ! releaseRecord ) <nl> throw Error ( \" missing release record ? \" ) ; <nl> var constraints = project . calculateCombinedConstraints ( <nl> directDependencies , releaseRecord . packages ) ; <nl> try { <nl> - solutionPackageVersions = catalog . resolveConstraints ( <nl> + solutionPackageVersions = catalog . complete . resolveConstraints ( <nl> constraints , { previousSolution : previousVersions } ) ; <nl> } catch ( e ) { <nl> / / XXX we should make the error handling explicitly detectable , and not <nl> main . registerCommand ( { <nl> var failed = false ; <nl> <nl> / / Refresh the catalog , cacheing the remote package data on the server . <nl> - officialCatalog . refresh ( ) ; <nl> + catalog . official . refresh ( ) ; <nl> <nl> / / Read in existing package dependencies . <nl> var packages = project . getConstraints ( ) ; <nl> main . registerCommand ( { <nl> <nl> _ . each ( constraints , function ( constraint ) { <nl> / / Check that the package exists . <nl> - if ( ! catalog . getPackage ( constraint . package ) ) { <nl> + if ( ! catalog . complete . getPackage ( constraint . package ) ) { <nl> process . stderr . write ( constraint . package + \" : no such package \\ n \" ) ; <nl> failed = true ; <nl> return ; <nl> main . registerCommand ( { <nl> <nl> / / If the version was specified , check that the version exists . <nl> if ( constraint . constraint ! = = null ) { <nl> - var versionInfo = catalog . getVersion ( <nl> + var versionInfo = catalog . complete . getVersion ( <nl> constraint . package , <nl> constraint . constraint ) ; <nl> if ( ! versionInfo ) { <nl> main . registerCommand ( { <nl> previousSolution : versions , <nl> breaking : ! ! options . force <nl> } ; <nl> - var newVersions = catalog . resolveConstraints ( allPackages , <nl> + var newVersions = catalog . complete . resolveConstraints ( allPackages , <nl> resolverOpts , <nl> { ignoreProjectDeps : true } ) ; <nl> if ( ! newVersions ) { <nl> main . registerCommand ( { <nl> process . stdout . write ( \" Successfully added the following packages . \\ n \" ) ; <nl> _ . each ( constraints , function ( constraint ) { <nl> var version = newVersions [ constraint . package ] ; <nl> - var versionRecord = catalog . getVersion ( constraint . package , version ) ; <nl> + var versionRecord = catalog . complete . getVersion ( constraint . package , version ) ; <nl> if ( constraint . constraint ! = = null & & <nl> version ! = = constraint . constraint ) { <nl> process . stdout . write ( \" Added \" + constraint . package + \" at version \" + version + <nl> main . registerCommand ( { <nl> / / server . Technically , we don ' t need to do this , since it is unlikely that <nl> / / new data will change our constraint solver decisions . But as a user , I <nl> / / would expect this command to update the local catalog . <nl> - officialCatalog . refresh ( true ) ; <nl> + catalog . official . refresh ( true ) ; <nl> <nl> / / Read in existing package dependencies . <nl> var packages = project . getConstraints ( ) ; <nl> main . registerCommand ( { <nl> / / are only calling ' using ' , this is not nessessary , but , once again , as a <nl> / / user , I would not be surprised to see this contact the server . In the <nl> / / future , we should move this call to sync somewhere in the background . <nl> - officialCatalog . refresh ( true ) ; <nl> + catalog . official . refresh ( true ) ; <nl> <nl> if ( options . releases & & options . using ) { <nl> console . log ( \" XXX : The contents of your release file . \" ) ; <nl> } else if ( options . releases ) { <nl> / / XXX : We probably want the recommended version rather than all of them , <nl> / / but for now , let ' s just display some stuff to make sure that it worked . <nl> - _ . each ( officialCatalog . getAllReleaseTracks ( ) , function ( name ) { <nl> - var versions = officialCatalog . getSortedRecommendedReleaseVersions ( name ) ; <nl> + _ . each ( catalog . official . getAllReleaseTracks ( ) , function ( name ) { <nl> + var versions = catalog . official . getSortedRecommendedReleaseVersions ( name ) ; <nl> _ . each ( versions , function ( version ) { <nl> - var versionInfo = officialCatalog . getReleaseVersion ( name , version ) ; <nl> + var versionInfo = catalog . official . getReleaseVersion ( name , version ) ; <nl> if ( versionInfo ) { <nl> items . push ( { name : name + \" \" + version , description : versionInfo . description } ) ; <nl> } <nl> main . registerCommand ( { <nl> if ( ! version ) { <nl> version = versions [ name ] ; <nl> } <nl> - var versionInfo = officialCatalog . getVersion ( name , version ) ; <nl> + var versionInfo = catalog . official . getVersion ( name , version ) ; <nl> if ( ! versionInfo ) { <nl> buildmessage . error ( \" Cannot process package list . Unknown : \" + name + <nl> \" at version \" + version + \" \\ n \" ) ; <nl> main . registerCommand ( { <nl> return 1 ; <nl> } <nl> } else { <nl> - _ . each ( officialCatalog . getAllPackageNames ( ) , function ( name ) { <nl> - var versionInfo = officialCatalog . getLatestVersion ( name ) ; <nl> + _ . each ( catalog . official . getAllPackageNames ( ) , function ( name ) { <nl> + var versionInfo = catalog . official . getLatestVersion ( name ) ; <nl> if ( versionInfo ) { <nl> items . push ( { name : name , description : versionInfo . description } ) ; <nl> } <nl> main . registerCommand ( { <nl> / / state ) but it ' ll do for now . <nl> var packageDir = path . resolve ( p ) ; <nl> var packageName = path . basename ( packageDir ) ; <nl> - catalog . addLocalPackage ( packageName , packageDir ) ; <nl> + catalog . complete . addLocalPackage ( packageName , packageDir ) ; <nl> localPackageNames . push ( packageName ) ; <nl> return packageName ; <nl> } ) ; <nl> main . registerCommand ( { <nl> / / as they work together . <nl> var tests = [ ] ; <nl> _ . each ( testPackages , function ( name ) { <nl> - var versionRecord = catalog . getLatestVersion ( name ) ; <nl> + var versionRecord = catalog . complete . getLatestVersion ( name ) ; <nl> if ( versionRecord & & versionRecord . testName ) { <nl> tests . push ( versionRecord . testName ) ; <nl> } <nl> main . registerCommand ( { <nl> } <nl> <nl> _ . each ( localPackageNames , function ( name ) { <nl> - catalog . removeLocalPackage ( name ) ; <nl> + catalog . complete . removeLocalPackage ( name ) ; <nl> } ) ; <nl> <nl> return ret ; <nl> main . registerCommand ( { <nl> } <nl> <nl> messages = buildmessage . capture ( function ( ) { <nl> - count = catalog . rebuildLocalPackages ( ) ; <nl> + count = catalog . complete . rebuildLocalPackages ( ) ; <nl> } ) ; <nl> } else { <nl> messages = buildmessage . capture ( function ( ) { <nl> main . registerCommand ( { <nl> <nl> _ . each ( options . args , function ( p ) { <nl> / / Let ' s remove the old unipackage directory first . <nl> - var packpath = catalog . getLoadPathForPackage ( p , null ) ; <nl> + var packpath = catalog . complete . getLoadPathForPackage ( p , null ) ; <nl> files . rm_recursive ( path . join ( packpath , \" . build . \" + p ) ) ; <nl> console . log ( path . join ( packpath , \" . build . \" + p ) ) ; <nl> <nl> main . registerCommand ( { <nl> / / In this function , we want to use the official catalog everywhere , because <nl> / / we assume that all packages have been published ( along with the release <nl> / / obviously ) and we want to be sure to only bundle the published versions . <nl> - officialCatalog . refresh ( ) ; <nl> + catalog . official . refresh ( ) ; <nl> <nl> var parsed = utils . splitConstraint ( releaseNameAndVersion ) ; <nl> if ( ! parsed . constraint ) <nl> throw new main . ShowUsage ; <nl> <nl> - var release = officialCatalog . getReleaseVersion ( parsed . package , <nl> + var release = catalog . official . getReleaseVersion ( parsed . package , <nl> parsed . constraint ) ; <nl> if ( ! release ) { <nl> / / XXX this could also mean package unknown . <nl> main . registerCommand ( { <nl> var toolPkg = release . tool & & utils . splitConstraint ( release . tool ) ; <nl> if ( ! ( toolPkg & & toolPkg . constraint ) ) <nl> throw new Error ( \" bad tool in release : \" + toolPkg ) ; <nl> - var toolPkgBuilds = officialCatalog . getAllBuilds ( <nl> + var toolPkgBuilds = catalog . official . getAllBuilds ( <nl> toolPkg . package , toolPkg . constraint ) ; <nl> if ( ! toolPkgBuilds ) { <nl> / / XXX this could also mean package unknown . <nl> main . registerCommand ( { <nl> / / need for the OSes that the tool is built for . <nl> _ . each ( osArches , function ( osArch ) { <nl> _ . each ( release . packages , function ( pkgVersion , pkgName ) { <nl> - if ( ! officialCatalog . getBuildsForArches ( pkgName , pkgVersion , [ osArch ] ) ) { <nl> + if ( ! catalog . official . getBuildsForArches ( pkgName , pkgVersion , [ osArch ] ) ) { <nl> throw Error ( \" missing build of \" + pkgName + \" @ \" + pkgVersion + <nl> \" for \" + osArch ) ; <nl> } <nl> main . registerCommand ( { <nl> _ . each ( osArches , function ( osArch ) { <nl> var tmpdir = files . mkdtemp ( ) ; <nl> / / We ' re going to build and tar up a tropohouse in a temporary directory ; we <nl> - / / don ' t want to use any of our local packages , so we use officialCatalog <nl> + / / don ' t want to use any of our local packages , so we use catalog . official <nl> / / instead of catalog . <nl> / / XXX update to ' . meteor ' when we combine houses <nl> var tmpTropo = new tropohouse . Tropohouse ( <nl> - path . join ( tmpdir , ' . meteor0 ' ) , officialCatalog ) ; <nl> + path . join ( tmpdir , ' . meteor0 ' ) , catalog . official ) ; <nl> tmpTropo . maybeDownloadPackageForArchitectures ( <nl> { packageName : toolPkg . package , version : toolPkg . constraint } , <nl> [ osArch ] ) ; / / XXX ' browser ' too ? <nl> main . registerCommand ( { <nl> bannersData . banners ) ; <nl> <nl> / / Refresh afterwards . <nl> - officialCatalog . refresh ( ) ; <nl> + catalog . official . refresh ( ) ; <nl> return 0 ; <nl> } ) ; <nl> <nl> main . registerCommand ( { <nl> / / Refresh the catalog , caching the remote package data on the server . We can <nl> / / optimize the workflow by using this data to weed out obviously incorrect <nl> / / submissions before they ever hit the wire . <nl> - officialCatalog . refresh ( true ) ; <nl> + catalog . official . refresh ( true ) ; <nl> <nl> try { <nl> var conn = packageClient . loggedInPackagesConnection ( ) ; <nl> main . registerCommand ( { <nl> } , function ( options ) { <nl> <nl> / / Refresh the catalog , cacheing the remote package data on the server . <nl> - officialCatalog . refresh ( true ) ; <nl> + catalog . official . refresh ( true ) ; <nl> <nl> - if ( ! catalog . getPackage ( options . name ) ) { <nl> + if ( ! catalog . complete . getPackage ( options . name ) ) { <nl> process . stderr . write ( ' No package named ' + options . name ) ; <nl> return 1 ; <nl> } <nl> - var pkgVersion = officialCatalog . getVersion ( options . name , options . versionString ) ; <nl> + var pkgVersion = catalog . official . getVersion ( options . name , options . versionString ) ; <nl> if ( ! pkgVersion ) { <nl> process . stderr . write ( ' There is no version ' + <nl> options . versionString + ' for package ' + <nl> main . registerCommand ( { <nl> } , function ( options ) { <nl> / / Refresh the catalog , cacheing the remote package data on the server . <nl> process . stdout . write ( \" Resyncing with package server . XXX Why so long ? ] \\ n \" ) ; <nl> - officialCatalog . refresh ( true ) ; <nl> + catalog . official . refresh ( true ) ; <nl> <nl> try { <nl> var conn = packageClient . loggedInPackagesConnection ( ) ; <nl> main . registerCommand ( { <nl> / / authorized to publish before we do any complicated / long operations , and <nl> / / before we publish its packages . <nl> if ( ! options [ ' create - track ' ] ) { <nl> - var trackRecord = officialCatalog . getReleaseTrack ( relConf . track ) ; <nl> + var trackRecord = catalog . official . getReleaseTrack ( relConf . track ) ; <nl> if ( ! trackRecord ) { <nl> process . stderr . write ( ' There is no release track named ' + relConf . track + <nl> ' . If you are creating a new track , use the - - create - track flag . \\ n ' ) ; <nl> main . registerCommand ( { <nl> / / Let ' s get the server version that this local package is <nl> / / overwriting . If such a version exists , we will need to make sure <nl> / / that the contents are the same . <nl> - var oldVersion = officialCatalog . getVersion <nl> + var oldVersion = catalog . official . getVersion <nl> ( item , packageSource . version ) ; <nl> <nl> / / Include this package in our release . <nl> main . registerCommand ( { <nl> compileResult : compileResult } ; <nl> return ; <nl> } else { <nl> - var existingBuild = officialCatalog . getBuildWithArchesString ( <nl> + var existingBuild = catalog . official . getBuildWithArchesString ( <nl> oldVersion , <nl> compileResult . unipackage . architecturesString ( ) ) ; <nl> <nl> main . registerCommand ( { <nl> _ . each ( toPublish , <nl> function ( prebuilt , name ) { <nl> var opts = { <nl> - new : ! officialCatalog . getPackage ( name ) <nl> + new : ! catalog . official . getPackage ( name ) <nl> } ; <nl> process . stdout . write ( \" Publishing package : \" + name + \" \\ n \" ) ; <nl> <nl> main . registerCommand ( { <nl> } <nl> <nl> / / Get it back . <nl> - officialCatalog . refresh ( ) ; <nl> + catalog . official . refresh ( ) ; <nl> <nl> process . stdout . write ( \" Done ! \\ n \" ) ; <nl> return 0 ; <nl>\n", "msg": "update how we refer to catalog in commands . js\n", "score": 1}
{"diff_id": 33763, "repo": "meteor/meteor\n", "sha": "58ad24d9328863c79120a4ffd006468f073bd705\n", "time": "2013-09-26T21:48:53Z\n", "diff": "mmm a / packages / mongo - livedata / mongo_livedata_tests . js <nl> ppp b / packages / mongo - livedata / mongo_livedata_tests . js <nl> if ( Meteor . isServer ) { <nl> onComplete ( ) ; <nl> } ) ; <nl> <nl> - Tinytest . addAsync ( \" mongo - livedata - upsert , \" + idGeneration , function ( test , onComplete ) { <nl> - var run = test . runId ( ) ; <nl> - var coll = new Meteor . Collection ( \" livedata_upsert_collection_ \" + run , collectionOptions ) ; <nl> - <nl> - var result1 = coll . update ( { foo : ' bar ' } , { foo : ' bar ' } , { upsert : true } ) ; <nl> - test . equal ( result1 . numberAffected , 1 ) ; <nl> - test . isTrue ( result1 . insertedId ) ; <nl> - test . equal ( coll . find ( ) . fetch ( ) , [ { foo : ' bar ' , _id : result1 . insertedId } ] ) ; <nl> - <nl> - var result2 = coll . update ( { foo : ' bar ' } , { foo : ' baz ' } , { upsert : true } ) ; <nl> - test . equal ( result2 . numberAffected , 1 ) ; <nl> - test . isFalse ( result2 . insertedId ) ; <nl> - test . equal ( coll . find ( ) . fetch ( ) , [ { foo : ' baz ' , _id : result1 . insertedId } ] ) ; <nl> - <nl> - coll . remove ( { } ) ; <nl> - <nl> - / / Test values that require transformation to go into Mongo : <nl> - <nl> - var t1 = new Meteor . Collection . ObjectID ( ) ; <nl> - var t2 = new Meteor . Collection . ObjectID ( ) ; <nl> - var result3 = coll . update ( { foo : t1 } , { foo : t1 } , { upsert : true } ) ; <nl> - test . equal ( result3 . numberAffected , 1 ) ; <nl> - test . isTrue ( result3 . insertedId ) ; <nl> - test . equal ( coll . find ( ) . fetch ( ) , [ { foo : t1 , _id : result3 . insertedId } ] ) ; <nl> - <nl> - var result4 = coll . update ( { foo : t1 } , { foo : t2 } , { upsert : true } ) ; <nl> - test . equal ( result2 . numberAffected , 1 ) ; <nl> - test . isFalse ( result2 . insertedId ) ; <nl> - test . equal ( coll . find ( ) . fetch ( ) , [ { foo : t2 , _id : result3 . insertedId } ] ) ; <nl> - <nl> - coll . remove ( { } ) ; <nl> + _ . each ( [ true , false ] , function ( minimongo ) { <nl> + Tinytest . addAsync ( \" mongo - livedata - upsert \" + ( minimongo ? \" minimongo \" : \" \" ) + \" , \" + idGeneration , function ( test , onComplete ) { <nl> + var run = test . runId ( ) ; <nl> + var options = collectionOptions ; ; <nl> + if ( minimongo ) <nl> + options = _ . extend ( collectionOptions , { connection : null } ) ; <nl> + var coll = new Meteor . Collection ( \" livedata_upsert_collection_ \" + run , options ) ; <nl> + <nl> + var result1 = coll . update ( { foo : ' bar ' } , { foo : ' bar ' } , { upsert : true } ) ; <nl> + test . equal ( result1 . numberAffected , 1 ) ; <nl> + test . isTrue ( result1 . insertedId ) ; <nl> + test . equal ( coll . find ( ) . fetch ( ) , [ { foo : ' bar ' , _id : result1 . insertedId } ] ) ; <nl> + <nl> + var result2 = coll . update ( { foo : ' bar ' } , { foo : ' baz ' } , { upsert : true } ) ; <nl> + test . equal ( result2 . numberAffected , 1 ) ; <nl> + test . isFalse ( result2 . insertedId ) ; <nl> + test . equal ( coll . find ( ) . fetch ( ) , [ { foo : ' baz ' , _id : result1 . insertedId } ] ) ; <nl> + <nl> + coll . remove ( { } ) ; <nl> + <nl> + / / Test values that require transformation to go into Mongo : <nl> + <nl> + var t1 = new Meteor . Collection . ObjectID ( ) ; <nl> + var t2 = new Meteor . Collection . ObjectID ( ) ; <nl> + var result3 = coll . update ( { foo : t1 } , { foo : t1 } , { upsert : true } ) ; <nl> + test . equal ( result3 . numberAffected , 1 ) ; <nl> + test . isTrue ( result3 . insertedId ) ; <nl> + test . equal ( coll . find ( ) . fetch ( ) , [ { foo : t1 , _id : result3 . insertedId } ] ) ; <nl> + <nl> + var result4 = coll . update ( { foo : t1 } , { foo : t2 } , { upsert : true } ) ; <nl> + test . equal ( result2 . numberAffected , 1 ) ; <nl> + test . isFalse ( result2 . insertedId ) ; <nl> + test . equal ( coll . find ( ) . fetch ( ) , [ { foo : t2 , _id : result3 . insertedId } ] ) ; <nl> + <nl> + coll . remove ( { } ) ; <nl> + <nl> + / / Test modification <nl> + <nl> + var result5 = coll . update ( { name : ' David ' } , { $ set : { foo : 1 } } , { upsert : true } ) ; <nl> + test . equal ( result5 . numberAffected , 1 ) ; <nl> + test . isTrue ( result5 . insertedId ) ; <nl> + var davidId = result5 . insertedId ; <nl> + test . equal ( coll . find ( ) . fetch ( ) , [ { name : ' David ' , foo : 1 , _id : davidId } ] ) ; <nl> + <nl> + test . throws ( function ( ) { <nl> + / / test that bad modifier fails fast <nl> + coll . update ( { name : ' David ' } , { $ blah : { foo : 2 } } , { upsert : true } ) ; <nl> + } ) ; <nl> <nl> - / / Test modification <nl> <nl> - var result5 = coll . update ( { name : ' David ' } , { $ set : { foo : 1 } } , { upsert : true } ) ; <nl> - test . equal ( result5 . numberAffected , 1 ) ; <nl> - test . isTrue ( result5 . insertedId ) ; <nl> - var davidId = result5 . insertedId ; <nl> - test . equal ( coll . find ( ) . fetch ( ) , [ { name : ' David ' , foo : 1 , _id : davidId } ] ) ; <nl> + var result6 = coll . update ( { name : ' David ' } , { $ set : { foo : 2 } } , { upsert : true } ) ; <nl> + test . equal ( result6 . numberAffected , 1 ) ; <nl> + test . isFalse ( result6 . insertedId ) ; <nl> + test . equal ( coll . find ( ) . fetch ( ) , [ { name : ' David ' , foo : 2 , <nl> + _id : result5 . insertedId } ] ) ; <nl> + <nl> + var emilyId = coll . insert ( { name : ' Emily ' , foo : 2 } ) ; <nl> + test . equal ( coll . find ( ) . fetch ( ) , [ { name : ' David ' , foo : 2 , _id : davidId } , <nl> + { name : ' Emily ' , foo : 2 , _id : emilyId } ] ) ; <nl> + <nl> + / / multi update by upsert <nl> + var result7 = coll . update ( { foo : 2 } , <nl> + { $ set : { bar : 7 } , $ setOnInsert : { name : ' Fred ' , foo : 2 } } , <nl> + { upsert : true , multi : true } ) ; <nl> + test . equal ( result7 . numberAffected , 2 ) ; <nl> + test . isFalse ( result7 . insertedId ) ; <nl> + test . equal ( coll . find ( ) . fetch ( ) , [ { name : ' David ' , foo : 2 , bar : 7 , _id : davidId } , <nl> + { name : ' Emily ' , foo : 2 , bar : 7 , _id : emilyId } ] ) ; <nl> + <nl> + / / insert by multi upsert <nl> + var result8 = coll . update ( { foo : 3 } , <nl> + { $ set : { bar : 7 } , $ setOnInsert : { name : ' Fred ' , foo : 2 } } , <nl> + { upsert : true , multi : true } ) ; <nl> + test . equal ( result8 . numberAffected , 1 ) ; <nl> + test . isTrue ( result8 . insertedId ) ; <nl> + var fredId = result8 . insertedId ; <nl> + test . equal ( coll . find ( ) . fetch ( ) , [ { name : ' David ' , foo : 2 , bar : 7 , _id : davidId } , <nl> + { name : ' Emily ' , foo : 2 , bar : 7 , _id : emilyId } , <nl> + { name : ' Fred ' , foo : 2 , bar : 7 , _id : fredId } ] ) ; <nl> <nl> - test . throws ( function ( ) { <nl> - / / test that bad modifier fails fast <nl> - coll . update ( { name : ' David ' } , { $ blah : { foo : 2 } } , { upsert : true } ) ; <nl> + onComplete ( ) ; <nl> } ) ; <nl> - <nl> - <nl> - var result6 = coll . update ( { name : ' David ' } , { $ set : { foo : 2 } } , { upsert : true } ) ; <nl> - test . equal ( result6 . numberAffected , 1 ) ; <nl> - test . isFalse ( result6 . insertedId ) ; <nl> - test . equal ( coll . find ( ) . fetch ( ) , [ { name : ' David ' , foo : 2 , <nl> - _id : result5 . insertedId } ] ) ; <nl> - <nl> - var emilyId = coll . insert ( { name : ' Emily ' , foo : 2 } ) ; <nl> - test . equal ( coll . find ( ) . fetch ( ) , [ { name : ' David ' , foo : 2 , _id : davidId } , <nl> - { name : ' Emily ' , foo : 2 , _id : emilyId } ] ) ; <nl> - <nl> - / / multi update by upsert <nl> - var result7 = coll . update ( { foo : 2 } , <nl> - { $ set : { bar : 7 } , $ setOnInsert : { name : ' Fred ' , foo : 2 } } , <nl> - { upsert : true , multi : true } ) ; <nl> - test . equal ( result7 . numberAffected , 2 ) ; <nl> - test . isFalse ( result7 . insertedId ) ; <nl> - test . equal ( coll . find ( ) . fetch ( ) , [ { name : ' David ' , foo : 2 , bar : 7 , _id : davidId } , <nl> - { name : ' Emily ' , foo : 2 , bar : 7 , _id : emilyId } ] ) ; <nl> - <nl> - / / insert by multi upsert <nl> - var result8 = coll . update ( { foo : 3 } , <nl> - { $ set : { bar : 7 } , $ setOnInsert : { name : ' Fred ' , foo : 2 } } , <nl> - { upsert : true , multi : true } ) ; <nl> - test . equal ( result8 . numberAffected , 1 ) ; <nl> - test . isTrue ( result8 . insertedId ) ; <nl> - var fredId = result8 . insertedId ; <nl> - test . equal ( coll . find ( ) . fetch ( ) , [ { name : ' David ' , foo : 2 , bar : 7 , _id : davidId } , <nl> - { name : ' Emily ' , foo : 2 , bar : 7 , _id : emilyId } , <nl> - { name : ' Fred ' , foo : 2 , bar : 7 , _id : fredId } ] ) ; <nl> - <nl> - onComplete ( ) ; <nl> } ) ; <nl> <nl> } / / end Meteor . isServer <nl>\n", "msg": "Run upsert tests for minimongo collections\n", "score": 1}
{"diff_id": 33949, "repo": "meteor/meteor\n", "sha": "dacedda571e49593f747bb6944945c0b663bd5d8\n", "time": "2018-05-12T15:30:13Z\n", "diff": "mmm a / packages / meteor / url_common . js <nl> ppp b / packages / meteor / url_common . js <nl> Meteor . absoluteUrl = function ( path , options ) { <nl> } ; <nl> <nl> / / allow later packages to override default options <nl> - Meteor . absoluteUrl . defaultOptions = { } ; <nl> + var defaultOptions = Meteor . absoluteUrl . defaultOptions = { } ; <nl> + <nl> + / / available only in a browser environment <nl> + var location = typeof window = = = \" object \" & & window . location ; <nl> + <nl> if ( typeof __meteor_runtime_config__ = = = \" object \" & & <nl> __meteor_runtime_config__ . ROOT_URL ) <nl> Meteor . absoluteUrl . defaultOptions . rootUrl = __meteor_runtime_config__ . ROOT_URL ; <nl> <nl> + / / Make absolute URLs use HTTPS by default if the current window . location <nl> + / / uses HTTPS . Since this is just a default , it can be overridden by <nl> + / / passing { secure : false } if necessary . <nl> + if ( location & & <nl> + location . protocol = = = \" https : \" ) { <nl> + defaultOptions . secure = true ; <nl> + } <nl> <nl> Meteor . _relativeToSiteRootUrl = function ( link ) { <nl> if ( typeof __meteor_runtime_config__ = = = \" object \" & & <nl>\n", "msg": "Use HTTPS in Meteor . absoluteUrl by default if window . location uses HTTPS .\n", "score": 1}
{"diff_id": 35173, "repo": "Leaflet/Leaflet\n", "sha": "bc405b59110b3dda42fb6833f53e4998ab03f27f\n", "time": "2013-12-23T19:33:25Z\n", "diff": "mmm a / src / layer / vector / Path . js <nl> ppp b / src / layer / vector / Path . js <nl> L . Path = L . Layer . extend ( { <nl> _fireMouseEvent : function ( e , type ) { <nl> type = type | | e . type ; <nl> <nl> - if ( ! this . listens ( type ) ) { return ; } <nl> + if ( ! this . listens ( type , true ) ) { return ; } <nl> <nl> var map = this . _map , <nl> containerPoint = map . mouseEventToContainerPoint ( e ) , <nl>\n", "msg": "make propagation work correctly for vector layers\n", "score": 1}
{"diff_id": 36460, "repo": "meteor/meteor\n", "sha": "b73aca8acc7a7944e26eb3f01dc1bb8bdb9abb77\n", "time": "2015-03-04T19:32:57Z\n", "diff": "mmm a / tools / commands - packages . js <nl> ppp b / tools / commands - packages . js <nl> main . registerCommand ( { <nl> } ) ; <nl> } ) ; <nl> <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + / / admin check - package - versions <nl> + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> + <nl> + / / Run before publish - release - - from - checkout to make sure that all of our <nl> + / / version numbers are up to date <nl> + main . registerCommand ( { <nl> + name : ' admin check - package - versions ' , <nl> + hidden : true , <nl> + catalogRefresh : new catalog . Refresh . OnceAtStart ( { ignoreErrors : false } ) <nl> + } , function ( options ) { <nl> + if ( ! files . inCheckout ( ) ) { <nl> + Console . error ( \" Must run from checkout . \" ) ; <nl> + return 1 ; <nl> + } ; <nl> + <nl> + / / Set up a temporary project context and build everything . <nl> + var tempProjectDir = files . mkdtemp ( ' meteor - release - build ' ) ; <nl> + var projectContext = new projectContextModule . ProjectContext ( { <nl> + projectDir : tempProjectDir , / / won ' t have a packages dir , that ' s OK <nl> + / / seriously , we only want checkout packages <nl> + ignorePackageDirsEnvVar : true , <nl> + / / When we publish , we should always include web . cordova unibuilds , even <nl> + / / though this temporary directory does not have any cordova platforms <nl> + forceIncludeCordovaUnibuild : true <nl> + } ) ; <nl> + <nl> + / / Read metadata and initialize catalog . <nl> + main . captureAndExit ( \" = > Errors while building for release : \" , function ( ) { <nl> + projectContext . initializeCatalog ( ) ; <nl> + } ) ; <nl> + <nl> + / / Ensure that all packages and their tests are built . ( We need to build <nl> + / / tests so that we can include their sources in source tarballs . ) <nl> + var allPackagesWithTests = projectContext . localCatalog . getAllPackageNames ( ) ; <nl> + var allPackages = projectContext . localCatalog . getAllNonTestPackageNames ( ) ; <nl> + projectContext . projectConstraintsFile . addConstraints ( <nl> + _ . map ( allPackagesWithTests , function ( p ) { <nl> + return utils . parsePackageConstraint ( p ) ; <nl> + } ) <nl> + ) ; <nl> + <nl> + Console . info ( \" Listing packages where the checkout version doesn ' t match the \" , <nl> + \" latest version on the package server . \" ) ; <nl> + <nl> + _ . each ( allPackages , function ( packageName ) { <nl> + var checkoutVersion = projectContext . localCatalog . getLatestVersion ( packageName ) . version ; <nl> + var remoteLatestVersion = catalog . official . getLatestVersion ( packageName ) . version ; <nl> + <nl> + if ( checkoutVersion ! = = remoteLatestVersion ) { <nl> + Console . info ( packageName , checkoutVersion , remoteLatestVersion ) ; <nl> + } <nl> + } ) ; <nl> + } ) ; <nl> + <nl> / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl> / / add <nl> / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / <nl>\n", "msg": "Made a useful new command for mangling version numbers\n", "score": 1}
{"diff_id": 36539, "repo": "balderdashy/sails\n", "sha": "1fe7f2e0f767de06e79beabe142db65fff1e4fd5\n", "time": "2013-01-14T07:25:49Z\n", "diff": "mmm a / test / nullValues . test . js <nl> ppp b / test / nullValues . test . js <nl> describe ( ' Null values ' , function ( ) { <nl> User . findAll ( { <nl> type : ' null value create test ' <nl> } , function ( err , users ) { <nl> + if ( err ) return done ( new Error ( err ) ) ; <nl> if ( users . length < 1 ) return done ( new Error ( ' Proper user was not created ! ' ) ) ; <nl> if ( users . length > 1 ) return done ( new Error ( ' Too many users created ! ' ) ) ; <nl> else done ( err ) ; <nl> describe ( ' Null values ' , function ( ) { <nl> / / Now check that the user we just created can be found <nl> / / but use the NULL name as the query <nl> User . findAll ( { <nl> - name : null <nl> + name : null , <nl> + type : ' null value create test ' <nl> } , function ( err , users ) { <nl> + if ( err ) return done ( new Error ( err ) ) ; <nl> if ( users . length < 1 ) return done ( new Error ( ' Proper user was not found ! ' ) ) ; <nl> if ( users . length > 1 ) return done ( new Error ( ' Too many users found ! ' ) ) ; <nl> else done ( err ) ; <nl>\n", "msg": "Made null test work independently or with other tests . Added better error handling .\n", "score": 1}
{"diff_id": 36638, "repo": "balderdashy/sails\n", "sha": "c6fd2719d21ca27c9a4fd30dcad2da7b02e39be1\n", "time": "2013-06-07T16:13:01Z\n", "diff": "mmm a / lib / lift / index . js <nl> ppp b / lib / lift / index . js <nl> function liftSails ( configOverride , cb ) { <nl> sails . log ( ' ( to see your app , visit : ' + ( usingSSL ? ' https ' : ' http ' ) + ' : / / ' + sails . config . host + ' : ' + sails . config . port + ' ) ' ) ; <nl> } <nl> <nl> - return cb & & cb ( err ) ; <nl> + return cb & & cb ( err , sails ) ; <nl> } ) ; <nl> } <nl> <nl>\n", "msg": "added sails object to callback for sails . lift , fixing issue\n", "score": 1}
{"diff_id": 36883, "repo": "meteor/meteor\n", "sha": "7e32a1cba4663641d2697bc104f169441452ba52\n", "time": "2014-08-21T06:21:30Z\n", "diff": "mmm a / tools / catalog . js <nl> ppp b / tools / catalog . js <nl> _ . extend ( CompleteCatalog . prototype , { <nl> } ) ; <nl> } <nl> <nl> - < < < < < < < HEAD <nl> var patience = new utils . Patience ( { <nl> messageAfterMs : 1000 , <nl> message : \" Figuring out the best package versions to use . This may take a moment . \" <nl> } ) ; <nl> - = = = = = = = <nl> - / / XXX : hack Before we run the constraint solver , let ' s do an 80 % check for <nl> - / / invalid packages . Specifically , if I am using a local package that <nl> - / / depends on ' hogwash ' , I should be told that hogwash doesn ' t exist <nl> - / / ( because constraint solver errors are not there yet , and , also , because <nl> - / / realistically , it is a rather common error , especially when starting <nl> - / / migration . This won ' t cover weirdly invalid packages on the server , for <nl> - / / example , but it is going to give us 80 % for 2 % effort , so it is worth it . <nl> - var depsToCheck = { } ; <nl> - / / Make a hash map of packages that we are going to have . <nl> - _ . each ( deps , function ( d ) { <nl> - depsToCheck [ d ] = false ; <nl> - } ) ; <nl> - <nl> - / / Checks the package & its dependencies ( if it is local ) for existing . <nl> - / / This function is recursive , but it only checks each package once ; it marks <nl> - / / that the check is done before recursing and it will stop upon hitting a <nl> - / / nonexistent package dependency . <nl> - var isValidDep = function ( pack ) { <nl> - if ( depsToCheck [ pack ] ) return ; <nl> - / / Do we even know about this package - - does it exist ? <nl> - if ( ! self . getPackage ( pack ) ) { <nl> - throw new Error ( <nl> - \" Trying to depend on a nonexistent package : \" + pack + \" \\ n \" ) ; <nl> - } <nl> - depsToCheck [ pack ] = true ; <nl> - / / If it does , is it local ? <nl> - if ( self . isLocalPackage ( pack ) ) { <nl> - var vr = self . getLatestVersion ( pack ) ; <nl> - var dirDeps = _ . keys ( vr . dependencies ) ; <nl> - _ . each ( vr . dependencies , function ( dep , name ) { <nl> - if ( _ . where ( dep . references , { weak : true } ) . length ! = = <nl> - dep . references . length ) <nl> - isValidDep ( name ) ; <nl> - } ) ; <nl> - } <nl> - } ; <nl> - <nl> - _ . each ( depsToCheck , function ( checked , pack ) { <nl> - if ( checked ) return ; <nl> - isValidDep ( pack ) ; <nl> - } ) ; <nl> - <nl> try { <nl> / / Then , call the constraint solver , to get the valid transitive subset of <nl> / / those versions to record for our solution . ( We don ' t just return the <nl>\n", "msg": "Revert \" one weird hack to maybe have better messages for nonexistent packages \"\n", "score": 1}
{"diff_id": 37068, "repo": "photonstorm/phaser\n", "sha": "e38adfed790e8eb84c95e7e1de24a13ec9b066d7\n", "time": "2017-11-16T14:23:04Z\n", "diff": "mmm a / v3 / src / sound / BaseSound . js <nl> ppp b / v3 / src / sound / BaseSound . js <nl> var BaseSound = new Class ( { <nl> * / <nl> this . volume = 1 ; <nl> / * * <nl> - * [ description ] <nl> + * Defines the speed at which the audio asset will be played . <nl> + * Value of 1 . 0 plays the audio at full speed , 0 . 5 plays the audio <nl> + * at half speed and 2 . 0 doubles the audio ' s playback speed . <nl> + * This value gets multiplied by global rate to have the final playback speed . <nl> * <nl> * @ property { number } rate <nl> * / <nl> var BaseSound = new Class ( { <nl> applyConfig : function ( ) { <nl> this . mute = this . currentConfig . mute ; <nl> this . volume = this . currentConfig . volume ; <nl> + this . rate = this . currentConfig . rate ; <nl> / / TODO assign other config values to buffer source <nl> } , <nl> fadeTo : function ( volume , duration ) { <nl>\n", "msg": "updated description for rate property for BaseSound class\n", "score": 1}
{"diff_id": 37132, "repo": "TryGhost/Ghost\n", "sha": "fb1b207db956155101ba6274c42a653c76b73e29\n", "time": "2019-09-18T15:08:18Z\n", "diff": "mmm a / core / server / data / migrations / versions / 3 . 0 / 10 - remove - empty - strings . js <nl> ppp b / core / server / data / migrations / versions / 3 . 0 / 10 - remove - empty - strings . js <nl> module . exports . up = ( { transacting } ) = > { <nl> ) ; <nl> } ; <nl> <nl> - module . exports . down = ( { connection } ) = > { <nl> - const replaceNullWithEmptyString = createReplace ( connection , null , ' ' ) ; <nl> + module . exports . down = ( { transacting } ) = > { <nl> + const replaceNullWithEmptyString = createReplace ( transacting , null , ' ' ) ; <nl> <nl> return Promise . all ( <nl> tablesToUpdate . map ( ( { tableName , columns } ) = > Promise . all ( <nl>\n", "msg": "Fixed error rolling back the \" remove empty strings \" migration\n", "score": 1}
{"diff_id": 37175, "repo": "photonstorm/phaser\n", "sha": "b8520f3b0dfda90117e573f9ff8fee38f95d9012\n", "time": "2020-10-02T09:58:18Z\n", "diff": "new file mode 100644 <nl> index 0000000000 . . 0f1f8a431a <nl> mmm / dev / null <nl> ppp b / src / tilemaps / components / IsometricWorldToTileXY . js <nl> <nl> + / * * <nl> + * @ author Richard Davey < rich @ photonstorm . com > <nl> + * @ copyright 2020 Photon Storm Ltd . <nl> + * @ license { @ link https : / / opensource . org / licenses / MIT | MIT License } <nl> + * / <nl> + <nl> + var Vector2 = require ( ' . . / . . / math / Vector2 ' ) ; <nl> + <nl> + / * * <nl> + * Converts from world XY coordinates ( pixels ) to isometric tile XY coordinates ( tile units ) , factoring in the <nl> + * layer ' s position , scale and scroll . This will return a new Vector2 object or update the given <nl> + * ` point ` object . <nl> + * <nl> + * @ function Phaser . Tilemaps . Components . IsometricWorldToTileXY <nl> + * @ since 3 . 50 . 0 <nl> + * <nl> + * @ param { number } worldX - The x coordinate to be converted , in pixels , not tiles . <nl> + * @ param { number } worldY - The y coordinate to be converted , in pixels , not tiles . <nl> + * @ param { boolean } [ snapToFloor = true ] - Whether or not to round the tile coordinate down to the nearest integer . <nl> + * @ param { Phaser . Math . Vector2 } [ point ] - A Vector2 to store the coordinates in . If not given a new Vector2 is created . <nl> + * @ param { Phaser . Cameras . Scene2D . Camera } [ camera = main camera ] - The Camera to use when calculating the tile index from the world values . <nl> + * @ param { Phaser . Tilemaps . LayerData } layer - The Tilemap Layer to act upon . <nl> + * <nl> + * @ return { Phaser . Math . Vector2 } The XY location in tile units . <nl> + * / <nl> + var IsometricWorldToTileXY = function ( worldX , worldY , snapToFloor , point , camera , layer ) <nl> + { <nl> + if ( snapToFloor = = = undefined ) { snapToFloor = true ; } <nl> + if ( point = = = undefined ) { point = new Vector2 ( ) ; } <nl> + <nl> + var tileWidth = layer . baseTileWidth ; <nl> + var tileHeight = layer . baseTileHeight ; <nl> + var tilemapLayer = layer . tilemapLayer ; <nl> + <nl> + if ( tilemapLayer ) <nl> + { <nl> + if ( camera = = = undefined ) { camera = tilemapLayer . scene . cameras . main ; } <nl> + <nl> + / / Find the world position relative to the static or dynamic layer ' s top left origin , <nl> + / / factoring in the camera ' s vertical scroll <nl> + <nl> + worldY = worldY - ( tilemapLayer . y + camera . scrollY * ( 1 - tilemapLayer . scrollFactorY ) ) ; <nl> + <nl> + tileHeight * = tilemapLayer . scaleY ; <nl> + <nl> + / / Find the world position relative to the static or dynamic layer ' s top left origin , <nl> + / / factoring in the camera ' s horizontal scroll <nl> + <nl> + worldX = worldX - ( tilemapLayer . x + camera . scrollX * ( 1 - tilemapLayer . scrollFactorX ) ) ; <nl> + <nl> + tileWidth * = tilemapLayer . scaleX ; <nl> + } <nl> + <nl> + worldX - = tileWidth / 2 ; <nl> + <nl> + var x = ( snapToFloor ) ? Math . floor ( ( worldX / ( tileWidth / 2 ) + worldY / ( tileHeight / 2 ) ) / 2 ) : ( ( worldX / ( tileWidth / 2 ) + worldY / ( tileHeight / 2 ) ) / 2 ) ; <nl> + var y = ( snapToFloor ) ? Math . floor ( ( worldY / ( tileHeight / 2 ) - worldX / ( tileWidth / 2 ) ) / 2 ) : ( ( worldY / ( tileHeight / 2 ) - worldX / ( tileWidth / 2 ) ) / 2 ) ; <nl> + <nl> + return point . set ( x , y ) ; <nl> + } ; <nl> + <nl> + module . exports = IsometricWorldToTileXY ; <nl>\n", "msg": "` Tilemaps . Components . IsometricWorldToTileXY ` is a new function that converts world coordinates to isometric tile coordinates .\n", "score": 1}
{"diff_id": 37220, "repo": "gatsbyjs/gatsby\n", "sha": "562361b09cd9ffe66163c0c29fed30b66bdd9e60\n", "time": "2019-09-20T21:15:58Z\n", "diff": "mmm a / www / src / components / layout . js <nl> ppp b / www / src / components / layout . js <nl> class DefaultLayout extends React . Component { <nl> < Banner / > <nl> < Navigation pathname = { this . props . location . pathname } / > <nl> < div <nl> - className = { ` main - body ` } <nl> + className = { ` main - body docSearch - content ` } <nl> css = { { <nl> paddingLeft : ` env ( safe - area - inset - left ) ` , <nl> paddingRight : ` env ( safe - area - inset - right ) ` , <nl>\n", "msg": "Add docSearch - content class to layout for Actions in the Gatsb  ( )\n", "score": 1}
{"diff_id": 37275, "repo": "Semantic-Org/Semantic-UI\n", "sha": "89c3a44c4c6717ded54d0769e00dc7b0579a55b0\n", "time": "2015-11-01T21:22:48Z\n", "diff": "mmm a / src / definitions / modules / dropdown . js <nl> ppp b / src / definitions / modules / dropdown . js <nl> $ . fn . dropdown = function ( parameters ) { <nl> onSuccess : function ( response ) { <nl> module . remove . message ( ) ; <nl> module . setup . menu ( { <nl> - values : response . results <nl> + values : response [ fields . remoteValues ] <nl> } ) ; <nl> callback ( ) ; <nl> } <nl> $ . fn . dropdown . settings = { <nl> <nl> / / property names for remote query <nl> fields : { <nl> - values : ' values ' , / / grouping for all dropdown values <nl> - name : ' name ' , / / displayed dropdown text <nl> - value : ' value ' / / actual dropdown value <nl> + remoteValues : ' results ' , / / grouping for api results <nl> + values : ' values ' , / / grouping for all dropdown values <nl> + name : ' name ' , / / displayed dropdown text <nl> + value : ' value ' / / actual dropdown value <nl> } , <nl> <nl> selector : { <nl> $ . fn . dropdown . settings . templates = { <nl> / / generates just menu from select <nl> menu : function ( response , fields ) { <nl> var <nl> - values = response . values | | { } , <nl> + values = response [ fields . values ] | | { } , <nl> html = ' ' <nl> ; <nl> - $ . each ( response [ fields . values ] , function ( index , option ) { <nl> + $ . each ( values , function ( index , option ) { <nl> html + = ' < div class = \" item \" data - value = \" ' + option [ fields . value ] + ' \" > ' + option [ fields . name ] + ' < / div > ' ; <nl> } ) ; <nl> return html ; <nl>\n", "msg": "Adds ability to use a different expected field group with API\n", "score": 1}
{"diff_id": 37326, "repo": "balderdashy/sails\n", "sha": "3f78364339b591e4bab0ac86e32e611f7f9c8d82\n", "time": "2013-10-23T02:06:10Z\n", "diff": "mmm a / lib / hooks / orm / index . js <nl> ppp b / lib / hooks / orm / index . js <nl> module . exports = function ( sails ) { <nl> <nl> Object . keys ( collections ) . forEach ( function eachInstantiatedCollection ( modelID ) { <nl> <nl> + / / Bind context for models <nl> + / / ( this allows usage with tools like ` async ` ) <nl> + util . bindAll ( collections [ modelID ] ) ; <nl> + <nl> / / Set ` sails . models . * ` reference to instantiated Collection <nl> / / Exposed as ` sails . models [ modelID ] ` <nl> sails . models [ modelID ] = collections [ modelID ] ; <nl>\n", "msg": "Bind context for model methods , to allow them to be used transparently with tools like async .\n", "score": 1}
{"diff_id": 37762, "repo": "jashkenas/backbone\n", "sha": "82eed08b7a3d7efb17a0b613af4840d23c3f0495\n", "time": "2012-03-14T01:14:16Z\n", "diff": "mmm a / backbone . js <nl> ppp b / backbone . js <nl> <nl> / / Backbone . Events <nl> / / mmmmmmmmmmmmmmm - - <nl> <nl> + / / Regular expression used to split event strings <nl> + var eventSplitter = / \\ s + / ; <nl> + <nl> / / A module that can be mixed in to * any object * in order to provide it with <nl> / / custom events . You may bind with ` on ` or remove with ` off ` callback functions <nl> / / to an event ; trigger ` - ing an event fires all callbacks in succession . <nl> <nl> on : function ( events , callback , context ) { <nl> var calls , event , node , tail , list ; <nl> if ( ! callback ) return this ; <nl> - events = events . split ( / \\ s + / ) ; <nl> + events = events . split ( eventSplitter ) ; <nl> calls = this . _callbacks | | ( this . _callbacks = { } ) ; <nl> while ( event = events . shift ( ) ) { <nl> / / Create an immutable callback list , allowing traversal during <nl> <nl> if ( ! events ) { <nl> delete this . _callbacks ; <nl> } else if ( calls = this . _callbacks ) { <nl> - events = events . split ( / \\ s + / ) ; <nl> + events = events . split ( eventSplitter ) ; <nl> while ( event = events . shift ( ) ) { <nl> node = calls [ event ] ; <nl> delete calls [ event ] ; <nl> <nl> var event , node , calls , tail , args , all , rest ; <nl> if ( ! ( calls = this . _callbacks ) ) return this ; <nl> all = calls . all ; <nl> - events = events . split ( / \\ s + / ) ; <nl> + events = events . split ( eventSplitter ) ; <nl> rest = slice . call ( arguments , 1 ) ; <nl> while ( event = events . shift ( ) ) { <nl> if ( node = calls [ event ] ) { <nl> <nl> } ; <nl> <nl> / / Cached regex to split keys for ` delegate ` . <nl> - var eventSplitter = / ^ ( \\ S + ) \\ s * ( . * ) $ / ; <nl> + var delegateEventSplitter = / ^ ( \\ S + ) \\ s * ( . * ) $ / ; <nl> <nl> / / List of view options to be merged as properties . <nl> var viewOptions = [ ' model ' , ' collection ' , ' el ' , ' id ' , ' attributes ' , ' className ' , ' tagName ' ] ; <nl> <nl> var method = events [ key ] ; <nl> if ( ! _ . isFunction ( method ) ) method = this [ events [ key ] ] ; <nl> if ( ! method ) throw new Error ( ' Method \" ' + events [ key ] + ' \" does not exist ' ) ; <nl> - var match = key . match ( eventSplitter ) ; <nl> + var match = key . match ( delegateEventSplitter ) ; <nl> var eventName = match [ 1 ] , selector = match [ 2 ] ; <nl> method = _ . bind ( method , this ) ; <nl> eventName + = ' . delegateEvents ' + this . cid ; <nl>\n", "msg": "Slight optimization for Events cache splitting Regex\n", "score": 1}
{"diff_id": 37784, "repo": "meteor/meteor\n", "sha": "bf7821809b90b2af4696424f652e4651d7eb4b16\n", "time": "2018-01-19T02:57:26Z\n", "diff": "mmm a / tools / tests / dynamic - import . js <nl> ppp b / tools / tests / dynamic - import . js <nl> function run ( isProduction ) { <nl> run . match ( \" App running at \" ) ; <nl> run . match ( \" SERVER FAILURES : 0 \" ) ; <nl> run . match ( \" CLIENT FAILURES : 0 \" ) ; <nl> + run . waitSecs ( 30 ) ; <nl> run . expectExit ( 0 ) ; <nl> } <nl>\n", "msg": "Increase exit timeout of dynamic - import test to fix AppVeyor CI .\n", "score": 1}
{"diff_id": 37921, "repo": "RocketChat/Rocket.Chat\n", "sha": "80f53d4a8b3c72637a5684c193302d18d4468bd7\n", "time": "2016-03-02T18:06:01Z\n", "diff": "mmm a / packages / rocketchat - ldap / server / loginHandler . js <nl> ppp b / packages / rocketchat - ldap / server / loginHandler . js <nl> Accounts . registerLoginHandler ( \" ldap \" , function ( loginRequest ) { <nl> } else if ( RocketChat . settings . get ( ' LDAP_Default_Domain ' ) ! = = ' ' ) { <nl> userObject . email = username + ' @ ' + RocketChat . settings . get ( ' LDAP_Default_Domain ' ) ; <nl> } else { <nl> - throw new Meteor . Error ( \" LDAP - login - error \" , \" LDAP Authentication succeded , there is no email to create an account . \" ) ; <nl> + const error = new Meteor . Error ( \" LDAP - login - error \" , \" LDAP Authentication succeded , there is no email to create an account . \" ) ; <nl> + logger . error ( error ) ; <nl> + throw error ; <nl> } <nl> <nl> logger . debug ( ' New user data ' , userObject ) ; <nl>\n", "msg": "Log error when trying to creat a user with no email via LDAP\n", "score": 1}
{"diff_id": 38258, "repo": "expressjs/express\n", "sha": "ee9d50c1283c74f6b2aabeeb76a294362e75a37b\n", "time": "2013-04-05T06:26:27Z\n", "diff": "mmm a / examples / auth / pass . js <nl> ppp b / examples / auth / pass . js <nl> var iterations = 12000 ; <nl> <nl> exports . hash = function ( pwd , salt , fn ) { <nl> if ( 3 = = arguments . length ) { <nl> - crypto . pbkdf2 ( pwd , salt , iterations , len , fn ) ; <nl> + crypto . pbkdf2 ( pwd , salt , iterations , len , function ( err , hash ) { <nl> + fn ( err , ( new Buffer ( hash , ' binary ' ) ) . toString ( ' base64 ' ) ) ; <nl> + } ) ; <nl> } else { <nl> fn = salt ; <nl> crypto . randomBytes ( len , function ( err , salt ) { <nl> exports . hash = function ( pwd , salt , fn ) { <nl> salt = salt . toString ( ' base64 ' ) ; <nl> crypto . pbkdf2 ( pwd , salt , iterations , len , function ( err , hash ) { <nl> if ( err ) return fn ( err ) ; <nl> - fn ( null , salt , hash ) ; <nl> + fn ( null , salt , ( new Buffer ( hash , ' binary ' ) ) . toString ( ' base64 ' ) ) ; <nl> } ) ; <nl> } ) ; <nl> } <nl> - } ; <nl> + } ; <nl> \\ No newline at end of file <nl>\n", "msg": "Modified hash to return base64 encoded strings .\n", "score": 1}
{"diff_id": 38327, "repo": "photonstorm/phaser\n", "sha": "e728f3a1b954482b7498c0f82ff0a8c56608a3a3\n", "time": "2018-03-29T19:40:32Z\n", "diff": "mmm a / src / scene / SceneManager . js <nl> ppp b / src / scene / SceneManager . js <nl> var SceneManager = new Class ( { <nl> { <nl> entry = this . _start [ i ] ; <nl> <nl> - this . start ( entry ) ; <nl> + this . start ( entry , entry . scene . data ) ; <nl> } <nl> <nl> this . _start . length = 0 ; <nl> var SceneManager = new Class ( { <nl> { <nl> entry = this . _start [ i ] ; <nl> <nl> - this . start ( entry ) ; <nl> + this . start ( entry , entry . scene . data ) ; <nl> } <nl> <nl> / / Clear the pending lists <nl> var SceneManager = new Class ( { <nl> { <nl> if ( this . game . isBooted ) <nl> { <nl> - this . start ( key ) ; <nl> + this . start ( key , newScene . sys . settings . data ) ; <nl> } <nl> else <nl> { <nl> var SceneManager = new Class ( { <nl> } <nl> } <nl> <nl> + if ( sceneConfig . hasOwnProperty ( ' data ' ) ) <nl> + { <nl> + newScene . data = sceneConfig . data ; <nl> + } <nl> + <nl> return newScene ; <nl> } , <nl> <nl> var SceneManager = new Class ( { <nl> if ( entry . key = = = key ) <nl> { <nl> entry . autoStart = true ; <nl> - entry . data = data ; <nl> + entry . scene . data = data ; <nl> } <nl> } <nl> <nl>\n", "msg": "[ ISSUE ] Phaser Scene - passing data to scene init & create methods\n", "score": 1}
{"diff_id": 38635, "repo": "lodash/lodash\n", "sha": "58aea21b8277175e2e3b8a5d95e7eb17ca58028c\n", "time": "2015-05-17T07:55:30Z\n", "diff": "mmm a / test / test . js <nl> ppp b / test / test . js <nl> <nl> } ) ; <nl> <nl> test ( ' should work with strings ' , 4 , function ( ) { <nl> - var pairs = [ [ ' hi ' , Object ( ' h ' ) ] , [ Object ( ' hi ' ) , ' h ' ] ] ; <nl> + var pairs = [ [ ' xo ' , Object ( ' x ' ) ] , [ Object ( ' xo ' ) , ' x ' ] ] ; <nl> <nl> _ . each ( pairs , function ( pair ) { <nl> strictEqual ( _ . isMatch ( pair [ 0 ] , pair [ 1 ] ) , true ) ; <nl> <nl> } ) ; <nl> <nl> test ( ' should work with strings ' , 4 , function ( ) { <nl> - var pairs = [ [ ' hi ' , Object ( ' h ' ) ] , [ Object ( ' hi ' ) , ' h ' ] ] ; <nl> + var pairs = [ [ ' xo ' , Object ( ' x ' ) ] , [ Object ( ' xo ' ) , ' x ' ] ] ; <nl> <nl> _ . each ( pairs , function ( pair ) { <nl> var matches = _ . matches ( pair [ 1 ] ) ; <nl> <nl> } ) ; <nl> <nl> test ( ' should work with strings ' , 4 , function ( ) { <nl> - var pairs = [ [ ' hi ' , Object ( ' h ' ) ] , [ Object ( ' hi ' ) , ' h ' ] ] ; <nl> + var pairs = [ [ ' xo ' , Object ( ' x ' ) ] , [ Object ( ' xo ' ) , ' x ' ] ] ; <nl> <nl> _ . each ( pairs , function ( pair ) { <nl> var matches = _ . matchesProperty ( ' 0 ' , pair [ 1 ] ) ; <nl>\n", "msg": "Use ' xo ' instead of ' hi ' for string tests .\n", "score": 1}
{"diff_id": 38867, "repo": "mozilla/pdf.js\n", "sha": "81b4761e6e0fcc6784e6acb2c5447a8fa2ce6ebe\n", "time": "2017-08-19T09:41:04Z\n", "diff": "mmm a / web / view_history . js <nl> ppp b / web / view_history . js <nl> class ViewHistory { <nl> PDFJSDev . test ( ' FIREFOX | | MOZCENTRAL ' ) ) { <nl> resolve ( sessionStorage . getItem ( ' pdfjs . history ' ) ) ; <nl> } else { <nl> - let value = localStorage . getItem ( ' pdfjs . history ' ) ; <nl> - <nl> - / / TODO : Remove this key - name conversion after a suitable time - frame . <nl> - / / Note that we only remove the old ' database ' entry if it looks like <nl> - / / it was created by PDF . js , to avoid removing someone else ' s data . <nl> - if ( ! value ) { <nl> - let databaseStr = localStorage . getItem ( ' database ' ) ; <nl> - if ( databaseStr ) { <nl> - try { <nl> - let database = JSON . parse ( databaseStr ) ; <nl> - if ( typeof database . files [ 0 ] . fingerprint = = = ' string ' ) { <nl> - localStorage . setItem ( ' pdfjs . history ' , databaseStr ) ; <nl> - localStorage . removeItem ( ' database ' ) ; <nl> - value = databaseStr ; <nl> - } <nl> - } catch ( ex ) { } <nl> - } <nl> - } <nl> - resolve ( value ) ; <nl> + resolve ( localStorage . getItem ( ' pdfjs . history ' ) ) ; <nl> } <nl> } ) ; <nl> } <nl>\n", "msg": "Remove the migration code for old localStorage data in ` ViewHistory `\n", "score": 1}
{"diff_id": 38995, "repo": "photonstorm/phaser\n", "sha": "15f2717e9b91aa1424cd71327038308859359759\n", "time": "2018-01-11T16:24:26Z\n", "diff": "mmm a / src / sound / BaseSound . js <nl> ppp b / src / sound / BaseSound . js <nl> var Class = require ( ' . . / utils / Class ' ) ; <nl> var Extend = require ( ' . . / utils / object / Extend ' ) ; <nl> var EventDispatcher = require ( ' . . / events / EventDispatcher ' ) ; <nl> var NOOP = require ( ' . . / utils / NOOP ' ) ; <nl> + var SoundValueEvent = require ( ' . / SoundValueEvent ' ) ; <nl> / * ! <nl> * @ author Pavle Goloskokovic < pgoloskokovic @ gmail . com > ( http : / / prunegames . com ) <nl> * / <nl> var BaseSound = new Class ( { <nl> this . totalRate = this . currentConfig . rate * this . manager . rate * detuneRate ; <nl> } <nl> } ) ; <nl> + / * * <nl> + * Playback rate . <nl> + * <nl> + * @ name Phaser . Sound . BaseSound # rate <nl> + * @ property { number } rate <nl> + * / <nl> + Object . defineProperty ( BaseSound . prototype , ' rate ' , { <nl> + get : function ( ) { <nl> + return this . currentConfig . rate ; <nl> + } , <nl> + set : function ( value ) { <nl> + this . currentConfig . rate = value ; <nl> + this . setRate ( ) ; <nl> + this . events . dispatch ( new SoundValueEvent ( this , ' SOUND_RATE ' , value ) ) ; <nl> + } <nl> + } ) ; <nl> module . exports = BaseSound ; <nl>\n", "msg": "Defining rate property on a BaseSound class since it ' s the shared behaviour between subclasses\n", "score": 1}
{"diff_id": 39296, "repo": "meteor/meteor\n", "sha": "55fbe16acf958b0767020785a409ff491fc22a2a\n", "time": "2013-03-30T04:45:53Z\n", "diff": "mmm a / tools / meteor . js <nl> ppp b / tools / meteor . js <nl> Fiber ( function ( ) { <nl> <nl> Commands . push ( { <nl> name : \" update \" , <nl> - help : \" Upgrade to the latest version of Meteor \" , <nl> + help : \" Upgrade this project to the latest version of Meteor \" , <nl> func : function ( argv ) { <nl> / / reparse args <nl> var opt = require ( ' optimist ' ) . usage ( <nl>\n", "msg": "slightly better short description for update\n", "score": 1}
{"diff_id": 39516, "repo": "atom/atom\n", "sha": "326ae6bf324279690c30cf18a88f1cfb8f8c102b\n", "time": "2017-04-06T18:56:45Z\n", "diff": "mmm a / src / pane - container . js <nl> ppp b / src / pane - container . js <nl> class PaneContainer { <nl> for ( let pane of this . getPanes ( ) ) { if ( pane . items . length = = = 0 ) { pane . destroy ( ) } } <nl> } <nl> <nl> + didAddPaneItem ( item , pane , index ) { <nl> + this . itemRegistry . addItem ( item ) <nl> + this . emitter . emit ( ' did - add - pane - item ' , { item , pane , index } ) <nl> + } <nl> + <nl> willDestroyPaneItem ( event ) { <nl> this . emitter . emit ( ' will - destroy - pane - item ' , event ) <nl> } <nl> <nl> didDestroyPaneItem ( event ) { <nl> + this . itemRegistry . removeItem ( event . item ) <nl> this . emitter . emit ( ' did - destroy - pane - item ' , event ) <nl> } <nl> <nl> class PaneContainer { <nl> const item = iterable [ index ] <nl> this . didAddPaneItem ( item , pane , index ) <nl> } <nl> - <nl> - pane . onDidRemoveItem ( ( { item , moved } ) = > { <nl> - if ( ! moved ) { this . removedPaneItem ( item ) } <nl> - } ) <nl> } ) ) <nl> } <nl> - <nl> - didAddPaneItem ( item , pane , index ) { <nl> - this . itemRegistry . addItem ( item ) <nl> - this . emitter . emit ( ' did - add - pane - item ' , { item , pane , index } ) <nl> - } <nl> - <nl> - removedPaneItem ( item ) { <nl> - this . itemRegistry . removeItem ( item ) <nl> - } <nl> } <nl>\n", "msg": "Use didDestroyPaneItem to remove item from item registry\n", "score": 1}
{"diff_id": 39533, "repo": "facebook/react-native\n", "sha": "de0d7cfb79c7f4011d4b6748b1afc656d33fd5ac\n", "time": "2019-05-13T21:37:27Z\n", "diff": "mmm a / Libraries / Lists / VirtualizedList . js <nl> ppp b / Libraries / Lists / VirtualizedList . js <nl> type RequiredProps = { <nl> / / ` VirtualizedSectionList ` ' s props . <nl> renderItem : $ FlowFixMe < renderItemType > , <nl> / * * <nl> - * The default accessor functions assume this is an Array < { key : string } > but you can override <nl> + * The default accessor functions assume this is an Array < { key : string } | { id : string } > but you can override <nl> * getItem , getItemCount , and keyExtractor to handle any type of index - based data . <nl> * / <nl> data ? : any , <nl> type State = { first : number , last : number } ; <nl> * offscreen . This means it ' s possible to scroll faster than the fill rate ands momentarily see <nl> * blank content . This is a tradeoff that can be adjusted to suit the needs of each application , <nl> * and we are working on improving it behind the scenes . <nl> - * - By default , the list looks for a ` key ` prop on each item and uses that for the React key . <nl> + * - By default , the list looks for a ` key ` or ` id ` prop on each item and uses that for the React key . <nl> * Alternatively , you can provide a custom ` keyExtractor ` prop . <nl> * <nl> * / <nl> class VirtualizedList extends React . PureComponent < Props , State > { <nl> if ( item . key ! = null ) { <nl> return item . key ; <nl> } <nl> + if ( item . id ! = null ) { <nl> + return item . id ; <nl> + } <nl> _usedIndexForKey = true ; <nl> if ( item . type & & item . type . displayName ) { <nl> _keylessItemComponentName = item . type . displayName ; <nl> class VirtualizedList extends React . PureComponent < Props , State > { <nl> ) ; <nl> if ( ! this . _hasWarned . keys & & _usedIndexForKey ) { <nl> console . warn ( <nl> - ' VirtualizedList : missing keys for items , make sure to specify a key property on each ' + <nl> + ' VirtualizedList : missing keys for items , make sure to specify a key or id property on each ' + <nl> ' item or provide a custom keyExtractor . ' , <nl> _keylessItemComponentName , <nl> ) ; <nl>\n", "msg": "Add default support for ` item . id ` as key in FlatList / VList ` keyExtractor `\n", "score": 1}
{"diff_id": 39790, "repo": "codemirror/CodeMirror\n", "sha": "c497aa6cbd88fc055edc3abf1470620366abce95\n", "time": "2012-06-21T13:31:49Z\n", "diff": "mmm a / lib / codemirror . js <nl> ppp b / lib / codemirror . js <nl> var CodeMirror = ( function ( ) { <nl> <nl> var line = getLine ( n ) , curSpace = line . indentation ( options . tabSize ) , <nl> curSpaceString = line . text . match ( / ^ \\ s * / ) [ 0 ] , indentation ; <nl> + if ( how = = \" smart \" ) { <nl> + indentation = mode . indent ( state , line . text . slice ( curSpaceString . length ) , line . text ) ; <nl> + if ( indentation = = Pass ) how = \" prev \" ; <nl> + } <nl> if ( how = = \" prev \" ) { <nl> if ( n ) indentation = getLine ( n - 1 ) . indentation ( options . tabSize ) ; <nl> else indentation = 0 ; <nl> } <nl> - else if ( how = = \" smart \" ) indentation = mode . indent ( state , line . text . slice ( curSpaceString . length ) , line . text ) ; <nl> else if ( how = = \" add \" ) indentation = curSpace + options . indentUnit ; <nl> else if ( how = = \" subtract \" ) indentation = curSpace - options . indentUnit ; <nl> indentation = Math . max ( 0 , indentation ) ; <nl>\n", "msg": "Allow indent methods to return CodeMirror . Pass to indicate no support\n", "score": 1}
{"diff_id": 39859, "repo": "photonstorm/phaser\n", "sha": "932737343b7cbca3494719f124d47595252400a7\n", "time": "2018-06-23T11:18:44Z\n", "diff": "mmm a / src / cameras / 2d / Camera . js <nl> ppp b / src / cameras / 2d / Camera . js <nl> var Camera = new Class ( { <nl> * / <nl> this . scene ; <nl> <nl> + / * * <nl> + * The Camera ID . Assigned by the Camera Manager and used to handle camera exclusion . <nl> + * <nl> + * @ name Phaser . Cameras . Scene2D . Camera # id <nl> + * @ type { integer } <nl> + * @ readOnly <nl> + * @ since 3 . 11 . 0 <nl> + * / <nl> + this . id = 0 ; <nl> + <nl> / * * <nl> * The name of the Camera . This is left empty for your own use . <nl> * <nl> var Camera = new Class ( { <nl> * @ since 3 . 0 . 0 <nl> * / <nl> this . _follow = null ; <nl> - <nl> - / * * <nl> - * Internal camera ID . Assigned by the Camera Manager and used in the camera pool . <nl> - * <nl> - * @ name Phaser . Cameras . Scene2D . Camera # _id <nl> - * @ type { integer } <nl> - * @ private <nl> - * @ default 0 <nl> - * @ since 3 . 0 . 0 <nl> - * / <nl> - this . _id = 0 ; <nl> } , <nl> <nl> / * * <nl> var Camera = new Class ( { <nl> * @ param { integer } y - The top - left y coordinate of the bounds . <nl> * @ param { integer } width - The width of the bounds , in pixels . <nl> * @ param { integer } height - The height of the bounds , in pixels . <nl> + * @ param { boolean } [ centerOn ] - If ` true ` the Camera will automatically be centered on the new bounds . <nl> * <nl> * @ return { Phaser . Cameras . Scene2D . Camera } This Camera instance . <nl> * / <nl> - setBounds : function ( x , y , width , height ) <nl> + setBounds : function ( x , y , width , height , centerOn ) <nl> { <nl> this . _bounds . setTo ( x , y , width , height ) ; <nl> <nl> this . useBounds = true ; <nl> <nl> + if ( centerOn ) <nl> + { <nl> + this . centerToBounds ( ) ; <nl> + } <nl> + <nl> return this ; <nl> } , <nl> <nl>\n", "msg": "Added centerOn argument to setBounds and bumped Camera id to be public\n", "score": 1}
{"diff_id": 40030, "repo": "sahat/hackathon-starter\n", "sha": "11e8385b77b247737dd0591df07751504e605695\n", "time": "2013-12-19T18:40:43Z\n", "diff": "mmm a / controllers / user . js <nl> ppp b / controllers / user . js <nl> exports . getAccount = function ( req , res ) { <nl> * / <nl> exports . postAccountProfileTab = function ( req , res ) { <nl> User . findById ( req . user . id , function ( err , user ) { <nl> + if ( err ) { <nl> + req . flash ( ' error ' , err . message ) ; <nl> + return res . redirect ( ' / account ' ) ; <nl> + } <nl> user . profile . name = req . body . name | | ' ' ; <nl> user . profile . email = req . body . email | | ' ' ; <nl> user . profile . gender = req . body . gender | | ' ' ; <nl> exports . postAccountProfileTab = function ( req , res ) { <nl> user . profile . website = req . body . website | | ' ' ; <nl> <nl> user . save ( function ( err ) { <nl> + if ( err ) { <nl> + req . flash ( ' error ' , err . message ) ; <nl> + return res . redirect ( ' / contact ' ) ; <nl> + } <nl> req . flash ( ' success ' , ' Profile information updated ' ) ; <nl> res . redirect ( ' / account ' ) ; <nl> } ) ; <nl> exports . postAccountSettingsTab = function ( req , res ) { <nl> } <nl> <nl> User . findById ( req . user . id , function ( err , user ) { <nl> + if ( err ) { <nl> + req . flash ( ' error ' , err . message ) ; <nl> + return res . redirect ( ' / account ' ) ; <nl> + } <nl> user . password = req . body . password ; <nl> user . save ( function ( err ) { <nl> + if ( err ) { <nl> + req . flash ( ' error ' , err . message ) ; <nl> + return res . redirect ( ' / account ' ) ; <nl> + } <nl> req . flash ( ' success ' , ' Password has been changed ' ) ; <nl> res . redirect ( ' / account ' ) ; <nl> } ) ; <nl>\n", "msg": "Error handlers for some routes on users controller\n", "score": 1}
{"diff_id": 40072, "repo": "meteor/meteor\n", "sha": "c711473a6995b247b5b12de365feda76a6efb941\n", "time": "2015-06-16T21:00:47Z\n", "diff": "mmm a / tools / isopack . js <nl> ppp b / tools / isopack . js <nl> _ . extend ( Isopack . prototype , { <nl> dir = files . realpath ( dir ) ; <nl> <nl> var mainJson = Isopack . readMetadataFromDirectory ( dir ) ; <nl> + if ( ! mainJson ) { <nl> + throw new Error ( \" No metadata files found for isopack at : \" + dir ) ; <nl> + } <nl> <nl> / / isopacks didn ' t used to know their name , but they should . <nl> if ( _ . has ( mainJson , ' name ' ) & & name ! = = mainJson . name ) { <nl>\n", "msg": "Throw a better error if no isopack metadata files\n", "score": 1}
{"diff_id": 40333, "repo": "gorhill/uBlock\n", "sha": "c33de41660de0b7c982a40f4bfde31f32180a2ee\n", "time": "2020-07-19T12:16:40Z\n", "diff": "mmm a / assets / resources / scriptlets . js <nl> ppp b / assets / resources / scriptlets . js <nl> <nl> / / / set - constant . js <nl> / / / alias set . js <nl> ( function ( ) { <nl> - const thisScript = document . currentScript ; <nl> + const chain = ' { { 1 } } ' ; <nl> let cValue = ' { { 2 } } ' ; <nl> + const thisScript = document . currentScript ; <nl> if ( cValue = = = ' undefined ' ) { <nl> cValue = undefined ; <nl> } else if ( cValue = = = ' false ' ) { <nl> <nl> ( typeof v ! = = typeof cValue ) ; <nl> return aborted ; <nl> } ; <nl> - const makeProxy = function ( owner , chain ) { <nl> + / / https : / / github . com / uBlockOrigin / uBlock - issues / issues / 156 <nl> + / / Support multiple trappers for the same property . <nl> + const trapProp = function ( owner , prop , handler ) { <nl> + if ( handler . init ( owner [ prop ] ) = = = false ) { return ; } <nl> + const odesc = Object . getOwnPropertyDescriptor ( owner , prop ) ; <nl> + let prevGetter , prevSetter ; <nl> + if ( odesc instanceof Object ) { <nl> + if ( odesc . get instanceof Function ) { <nl> + prevGetter = odesc . get ; <nl> + } <nl> + if ( odesc . set instanceof Function ) { <nl> + prevSetter = odesc . set ; <nl> + } <nl> + } <nl> + Object . defineProperty ( owner , prop , { <nl> + configurable : true , <nl> + get ( ) { <nl> + if ( prevGetter ! = = undefined ) { <nl> + prevGetter ( ) ; <nl> + } <nl> + return handler . getter ( ) ; <nl> + } , <nl> + set ( a ) { <nl> + if ( prevSetter ! = = undefined ) { <nl> + prevSetter ( a ) ; <nl> + } <nl> + handler . setter ( a ) ; <nl> + } <nl> + } ) ; <nl> + } ; <nl> + const trapChain = function ( owner , chain ) { <nl> const pos = chain . indexOf ( ' . ' ) ; <nl> if ( pos = = = - 1 ) { <nl> - const original = owner [ chain ] ; <nl> - if ( mustAbort ( original ) ) { return ; } <nl> - const desc = Object . getOwnPropertyDescriptor ( owner , chain ) ; <nl> - if ( desc = = = undefined | | desc . get = = = undefined ) { <nl> - Object . defineProperty ( owner , chain , { <nl> - get : function ( ) { <nl> - return document . currentScript = = = thisScript <nl> - ? original <nl> - : cValue ; <nl> - } , <nl> - set : function ( a ) { <nl> - if ( mustAbort ( a ) ) { <nl> - cValue = a ; <nl> - } <nl> - } <nl> - } ) ; <nl> - } <nl> + trapProp ( owner , chain , { <nl> + v : undefined , <nl> + init : function ( v ) { <nl> + if ( mustAbort ( v ) ) { return false ; } <nl> + this . v = v ; <nl> + return true ; <nl> + } , <nl> + getter : function ( ) { <nl> + return document . currentScript = = = thisScript <nl> + ? this . v <nl> + : cValue ; <nl> + } , <nl> + setter : function ( a ) { <nl> + if ( mustAbort ( a ) = = = false ) { return ; } <nl> + cValue = a ; <nl> + } <nl> + } ) ; <nl> return ; <nl> } <nl> const prop = chain . slice ( 0 , pos ) ; <nl> - let v = owner [ prop ] ; <nl> + const v = owner [ prop ] ; <nl> chain = chain . slice ( pos + 1 ) ; <nl> - if ( <nl> - ( v instanceof Object ) | | <nl> - ( typeof v = = = ' object ' & & v ! = = null ) <nl> - ) { <nl> - makeProxy ( v , chain ) ; <nl> + if ( v instanceof Object | | typeof v = = = ' object ' & & v ! = = null ) { <nl> + trapChain ( v , chain ) ; <nl> return ; <nl> } <nl> - const desc = Object . getOwnPropertyDescriptor ( owner , prop ) ; <nl> - if ( desc & & desc . set ! = = undefined ) { return ; } <nl> - Object . defineProperty ( owner , prop , { <nl> - get : function ( ) { <nl> - return v ; <nl> + trapProp ( owner , prop , { <nl> + v : undefined , <nl> + init : function ( v ) { <nl> + this . v = v ; <nl> + return true ; <nl> } , <nl> - set : function ( a ) { <nl> - v = a ; <nl> + getter : function ( ) { <nl> + return this . v ; <nl> + } , <nl> + setter : function ( a ) { <nl> + this . v = a ; <nl> if ( a instanceof Object ) { <nl> - makeProxy ( a , chain ) ; <nl> + trapChain ( a , chain ) ; <nl> } <nl> } <nl> } ) ; <nl> } ; <nl> - makeProxy ( window , ' { { 1 } } ' ) ; <nl> + trapChain ( window , chain ) ; <nl> } ) ( ) ; <nl> <nl> <nl>\n", "msg": "Support multiple trappers to same property in set - constant\n", "score": 1}
{"diff_id": 40547, "repo": "request/request\n", "sha": "2127aa3b4395f6b522f9530ac1f79d8343b7d05f\n", "time": "2015-06-22T17:24:41Z\n", "diff": "mmm a / request . js <nl> ppp b / request . js <nl> Request . prototype . init = function ( options ) { <nl> self . elapsedTime = self . elapsedTime | | 0 <nl> } <nl> <nl> - if ( self . body ) { <nl> - var length = 0 <nl> - if ( ! Buffer . isBuffer ( self . body ) ) { <nl> - if ( Array . isArray ( self . body ) ) { <nl> - for ( var i = 0 ; i < self . body . length ; i + + ) { <nl> - length + = self . body [ i ] . length <nl> - } <nl> - } else { <nl> - self . body = new Buffer ( self . body ) <nl> - length = self . body . length <nl> - } <nl> - } else { <nl> - length = self . body . length <nl> + function setContentLength ( ) { <nl> + if ( ! Buffer . isBuffer ( self . body ) & & ! Array . isArray ( self . body ) ) { <nl> + self . body = new Buffer ( self . body ) <nl> } <nl> - if ( length ) { <nl> - if ( ! self . hasHeader ( ' content - length ' ) ) { <nl> + if ( ! self . hasHeader ( ' content - length ' ) ) { <nl> + var length = ( Array . isArray ( self . body ) ) <nl> + ? self . body . reduce ( function ( a , b ) { return a + b . length } , 0 ) <nl> + : self . body . length <nl> + if ( length ) { <nl> self . setHeader ( ' content - length ' , length ) <nl> + } else { <nl> + self . emit ( ' error ' , new Error ( ' Argument error , options . body . ' ) ) <nl> } <nl> - } else { <nl> - self . emit ( ' error ' , new Error ( ' Argument error , options . body . ' ) ) <nl> } <nl> } <nl> + if ( self . body ) { <nl> + setContentLength ( ) <nl> + } <nl> <nl> if ( options . oauth ) { <nl> self . oauth ( options . oauth ) <nl> Request . prototype . init = function ( options ) { <nl> self . _multipart . body . pipe ( self ) <nl> } <nl> if ( self . body ) { <nl> + setContentLength ( ) <nl> if ( Array . isArray ( self . body ) ) { <nl> self . body . forEach ( function ( part ) { <nl> self . write ( part ) <nl>\n", "msg": "Add function for setting up the content - length\n", "score": 1}
{"diff_id": 40672, "repo": "request/request\n", "sha": "7946393893e75df24b390b7ab19eb5b9d6c23891\n", "time": "2011-02-11T23:32:37Z\n", "diff": "mmm a / main . js <nl> ppp b / main . js <nl> var Request = function ( options ) { <nl> this [ i ] = options [ i ] ; <nl> } <nl> if ( ! this . pool ) this . pool = globalPool ; <nl> + this . dests = [ ] ; <nl> } <nl> util . inherits ( Request , stream . Stream ) ; <nl> Request . prototype . getAgent = function ( host , port ) { <nl> Request . prototype . getAgent = function ( host , port ) { <nl> } <nl> return this . pool [ host + ' : ' + port ] ; <nl> } <nl> - <nl> - Request . prototype . pipe = function ( dest ) { <nl> - this . dest = dest ; <nl> - } <nl> Request . prototype . request = function ( ) { <nl> var options = this ; <nl> if ( options . url ) { <nl> Request . prototype . request = function ( ) { <nl> } <nl> <nl> options . req = options . httpModule . request ( options , function ( response ) { <nl> + options . response = response ; <nl> if ( setHost ) delete options . headers . host ; <nl> <nl> if ( response . statusCode > = 300 & & <nl> Request . prototype . request = function ( ) { <nl> options . _redirectsFollowed = 0 ; <nl> <nl> if ( options . encoding ) { <nl> - if ( options . dest ) { <nl> + if ( options . dests . length ! = = 0 ) { <nl> console . error ( \" Ingoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid . \" ) ; <nl> } else { <nl> response . setEncoding ( options . encoding ) ; <nl> } <nl> } <nl> - if ( options . dest ) { <nl> - response . pipe ( options . dest ) ; <nl> + if ( options . dests . length ! = = 0 ) { <nl> + options . dests . forEach ( function ( dest ) { <nl> + response . pipe ( dest ) ; <nl> + } ) <nl> if ( options . onResponse ) options . onResponse ( null , response ) ; <nl> if ( options . callback ) options . callback ( null , response , options . responseBodyStream ) ; <nl> } else { <nl> Request . prototype . request = function ( ) { <nl> <nl> options . req . on ( ' error ' , clientErrorHandler ) ; <nl> <nl> - this . once ( ' pipe ' , function ( src ) { <nl> + options . once ( ' pipe ' , function ( src ) { <nl> if ( options . ntick ) throw new Error ( \" You cannot pipe to this stream after the first nextTick ( ) after creation of the request stream . \" ) <nl> options . src = src ; <nl> + options . on ( ' pipe ' , function ( ) { <nl> + console . error ( \" You have already piped to this stream . Pipeing twice is likely to break the request . \" ) <nl> + } ) <nl> } ) <nl> <nl> process . nextTick ( function ( ) { <nl> Request . prototype . request = function ( ) { <nl> options . ntick = true ; <nl> } ) <nl> } <nl> - <nl> + Request . prototype . pipe = function ( dest ) { <nl> + if ( this . response ) throw new Error ( \" You cannot pipe after the response event . \" ) <nl> + this . dests . push ( dest ) ; <nl> + } <nl> Request . prototype . write = function ( ) { <nl> if ( ! this . req ) throw new Error ( \" This request has been piped before http . request ( ) was called . \" ) ; <nl> this . req . write . apply ( this . req , arguments ) ; <nl> Request . prototype . resume = function ( ) { <nl> this . req . resume . apply ( this . req , arguments ) ; <nl> } <nl> <nl> - <nl> - <nl> - <nl> function request ( options , callback ) { <nl> if ( callback ) options . callback = callback ; <nl> var r = new Request ( options ) ; <nl> function request ( options , callback ) { <nl> return r ; <nl> } <nl> <nl> - <nl> module . exports = request ; <nl> <nl> request . defaults = function ( options ) { <nl>\n", "msg": "Better errors and warnings for different pipe conditions .\n", "score": 1}
{"diff_id": 40717, "repo": "mozilla/pdf.js\n", "sha": "236871c68b1330be9a62ae1534f7a53d9efe2f0e\n", "time": "2018-10-03T08:47:07Z\n", "diff": "mmm a / web / pdf_find_controller . js <nl> ppp b / web / pdf_find_controller . js <nl> class PDFFindController { <nl> } <nl> <nl> executeCommand ( cmd , state ) { <nl> - if ( ! this . _pdfDocument ) { <nl> - return ; <nl> - } <nl> + const pdfDocument = this . _pdfDocument ; <nl> <nl> if ( this . _state = = = null | | cmd ! = = ' findagain ' ) { <nl> this . _dirtyMatch = true ; <nl> class PDFFindController { <nl> this . _updateUIState ( FindState . PENDING ) ; <nl> <nl> this . _firstPagePromise . then ( ( ) = > { <nl> + if ( ! this . _pdfDocument | | <nl> + ( pdfDocument & & this . _pdfDocument ! = = pdfDocument ) ) { <nl> + / / If the document was closed before searching began , or if the search <nl> + / / operation was relevant for a previously opened document , do nothing . <nl> + return ; <nl> + } <nl> this . _extractText ( ) ; <nl> <nl> - clearTimeout ( this . _findTimeout ) ; <nl> + if ( this . _findTimeout ) { <nl> + clearTimeout ( this . _findTimeout ) ; <nl> + this . _findTimeout = null ; <nl> + } <nl> if ( cmd = = = ' find ' ) { <nl> / / Trigger the find action with a small delay to avoid starting the <nl> / / search when the user is still typing ( saving resources ) . <nl> - this . _findTimeout = <nl> - setTimeout ( this . _nextMatch . bind ( this ) , FIND_TIMEOUT ) ; <nl> + this . _findTimeout = setTimeout ( ( ) = > { <nl> + this . _nextMatch ( ) ; <nl> + this . _findTimeout = null ; <nl> + } , FIND_TIMEOUT ) ; <nl> } else { <nl> this . _nextMatch ( ) ; <nl> } <nl> class PDFFindController { <nl> this . _pendingFindMatches = Object . create ( null ) ; <nl> this . _resumePageIdx = null ; <nl> this . _dirtyMatch = false ; <nl> + clearTimeout ( this . _findTimeout ) ; <nl> this . _findTimeout = null ; <nl> <nl> this . _firstPagePromise = new Promise ( ( resolve ) = > { <nl> - const eventBus = this . _eventBus ; <nl> - eventBus . on ( ' pagesinit ' , function onPagesInit ( ) { <nl> - eventBus . off ( ' pagesinit ' , onPagesInit ) ; <nl> + const onPagesInit = ( ) = > { <nl> + if ( ! this . _pdfDocument ) { <nl> + throw new Error ( <nl> + ' PDFFindController : ` setDocument ( ) ` should have been called . ' ) ; <nl> + } <nl> + this . _eventBus . off ( ' pagesinit ' , onPagesInit ) ; <nl> resolve ( ) ; <nl> - } ) ; <nl> + } ; <nl> + this . _eventBus . on ( ' pagesinit ' , onPagesInit ) ; <nl> } ) ; <nl> } <nl> <nl>\n", "msg": "[ Regression ] Restore the ability to start searching before a document has loaded , and ignore searches for previously opened documents ( PR 10099 follow - up )\n", "score": 1}
{"diff_id": 40928, "repo": "jashkenas/backbone\n", "sha": "478aaf3d000ff8d4b7f9d6c78d657f4e9904df65\n", "time": "2012-01-09T18:49:32Z\n", "diff": "mmm a / backbone . js <nl> ppp b / backbone . js <nl> <nl> this . cid = _ . uniqueId ( ' view ' ) ; <nl> this . _configure ( options | | { } ) ; <nl> this . _ensureElement ( ) ; <nl> - this . delegateEvents ( ) ; <nl> this . initialize . apply ( this , arguments ) ; <nl> + this . delegateEvents ( ) ; <nl> } ; <nl> <nl> / / Cached regex to split keys for ` delegate ` . <nl>\n", "msg": "Switched order of delegateEvents and initialize in Backbone . View constructor in order to allow for explicit setting of this . el in initialize ( and ensure that events are bound correctly ) .\n", "score": 1}
{"diff_id": 41772, "repo": "request/request\n", "sha": "9dc27e247698c46ff69277cd2a6a49627e9daac9\n", "time": "2014-08-29T04:40:17Z\n", "diff": "mmm a / index . js <nl> ppp b / index . js <nl> <nl> <nl> var cookies = require ( ' . / lib / cookies ' ) <nl> , copy = require ( ' . / lib / copy ' ) <nl> - , Request = require ( ' . / request ' ) <nl> , util = require ( ' util ' ) <nl> ; <nl> <nl> function request ( uri , options , callback ) { <nl> } <nl> <nl> if ( callback ) opts . callback = callback <nl> - var r = new Request ( opts ) <nl> + var r = new request . Request ( opts ) <nl> return r <nl> } <nl> <nl> module . exports = request <nl> <nl> - request . Request = Request ; <nl> + request . debug = process . env . NODE_DEBUG & & / \\ brequest \\ b / . test ( process . env . NODE_DEBUG ) <nl> <nl> - request . debug = process . env . NODE_DEBUG & & / request / . test ( process . env . NODE_DEBUG ) <nl> + request . Request = require ( ' . / request ' ) <nl> <nl> request . initParams = initParams <nl> <nl>\n", "msg": "Rearrange requires to prepare for fixing debug code\n", "score": 1}
{"diff_id": 41865, "repo": "adobe/brackets\n", "sha": "ab42b2d52069eb3e9731e03db853d0003d3a493e\n", "time": "2017-09-07T03:54:37Z\n", "diff": "mmm a / src / document / DocumentCommandHandlers . js <nl> ppp b / src / document / DocumentCommandHandlers . js <nl> define ( function ( require , exports , module ) { <nl> } <nl> } ; <nl> var encoding = PreferencesManager . getViewState ( \" encoding \" , context ) ; <nl> - if ( encoding [ fullPath ] ) { <nl> + if ( encoding & & encoding [ fullPath ] ) { <nl> file . _encoding = encoding [ fullPath ] ; <nl> } <nl> } <nl>\n", "msg": "Adding null check for encoding preference ( )\n", "score": 1}
{"diff_id": 41874, "repo": "vuejs/vuex\n", "sha": "7afede5d06fe733a6a6ea15751a826b6c275c6e0\n", "time": "2015-11-30T02:26:45Z\n", "diff": "mmm a / src / index . js <nl> ppp b / src / index . js <nl> export default class Vuex { <nl> return this . _vm . _data <nl> } <nl> <nl> + set state ( v ) { <nl> + throw new Error ( ' [ vuex ] Vuex root state is read only . ' ) <nl> + } <nl> + <nl> / * * <nl> * Dispatch an action . <nl> * <nl>\n", "msg": "throw error when user tries to replace root state\n", "score": 1}
{"diff_id": 42466, "repo": "twbs/bootstrap\n", "sha": "e5fb1da164171a62612df8bded8ed3b2af8fed56\n", "time": "2011-11-21T05:59:31Z\n", "diff": "mmm a / js / bootstrap - buttons . js <nl> ppp b / js / bootstrap - buttons . js <nl> <nl> <nl> $ el . html ( data [ state ] | | $ . fn . button . defaults [ state ] ) <nl> <nl> - state = = ' loadingText ' ? <nl> - $ el . addClass ( d ) . attr ( d , d ) : <nl> - $ el . removeClass ( d ) . removeAttr ( d ) <nl> + setTimeout ( function ( ) { <nl> + state = = ' loadingText ' ? <nl> + $ el . addClass ( d ) . attr ( d , d ) : <nl> + $ el . removeClass ( d ) . removeAttr ( d ) <nl> + } , 0 ) <nl> } <nl> <nl> function toggle ( el ) { <nl>\n", "msg": "push disable setting to the event loop - this allows for form submit to begin\n", "score": 1}
{"diff_id": 42771, "repo": "adobe/brackets\n", "sha": "0653d0163870819ff3f542278543aae52dc6ac99\n", "time": "2014-11-20T05:28:49Z\n", "diff": "mmm a / src / utils / PerfUtils . js <nl> ppp b / src / utils / PerfUtils . js <nl> define ( function ( require , exports , module ) { <nl> * explicit conversion . <nl> * / <nl> PerfMeasurement . prototype . toString = function ( ) { <nl> - return this . id ; <nl> + return this . name ; <nl> } ; <nl> <nl> / * * <nl> define ( function ( require , exports , module ) { <nl> <nl> / * * <nl> * @ private <nl> - * Generates unique identifier for the measurements . <nl> + * Generates PerfMeasurements based on the name or array of names . <nl> * / <nl> - function generateId ( name ) { <nl> + function _generatePerfMeasurements ( name ) { <nl> / / always convert it to array so that the rest of the routines could rely on it <nl> var id = ( ! Array . isArray ( name ) ) ? [ name ] : name ; <nl> / / generate unique identifiers for each name <nl> define ( function ( require , exports , module ) { <nl> * @ param { number } time Timer start time . <nl> * / <nl> function _markStart ( id , time ) { <nl> - if ( activeTests [ id ] ) { <nl> - console . error ( \" Recursive tests with the same name are not supported . Timer name : \" + id . name ) ; <nl> + if ( activeTests [ id . id ] ) { <nl> + console . error ( \" Recursive tests with the same id are not supported . Timer id : \" + id . id ) ; <nl> } <nl> <nl> - activeTests [ id ] = { startTime : time } ; <nl> + activeTests [ id . id ] = { startTime : time } ; <nl> } <nl> <nl> / * * <nl> define ( function ( require , exports , module ) { <nl> } <nl> <nl> var time = brackets . app . getElapsedMilliseconds ( ) ; <nl> - var id = generateId ( name ) ; <nl> + var id = _generatePerfMeasurements ( name ) ; <nl> var i ; <nl> <nl> for ( i = 0 ; i < id . length ; i + + ) { <nl> define ( function ( require , exports , module ) { <nl> <nl> var elapsedTime = brackets . app . getElapsedMilliseconds ( ) ; <nl> <nl> - if ( activeTests [ id ] ) { <nl> - elapsedTime - = activeTests [ id ] . startTime ; <nl> - delete activeTests [ id ] ; <nl> + if ( activeTests [ id . id ] ) { <nl> + elapsedTime - = activeTests [ id . id ] . startTime ; <nl> + delete activeTests [ id . id ] ; <nl> } <nl> <nl> - if ( perfData [ id . name ] ) { <nl> + if ( perfData [ id ] ) { <nl> / / We have existing data , add to it <nl> - if ( Array . isArray ( perfData [ id . name ] ) ) { <nl> - perfData [ id . name ] . push ( elapsedTime ) ; <nl> + if ( Array . isArray ( perfData [ id ] ) ) { <nl> + perfData [ id ] . push ( elapsedTime ) ; <nl> } else { <nl> / / Current data is a number , convert to Array <nl> - perfData [ id . name ] = [ perfData [ id . name ] , elapsedTime ] ; <nl> + perfData [ id ] = [ perfData [ id ] , elapsedTime ] ; <nl> } <nl> } else { <nl> - perfData [ id . name ] = elapsedTime ; <nl> + perfData [ id ] = elapsedTime ; <nl> } <nl> <nl> if ( id . reent ! = = undefined ) { <nl> - if ( testSequenceIds [ id . name ] = = = 0 ) { <nl> - delete testSequenceIds [ id . name ] ; <nl> + if ( testSequenceIds [ id ] = = = 0 ) { <nl> + delete testSequenceIds [ id ] ; <nl> } else { <nl> - testSequenceIds [ id . name ] - - ; <nl> + testSequenceIds [ id ] - - ; <nl> } <nl> } <nl> <nl> define ( function ( require , exports , module ) { <nl> function updateMeasurement ( id ) { <nl> var elapsedTime = brackets . app . getElapsedMilliseconds ( ) ; <nl> <nl> - if ( updatableTests [ id ] ) { <nl> + if ( updatableTests [ id . id ] ) { <nl> / / update existing measurement <nl> elapsedTime - = updatableTests [ id ] . startTime ; <nl> <nl> / / update <nl> - if ( perfData [ id . name ] & & Array . isArray ( perfData [ id . name ] ) ) { <nl> + if ( perfData [ id ] & & Array . isArray ( perfData [ id ] ) ) { <nl> / / We have existing data and it ' s an array , so update the last entry <nl> - perfData [ id . name ] [ perfData [ id . name ] . length - 1 ] = elapsedTime ; <nl> + perfData [ id ] [ perfData [ id ] . length - 1 ] = elapsedTime ; <nl> } else { <nl> / / No current data or a single entry , so set / update it <nl> - perfData [ id . name ] = elapsedTime ; <nl> + perfData [ id ] = elapsedTime ; <nl> } <nl> <nl> } else { <nl> / / not yet in updatable list <nl> <nl> - if ( activeTests [ id ] ) { <nl> + if ( activeTests [ id . id ] ) { <nl> / / save startTime in updatable list before addMeasurement ( ) deletes it <nl> - updatableTests [ id ] = { startTime : activeTests [ id ] . startTime } ; <nl> + updatableTests [ id . id ] = { startTime : activeTests [ id . id ] . startTime } ; <nl> } <nl> <nl> / / let addMeasurement ( ) handle the initial case <nl> define ( function ( require , exports , module ) { <nl> * @ param { Object } id Timer id . <nl> * / <nl> function finalizeMeasurement ( id ) { <nl> - if ( activeTests [ id ] ) { <nl> - delete activeTests [ id ] ; <nl> + if ( activeTests [ id . id ] ) { <nl> + delete activeTests [ id . id ] ; <nl> } <nl> <nl> - if ( updatableTests [ id ] ) { <nl> - delete updatableTests [ id ] ; <nl> + if ( updatableTests [ id . id ] ) { <nl> + delete updatableTests [ id . id ] ; <nl> } <nl> } <nl> <nl> define ( function ( require , exports , module ) { <nl> * @ return { boolean } Whether a timer is active or not . <nl> * / <nl> function isActive ( id ) { <nl> - return ( activeTests [ id ] ) ? true : false ; <nl> + return ( activeTests [ id . id ] ) ? true : false ; <nl> } <nl> <nl> / * * <nl> define ( function ( require , exports , module ) { <nl> return perfData ; <nl> } <nl> <nl> - return perfData [ id . name ] ; <nl> + return perfData [ id ] ; <nl> } <nl> <nl> function searchData ( regExp ) { <nl>\n", "msg": "Use this . name for toString ( ) instead of this . id .\n", "score": 1}
{"diff_id": 42816, "repo": "vercel/next.js\n", "sha": "2ff0913864790a456a38445b9ccfe4af1bbfd7c1\n", "time": "2020-02-11T17:33:27Z\n", "diff": "mmm a / packages / create - next - app / templates / default / pages / index . js <nl> ppp b / packages / create - next - app / templates / default / pages / index . js <nl> const Home = ( ) = > ( <nl> < / a > <nl> <nl> < a <nl> - href = \" https : / / zeit . co / new ? utm_source = create - next - app & utm_medium = default - template & utm_campaign = create - next - app \" <nl> + href = \" https : / / zeit . co / new ? filter = next . js & utm_source = create - next - app & utm_medium = default - template & utm_campaign = create - next - app \" <nl> className = \" card \" <nl> > <nl> < h3 > Deploy & rarr ; < / h3 > <nl>\n", "msg": "Use filter for create - next - app template ( )\n", "score": 1}
{"diff_id": 43031, "repo": "nuxt/nuxt.js\n", "sha": "29110694fb4692389bbfb5b35a0232468c51c8a9\n", "time": "2018-01-13T05:29:47Z\n", "diff": "mmm a / lib / common / utils . js <nl> ppp b / lib / common / utils . js <nl> exports . pe = new PrettyError ( ) <nl> exports . printWarn = function ( msg , from ) { <nl> / * eslint - disable no - console * / <nl> const fromStr = from ? Chalk . yellow ( ` $ { from } \\ n \\ n ` ) : ' ' <nl> - console . error ( ' \\ n ' + Chalk . bgYellow . black ( ' WARN ' ) + fromStr + msg + ' \\ n ' ) <nl> + console . warn ( ' \\ n ' + Chalk . bgYellow . black ( ' WARN ' ) + fromStr + msg + ' \\ n ' ) <nl> } <nl> <nl> exports . renderError = function ( _error , from ) { <nl>\n", "msg": "use console . warn for warnings\n", "score": 1}
{"diff_id": 43045, "repo": "transloadit/uppy\n", "sha": "9baca15db38eec81ef5547f6e5f1ceb9b3dfc432\n", "time": "2019-05-17T13:41:40Z\n", "diff": "mmm a / packages / @ uppy / companion - client / src / RequestClient . js <nl> ppp b / packages / @ uppy / companion - client / src / RequestClient . js <nl> module . exports = class RequestClient { <nl> get defaultHeaders ( ) { <nl> return { <nl> ' Accept ' : ' application / json ' , <nl> - ' Content - Type ' : ' application / json ' , <nl> - / / @ todo remove this hardcoded version <nl> - ' uppy - client ' : ' companion - client : 1 . 0 . 2 ' <nl> + ' Content - Type ' : ' application / json ' <nl> } <nl> } <nl> <nl>\n", "msg": "companion - client : remove version header to avoid block headers against\n", "score": 1}
{"diff_id": 43146, "repo": "balderdashy/sails\n", "sha": "0d39ae726ee91d851958ebde05577d97d244aaf4\n", "time": "2013-10-30T00:33:31Z\n", "diff": "mmm a / bin / boilerplates / Gruntfile . js <nl> ppp b / bin / boilerplates / Gruntfile . js <nl> module . exports = function ( grunt ) { <nl> startTag : ' < ! - - SCRIPTS - - > ' , <nl> endTag : ' < ! - - SCRIPTS END - - > ' , <nl> fileTmpl : ' < script src = \" % s \" > < / script > ' , <nl> - appRoot : ' . tmp / public ' <nl> + appRoot : ' . tmp / public ' , <nl> + relative : true <nl> } , <nl> files : { <nl> ' . tmp / public / * * / * . html ' : jsFilesToInject , <nl> module . exports = function ( grunt ) { <nl> startTag : ' < ! - - SCRIPTS - - > ' , <nl> endTag : ' < ! - - SCRIPTS END - - > ' , <nl> fileTmpl : ' < script src = \" % s \" > < / script > ' , <nl> - appRoot : ' . tmp / public ' <nl> + appRoot : ' . tmp / public ' , <nl> + relative : true <nl> } , <nl> files : { <nl> ' . tmp / public / * * / * . html ' : [ ' . tmp / public / min / production . js ' ] , <nl> module . exports = function ( grunt ) { <nl> startTag : ' < ! - - STYLES - - > ' , <nl> endTag : ' < ! - - STYLES END - - > ' , <nl> fileTmpl : ' < link rel = \" stylesheet \" href = \" % s \" > ' , <nl> - appRoot : ' . tmp / public ' <nl> + appRoot : ' . tmp / public ' , <nl> + relative : true <nl> } , <nl> <nl> / / cssFilesToInject defined up top <nl> module . exports = function ( grunt ) { <nl> startTag : ' < ! - - STYLES - - > ' , <nl> endTag : ' < ! - - STYLES END - - > ' , <nl> fileTmpl : ' < link rel = \" stylesheet \" href = \" % s \" > ' , <nl> - appRoot : ' . tmp / public ' <nl> + appRoot : ' . tmp / public ' , <nl> + relative : true <nl> } , <nl> files : { <nl> ' . tmp / public / index . html ' : [ ' . tmp / public / min / production . css ' ] , <nl> module . exports = function ( grunt ) { <nl> startTag : ' < ! - - TEMPLATES - - > ' , <nl> endTag : ' < ! - - TEMPLATES END - - > ' , <nl> fileTmpl : ' < script type = \" text / javascript \" src = \" % s \" > < / script > ' , <nl> - appRoot : ' . tmp / public ' <nl> + appRoot : ' . tmp / public ' , <nl> + relative : true <nl> } , <nl> files : { <nl> ' . tmp / public / index . html ' : [ ' . tmp / public / jst . js ' ] , <nl> module . exports = function ( grunt ) { <nl> startTag : ' / / SCRIPTS ' , <nl> endTag : ' / / SCRIPTS END ' , <nl> fileTmpl : ' script ( type = \" text / javascript \" , src = \" % s \" ) ' , <nl> - appRoot : ' . tmp / public ' <nl> + appRoot : ' . tmp / public ' , <nl> + relative : true <nl> } , <nl> files : { <nl> ' views / * * / * . jade ' : jsFilesToInject <nl> module . exports = function ( grunt ) { <nl> startTag : ' / / SCRIPTS ' , <nl> endTag : ' / / SCRIPTS END ' , <nl> fileTmpl : ' script ( type = \" text / javascript \" , src = \" % s \" ) ' , <nl> - appRoot : ' . tmp / public ' <nl> + appRoot : ' . tmp / public ' , <nl> + relative : true <nl> } , <nl> files : { <nl> ' views / * * / * . jade ' : [ ' . tmp / public / min / production . js ' ] <nl> module . exports = function ( grunt ) { <nl> startTag : ' / / STYLES ' , <nl> endTag : ' / / STYLES END ' , <nl> fileTmpl : ' link ( rel = \" stylesheet \" , href = \" % s \" ) ' , <nl> - appRoot : ' . tmp / public ' <nl> + appRoot : ' . tmp / public ' , <nl> + relative : true <nl> } , <nl> files : { <nl> ' views / * * / * . jade ' : cssFilesToInject <nl> module . exports = function ( grunt ) { <nl> startTag : ' / / STYLES ' , <nl> endTag : ' / / STYLES END ' , <nl> fileTmpl : ' link ( rel = \" stylesheet \" , href = \" % s \" ) ' , <nl> - appRoot : ' . tmp / public ' <nl> + appRoot : ' . tmp / public ' , <nl> + relative : true <nl> } , <nl> files : { <nl> ' views / * * / * . jade ' : [ ' . tmp / public / min / production . css ' ] <nl> module . exports = function ( grunt ) { <nl> startTag : ' / / TEMPLATES ' , <nl> endTag : ' / / TEMPLATES END ' , <nl> fileTmpl : ' script ( type = \" text / javascript \" , src = \" % s \" ) ' , <nl> - appRoot : ' . tmp / public ' <nl> + appRoot : ' . tmp / public ' , <nl> + relative : true <nl> } , <nl> files : { <nl> ' views / * * / * . jade ' : [ ' . tmp / public / jst . js ' ] <nl>\n", "msg": "set linker option to make relative paths instread of absolute paths\n", "score": 1}
{"diff_id": 43317, "repo": "RocketChat/Rocket.Chat\n", "sha": "b6b8b9e44a25a976aa8484ad061c0acd8bf83abf\n", "time": "2018-04-10T23:16:19Z\n", "diff": "mmm a / packages / rocketchat - api / server / api . js <nl> ppp b / packages / rocketchat - api / server / api . js <nl> class API extends Restivus { <nl> roles : 0 , <nl> statusDefault : 0 , <nl> _updatedAt : 0 , <nl> - customFields : 0 <nl> + customFields : 0 , <nl> + settings : 0 <nl> } ; <nl> <nl> this . _config . defaultOptionsEndpoint = function _defaultOptionsEndpoint ( ) { <nl>\n", "msg": "Don ' t expose the ' settings ' property on users to regular users via the rest api ( )\n", "score": 1}
{"diff_id": 43655, "repo": "RocketChat/Rocket.Chat\n", "sha": "2620419964547b4eff05c49ce8edb743b616d8a4\n", "time": "2016-03-21T20:19:50Z\n", "diff": "mmm a / packages / rocketchat - iframe - login / iframe_client . js <nl> ppp b / packages / rocketchat - iframe - login / iframe_client . js <nl> class IframeLogin { <nl> } <nl> } ; <nl> <nl> + let iframeUrl = this . iframeUrl ; <nl> + let separator = ' ? ' ; <nl> + if ( iframeUrl . indexOf ( ' ? ' ) > - 1 ) { <nl> + separator = ' & ' ; <nl> + } <nl> + <nl> + if ( window . cordova ) { <nl> + iframeUrl + = separator + ' client = cordova ' ; <nl> + } else if ( navigator . userAgent . indexOf ( ' Electron ' ) > - 1 ) { <nl> + iframeUrl + = separator + ' client = electron ' ; <nl> + } <nl> + <nl> HTTP . call ( this . apiMethod , this . apiUrl , options , ( error , result ) = > { <nl> console . log ( error , result ) ; <nl> if ( result & & result . data & & result . data . token ) { <nl> class IframeLogin { <nl> result . data . token = ' yaMadZ1RMBdMzs6kGycKybrHVptoDl7nokxtorz1me0 ' ; <nl> this . loginWithToken ( result . data . token , ( error , result ) = > { <nl> if ( error ) { <nl> - this . reactiveIframeUrl . set ( this . iframeUrl ) ; <nl> + this . reactiveIframeUrl . set ( iframeUrl ) ; <nl> } else { <nl> this . reactiveIframeUrl . set ( ) ; <nl> } <nl> callback ( error , result ) ; <nl> } ) ; <nl> } else { <nl> - this . reactiveIframeUrl . set ( this . iframeUrl ) ; <nl> + this . reactiveIframeUrl . set ( iframeUrl ) ; <nl> callback ( error , result ) ; <nl> } <nl> } ) ; <nl>\n", "msg": "Pass the client for iframe login ( cordova or electron )\n", "score": 1}
{"diff_id": 44015, "repo": "balderdashy/sails\n", "sha": "38b619a09c766d04e78be6e5d28687d6f257a3e1\n", "time": "2014-03-31T14:53:35Z\n", "diff": "mmm a / lib / hooks / views / res . view . js <nl> ppp b / lib / hooks / views / res . view . js <nl> module . exports = function _addResViewMethod ( req , res , next ) { <nl> <nl> / / Merge with config views locals <nl> if ( sails . config . views . locals ) { <nl> - _ . defaults ( locals , sails . config . views . locals ) ; <nl> + _ . merge ( locals , sails . config . views . locals , _ . defaults ) ; <nl> } <nl> <nl> / / If the path was specified , but invalid <nl>\n", "msg": "Merging locals in a more predictable way\n", "score": 1}
{"diff_id": 44057, "repo": "facebook/react-native\n", "sha": "ee8b50c955c15d8f5e663c9e14a1cf802143502c\n", "time": "2015-08-01T05:31:45Z\n", "diff": "mmm a / Libraries / Network / XMLHttpRequest . ios . js <nl> ppp b / Libraries / Network / XMLHttpRequest . ios . js <nl> class XMLHttpRequest extends XMLHttpRequestBase { <nl> } <nl> <nl> sendImpl ( method : ? string , url : ? string , headers : Object , data : any ) : void { <nl> - var body ; <nl> if ( typeof data = = = ' string ' ) { <nl> - body = { string : data } ; <nl> - } else if ( data instanceof FormData ) { <nl> - body = { formData : data . getParts ( ) } ; <nl> - } else { <nl> - body = data ; <nl> + data = { string : data } ; <nl> + } <nl> + if ( data instanceof FormData ) { <nl> + data = { formData : data . getParts ( ) } ; <nl> } <nl> RCTNetworking . sendRequest ( <nl> { <nl> method , <nl> url , <nl> - body , <nl> + data , <nl> headers , <nl> incrementalUpdates : this . onreadystatechange ? true : false , <nl> } , <nl>\n", "msg": "[ ReactNative ] fix up XMLHttpRequest failures\n", "score": 1}
{"diff_id": 44072, "repo": "photonstorm/phaser\n", "sha": "1c1e75ac85c986dd51ab8738012af5a4b2e8fdfd\n", "time": "2017-11-27T16:35:09Z\n", "diff": "mmm a / v3 / src / sound / BaseSoundManager . js <nl> ppp b / v3 / src / sound / BaseSoundManager . js <nl> var BaseSoundManager = new Class ( { <nl> } , <nl> destroy : NOOP <nl> } ) ; <nl> + / * * <nl> + * Global playback rate . <nl> + * @ property { number } rate <nl> + * / <nl> + Object . defineProperty ( BaseSoundManager . prototype , ' rate ' , { <nl> + get : function ( ) { <nl> + return this . _rate ; <nl> + } , <nl> + set : function ( value ) { <nl> + this . _rate = value ; <nl> + this . sounds . forEach ( function ( sound ) { <nl> + sound . setRate ( ) ; <nl> + } , this ) ; <nl> + } <nl> + } ) ; <nl> module . exports = BaseSoundManager ; <nl>\n", "msg": "Defining rate property in BaseSound class so it can be used in both Web Audio and HTML5 Audio implementations\n", "score": 1}
{"diff_id": 44101, "repo": "meteor/meteor\n", "sha": "06fe111bb68698fa10363026c1641977ec0460af\n", "time": "2012-03-06T23:59:50Z\n", "diff": "mmm a / app / lib / files . js <nl> ppp b / app / lib / files . js <nl> var files = module . exports = { <nl> } <nl> } <nl> } ) ; <nl> + } , <nl> + <nl> + / / Make a temporary directory . Returns the path to the newly created <nl> + / / directory . Caller is responsible for deleting the directory later . <nl> + mkdtemp : function ( prefix ) { <nl> + prefix = prefix | | ' meteor - temp - ' ; <nl> + / / find / tmp <nl> + var tmp_dir = _ . first ( _ . map ( [ ' TMPDIR ' , ' TMP ' , ' TEMP ' ] , function ( t ) { <nl> + return process . env [ t ] ; <nl> + } ) . filter ( _ . identity ) ) | | ' / tmp ' ; <nl> + tmp_dir = fs . realpathSync ( tmp_dir ) ; <nl> + <nl> + / / make the directory . give it 3 tries in case of collisions from <nl> + / / crappy random . <nl> + var tries = 3 ; <nl> + while ( tries > 0 ) { <nl> + var dir_path = path . join ( <nl> + tmp_dir , prefix + ( Math . random ( ) * 0x100000000 + 1 ) . toString ( 36 ) ) ; <nl> + try { <nl> + fs . mkdirSync ( dir_path , 0755 ) ; <nl> + return dir_path ; <nl> + } catch ( err ) { <nl> + tries - - ; <nl> + } <nl> + } <nl> + throw new Error ( \" failed to make tempory directory in \" + tmp_dir ) ; <nl> } <nl> <nl> } ; <nl>\n", "msg": "Add a function to make a temporary directory we can write to .\n", "score": 1}
{"diff_id": 44193, "repo": "facebook/react-native\n", "sha": "abeae870d40f5fa6a6c5b4003f2e3189448d4def\n", "time": "2020-10-16T05:53:55Z\n", "diff": "mmm a / packages / react - native - codegen / src / generators / components / __test_fixtures__ / fixtures . js <nl> ppp b / packages / react - native - codegen / src / generators / components / __test_fixtures__ / fixtures . js <nl> import type { SchemaType } from ' . . / . . / . . / CodegenSchema . js ' ; <nl> const NO_PROPS_NO_EVENTS : SchemaType = { <nl> modules : { <nl> NoPropsNoEvents : { <nl> + type : ' Component ' , <nl> components : { <nl> NoPropsNoEventsComponent : { <nl> extendsProps : [ <nl> const NO_PROPS_NO_EVENTS : SchemaType = { <nl> const INTERFACE_ONLY : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> InterfaceOnlyComponent : { <nl> interfaceOnly : true , <nl> const INTERFACE_ONLY : SchemaType = { <nl> const EVENTS_WITH_PAPER_NAME : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> InterfaceOnlyComponent : { <nl> interfaceOnly : true , <nl> const EVENTS_WITH_PAPER_NAME : SchemaType = { <nl> const BOOLEAN_PROP : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> BooleanPropNativeComponent : { <nl> extendsProps : [ <nl> const BOOLEAN_PROP : SchemaType = { <nl> const STRING_PROP : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> StringPropComponent : { <nl> extendsProps : [ <nl> const STRING_PROP : SchemaType = { <nl> const INTEGER_PROPS : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> IntegerPropNativeComponent : { <nl> extendsProps : [ <nl> const INTEGER_PROPS : SchemaType = { <nl> const FLOAT_PROPS : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> FloatPropNativeComponent : { <nl> extendsProps : [ <nl> const FLOAT_PROPS : SchemaType = { <nl> const DOUBLE_PROPS : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> DoublePropNativeComponent : { <nl> extendsProps : [ <nl> const DOUBLE_PROPS : SchemaType = { <nl> const COLOR_PROP : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> ColorPropNativeComponent : { <nl> extendsProps : [ <nl> const COLOR_PROP : SchemaType = { <nl> const IMAGE_PROP : SchemaType = { <nl> modules : { <nl> Slider : { <nl> + type : ' Component ' , <nl> components : { <nl> ImagePropNativeComponent : { <nl> extendsProps : [ <nl> const IMAGE_PROP : SchemaType = { <nl> const POINT_PROP : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> PointPropNativeComponent : { <nl> extendsProps : [ <nl> const POINT_PROP : SchemaType = { <nl> const INSETS_PROP : SchemaType = { <nl> modules : { <nl> ScrollView : { <nl> + type : ' Component ' , <nl> components : { <nl> InsetsPropNativeComponent : { <nl> extendsProps : [ <nl> const INSETS_PROP : SchemaType = { <nl> const ARRAY_PROPS : SchemaType = { <nl> modules : { <nl> Slider : { <nl> + type : ' Component ' , <nl> components : { <nl> ArrayPropsNativeComponent : { <nl> extendsProps : [ <nl> const ARRAY_PROPS : SchemaType = { <nl> const ARRAY_PROPS_WITH_NESTED_OBJECT : SchemaType = { <nl> modules : { <nl> Slider : { <nl> + type : ' Component ' , <nl> components : { <nl> ArrayPropsNativeComponent : { <nl> extendsProps : [ <nl> const ARRAY_PROPS_WITH_NESTED_OBJECT : SchemaType = { <nl> const OBJECT_PROPS : SchemaType = { <nl> modules : { <nl> ObjectPropsNativeComponent : { <nl> + type : ' Component ' , <nl> components : { <nl> ObjectProps : { <nl> extendsProps : [ <nl> const OBJECT_PROPS : SchemaType = { <nl> const MULTI_NATIVE_PROP : SchemaType = { <nl> modules : { <nl> Slider : { <nl> + type : ' Component ' , <nl> components : { <nl> ImageColorPropNativeComponent : { <nl> extendsProps : [ <nl> const MULTI_NATIVE_PROP : SchemaType = { <nl> const STRING_ENUM_PROP : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> StringEnumPropsNativeComponent : { <nl> extendsProps : [ <nl> const STRING_ENUM_PROP : SchemaType = { <nl> const INT32_ENUM_PROP : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> Int32EnumPropsNativeComponent : { <nl> extendsProps : [ <nl> const INT32_ENUM_PROP : SchemaType = { <nl> const EVENT_PROPS : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> EventsNativeComponent : { <nl> extendsProps : [ <nl> const EVENT_PROPS : SchemaType = { <nl> const EVENT_NESTED_OBJECT_PROPS : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> EventsNestedObjectNativeComponent : { <nl> extendsProps : [ <nl> const EVENT_NESTED_OBJECT_PROPS : SchemaType = { <nl> const TWO_COMPONENTS_SAME_FILE : SchemaType = { <nl> modules : { <nl> MyComponents : { <nl> + type : ' Component ' , <nl> components : { <nl> MultiComponent1NativeComponent : { <nl> extendsProps : [ <nl> const TWO_COMPONENTS_SAME_FILE : SchemaType = { <nl> const TWO_COMPONENTS_DIFFERENT_FILES : SchemaType = { <nl> modules : { <nl> ComponentFile1 : { <nl> + type : ' Component ' , <nl> components : { <nl> MultiFile1NativeComponent : { <nl> extendsProps : [ <nl> const TWO_COMPONENTS_DIFFERENT_FILES : SchemaType = { <nl> } , <nl> <nl> ComponentFile2 : { <nl> + type : ' Component ' , <nl> components : { <nl> MultiFile2NativeComponent : { <nl> extendsProps : [ <nl> const TWO_COMPONENTS_DIFFERENT_FILES : SchemaType = { <nl> const COMMANDS : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> CommandNativeComponent : { <nl> extendsProps : [ <nl> const COMMANDS : SchemaType = { <nl> const COMMANDS_AND_PROPS : SchemaType = { <nl> modules : { <nl> Switch : { <nl> + type : ' Component ' , <nl> components : { <nl> CommandNativeComponent : { <nl> extendsProps : [ <nl> const COMMANDS_AND_PROPS : SchemaType = { <nl> const EXCLUDE_ANDROID : SchemaType = { <nl> modules : { <nl> ExcludedAndroid : { <nl> + type : ' Component ' , <nl> components : { <nl> ExcludedAndroidComponent : { <nl> excludedPlatforms : [ ' android ' ] , <nl> const EXCLUDE_ANDROID : SchemaType = { <nl> const EXCLUDE_ANDROID_IOS : SchemaType = { <nl> modules : { <nl> ExcludedAndroidIos : { <nl> + type : ' Component ' , <nl> components : { <nl> ExcludedAndroidIosComponent : { <nl> excludedPlatforms : [ ' android ' , ' iOS ' ] , <nl>\n", "msg": "Update Component generator fixtures to follow new ComponentSchema\n", "score": 1}
{"diff_id": 44196, "repo": "hakimel/reveal.js\n", "sha": "3b111a1cd4cd8fe4a7bd27f70ea270e09a0073ce\n", "time": "2014-04-13T09:55:06Z\n", "diff": "mmm a / js / reveal . js <nl> ppp b / js / reveal . js <nl> var Reveal = ( function ( ) { <nl> / / Enable keyboard shortcuts for navigation <nl> keyboard : true , <nl> <nl> + / / Optional function that blocks keyboard events when retuning false <nl> + keyboardCondition : null , <nl> + <nl> / / Enable the slide overview mode <nl> overview : true , <nl> <nl> var Reveal = ( function ( ) { <nl> * / <nl> function onDocumentKeyDown ( event ) { <nl> <nl> + / / If there ' s a condition specified and it returns false , <nl> + / / ignore this event <nl> + if ( typeof config . keyboardCondition = = = ' function ' & & config . keyboardCondition ( ) = = = false ) { <nl> + return true ; <nl> + } <nl> + <nl> / / Remember if auto - sliding was paused so we can toggle it <nl> var autoSlideWasPaused = autoSlidePaused ; <nl> <nl>\n", "msg": "add support for custom keyboard availability condition\n", "score": 1}
{"diff_id": 44245, "repo": "photonstorm/phaser\n", "sha": "529c35adda622a6bddcac10651534acebb2112b7\n", "time": "2018-04-24T06:27:19Z\n", "diff": "mmm a / src / math / RadToDeg . js <nl> ppp b / src / math / RadToDeg . js <nl> var CONST = require ( ' . / const ' ) ; <nl> * <nl> * @ param { float } radians - The angle in radians to convert ot degrees . <nl> * <nl> - * @ return { integer } The given angle in degrees . <nl> + * @ return { integer } The given angle converted to degrees . <nl> * / <nl> var RadToDeg = function ( radians ) <nl> { <nl>\n", "msg": "Update return statement description in RadToDeg\n", "score": 1}
{"diff_id": 44688, "repo": "meteor/meteor\n", "sha": "4cca9a8082c400ea0df5f9a2e802b4a1947491ce\n", "time": "2012-04-08T17:13:57Z\n", "diff": "mmm a / packages / liveui / liveui . js <nl> ppp b / packages / liveui / liveui . js <nl> Meteor . ui = Meteor . ui | | { } ; <nl> endNode = = = startNode . parentNode . nextSibling ) { <nl> endNode = startNode . parentNode . lastChild ; <nl> } else { <nl> + var r = new RegExp ( ' < ! - - \\ \\ s * STARTRANGE_ ' + id + ' . * ? - - > ' , ' g ' ) ; <nl> + var match = r . exec ( html ) ; <nl> + var help = \" \" ; <nl> + if ( match ) { <nl> + var comment_end = r . lastIndex ; <nl> + var comment_start = comment_end - match [ 0 ] . length ; <nl> + var stripped_before = html . slice ( 0 , comment_start ) . replace ( <nl> + / < ! - - \\ s * ( START | END ) RANGE . * ? - - > / g , ' ' ) ; <nl> + var stripped_after = html . slice ( comment_end ) . replace ( <nl> + / < ! - - \\ s * ( START | END ) RANGE . * ? - - > / g , ' ' ) ; <nl> + var context_amount = 50 ; <nl> + var context = stripped_before . slice ( - context_amount ) + <nl> + stripped_after . slice ( 0 , context_amount ) ; <nl> + help = \" ( possible unclosed near : \" + context + \" ) \" ; <nl> + } <nl> throw new Error ( \" Could not create liverange in template . \" + <nl> - \" Check for unclosed tags in your HTML . \" ) ; <nl> + \" Check for unclosed tags in your HTML . \" + help ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "even more helpful LiveUI message on mismatched tags\n", "score": 1}
{"diff_id": 44699, "repo": "gorhill/uBlock\n", "sha": "6926030b68f8b6bd3dbba1820b050d13b654e8bd\n", "time": "2020-06-10T16:15:50Z\n", "diff": "mmm a / src / js / static - filtering - parser . js <nl> ppp b / src / js / static - filtering - parser . js <nl> const Parser = class { <nl> } else if ( this . patternIsDubious ( ) ) { <nl> this . markSpan ( this . patternSpan , BITError ) ; <nl> } <nl> - / / Validate options <nl> - for ( const _ of this . options ( ) ) { void _ ; } <nl> + this . netOptionsIterator . init ( ) ; <nl> } <nl> <nl> analyzeDomainList ( from , to , bitSeparator , canEntity ) { <nl> const Parser = class { <nl> <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> <nl> + const hasNoBits = ( v , bits ) = > ( v & bits ) = = = 0 ; <nl> + const hasBits = ( v , bits ) = > ( v & bits ) ! = = 0 ; <nl> + const hasNotAllBits = ( v , bits ) = > ( v & bits ) ! = = bits ; <nl> + <nl> + / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> + <nl> const CATNone = 0 ; <nl> const CATStaticExtFilter = 1 ; <nl> const CATStaticNetFilter = 2 ; <nl> const OPTAllowOnly = 1 < < 10 ; <nl> const OPTMustAssign = 1 < < 11 ; <nl> const OPTAllowMayAssign = 1 < < 12 ; <nl> const OPTDomainList = 1 < < 13 ; <nl> - const OPTNotSupported = 1 < < 14 ; <nl> - <nl> - const hasNoBits = ( v , bits ) = > ( v & bits ) = = = 0 ; <nl> - const hasBits = ( v , bits ) = > ( v & bits ) ! = = 0 ; <nl> - const hasNotAllBits = ( v , bits ) = > ( v & bits ) ! = = bits ; <nl> + const OPTType = 1 < < 14 ; <nl> + const OPTNetworkType = 1 < < 15 ; <nl> + const OPTRedirectType = 1 < < 16 ; <nl> + const OPTNotSupported = 1 < < 17 ; <nl> <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> <nl> const NetOptionsIterator = class { <nl> this . value = undefined ; <nl> this . done = true ; <nl> } <nl> - [ Symbol . iterator ] ( ) { <nl> + init ( ) { <nl> this . readPtr = this . writePtr = 0 ; <nl> this . done = this . parser . optionsSpan . l = = = 0 ; <nl> if ( this . done ) { <nl> const NetOptionsIterator = class { <nl> const ropts = lopts + this . parser . optionsSpan . l ; <nl> const slices = this . parser . slices ; <nl> const optSlices = this . optSlices ; <nl> + let typeCount = 0 ; <nl> + let networkTypeCount = 0 ; <nl> + let redirectIndex = - 1 ; <nl> + let cspIndex = - 1 ; <nl> let writePtr = 0 ; <nl> let lopt = lopts ; <nl> while ( lopt < ropts ) { <nl> let good = true ; <nl> let ltok = lopt ; <nl> + / / Parse optional negation <nl> if ( hasBits ( slices [ lopt ] , BITTilde ) ) { <nl> if ( slices [ lopt + 2 ] > 1 ) { good = false ; } <nl> ltok + = 3 ; <nl> } <nl> + / / Find end of current option <nl> let lval = 0 ; <nl> let i = ltok ; <nl> while ( i < ropts ) { <nl> const NetOptionsIterator = class { <nl> const token = this . parser . raw . slice ( slices [ ltok + 1 ] , slices [ rtok + 1 ] ) ; <nl> descriptor = netOptionTokens . get ( token ) ; <nl> } <nl> + / / Validate option according to context <nl> if ( <nl> descriptor = = = undefined | | <nl> ltok ! = = lopt & & hasNoBits ( descriptor , OPTCanNegate ) | | <nl> const NetOptionsIterator = class { <nl> ) { <nl> descriptor = OPTTokenInvalid ; <nl> } <nl> + / / Keep count of types <nl> + if ( hasBits ( descriptor , OPTType ) ) { <nl> + typeCount + = 1 ; <nl> + if ( hasBits ( descriptor , OPTNetworkType ) ) { <nl> + networkTypeCount + = 1 ; <nl> + } <nl> + } <nl> + / / Only one ` redirect ` or ` csp ` can be present <nl> + if ( hasBits ( descriptor , OPTRedirectType ) ) { <nl> + if ( redirectIndex = = = - 1 ) { <nl> + redirectIndex = writePtr ; <nl> + } else { <nl> + descriptor = OPTTokenInvalid ; <nl> + } <nl> + } else if ( ( descriptor & 0xFF ) = = = OPTTokenCsp ) { <nl> + if ( cspIndex = = = - 1 ) { <nl> + cspIndex = writePtr ; <nl> + } else { <nl> + descriptor = OPTTokenInvalid ; <nl> + } <nl> + } <nl> + / / Mark slices in case of invalid filter option <nl> if ( <nl> this . interactive & & ( <nl> descriptor = = = OPTTokenInvalid | | <nl> const NetOptionsIterator = class { <nl> ) { <nl> this . parser . markSlices ( lopt , i , BITError ) ; <nl> } <nl> + / / Store indices to raw slices - - this will be used during <nl> + / / iteration <nl> optSlices [ writePtr + 0 ] = descriptor ; <nl> optSlices [ writePtr + 1 ] = lopt ; <nl> optSlices [ writePtr + 2 ] = ltok ; <nl> if ( lval ! = = 0 ) { <nl> optSlices [ writePtr + 3 ] = lval ; <nl> optSlices [ writePtr + 4 ] = lval + 3 ; <nl> + if ( this . interactive & & hasBits ( descriptor , OPTDomainList ) ) { <nl> + this . parser . analyzeDomainList ( <nl> + lval + 3 , i , BITPipe , <nl> + ( descriptor & 0xFF ) = = = OPTTokenDomain <nl> + ) ; <nl> + } <nl> } else { <nl> optSlices [ writePtr + 3 ] = i ; <nl> optSlices [ writePtr + 4 ] = i ; <nl> } <nl> optSlices [ writePtr + 5 ] = i ; <nl> + / / Advance to next option <nl> writePtr + = 6 ; <nl> lopt = i + 3 ; <nl> } <nl> const NetOptionsIterator = class { <nl> if ( this . interactive & & hasBits ( this . parser . slices [ ropts - 3 ] , BITComma ) ) { <nl> this . parser . slices [ ropts - 3 ] | = BITError ; <nl> } <nl> - / / TODO : Now that all options are parsed , find out erroneous <nl> - / / combinations of options : <nl> - / / - redirect ( - rule ) requires a single discrete type <nl> - / / - csp can ' t be mixed with any other types <nl> - / / - any option should appear only once <nl> - / / - etc . <nl> + / / Invalid combinations of options <nl> + / / <nl> + / / ` csp ` can ' t be used with any other types <nl> + if ( cspIndex ! = = - 1 & & typeCount ! = = 0 ) { <nl> + optSlices [ cspIndex ] = OPTTokenInvalid ; <nl> + if ( this . interactive ) { <nl> + this . parser . markSlices ( <nl> + optSlices [ cspIndex + 1 ] , <nl> + optSlices [ cspIndex + 5 ] , <nl> + BITError <nl> + ) ; <nl> + } <nl> + } <nl> + / / ` redirect ` requires one single network type <nl> + if ( redirectIndex ! = = - 1 & & typeCount ! = = 1 & & networkTypeCount ! = = 1 ) { <nl> + optSlices [ redirectIndex ] = OPTTokenInvalid ; <nl> + if ( this . interactive ) { <nl> + this . parser . markSlices ( <nl> + optSlices [ redirectIndex + 1 ] , <nl> + optSlices [ redirectIndex + 5 ] , <nl> + BITError <nl> + ) ; <nl> + } <nl> + } <nl> return this ; <nl> } <nl> next ( ) { <nl> const NetOptionsIterator = class { <nl> parser . slices [ optSlices [ i + 4 ] + 1 ] , <nl> parser . slices [ optSlices [ i + 5 ] + 1 ] <nl> ) ; <nl> - if ( parser . interactive & & hasBits ( descriptor , OPTDomainList ) ) { <nl> - parser . analyzeDomainList ( <nl> - optSlices [ i + 4 ] , <nl> - optSlices [ i + 5 ] , <nl> - BITPipe , <nl> - this . item . id = = = OPTTokenDomain <nl> - ) ; <nl> - } <nl> } <nl> this . readPtr = i + 6 ; <nl> return this ; <nl> } <nl> + [ Symbol . iterator ] ( ) { <nl> + return this . init ( ) ; <nl> + } <nl> } ; <nl> <nl> const netOptionTokens = new Map ( [ <nl> - [ ' 1p ' , OPTToken1p | OPTCanNegate ] , [ ' first - party ' , OPTToken1p | OPTCanNegate ] , <nl> - [ ' 3p ' , OPTToken3p | OPTCanNegate ] , [ ' third - party ' , OPTToken3p | OPTCanNegate ] , <nl> - [ ' all ' , OPTTokenAll ] , <nl> + [ ' 1p ' , OPTToken1p | OPTCanNegate ] , <nl> + [ ' first - party ' , OPTToken1p | OPTCanNegate ] , <nl> + [ ' 3p ' , OPTToken3p | OPTCanNegate ] , <nl> + [ ' third - party ' , OPTToken3p | OPTCanNegate ] , <nl> + [ ' all ' , OPTTokenAll | OPTType | OPTNetworkType ] , <nl> [ ' badfilter ' , OPTTokenBadfilter ] , <nl> - [ ' cname ' , OPTTokenCname | OPTAllowOnly ] , <nl> + [ ' cname ' , OPTTokenCname | OPTAllowOnly | OPTType ] , <nl> [ ' csp ' , OPTTokenCsp | OPTMustAssign | OPTAllowMayAssign ] , <nl> - [ ' css ' , OPTTokenCss | OPTCanNegate ] , [ ' stylesheet ' , OPTTokenCss | OPTCanNegate ] , <nl> + [ ' css ' , OPTTokenCss | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' stylesheet ' , OPTTokenCss | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> [ ' denyallow ' , OPTTokenDenyAllow | OPTMustAssign | OPTDomainList ] , <nl> - [ ' doc ' , OPTTokenDoc ] , [ ' document ' , OPTTokenDoc ] , <nl> + [ ' doc ' , OPTTokenDoc | OPTType | OPTNetworkType ] , <nl> + [ ' document ' , OPTTokenDoc | OPTType | OPTNetworkType ] , <nl> [ ' domain ' , OPTTokenDomain | OPTMustAssign | OPTDomainList ] , <nl> - [ ' ehide ' , OPTTokenEhide ] , [ ' elemhide ' , OPTTokenEhide ] , <nl> - [ ' empty ' , OPTTokenEmpty | OPTBlockOnly ] , <nl> - [ ' frame ' , OPTTokenFrame | OPTCanNegate ] , [ ' subdocument ' , OPTTokenFrame | OPTCanNegate ] , <nl> - [ ' font ' , OPTTokenFont | OPTCanNegate ] , <nl> + [ ' ehide ' , OPTTokenEhide | OPTType ] , <nl> + [ ' elemhide ' , OPTTokenEhide | OPTType ] , <nl> + [ ' empty ' , OPTTokenEmpty | OPTBlockOnly | OPTType | OPTNetworkType | OPTBlockOnly | OPTRedirectType ] , <nl> + [ ' frame ' , OPTTokenFrame | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' subdocument ' , OPTTokenFrame | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' font ' , OPTTokenFont | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> [ ' genericblock ' , OPTTokenGenericblock | OPTNotSupported ] , <nl> - [ ' ghide ' , OPTTokenGhide ] , [ ' generichide ' , OPTTokenGhide ] , <nl> - [ ' image ' , OPTTokenImage | OPTCanNegate ] , <nl> + [ ' ghide ' , OPTTokenGhide | OPTType ] , <nl> + [ ' generichide ' , OPTTokenGhide | OPTType ] , <nl> + [ ' image ' , OPTTokenImage | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> [ ' important ' , OPTTokenImportant | OPTBlockOnly ] , <nl> - [ ' inline - font ' , OPTTokenInlineFont ] , <nl> - [ ' inline - script ' , OPTTokenInlineScript ] , <nl> - [ ' media ' , OPTTokenMedia | OPTCanNegate ] , <nl> - [ ' mp4 ' , OPTTokenMp4 ] , <nl> - [ ' object ' , OPTTokenObject | OPTCanNegate ] , [ ' object - subrequest ' , OPTTokenObject | OPTCanNegate ] , <nl> - [ ' other ' , OPTTokenOther | OPTCanNegate ] , <nl> - [ ' ping ' , OPTTokenPing | OPTCanNegate ] , [ ' beacon ' , OPTTokenPing | OPTCanNegate ] , <nl> - [ ' popunder ' , OPTTokenPopunder ] , <nl> - [ ' popup ' , OPTTokenPopup ] , <nl> - [ ' redirect ' , OPTTokenRedirect | OPTMustAssign | OPTBlockOnly ] , <nl> - [ ' redirect - rule ' , OPTTokenRedirectRule | OPTMustAssign | OPTBlockOnly ] , <nl> - [ ' script ' , OPTTokenScript | OPTCanNegate ] , <nl> - [ ' shide ' , OPTTokenShide ] , [ ' specifichide ' , OPTTokenShide ] , <nl> - [ ' xhr ' , OPTTokenXhr | OPTCanNegate ] , [ ' xmlhttprequest ' , OPTTokenXhr | OPTCanNegate ] , <nl> + [ ' inline - font ' , OPTTokenInlineFont | OPTType ] , <nl> + [ ' inline - script ' , OPTTokenInlineScript | OPTType ] , <nl> + [ ' media ' , OPTTokenMedia | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' mp4 ' , OPTTokenMp4 | OPTType | OPTNetworkType | OPTBlockOnly | OPTRedirectType ] , <nl> + [ ' object ' , OPTTokenObject | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' object - subrequest ' , OPTTokenObject | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' other ' , OPTTokenOther | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' ping ' , OPTTokenPing | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' beacon ' , OPTTokenPing | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' popunder ' , OPTTokenPopunder | OPTType ] , <nl> + [ ' popup ' , OPTTokenPopup | OPTType ] , <nl> + [ ' redirect ' , OPTTokenRedirect | OPTMustAssign | OPTBlockOnly | OPTRedirectType ] , <nl> + [ ' redirect - rule ' , OPTTokenRedirectRule | OPTMustAssign | OPTBlockOnly | OPTRedirectType ] , <nl> + [ ' script ' , OPTTokenScript | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' shide ' , OPTTokenShide | OPTType ] , <nl> + [ ' specifichide ' , OPTTokenShide | OPTType ] , <nl> + [ ' xhr ' , OPTTokenXhr | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> + [ ' xmlhttprequest ' , OPTTokenXhr | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> [ ' webrtc ' , OPTTokenWebrtc | OPTNotSupported ] , <nl> - [ ' websocket ' , OPTTokenWebsocket | OPTCanNegate ] , <nl> + [ ' websocket ' , OPTTokenWebsocket | OPTCanNegate | OPTType | OPTNetworkType ] , <nl> ] ) ; <nl> <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> const ExtOptionsIterator = class { <nl> this . value = undefined ; <nl> this . done = true ; <nl> } <nl> - [ Symbol . iterator ] ( ) { <nl> + init ( ) { <nl> const { i , l } = this . parser . optionsSpan ; <nl> this . l = i ; <nl> this . r = i + l ; <nl> const ExtOptionsIterator = class { <nl> this . l = i ; <nl> return this ; <nl> } <nl> + [ Symbol . iterator ] ( ) { <nl> + return this . init ( ) ; <nl> + } <nl> } ; <nl> <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl>\n", "msg": "Expand static parser to better detect invalid syntax\n", "score": 1}
{"diff_id": 44726, "repo": "hexojs/hexo\n", "sha": "192614be0c55f4d51b894a442b8e8712349bf8ad\n", "time": "2013-08-10T14:19:07Z\n", "diff": "mmm a / lib / core . js <nl> ppp b / lib / core . js <nl> var Hexo = module . exports = function ( baseDir , args ) { <nl> <nl> this . base_dir = baseDir ; <nl> this . public_dir = path . join ( baseDir , ' public ' ) ; <nl> - this . source_dir = path . join ( baseDir + ' source ' ) ; <nl> - this . plugin_dir = path . join ( baseDir + ' node_modules ' ) ; <nl> - this . script_dir = path . join ( baseDir + ' scripts ' ) ; <nl> + this . source_dir = path . join ( baseDir , ' source ' ) ; <nl> + this . plugin_dir = path . join ( baseDir , ' node_modules ' ) ; <nl> + this . script_dir = path . join ( baseDir , ' scripts ' ) ; <nl> <nl> this . __defineGetter__ ( ' theme_dir ' , function ( ) { <nl> return path . join ( baseDir , ' themes ' , config . theme ) ; <nl> proto . call = function ( name , args , callback ) { <nl> var d = domain . create ( ) ; <nl> <nl> d . on ( ' error ' , function ( err ) { <nl> + d . dispose ( ) ; <nl> callback ( err ) ; <nl> } ) ; <nl> <nl> proto . call = function ( name , args , callback ) { <nl> } else { <nl> callback ( new Error ( ' Console ` ' + name + ' ` not found ' ) ) ; <nl> } <nl> + <nl> + return this ; <nl> } ; <nl> \\ No newline at end of file <nl>\n", "msg": "Fixed core directory path . Dispose domain when a call done . Call chaining .\n", "score": 1}
{"diff_id": 44797, "repo": "select2/select2\n", "sha": "67699746b4fed4bc94688abb723cdfc3e62ddbd0\n", "time": "2013-09-16T19:54:29Z\n", "diff": "mmm a / select2 . js <nl> ppp b / select2 . js <nl> the specific language governing permissions and limitations under the Apache Lic <nl> / / abstract <nl> getPlaceholderOption : function ( ) { <nl> if ( this . select ) { <nl> - var firstOption = this . select . children ( ) . first ( ) ; <nl> + var firstOption = this . select . children ( ' option ' ) . first ( ) ; <nl> if ( this . opts . placeholderOption ! = = undefined ) { <nl> / / Determine the placeholder option based on the specified placeholderOption setting <nl> return ( this . opts . placeholderOption = = = \" first \" & & firstOption ) | | <nl>\n", "msg": "Use more specific selector for finding options of a select\n", "score": 1}
{"diff_id": 44823, "repo": "TryGhost/Ghost\n", "sha": "4dcf256371206eca990ad4f5083af555160a9ec7\n", "time": "2018-10-12T18:02:08Z\n", "diff": "mmm a / core / server / api / v2 / utils / permissions . js <nl> ppp b / core / server / api / v2 / utils / permissions . js <nl> const nonePublicAuth = ( apiConfig , frame ) = > { <nl> <nl> const singular = apiConfig . docName . replace ( / s $ / , ' ' ) ; <nl> <nl> - let unsafeAttrObject = apiConfig . unsafeAttrs & & _ . has ( frame , ` data . [ $ { apiConfig . docName } ] [ 0 ] ` ) ? _ . pick ( frame . data [ apiConfig . docName ] [ 0 ] , apiConfig . unsafeAttrs ) : { } , <nl> - permsPromise = permissions . canThis ( frame . options . context ) [ apiConfig . method ] [ singular ] ( frame . options . id , unsafeAttrObject ) ; <nl> + let permissionIdentifier = frame . options . id ; <nl> + <nl> + if ( apiConfig . permissionIdentifier ) { <nl> + permissionIdentifier = apiConfig . permissionIdentifier ( frame ) ; <nl> + } <nl> + <nl> + const unsafeAttrObject = apiConfig . unsafeAttrs & & _ . has ( frame , ` data . [ $ { apiConfig . docName } ] [ 0 ] ` ) ? _ . pick ( frame . data [ apiConfig . docName ] [ 0 ] , apiConfig . unsafeAttrs ) : { } ; <nl> + const permsPromise = permissions . canThis ( frame . options . context ) [ apiConfig . method ] [ singular ] ( permissionIdentifier , unsafeAttrObject ) ; <nl> <nl> return permsPromise . then ( ( result ) = > { <nl> / * <nl>\n", "msg": "Added ability to define permission identifier\n", "score": 1}
{"diff_id": 44907, "repo": "mozilla/pdf.js\n", "sha": "9d042ce16661b3453581786f701e172594ba5a13\n", "time": "2011-12-14T16:47:35Z\n", "diff": "mmm a / src / colorspace . js <nl> ppp b / src / colorspace . js <nl> var DeviceRgbCS = ( function DeviceRgbCSClosure ( ) { <nl> return rgbBuf ; <nl> } , <nl> isDefaultDecode : function rgbcs_isDefaultDecode ( decodeMap ) { <nl> - return 0 = = decodeMap [ 0 ] = = decodeMap [ 2 ] = = decodeMap [ 4 ] & & <nl> - 1 = = decodeMap [ 1 ] = = decodeMap [ 3 ] = = decoeMap [ 5 ] ; <nl> + ColorSpace . isDefaultDecode ( decodeMap , this . numComps ) ; <nl> } <nl> } ; <nl> return DeviceRgbCS ; <nl>\n", "msg": "Use the general function for is default decode .\n", "score": 1}
{"diff_id": 90, "repo": "lodash/lodash\n", "sha": "61acdd0c295e4447c9c10da04e287b1ebffe452c\n", "time": "2017-06-20T21:55:44Z\n", "diff": "mmm a / uniqueId . js <nl> ppp b / uniqueId . js <nl> let idCounter = 0 <nl> * uniqueId ( ) <nl> * / / = > ' 105 ' <nl> * / <nl> - function uniqueId ( prefix ) { <nl> + function uniqueId ( prefix = ' ' ) { <nl> const id = + + idCounter <nl> return ` $ { prefix + id } ` <nl> } <nl>\n", "msg": "default prefix to empty string ( )\n", "score": 1}
{"diff_id": 689, "repo": "meteor/meteor\n", "sha": "d320f9c134bdcc0ea810915a88cea01d4ddf8d96\n", "time": "2014-11-12T23:41:26Z\n", "diff": "mmm a / tools / tropohouse . js <nl> ppp b / tools / tropohouse . js <nl> _ . extend ( exports . Tropohouse . prototype , { <nl> } <nl> <nl> var relativePath = path . join ( config . getPackagesDirectoryName ( ) , <nl> - packageName , version ) ; <nl> + utils . escapePackageNameForPath ( packageName ) , <nl> + version ) ; <nl> return relative ? relativePath : path . join ( self . root , relativePath ) ; <nl> } , <nl> <nl> _ . extend ( exports . Tropohouse . prototype , { <nl> <nl> var packageRootDir = path . join ( self . root , packagesDirectoryName ) ; <nl> try { <nl> - var packages = fs . readdirSync ( packageRootDir ) ; <nl> + var escapedPackages = fs . readdirSync ( packageRootDir ) ; <nl> } catch ( e ) { <nl> / / No packages at all ? We ' re done . <nl> if ( e . code = = = ' ENOENT ' ) <nl> _ . extend ( exports . Tropohouse . prototype , { <nl> <nl> / / We want to be careful not to break the ' meteor ' symlink inside the <nl> / / tropohouse . Hopefully nobody deleted / modified that package ! <nl> - var latestToolPackage = null ; <nl> + var latestToolPackageEscaped = null ; <nl> var latestToolVersion = null ; <nl> - var currentToolPackage = null ; <nl> + var currentToolPackageEscaped = null ; <nl> var currentToolVersion = null ; <nl> / / Warning : we can ' t examine release . current here , because we might be <nl> / / currently processing release . load ! <nl> _ . extend ( exports . Tropohouse . prototype , { <nl> / / / home / user / . meteor / packages / meteor - tool / . 1 . 0 . 17 . ut200e + + os . osx . x86_64 + web . browser + web . cordova / meteor - tool - os . osx . x86_64 <nl> var toolsDir = files . getCurrentToolsDir ( ) ; <nl> / / eg , ' meteor - tool ' <nl> - currentToolPackage = path . basename ( path . dirname ( path . dirname ( toolsDir ) ) ) ; <nl> + currentToolPackageEscaped = <nl> + path . basename ( path . dirname ( path . dirname ( toolsDir ) ) ) ; <nl> / / eg , ' . 1 . 0 . 17 - xyz1 . 2 . ut200e + + os . osx . x86_64 + web . browser + web . cordova ' <nl> var toolVersionDir = path . basename ( path . dirname ( toolsDir ) ) ; <nl> var toolVersionWithDotAndRandomBit = toolVersionDir . split ( ' + + ' ) [ 0 ] ; <nl> _ . extend ( exports . Tropohouse . prototype , { <nl> packagesDirectoryName + path . sep ) ) { <nl> var rest = latestMeteorSymlink . substr ( packagesDirectoryName . length + path . sep . length ) ; <nl> var pieces = rest . split ( path . sep ) ; <nl> - latestToolPackage = pieces [ 0 ] ; <nl> + latestToolPackageEscaped = pieces [ 0 ] ; <nl> latestToolVersion = pieces [ 1 ] ; <nl> } <nl> } <nl> <nl> - _ . each ( packages , function ( package ) { <nl> - var packageDir = path . join ( packageRootDir , package ) ; <nl> + _ . each ( packagesEscaped , function ( packageEscaped ) { <nl> + var packageDir = path . join ( packageRootDir , packageEscaped ) ; <nl> try { <nl> var versions = fs . readdirSync ( packageDir ) ; <nl> } catch ( e ) { <nl> _ . extend ( exports . Tropohouse . prototype , { <nl> return ; <nl> throw e ; <nl> } <nl> - _ . each ( fs . readdirSync ( packageDir ) , function ( version ) { <nl> + _ . each ( versions , function ( version ) { <nl> / / Is this a pre - 0 . 9 . 0 \" warehouse \" version with a hash name ? <nl> if ( / ^ [ a - f0 - 9 ] { 3 , } $ / . test ( version ) ) <nl> return ; <nl> _ . extend ( exports . Tropohouse . prototype , { <nl> / / Skip the currently - latest tool ( ie , don ' t break top - level meteor <nl> / / symlink ) . This includes both the symlink with its name and the thing <nl> / / it points to . <nl> - if ( package = = = latestToolPackage & & <nl> + if ( packageEscaped = = = latestToolPackageEscaped & & <nl> ( version = = = latestToolVersion | | <nl> utils . startsWith ( version , ' . ' + latestToolVersion + ' . ' ) ) ) { <nl> return ; <nl> _ . extend ( exports . Tropohouse . prototype , { <nl> <nl> / / Skip the currently - executing tool ( ie , don ' t break the current <nl> / / operation ) . <nl> - if ( package = = = currentToolPackage & & <nl> + if ( packageEscaped = = = currentToolPackageEscaped & & <nl> ( version = = = currentToolVersion | | <nl> utils . startsWith ( version , ' . ' + currentToolVersion + ' . ' ) ) ) { <nl> return ; <nl>\n", "msg": "Escape package names for paths in in tropohouse\n", "score": 1}
{"diff_id": 1141, "repo": "facebook/react-native\n", "sha": "891550724450988a440756170b2475f1da6f9ba2\n", "time": "2016-10-03T11:28:46Z\n", "diff": "mmm a / Libraries / Components / Touchable / Touchable . js <nl> ppp b / Libraries / Components / Touchable / Touchable . js <nl> var TouchableMixin = { <nl> } <nl> <nl> if ( newIsHighlight & & ! curIsHighlight ) { <nl> - this . _savePressInLocation ( e ) ; <nl> - this . touchableHandleActivePressIn & & this . touchableHandleActivePressIn ( e ) ; <nl> - } else if ( ! newIsHighlight & & curIsHighlight & & this . touchableHandleActivePressOut ) { <nl> - if ( this . touchableGetPressOutDelayMS & & this . touchableGetPressOutDelayMS ( ) ) { <nl> - this . pressOutDelayTimeout = setTimeout ( ( ) = > { <nl> - this . touchableHandleActivePressOut ( e ) ; <nl> - } , this . touchableGetPressOutDelayMS ( ) ) ; <nl> - } else { <nl> - this . touchableHandleActivePressOut ( e ) ; <nl> - } <nl> + this . _startHighlight ( e ) ; <nl> + } else if ( ! newIsHighlight & & curIsHighlight ) { <nl> + this . _endHighlight ( e ) ; <nl> } <nl> <nl> if ( IsPressingIn [ curState ] & & signal = = = Signals . RESPONDER_RELEASE ) { <nl> var TouchableMixin = { <nl> <nl> var shouldInvokePress = ! IsLongPressingIn [ curState ] | | pressIsLongButStillCallOnPress ; <nl> if ( shouldInvokePress & & this . touchableHandlePress ) { <nl> + if ( ! newIsHighlight & & ! curIsHighlight ) { <nl> + / / we never highlighted because of delay , but we should highlight now <nl> + this . _startHighlight ( e ) ; <nl> + this . _endHighlight ( e ) ; <nl> + } <nl> this . touchableHandlePress ( e ) ; <nl> } <nl> } <nl> <nl> this . touchableDelayTimeout & & clearTimeout ( this . touchableDelayTimeout ) ; <nl> this . touchableDelayTimeout = null ; <nl> - } <nl> + } , <nl> + <nl> + _startHighlight : function ( e ) { <nl> + this . _savePressInLocation ( e ) ; <nl> + this . touchableHandleActivePressIn & & this . touchableHandleActivePressIn ( e ) ; <nl> + } , <nl> + <nl> + _endHighlight : function ( e ) { <nl> + if ( this . touchableHandleActivePressOut ) { <nl> + if ( this . touchableGetPressOutDelayMS & & this . touchableGetPressOutDelayMS ( ) ) { <nl> + this . pressOutDelayTimeout = setTimeout ( ( ) = > { <nl> + this . touchableHandleActivePressOut ( e ) ; <nl> + } , this . touchableGetPressOutDelayMS ( ) ) ; <nl> + } else { <nl> + this . touchableHandleActivePressOut ( e ) ; <nl> + } <nl> + } <nl> + } , <nl> <nl> } ; <nl> <nl>\n", "msg": "show touchable feedback for short touches\n", "score": 1}
{"diff_id": 1564, "repo": "serverless/serverless\n", "sha": "7ac85e4d120f7e1e076ee55ce58c292e8ee67942\n", "time": "2019-07-02T09:43:22Z\n", "diff": "mmm a / lib / plugins / aws / utils / credentials . js <nl> ppp b / lib / plugins / aws / utils / credentials . js <nl> const writeCredentialsContent = content = > <nl> writeFileError = > { <nl> if ( writeFileError ) { <nl> if ( writeFileError . code = = = ' ENOENT ' ) { <nl> - mkdir ( <nl> - awsConfigDirPath , <nl> - { mode : constants . S_IRUSR | constants . S_IWUSR | constants . S_IXUSR } , <nl> - mkdirError = > { <nl> - if ( mkdirError ) reject ( mkdirError ) ; <nl> - else resolve ( writeCredentialsContent ( content ) ) ; <nl> - } <nl> - ) ; <nl> + mkdir ( awsConfigDirPath , { mode : constants . S_IRWXU } , mkdirError = > { <nl> + if ( mkdirError ) reject ( mkdirError ) ; <nl> + else resolve ( writeCredentialsContent ( content ) ) ; <nl> + } ) ; <nl> } else { <nl> reject ( writeFileError ) ; <nl> } <nl>\n", "msg": "Simplify mode access setting\n", "score": 1}
{"diff_id": 2198, "repo": "balderdashy/sails\n", "sha": "f7f13d0db1515c91f6f82a1c1ee2bb7e8c93e7e4\n", "time": "2013-02-21T05:54:07Z\n", "diff": "mmm a / adapter . js <nl> ppp b / adapter . js <nl> module . exports = function ( adapterDef , cb ) { <nl> } ) ; <nl> <nl> / / Add and remove attributes using the specified adapterDef <nl> - async . forEach ( _ . keys ( newAttributes ) , function ( attrName , cb ) { <nl> + async . forEachSeries ( _ . keys ( newAttributes ) , function ( attrName , cb ) { <nl> adapterDef . addAttribute ( collectionName , attrName , newAttributes [ attrName ] , cb ) ; <nl> } , function ( err ) { <nl> if ( err ) return cb ( err ) ; <nl> - async . forEach ( _ . keys ( deprecatedAttributes ) , function ( attrName , cb ) { <nl> + async . forEachSeries ( _ . keys ( deprecatedAttributes ) , function ( attrName , cb ) { <nl> adapterDef . removeAttribute ( collectionName , attrName , deprecatedAttributes [ attrName ] , cb ) ; <nl> } , cb ) ; <nl> } ) ; <nl> module . exports = function ( adapterDef , cb ) { <nl> else { <nl> / / Create transaction name based on collection <nl> self . transaction ( collectionName + ' . waterline . default . createEach ' , function ( err , done ) { <nl> - async . forEach ( valuesList , function ( values , cb ) { <nl> + async . forEachSeries ( valuesList , function ( values , cb ) { <nl> self . create ( collectionName , values , cb ) ; <nl> } , done ) ; <nl> } , cb ) ; <nl>\n", "msg": "Used forEachSeries throughout to guarantee transactions .\n", "score": 1}
{"diff_id": 2434, "repo": "markedjs/marked\n", "sha": "173eb82d4754e9d63bf7aea9550bb1796acda467\n", "time": "2018-10-18T19:10:53Z\n", "diff": "mmm a / docs / demo / demo . js <nl> ppp b / docs / demo / demo . js <nl> if ( ' text ' in search ) { <nl> if ( ' options ' in search ) { <nl> $ optionsElem . value = search . options ; <nl> } else { <nl> - $ optionsElem . value = JSON . stringify ( marked . getDefaults ( ) , null , ' ' ) ; <nl> + $ optionsElem . value = JSON . stringify ( <nl> + marked . getDefaults ( ) , <nl> + function ( key , value ) { <nl> + if ( value & & typeof ( value ) = = = \" object \" & & Object . getPrototypeOf ( value ) ! = = Object . prototype ) { <nl> + return undefined ; <nl> + } <nl> + return value ; <nl> + } , ' ' ) ; <nl> } <nl> <nl> if ( search . outputType ) { <nl>\n", "msg": "Filter complex objects out of JSON defaults .\n", "score": 1}
{"diff_id": 2565, "repo": "RocketChat/Rocket.Chat\n", "sha": "2b644d79c138e5a274270879e2fe87bd63b43b2a\n", "time": "2016-11-15T22:09:58Z\n", "diff": "mmm a / packages / rocketchat - lib / client / lib / cachedCollection . js <nl> ppp b / packages / rocketchat - lib / client / lib / cachedCollection . js <nl> class CachedCollection { <nl> useSync = true , <nl> useCache = true , <nl> debug = true , <nl> - version = 2 , <nl> + version = 3 , <nl> maxCacheTime = 60 * 60 * 24 * 30 <nl> } ) { <nl> this . collection = collection | | new Meteor . Collection ( null ) ; <nl>\n", "msg": "Increase client cache version to force resync\n", "score": 1}
{"diff_id": 2570, "repo": "vuejs/vue\n", "sha": "4e12b25d785aa721d71ec2f553d150c8df15f875\n", "time": "2017-04-05T06:38:46Z\n", "diff": "mmm a / src / core / vdom / create - functional - component . js <nl> ppp b / src / core / vdom / create - functional - component . js <nl> import { resolveSlots } from ' . . / instance / render - helpers / resolve - slots ' <nl> <nl> import { <nl> isDef , <nl> + camelize , <nl> validateProp <nl> } from ' . . / util / index ' <nl> <nl> export function createFunctionalComponent ( <nl> for ( const key in propOptions ) { <nl> props [ key ] = validateProp ( key , propOptions , propsData ) <nl> } <nl> + } else { <nl> + if ( isDef ( data . attrs ) ) mergeProps ( props , data . attrs ) <nl> + if ( isDef ( data . props ) ) mergeProps ( props , data . props ) <nl> } <nl> / / ensure the createElement function in functional components <nl> / / gets a unique context - this is necessary for correct named slot check <nl> export function createFunctionalComponent ( <nl> const h = ( a , b , c , d ) = > createElement ( _context , a , b , c , d , true ) <nl> const vnode = Ctor . options . render . call ( null , h , { <nl> props , <nl> + listeners : data . on | | { } , <nl> data , <nl> parent : context , <nl> children , <nl> export function createFunctionalComponent ( <nl> } <nl> return vnode <nl> } <nl> + <nl> + function mergeProps ( to , from ) { <nl> + for ( const key in from ) { <nl> + to [ camelize ( key ) ] = from [ key ] <nl> + } <nl> + } <nl>\n", "msg": "simplify functional component usage\n", "score": 1}
{"diff_id": 2834, "repo": "hakimel/reveal.js\n", "sha": "c6b9da7000bc87f29dde25a859fee0e8858a31df\n", "time": "2014-06-18T16:42:45Z\n", "diff": "mmm a / js / reveal . js <nl> ppp b / js / reveal . js <nl> <nl> injectStyleSheet ( ' @ page { size : ' + pageWidth + ' px ' + pageHeight + ' px ; margin : 0 ; } ' ) ; <nl> <nl> / / Limit the size of certain elements to the dimensions of the slide <nl> - injectStyleSheet ( ' . reveal img , . reveal video , . reveal iframe { max - width : ' + slideWidth + ' px ; max - height : ' + slideHeight + ' px } ' ) ; <nl> + injectStyleSheet ( ' . reveal section > img , . reveal section > video , . reveal section > iframe { max - width : ' + slideWidth + ' px ; max - height : ' + slideHeight + ' px } ' ) ; <nl> <nl> document . body . classList . add ( ' print - pdf ' ) ; <nl> document . body . style . width = pageWidth + ' px ' ; <nl>\n", "msg": "more specific targeting for pdf printing hack\n", "score": 1}
{"diff_id": 3319, "repo": "TryGhost/Ghost\n", "sha": "70cf2b2c86f58d73e32666663d40df5e177110f0\n", "time": "2020-02-10T12:41:39Z\n", "diff": "mmm a / core / server / data / db / backup . js <nl> ppp b / core / server / data / db / backup . js <nl> writeExportFile = function writeExportFile ( exportResult ) { <nl> } ; <nl> <nl> const readBackup = async ( filename ) = > { <nl> - / / TODO : prevent from directory traversal - need to sanitize the filename probably on validation layer <nl> - var backupPath = path . resolve ( urlUtils . urlJoin ( config . get ( ' paths ' ) . contentPath , ' data ' , filename ) ) ; <nl> + const parsedFileName = path . parse ( filename ) ; <nl> + const sanitized = ` $ { parsedFileName . name } $ { parsedFileName . ext } ` ; <nl> + const backupPath = path . resolve ( urlUtils . urlJoin ( config . get ( ' paths ' ) . contentPath , ' data ' , sanitized ) ) ; <nl> <nl> const exists = await fs . pathExists ( backupPath ) ; <nl> <nl>\n", "msg": "Added input sanitization for backup path\n", "score": 1}
{"diff_id": 4080, "repo": "photonstorm/phaser\n", "sha": "4281bc1763a0c9960d263be13577ccf48abd3f10\n", "time": "2020-10-02T10:22:39Z\n", "diff": "new file mode 100644 <nl> index 0000000000 . . ffc6cc8ffb <nl> mmm / dev / null <nl> ppp b / src / tilemaps / components / IsometricTileToWorldXY . js <nl> <nl> + / * * <nl> + * @ author Richard Davey < rich @ photonstorm . com > <nl> + * @ copyright 2020 Photon Storm Ltd . <nl> + * @ license { @ link https : / / opensource . org / licenses / MIT | MIT License } <nl> + * / <nl> + <nl> + var Vector2 = require ( ' . . / . . / math / Vector2 ' ) ; <nl> + <nl> + / * * <nl> + * Converts from isometric tile XY coordinates ( tile units ) to world XY coordinates ( pixels ) , factoring in the <nl> + * layer ' s position , scale and scroll . This will return a new Vector2 object or update the given <nl> + * ` point ` object . <nl> + * <nl> + * @ function Phaser . Tilemaps . Components . IsometricTileToWorldXY <nl> + * @ since 3 . 50 . 0 <nl> + * <nl> + * @ param { integer } tileX - The x coordinate , in tiles , not pixels . <nl> + * @ param { integer } tileY - The y coordinate , in tiles , not pixels . <nl> + * @ param { Phaser . Math . Vector2 } [ point ] - A Vector2 to store the coordinates in . If not given a new Vector2 is created . <nl> + * @ param { Phaser . Cameras . Scene2D . Camera } [ camera = main camera ] - The Camera to use when calculating the tile index from the world values . <nl> + * @ param { Phaser . Tilemaps . LayerData } layer - The Tilemap Layer to act upon . <nl> + * <nl> + * @ return { Phaser . Math . Vector2 } The XY location in world coordinates . <nl> + * / <nl> + var IsometricTileToWorldXY = function ( tileX , tileY , point , camera , layer ) <nl> + { <nl> + if ( point = = = undefined ) { point = new Vector2 ( ) ; } <nl> + <nl> + var tileWidth = layer . baseTileWidth ; <nl> + var tileHeight = layer . baseTileHeight ; <nl> + var tilemapLayer = layer . tilemapLayer ; <nl> + <nl> + var layerWorldX = 0 ; <nl> + var layerWorldY = 0 ; <nl> + <nl> + if ( tilemapLayer ) <nl> + { <nl> + if ( camera = = = undefined ) { camera = tilemapLayer . scene . cameras . main ; } <nl> + <nl> + layerWorldX = tilemapLayer . x + camera . scrollX * ( 1 - tilemapLayer . scrollFactorX ) ; <nl> + <nl> + tileWidth * = tilemapLayer . scaleX ; <nl> + <nl> + layerWorldY = ( tilemapLayer . y + camera . scrollY * ( 1 - tilemapLayer . scrollFactorY ) ) ; <nl> + <nl> + tileHeight * = tilemapLayer . scaleY ; <nl> + } <nl> + <nl> + var x = layerWorldX + ( tileX - tileY ) * ( tileWidth / 2 ) ; <nl> + var y = layerWorldY + ( tileX + tileY ) * ( tileHeight / 2 ) ; <nl> + <nl> + return point . set ( x , y ) ; <nl> + } ; <nl> + <nl> + module . exports = IsometricTileToWorldXY ; <nl>\n", "msg": "` Tilemaps . Components . IsometricTileToWorldXY ` is a new function that converts isometric tile coordinates to world coordinates .\n", "score": 1}
{"diff_id": 4155, "repo": "photonstorm/phaser\n", "sha": "3a2fcd0951e36b0a363b077b537178065092a46e\n", "time": "2018-07-25T16:04:44Z\n", "diff": "mmm a / src / renderer / webgl / pipelines / FlatTintPipeline . js <nl> ppp b / src / renderer / webgl / pipelines / FlatTintPipeline . js <nl> var FlatTintPipeline = new Class ( { <nl> { x : 0 , y : 0 , width : 0 , rgb : 0xFFFFFF , alpha : 1 . 0 } <nl> ] ; <nl> <nl> + this . prevQuad = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; <nl> + <nl> / * * <nl> * Used internally for triangulating a polygon <nl> * <nl> var FlatTintPipeline = new Class ( { <nl> vertexViewF32 [ + + vertexOffset ] = y ; <nl> vertexViewF32 [ + + vertexOffset ] = 0 ; <nl> vertexViewF32 [ + + vertexOffset ] = 0 ; <nl> - vertexViewF32 [ + + vertexOffset ] = 0 . 5 ; <nl> + vertexViewF32 [ + + vertexOffset ] = 2 ; <nl> vertexViewU32 [ + + vertexOffset ] = tint ; <nl> <nl> this . vertexCount + + ; <nl> } , <nl> <nl> - batchTri : function ( x1 , y1 , x2 , y2 , x3 , y3 , tint ) <nl> + / / batchTri : function ( x1 , y1 , x2 , y2 , x3 , y3 , tint ) <nl> + batchTri : function ( x1 , y1 , x2 , y2 , x3 , y3 , tint1 , tint2 , tint3 ) <nl> { <nl> var vertexViewF32 = this . vertexViewF32 ; <nl> var vertexViewU32 = this . vertexViewU32 ; <nl> <nl> var vertexOffset = ( this . vertexCount * this . vertexComponentCount ) - 1 ; <nl> <nl> + / / 0 = texture multiplied by color <nl> + / / 1 = solid color + texture alpha <nl> + / / 2 = solid color , no texture <nl> + / / 3 = solid texture , no color <nl> + <nl> vertexViewF32 [ + + vertexOffset ] = x1 ; <nl> vertexViewF32 [ + + vertexOffset ] = y1 ; <nl> vertexViewF32 [ + + vertexOffset ] = 0 ; <nl> vertexViewF32 [ + + vertexOffset ] = 0 ; <nl> - vertexViewF32 [ + + vertexOffset ] = 0 . 5 ; <nl> - vertexViewU32 [ + + vertexOffset ] = tint ; <nl> + vertexViewF32 [ + + vertexOffset ] = 2 ; <nl> + vertexViewU32 [ + + vertexOffset ] = tint1 ; <nl> <nl> vertexViewF32 [ + + vertexOffset ] = x2 ; <nl> vertexViewF32 [ + + vertexOffset ] = y2 ; <nl> vertexViewF32 [ + + vertexOffset ] = 0 ; <nl> - vertexViewF32 [ + + vertexOffset ] = 0 ; <nl> - vertexViewF32 [ + + vertexOffset ] = 0 . 5 ; <nl> - vertexViewU32 [ + + vertexOffset ] = tint ; <nl> + vertexViewF32 [ + + vertexOffset ] = 1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = 2 ; <nl> + vertexViewU32 [ + + vertexOffset ] = tint2 ; <nl> <nl> vertexViewF32 [ + + vertexOffset ] = x3 ; <nl> vertexViewF32 [ + + vertexOffset ] = y3 ; <nl> - vertexViewF32 [ + + vertexOffset ] = 0 ; <nl> - vertexViewF32 [ + + vertexOffset ] = 0 ; <nl> - vertexViewF32 [ + + vertexOffset ] = 0 . 5 ; <nl> - vertexViewU32 [ + + vertexOffset ] = tint ; <nl> + vertexViewF32 [ + + vertexOffset ] = 1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = 1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = 2 ; <nl> + vertexViewU32 [ + + vertexOffset ] = tint3 ; <nl> <nl> this . vertexCount + = 3 ; <nl> } , <nl> <nl> + / * * <nl> + * Adds the vertices data into the batch and flushes if full . <nl> + * <nl> + * Assumes 6 vertices in the following arrangement : <nl> + * <nl> + * ` ` ` <nl> + * 0mmm - 3 <nl> + * | \\ B | <nl> + * | \\ | <nl> + * | \\ | <nl> + * | A \\ | <nl> + * | \\ <nl> + * 1mmm - 2 <nl> + * ` ` ` <nl> + * <nl> + * Where tx0 / ty0 = 0 , tx1 / ty1 = 1 , tx2 / ty2 = 2 and tx3 / ty3 = 3 <nl> + * <nl> + * @ method Phaser . Renderer . WebGL . Pipelines . TextureTintPipeline # batchVertices <nl> + * @ since 3 . 11 . 0 <nl> + * <nl> + * @ param { number } tx0 - The top - left x position . <nl> + * @ param { number } ty0 - The top - left y position . <nl> + * @ param { number } tx1 - The bottom - left x position . <nl> + * @ param { number } ty1 - The bottom - left y position . <nl> + * @ param { number } tx2 - The bottom - right x position . <nl> + * @ param { number } ty2 - The bottom - right y position . <nl> + * @ param { number } tx3 - The top - right x position . <nl> + * @ param { number } ty3 - The top - right y position . <nl> + * @ param { number } u0 - UV u0 value . <nl> + * @ param { number } v0 - UV v0 value . <nl> + * @ param { number } u1 - UV u1 value . <nl> + * @ param { number } v1 - UV v1 value . <nl> + * @ param { number } tintTL - The top - left tint color value . <nl> + * @ param { number } tintTR - The top - right tint color value . <nl> + * @ param { number } tintBL - The bottom - left tint color value . <nl> + * @ param { number } tintBR - The bottom - right tint color value . <nl> + * @ param { ( number | boolean ) } tintEffect - The tint effect for the shader to use . <nl> + * <nl> + * @ return { boolean } ` true ` if this method caused the batch to flush , otherwise ` false ` . <nl> + * / <nl> + batchQuad : function ( tx0 , ty0 , tx1 , ty1 , tx2 , ty2 , tx3 , ty3 , u0 , v0 , u1 , v1 , tintTL , tintTR , tintBL , tintBR , tintEffect ) <nl> + { <nl> + var hasFlushed = false ; <nl> + <nl> + if ( this . vertexCount + 6 > this . vertexCapacity ) <nl> + { <nl> + this . flush ( ) ; <nl> + <nl> + hasFlushed = true ; <nl> + } <nl> + <nl> + var vertexViewF32 = this . vertexViewF32 ; <nl> + var vertexViewU32 = this . vertexViewU32 ; <nl> + <nl> + var vertexOffset = ( this . vertexCount * this . vertexComponentCount ) - 1 ; <nl> + <nl> + vertexViewF32 [ + + vertexOffset ] = tx0 ; <nl> + vertexViewF32 [ + + vertexOffset ] = ty0 ; <nl> + vertexViewF32 [ + + vertexOffset ] = u0 ; <nl> + vertexViewF32 [ + + vertexOffset ] = v0 ; <nl> + vertexViewF32 [ + + vertexOffset ] = tintEffect ; <nl> + vertexViewU32 [ + + vertexOffset ] = tintTL ; <nl> + <nl> + vertexViewF32 [ + + vertexOffset ] = tx1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = ty1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = u0 ; <nl> + vertexViewF32 [ + + vertexOffset ] = v1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = tintEffect ; <nl> + vertexViewU32 [ + + vertexOffset ] = tintBL ; <nl> + <nl> + vertexViewF32 [ + + vertexOffset ] = tx2 ; <nl> + vertexViewF32 [ + + vertexOffset ] = ty2 ; <nl> + vertexViewF32 [ + + vertexOffset ] = u1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = v1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = tintEffect ; <nl> + vertexViewU32 [ + + vertexOffset ] = tintBR ; <nl> + <nl> + vertexViewF32 [ + + vertexOffset ] = tx0 ; <nl> + vertexViewF32 [ + + vertexOffset ] = ty0 ; <nl> + vertexViewF32 [ + + vertexOffset ] = u0 ; <nl> + vertexViewF32 [ + + vertexOffset ] = v0 ; <nl> + vertexViewF32 [ + + vertexOffset ] = tintEffect ; <nl> + vertexViewU32 [ + + vertexOffset ] = tintTL ; <nl> + <nl> + vertexViewF32 [ + + vertexOffset ] = tx2 ; <nl> + vertexViewF32 [ + + vertexOffset ] = ty2 ; <nl> + vertexViewF32 [ + + vertexOffset ] = u1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = v1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = tintEffect ; <nl> + vertexViewU32 [ + + vertexOffset ] = tintBR ; <nl> + <nl> + vertexViewF32 [ + + vertexOffset ] = tx3 ; <nl> + vertexViewF32 [ + + vertexOffset ] = ty3 ; <nl> + vertexViewF32 [ + + vertexOffset ] = u1 ; <nl> + vertexViewF32 [ + + vertexOffset ] = v0 ; <nl> + vertexViewF32 [ + + vertexOffset ] = tintEffect ; <nl> + vertexViewU32 [ + + vertexOffset ] = tintTR ; <nl> + <nl> + this . vertexCount + = 6 ; <nl> + <nl> + if ( this . vertexCapacity - this . vertexCount < 6 ) <nl> + { <nl> + / / No more room at the inn <nl> + this . flush ( ) ; <nl> + <nl> + hasFlushed = true ; <nl> + } <nl> + <nl> + return hasFlushed ; <nl> + } , <nl> + <nl> / * * <nl> * Pushes a rectangle into the vertex batch <nl> * <nl> var FlatTintPipeline = new Class ( { <nl> var tx3 = calcMatrix . getX ( xw , y ) ; <nl> var ty3 = calcMatrix . getY ( xw , y ) ; <nl> <nl> - / / var tx0 = x * calcMatrix . a + y * calcMatrix . c + calcMatrix . e ; <nl> - / / var ty0 = x * calcMatrix . b + y * calcMatrix . d + calcMatrix . f ; <nl> - <nl> - / / var tx1 = x * calcMatrix . a + yh * calcMatrix . c + calcMatrix . e ; <nl> - / / var ty1 = x * calcMatrix . b + yh * calcMatrix . d + calcMatrix . f ; <nl> - <nl> - / / var tx2 = xw * calcMatrix . a + yh * calcMatrix . c + calcMatrix . e ; <nl> - / / var ty2 = xw * calcMatrix . b + yh * calcMatrix . d + calcMatrix . f ; <nl> - <nl> - / / var tx3 = xw * calcMatrix . a + y * calcMatrix . c + calcMatrix . e ; <nl> - / / var ty3 = xw * calcMatrix . b + y * calcMatrix . d + calcMatrix . f ; <nl> - <nl> - / / var a0 = currentMatrix [ 0 ] ; <nl> - / / var b0 = currentMatrix [ 1 ] ; <nl> - / / var c0 = currentMatrix [ 2 ] ; <nl> - / / var d0 = currentMatrix [ 3 ] ; <nl> - / / var e0 = currentMatrix [ 4 ] ; <nl> - / / var f0 = currentMatrix [ 5 ] ; <nl> - / / var a = a1 * a0 + b1 * c0 ; <nl> - / / var b = a1 * b0 + b1 * d0 ; <nl> - / / var c = c1 * a0 + d1 * c0 ; <nl> - / / var d = c1 * b0 + d1 * d0 ; <nl> - / / var e = e1 * a0 + f1 * c0 + e0 ; <nl> - / / var f = e1 * b0 + f1 * d0 + f0 ; <nl> - / / var tx0 = x * a + y * c + e ; <nl> - / / var ty0 = x * b + y * d + f ; <nl> - / / var tx1 = x * a + yh * c + e ; <nl> - / / var ty1 = x * b + yh * d + f ; <nl> - / / var tx2 = xw * a + yh * c + e ; <nl> - / / var ty2 = xw * b + yh * d + f ; <nl> - / / var tx3 = xw * a + y * c + e ; <nl> - / / var ty3 = xw * b + y * d + f ; <nl> - <nl> var tint = Utils . getTintAppendFloatAlphaAndSwap ( fillColor , fillAlpha ) ; <nl> <nl> this . batchTri ( tx0 , ty0 , tx1 , ty1 , tx2 , ty2 , tint ) ; <nl> var FlatTintPipeline = new Class ( { <nl> var tx2 = calcMatrix . getX ( x2 , y2 ) ; <nl> var ty2 = calcMatrix . getY ( x2 , y2 ) ; <nl> <nl> - / / var tx0 = x0 * calcMatrix . a + y0 * calcMatrix . c + calcMatrix . e ; <nl> - / / var ty0 = x0 * calcMatrix . b + y0 * calcMatrix . d + calcMatrix . f ; <nl> - <nl> - / / var tx1 = x1 * calcMatrix . a + y1 * calcMatrix . c + calcMatrix . e ; <nl> - / / var ty1 = x1 * calcMatrix . b + y1 * calcMatrix . d + calcMatrix . f ; <nl> - <nl> - / / var tx2 = x2 * calcMatrix . a + y2 * calcMatrix . c + calcMatrix . e ; <nl> - / / var ty2 = x2 * calcMatrix . b + y2 * calcMatrix . d + calcMatrix . f ; <nl> - <nl> - / / var a0 = currentMatrix [ 0 ] ; <nl> - / / var b0 = currentMatrix [ 1 ] ; <nl> - / / var c0 = currentMatrix [ 2 ] ; <nl> - / / var d0 = currentMatrix [ 3 ] ; <nl> - / / var e0 = currentMatrix [ 4 ] ; <nl> - / / var f0 = currentMatrix [ 5 ] ; <nl> - / / var a = a1 * a0 + b1 * c0 ; <nl> - / / var b = a1 * b0 + b1 * d0 ; <nl> - / / var c = c1 * a0 + d1 * c0 ; <nl> - / / var d = c1 * b0 + d1 * d0 ; <nl> - / / var e = e1 * a0 + f1 * c0 + e0 ; <nl> - / / var f = e1 * b0 + f1 * d0 + f0 ; <nl> - / / var tx0 = x0 * a + y0 * c + e ; <nl> - / / var ty0 = x0 * b + y0 * d + f ; <nl> - / / var tx1 = x1 * a + y1 * c + e ; <nl> - / / var ty1 = x1 * b + y1 * d + f ; <nl> - / / var tx2 = x2 * a + y2 * c + e ; <nl> - / / var ty2 = x2 * b + y2 * d + f ; <nl> - <nl> var tint = Utils . getTintAppendFloatAlphaAndSwap ( fillColor , fillAlpha ) ; <nl> <nl> this . batchTri ( tx0 , ty0 , tx1 , ty1 , tx2 , ty2 , tint ) ; <nl> var FlatTintPipeline = new Class ( { <nl> * @ param { number } f1 - Matrix stack top f component <nl> * @ param { Float32Array } currentMatrix - Parent matrix , generally used by containers <nl> * / <nl> - batchFillPath : function ( srcX , srcY , srcScaleX , srcScaleY , srcRotation , path , fillColor , fillAlpha , a1 , b1 , c1 , d1 , e1 , f1 , currentMatrix ) <nl> + batchFillPath : function ( path , fillColor , fillAlpha , currentMatrix , parentMatrix ) <nl> { <nl> this . renderer . setPipeline ( this ) ; <nl> <nl> + var calcMatrix = this . _tempMatrix3 ; <nl> + <nl> + / / Multiply and store result in calcMatrix <nl> + parentMatrix . multiply ( currentMatrix , calcMatrix ) ; <nl> + <nl> var length = path . length ; <nl> var polygonCache = this . polygonCache ; <nl> var polygonIndexArray ; <nl> var point ; <nl> - var v0 , v1 , v2 ; <nl> - var x0 , y0 , x1 , y1 , x2 , y2 ; <nl> - var tx0 , ty0 , tx1 , ty1 , tx2 , ty2 ; <nl> - var a0 = currentMatrix [ 0 ] ; <nl> - var b0 = currentMatrix [ 1 ] ; <nl> - var c0 = currentMatrix [ 2 ] ; <nl> - var d0 = currentMatrix [ 3 ] ; <nl> - var e0 = currentMatrix [ 4 ] ; <nl> - var f0 = currentMatrix [ 5 ] ; <nl> - var a = a1 * a0 + b1 * c0 ; <nl> - var b = a1 * b0 + b1 * d0 ; <nl> - var c = c1 * a0 + d1 * c0 ; <nl> - var d = c1 * b0 + d1 * d0 ; <nl> - var e = e1 * a0 + f1 * c0 + e0 ; <nl> - var f = e1 * b0 + f1 * d0 + f0 ; <nl> + <nl> var tint = Utils . getTintAppendFloatAlphaAndSwap ( fillColor , fillAlpha ) ; <nl> <nl> for ( var pathIndex = 0 ; pathIndex < length ; + + pathIndex ) <nl> var FlatTintPipeline = new Class ( { <nl> <nl> for ( var index = 0 ; index < length ; index + = 3 ) <nl> { <nl> - v0 = polygonIndexArray [ index + 0 ] * 2 ; <nl> - v1 = polygonIndexArray [ index + 1 ] * 2 ; <nl> - v2 = polygonIndexArray [ index + 2 ] * 2 ; <nl> + var v0 = polygonIndexArray [ index + 0 ] * 2 ; <nl> + var v1 = polygonIndexArray [ index + 1 ] * 2 ; <nl> + var v2 = polygonIndexArray [ index + 2 ] * 2 ; <nl> + <nl> + var x0 = polygonCache [ v0 + 0 ] ; <nl> + var y0 = polygonCache [ v0 + 1 ] ; <nl> + var x1 = polygonCache [ v1 + 0 ] ; <nl> + var y1 = polygonCache [ v1 + 1 ] ; <nl> + var x2 = polygonCache [ v2 + 0 ] ; <nl> + var y2 = polygonCache [ v2 + 1 ] ; <nl> + <nl> + var tx0 = calcMatrix . getX ( x0 , y0 ) ; <nl> + var ty0 = calcMatrix . getY ( x0 , y0 ) ; <nl> + <nl> + var tx1 = calcMatrix . getX ( x1 , y1 ) ; <nl> + var ty1 = calcMatrix . getY ( x1 , y1 ) ; <nl> + <nl> + var tx2 = calcMatrix . getX ( x2 , y2 ) ; <nl> + var ty2 = calcMatrix . getY ( x2 , y2 ) ; <nl> <nl> if ( this . vertexCount + 3 > this . vertexCapacity ) <nl> { <nl> this . flush ( ) ; <nl> } <nl> <nl> - x0 = polygonCache [ v0 + 0 ] ; <nl> - y0 = polygonCache [ v0 + 1 ] ; <nl> - x1 = polygonCache [ v1 + 0 ] ; <nl> - y1 = polygonCache [ v1 + 1 ] ; <nl> - x2 = polygonCache [ v2 + 0 ] ; <nl> - y2 = polygonCache [ v2 + 1 ] ; <nl> - <nl> - tx0 = x0 * a + y0 * c + e ; <nl> - ty0 = x0 * b + y0 * d + f ; <nl> - tx1 = x1 * a + y1 * c + e ; <nl> - ty1 = x1 * b + y1 * d + f ; <nl> - tx2 = x2 * a + y2 * c + e ; <nl> - ty2 = x2 * b + y2 * d + f ; <nl> - <nl> this . batchTri ( tx0 , ty0 , tx1 , ty1 , tx2 , ty2 , tint ) ; <nl> } <nl> <nl> var FlatTintPipeline = new Class ( { <nl> * @ param { boolean } isLastPath - Indicates if the path should be closed <nl> * @ param { Float32Array } currentMatrix - Parent matrix , generally used by containers <nl> * / <nl> - batchStrokePath : function ( srcX , srcY , srcScaleX , srcScaleY , srcRotation , path , lineWidth , lineColor , lineAlpha , a , b , c , d , e , f , isLastPath , currentMatrix ) <nl> + batchStrokePath : function ( path , lineWidth , lineColor , lineAlpha , isLastPath , currentMatrix , parentMatrix ) <nl> { <nl> this . renderer . setPipeline ( this ) ; <nl> <nl> - var point0 , point1 ; <nl> var pathLength = path . length ; <nl> - var polylines = this . polygonCache ; <nl> - var last , curr ; <nl> - var line ; <nl> - var getTint = Utils . getTintAppendFloatAlphaAndSwap ; <nl> <nl> - for ( var pathIndex = 0 ; pathIndex + 1 < pathLength ; pathIndex + = 1 ) <nl> + for ( var pathIndex = 0 ; pathIndex + 1 < pathLength ; pathIndex + + ) <nl> { <nl> - point0 = path [ pathIndex ] ; <nl> - point1 = path [ pathIndex + 1 ] ; <nl> - <nl> - line = this . batchLine ( <nl> - srcX , srcY , srcScaleX , srcScaleY , srcRotation , <nl> - point0 . x , point0 . y , <nl> - point1 . x , point1 . y , <nl> - point0 . width / 2 , point1 . width / 2 , <nl> - point0 . rgb , point1 . rgb , lineAlpha , <nl> - a , b , c , d , e , f , <nl> - currentMatrix <nl> + var point0 = path [ pathIndex ] ; <nl> + var point1 = path [ pathIndex + 1 ] ; <nl> + <nl> + this . batchLine ( <nl> + point0 . x , <nl> + point0 . y , <nl> + point1 . x , <nl> + point1 . y , <nl> + point0 . width / 2 , <nl> + point1 . width / 2 , <nl> + point0 . rgb , <nl> + point1 . rgb , <nl> + lineAlpha , <nl> + currentMatrix , <nl> + parentMatrix , <nl> + true <nl> ) ; <nl> <nl> - polylines . push ( line ) ; <nl> + / / Render joint <nl> + if ( pathIndex > 0 ) <nl> + { <nl> + / / var prev = this . prevQuad ; <nl> + } <nl> } <nl> <nl> / * Render joints * / <nl> + / * <nl> for ( var index = 1 , polylinesLength = polylines . length ; index < polylinesLength ; + + index ) <nl> { <nl> if ( this . vertexCount + 6 > this . vertexCapacity ) <nl> var FlatTintPipeline = new Class ( { <nl> } <nl> <nl> polylines . length = 0 ; <nl> + * / <nl> } , <nl> <nl> / * * <nl> var FlatTintPipeline = new Class ( { <nl> * @ param { number } f1 - Matrix stack top f component <nl> * @ param { Float32Array } currentMatrix - Parent matrix , generally used by containers <nl> * / <nl> - batchLine : function ( srcX , srcY , srcScaleX , srcScaleY , srcRotation , ax , ay , bx , by , aLineWidth , bLineWidth , aLineColor , bLineColor , lineAlpha , a1 , b1 , c1 , d1 , e1 , f1 , currentMatrix ) <nl> + batchLine : function ( ax , ay , bx , by , aLineWidth , bLineWidth , aLineColor , bLineColor , lineAlpha , currentMatrix , parentMatrix , save ) <nl> { <nl> this . renderer . setPipeline ( this ) ; <nl> <nl> + var calcMatrix = this . _tempMatrix3 ; <nl> + <nl> + / / Multiply and store result in calcMatrix <nl> + parentMatrix . multiply ( currentMatrix , calcMatrix ) ; <nl> + <nl> if ( this . vertexCount + 6 > this . vertexCapacity ) <nl> { <nl> this . flush ( ) ; <nl> } <nl> <nl> - var a0 = currentMatrix [ 0 ] ; <nl> - var b0 = currentMatrix [ 1 ] ; <nl> - var c0 = currentMatrix [ 2 ] ; <nl> - var d0 = currentMatrix [ 3 ] ; <nl> - var e0 = currentMatrix [ 4 ] ; <nl> - var f0 = currentMatrix [ 5 ] ; <nl> - var a = a1 * a0 + b1 * c0 ; <nl> - var b = a1 * b0 + b1 * d0 ; <nl> - var c = c1 * a0 + d1 * c0 ; <nl> - var d = c1 * b0 + d1 * d0 ; <nl> - var e = e1 * a0 + f1 * c0 + e0 ; <nl> - var f = e1 * b0 + f1 * d0 + f0 ; <nl> var dx = bx - ax ; <nl> var dy = by - ay ; <nl> + <nl> var len = Math . sqrt ( dx * dx + dy * dy ) ; <nl> var al0 = aLineWidth * ( by - ay ) / len ; <nl> var al1 = aLineWidth * ( ax - bx ) / len ; <nl> var bl0 = bLineWidth * ( by - ay ) / len ; <nl> var bl1 = bLineWidth * ( ax - bx ) / len ; <nl> + <nl> var lx0 = bx - bl0 ; <nl> var ly0 = by - bl1 ; <nl> var lx1 = ax - al0 ; <nl> var FlatTintPipeline = new Class ( { <nl> var ly2 = by + bl1 ; <nl> var lx3 = ax + al0 ; <nl> var ly3 = ay + al1 ; <nl> - var x0 = lx0 * a + ly0 * c + e ; <nl> - var y0 = lx0 * b + ly0 * d + f ; <nl> - var x1 = lx1 * a + ly1 * c + e ; <nl> - var y1 = lx1 * b + ly1 * d + f ; <nl> - var x2 = lx2 * a + ly2 * c + e ; <nl> - var y2 = lx2 * b + ly2 * d + f ; <nl> - var x3 = lx3 * a + ly3 * c + e ; <nl> - var y3 = lx3 * b + ly3 * d + f ; <nl> - var getTint = Utils . getTintAppendFloatAlphaAndSwap ; <nl> - var aTint = getTint ( aLineColor , lineAlpha ) ; <nl> - var bTint = getTint ( bLineColor , lineAlpha ) ; <nl> - <nl> - this . batchVertex ( x0 , y0 , bTint ) ; <nl> - this . batchVertex ( x1 , y1 , aTint ) ; <nl> - this . batchVertex ( x2 , y2 , bTint ) ; <nl> - this . batchVertex ( x1 , y1 , aTint ) ; <nl> - this . batchVertex ( x3 , y3 , aTint ) ; <nl> - this . batchVertex ( x2 , y2 , bTint ) ; <nl> - <nl> - return [ <nl> - x0 , y0 , bLineColor , <nl> - x1 , y1 , aLineColor , <nl> - x2 , y2 , bLineColor , <nl> - x3 , y3 , aLineColor <nl> - ] ; <nl> + <nl> + / / tx0 = bottom right <nl> + var tx0 = calcMatrix . getX ( lx0 , ly0 ) ; <nl> + var ty0 = calcMatrix . getY ( lx0 , ly0 ) ; <nl> + <nl> + / / tx1 = bottom left <nl> + var tx1 = calcMatrix . getX ( lx1 , ly1 ) ; <nl> + var ty1 = calcMatrix . getY ( lx1 , ly1 ) ; <nl> + <nl> + / / tx2 = top right <nl> + var tx2 = calcMatrix . getX ( lx2 , ly2 ) ; <nl> + var ty2 = calcMatrix . getY ( lx2 , ly2 ) ; <nl> + <nl> + / / tx3 = top left <nl> + var tx3 = calcMatrix . getX ( lx3 , ly3 ) ; <nl> + var ty3 = calcMatrix . getY ( lx3 , ly3 ) ; <nl> + <nl> + var aTint = Utils . getTintAppendFloatAlphaAndSwap ( aLineColor , lineAlpha ) ; <nl> + var bTint = Utils . getTintAppendFloatAlphaAndSwap ( bLineColor , lineAlpha ) ; <nl> + <nl> + this . batchQuad ( tx3 , ty3 , tx1 , ty1 , tx0 , ty0 , tx2 , ty2 , 0 , 0 , 1 , 1 , aTint , bTint , aTint , bTint , 2 ) ; <nl> + <nl> + / / Store it <nl> + if ( save ) <nl> + { <nl> + var prev = this . prevQuad ; <nl> + <nl> + prev [ 0 ] = tx0 ; <nl> + prev [ 1 ] = ty0 ; <nl> + prev [ 2 ] = bLineColor ; <nl> + prev [ 3 ] = tx1 ; <nl> + prev [ 4 ] = ty1 ; <nl> + prev [ 5 ] = aLineColor ; <nl> + prev [ 6 ] = tx2 ; <nl> + prev [ 7 ] = ty2 ; <nl> + prev [ 8 ] = bLineColor ; <nl> + prev [ 9 ] = tx3 ; <nl> + prev [ 10 ] = ty3 ; <nl> + prev [ 11 ] = aLineColor ; <nl> + } <nl> } , <nl> <nl> / * * <nl> var FlatTintPipeline = new Class ( { <nl> var graphicsMatrix = this . _tempMatrix2 ; <nl> var calcMatrix = this . _tempMatrix3 ; <nl> var currentMatrix = this . _tempMatrix4 ; <nl> - <nl> - / / var parentMatrix = null ; <nl> - <nl> - / / if ( parentTransformMatrix ) <nl> - / / { <nl> - / / parentMatrix = parentTransformMatrix . matrix ; <nl> - / / } <nl> - <nl> + <nl> this . renderer . setPipeline ( this ) ; <nl> <nl> currentMatrix . loadIdentity ( ) ; <nl> var FlatTintPipeline = new Class ( { <nl> camMatrix . multiply ( graphicsMatrix ) ; <nl> } <nl> <nl> - / / var cameraScrollX = camera . scrollX * graphics . scrollFactorX ; <nl> - / / var cameraScrollY = camera . scrollY * graphics . scrollFactorY ; <nl> - / / var srcX = graphics . x ; <nl> - / / var srcY = graphics . y ; <nl> - / / var srcScaleX = graphics . scaleX ; <nl> - / / var srcScaleY = graphics . scaleY ; <nl> - / / var srcRotation = graphics . rotation ; <nl> var commands = graphics . commandBuffer ; <nl> var alpha = camera . alpha * graphics . alpha ; <nl> var lineAlpha = 1 . 0 ; <nl> var FlatTintPipeline = new Class ( { <nl> var lineColor = 0 ; <nl> var fillColor = 0 ; <nl> var lineWidth = 1 . 0 ; <nl> - / / var cameraMatrix = camera . matrix . matrix ; <nl> var lastPath = null ; <nl> var iteration = 0 ; <nl> var iterStep = 0 . 01 ; <nl> var FlatTintPipeline = new Class ( { <nl> var radius = 0 ; <nl> var startAngle = 0 ; <nl> var endAngle = 0 ; <nl> - var path = null ; <nl> - / / var sin = Math . sin ; <nl> - / / var cos = Math . cos ; <nl> - / / var sr = sin ( srcRotation ) ; <nl> - / / var cr = cos ( srcRotation ) ; <nl> - / / var sra = cr * srcScaleX ; <nl> - / / var srb = sr * srcScaleX ; <nl> - / / var src = - sr * srcScaleY ; <nl> - / / var srd = cr * srcScaleY ; <nl> - / / var sre = srcX ; <nl> - / / var srf = srcY ; <nl> - / / var cma = cameraMatrix [ 0 ] ; <nl> - / / var cmb = cameraMatrix [ 1 ] ; <nl> - / / var cmc = cameraMatrix [ 2 ] ; <nl> - / / var cmd = cameraMatrix [ 3 ] ; <nl> - / / var cme = cameraMatrix [ 4 ] ; <nl> - / / var cmf = cameraMatrix [ 5 ] ; <nl> - / / var mva , mvb , mvc , mvd , mve , mvf ; <nl> - <nl> - / / if ( parentMatrix ) <nl> - / / { <nl> - / / var pma = parentMatrix [ 0 ] ; <nl> - / / var pmb = parentMatrix [ 1 ] ; <nl> - / / var pmc = parentMatrix [ 2 ] ; <nl> - / / var pmd = parentMatrix [ 3 ] ; <nl> - / / var pme = parentMatrix [ 4 ] ; <nl> - / / var pmf = parentMatrix [ 5 ] ; <nl> - / / var cse = - cameraScrollX ; <nl> - / / var csf = - cameraScrollY ; <nl> - / / var pse = cse * cma + csf * cmc + cme ; <nl> - / / var psf = cse * cmb + csf * cmd + cmf ; <nl> - / / var pca = pma * cma + pmb * cmc ; <nl> - / / var pcb = pma * cmb + pmb * cmd ; <nl> - / / var pcc = pmc * cma + pmd * cmc ; <nl> - / / var pcd = pmc * cmb + pmd * cmd ; <nl> - / / var pce = pme * cma + pmf * cmc + pse ; <nl> - / / var pcf = pme * cmb + pmf * cmd + psf ; <nl> - <nl> - / / mva = sra * pca + srb * pcc ; <nl> - / / mvb = sra * pcb + srb * pcd ; <nl> - / / mvc = src * pca + srd * pcc ; <nl> - / / mvd = src * pcb + srd * pcd ; <nl> - / / mve = sre * pca + srf * pcc + pce ; <nl> - / / mvf = sre * pcb + srf * pcd + pcf ; <nl> - / / } <nl> - / / else <nl> - / / { <nl> - / / sre - = cameraScrollX ; <nl> - / / srf - = cameraScrollY ; <nl> - <nl> - / / mva = sra * cma + srb * cmc ; <nl> - / / mvb = sra * cmb + srb * cmd ; <nl> - / / mvc = src * cma + srd * cmc ; <nl> - / / mvd = src * cmb + srd * cmd ; <nl> - / / mve = sre * cma + srf * cmc + cme ; <nl> - / / mvf = sre * cmb + srf * cmd + cmf ; <nl> - / / } <nl> - <nl> - var pathArrayIndex ; <nl> - var pathArrayLength ; <nl> - var cmd ; <nl> <nl> - pathArray . length = 0 ; <nl> + var cmd ; <nl> + var path = [ ] ; <nl> + var pathIndex = 0 ; <nl> <nl> for ( var cmdIndex = 0 , cmdLength = commands . length ; cmdIndex < cmdLength ; + + cmdIndex ) <nl> { <nl> var FlatTintPipeline = new Class ( { <nl> <nl> switch ( cmd ) <nl> { <nl> + case Commands . BEGIN_PATH : <nl> + path . length = 0 ; <nl> + lastPath = null ; <nl> + break ; <nl> + <nl> + case Commands . CLOSE_PATH : <nl> + if ( lastPath & & lastPath . points . length ) <nl> + { <nl> + lastPath . points . push ( lastPath . points [ 0 ] ) ; <nl> + } <nl> + break ; <nl> + <nl> + case Commands . FILL_PATH : <nl> + for ( pathIndex = 0 ; pathIndex < path . length ; pathIndex + + ) <nl> + { <nl> + this . batchFillPath ( <nl> + path [ pathIndex ] . points , <nl> + fillColor , <nl> + fillAlpha * alpha , <nl> + currentMatrix , <nl> + camMatrix <nl> + ) ; <nl> + } <nl> + break ; <nl> + <nl> + case Commands . STROKE_PATH : <nl> + for ( pathIndex = 0 ; pathIndex < path . length ; pathIndex + + ) <nl> + { <nl> + this . batchStrokePath ( <nl> + path [ pathIndex ] . points , <nl> + lineWidth , <nl> + lineColor , <nl> + lineAlpha * alpha , <nl> + true , <nl> + currentMatrix , <nl> + camMatrix <nl> + ) ; <nl> + } <nl> + break ; <nl> + <nl> case Commands . LINE_STYLE : <nl> lineWidth = commands [ + + cmdIndex ] ; <nl> lineColor = commands [ + + cmdIndex ] ; <nl> var FlatTintPipeline = new Class ( { <nl> ) ; <nl> break ; <nl> <nl> - case Commands . SAVE : <nl> + case Commands . LINE_TO : <nl> + if ( lastPath ! = = null ) <nl> + { <nl> + lastPath . points . push ( new Point ( commands [ cmdIndex + 1 ] , commands [ cmdIndex + 2 ] , lineWidth , lineColor , lineAlpha * alpha ) ) ; <nl> + } <nl> + else <nl> + { <nl> + lastPath = new Path ( commands [ cmdIndex + 1 ] , commands [ cmdIndex + 2 ] , lineWidth , lineColor , lineAlpha * alpha ) ; <nl> + path . push ( lastPath ) ; <nl> + } <nl> + cmdIndex + = 2 ; <nl> + break ; <nl> + <nl> + case Commands . MOVE_TO : <nl> + lastPath = new Path ( commands [ cmdIndex + 1 ] , commands [ cmdIndex + 2 ] , lineWidth , lineColor , lineAlpha * alpha ) ; <nl> + path . push ( lastPath ) ; <nl> + cmdIndex + = 2 ; <nl> + break ; <nl> <nl> + case Commands . SAVE : <nl> matrixStack . push ( currentMatrix . copyToArray ( ) ) ; <nl> break ; <nl> <nl> case Commands . RESTORE : <nl> - <nl> currentMatrix . copyFromArray ( matrixStack . pop ( ) ) ; <nl> break ; <nl> <nl> + case Commands . TRANSLATE : <nl> + x = commands [ + + cmdIndex ] ; <nl> + y = commands [ + + cmdIndex ] ; <nl> + currentMatrix . translate ( x , y ) ; <nl> + break ; <nl> + <nl> + case Commands . SCALE : <nl> + x = commands [ + + cmdIndex ] ; <nl> + y = commands [ + + cmdIndex ] ; <nl> + currentMatrix . scale ( x , y ) ; <nl> + break ; <nl> + <nl> + case Commands . ROTATE : <nl> + var r = commands [ + + cmdIndex ] ; <nl> + currentMatrix . rotate ( r ) ; <nl> + break ; <nl> + <nl> } <nl> <nl> / * * <nl> var FlatTintPipeline = new Class ( { <nl> cmdIndex + = 6 ; <nl> break ; <nl> <nl> - case Commands . LINE_STYLE : <nl> - lineWidth = commands [ cmdIndex + 1 ] ; <nl> - lineColor = commands [ cmdIndex + 2 ] ; <nl> - lineAlpha = commands [ cmdIndex + 3 ] ; <nl> - cmdIndex + = 3 ; <nl> - break ; <nl> - <nl> - case Commands . FILL_STYLE : <nl> - fillColor = commands [ cmdIndex + 1 ] ; <nl> - fillAlpha = commands [ cmdIndex + 2 ] ; <nl> - cmdIndex + = 2 ; <nl> - break ; <nl> - <nl> - case Commands . BEGIN_PATH : <nl> - pathArray . length = 0 ; <nl> - lastPath = null ; <nl> - break ; <nl> - <nl> - case Commands . CLOSE_PATH : <nl> - if ( lastPath & & lastPath . points . length ) <nl> - { <nl> - lastPath . points . push ( lastPath . points [ 0 ] ) ; <nl> - } <nl> - break ; <nl> - <nl> - case Commands . FILL_PATH : <nl> - for ( pathArrayIndex = 0 , pathArrayLength = pathArray . length ; <nl> - pathArrayIndex < pathArrayLength ; <nl> - + + pathArrayIndex ) <nl> - { <nl> - this . batchFillPath ( <nl> - <nl> - srcX , srcY , srcScaleX , srcScaleY , srcRotation , <nl> - <nl> - pathArray [ pathArrayIndex ] . points , <nl> - fillColor , <nl> - fillAlpha * alpha , <nl> - <nl> - mva , mvb , mvc , mvd , mve , mvf , <nl> - currentMatrix <nl> - ) ; <nl> - } <nl> - break ; <nl> <nl> case Commands . STROKE_PATH : <nl> for ( pathArrayIndex = 0 , pathArrayLength = pathArray . length ; <nl> var FlatTintPipeline = new Class ( { <nl> ) ; <nl> } <nl> break ; <nl> - <nl> - case Commands . FILL_RECT : <nl> - this . batchFillRect ( <nl> - <nl> - commands [ cmdIndex + 1 ] , <nl> - commands [ cmdIndex + 2 ] , <nl> - commands [ cmdIndex + 3 ] , <nl> - commands [ cmdIndex + 4 ] , <nl> - fillColor , <nl> - fillAlpha * alpha , <nl> - <nl> - mva , mvb , mvc , mvd , mve , mvf , <nl> - currentMatrix <nl> - ) ; <nl> - <nl> - cmdIndex + = 4 ; <nl> - break ; <nl> - <nl> - case Commands . FILL_TRIANGLE : <nl> - this . batchFillTriangle ( <nl> - <nl> - srcX , srcY , srcScaleX , srcScaleY , srcRotation , <nl> - <nl> - commands [ cmdIndex + 1 ] , <nl> - commands [ cmdIndex + 2 ] , <nl> - commands [ cmdIndex + 3 ] , <nl> - commands [ cmdIndex + 4 ] , <nl> - commands [ cmdIndex + 5 ] , <nl> - commands [ cmdIndex + 6 ] , <nl> - fillColor , <nl> - fillAlpha * alpha , <nl> - <nl> - mva , mvb , mvc , mvd , mve , mvf , <nl> - currentMatrix <nl> - ) ; <nl> - <nl> - cmdIndex + = 6 ; <nl> - break ; <nl> + <nl> <nl> case Commands . STROKE_TRIANGLE : <nl> this . batchStrokeTriangle ( <nl> var FlatTintPipeline = new Class ( { <nl> cmdIndex + = 6 ; <nl> break ; <nl> <nl> - case Commands . LINE_TO : <nl> - if ( lastPath ! = = null ) <nl> - { <nl> - lastPath . points . push ( new Point ( commands [ cmdIndex + 1 ] , commands [ cmdIndex + 2 ] , lineWidth , lineColor , lineAlpha * alpha ) ) ; <nl> - } <nl> - else <nl> - { <nl> - lastPath = new Path ( commands [ cmdIndex + 1 ] , commands [ cmdIndex + 2 ] , lineWidth , lineColor , lineAlpha * alpha ) ; <nl> - pathArray . push ( lastPath ) ; <nl> - } <nl> - cmdIndex + = 2 ; <nl> - break ; <nl> - <nl> - case Commands . MOVE_TO : <nl> - lastPath = new Path ( commands [ cmdIndex + 1 ] , commands [ cmdIndex + 2 ] , lineWidth , lineColor , lineAlpha * alpha ) ; <nl> - pathArray . push ( lastPath ) ; <nl> - cmdIndex + = 2 ; <nl> - break ; <nl> - <nl> case Commands . LINE_FX_TO : <nl> if ( lastPath ! = = null ) <nl> { <nl> var FlatTintPipeline = new Class ( { <nl> pathArray . push ( lastPath ) ; <nl> cmdIndex + = 5 ; <nl> break ; <nl> - <nl> - case Commands . SAVE : <nl> - matrixStack [ matrixStackLength + 0 ] = currentMatrix [ 0 ] ; <nl> - matrixStack [ matrixStackLength + 1 ] = currentMatrix [ 1 ] ; <nl> - matrixStack [ matrixStackLength + 2 ] = currentMatrix [ 2 ] ; <nl> - matrixStack [ matrixStackLength + 3 ] = currentMatrix [ 3 ] ; <nl> - matrixStack [ matrixStackLength + 4 ] = currentMatrix [ 4 ] ; <nl> - matrixStack [ matrixStackLength + 5 ] = currentMatrix [ 5 ] ; <nl> - matrixStackLength + = 6 ; <nl> - break ; <nl> - <nl> - case Commands . RESTORE : <nl> - matrixStackLength - = 6 ; <nl> - currentMatrix [ 0 ] = matrixStack [ matrixStackLength + 0 ] ; <nl> - currentMatrix [ 1 ] = matrixStack [ matrixStackLength + 1 ] ; <nl> - currentMatrix [ 2 ] = matrixStack [ matrixStackLength + 2 ] ; <nl> - currentMatrix [ 3 ] = matrixStack [ matrixStackLength + 3 ] ; <nl> - currentMatrix [ 4 ] = matrixStack [ matrixStackLength + 4 ] ; <nl> - currentMatrix [ 5 ] = matrixStack [ matrixStackLength + 5 ] ; <nl> - break ; <nl> - <nl> - case Commands . TRANSLATE : <nl> - x = commands [ cmdIndex + 1 ] ; <nl> - y = commands [ cmdIndex + 2 ] ; <nl> - currentMatrix [ 4 ] = currentMatrix [ 0 ] * x + currentMatrix [ 2 ] * y + currentMatrix [ 4 ] ; <nl> - currentMatrix [ 5 ] = currentMatrix [ 1 ] * x + currentMatrix [ 3 ] * y + currentMatrix [ 5 ] ; <nl> - cmdIndex + = 2 ; <nl> - break ; <nl> - <nl> - case Commands . SCALE : <nl> - x = commands [ cmdIndex + 1 ] ; <nl> - y = commands [ cmdIndex + 2 ] ; <nl> - currentMatrix [ 0 ] * = x ; <nl> - currentMatrix [ 1 ] * = x ; <nl> - currentMatrix [ 2 ] * = y ; <nl> - currentMatrix [ 3 ] * = y ; <nl> - cmdIndex + = 2 ; <nl> - break ; <nl> - <nl> - case Commands . ROTATE : <nl> - y = commands [ cmdIndex + 1 ] ; <nl> - x = Math . sin ( y ) ; <nl> - y = Math . cos ( y ) ; <nl> - sra = currentMatrix [ 0 ] ; <nl> - srb = currentMatrix [ 1 ] ; <nl> - src = currentMatrix [ 2 ] ; <nl> - srd = currentMatrix [ 3 ] ; <nl> - currentMatrix [ 0 ] = y * sra + x * src ; <nl> - currentMatrix [ 1 ] = y * srb + x * srd ; <nl> - currentMatrix [ 2 ] = - x * sra + y * src ; <nl> - currentMatrix [ 3 ] = - x * srb + y * srd ; <nl> - cmdIndex + = 1 ; <nl> - break ; <nl> - <nl> - default : <nl> - / / eslint - disable - next - line no - console <nl> - console . error ( ' Phaser : Invalid Graphics Command ID ' + cmd ) ; <nl> - break ; <nl> } <nl> * / <nl> } <nl>\n", "msg": "Updated path drawing , sorting out line - cap differences with Canvas\n", "score": 1}
{"diff_id": 4343, "repo": "redux-saga/redux-saga\n", "sha": "1847d7d40b020784525304061f55d92b466135b1\n", "time": "2017-10-29T23:14:31Z\n", "diff": "mmm a / src / internal / io . js <nl> ppp b / src / internal / io . js <nl> const TEST_HINT = <nl> const effect = ( type , payload ) = > ( { [ IO ] : true , [ type ] : payload } ) <nl> <nl> export const detach = eff = > { <nl> - check ( asEffect . fork ( eff ) , is . object , ' detach ( eff ) : argument must be a fork effect ' ) <nl> + if ( process . env . NODE_ENV = = = ' development ' ) { <nl> + check ( asEffect . fork ( eff ) , is . object , ' detach ( eff ) : argument must be a fork effect ' ) <nl> + } <nl> eff [ FORK ] . detached = true <nl> return eff <nl> } <nl> export function cancel ( . . . tasks ) { <nl> <nl> export function select ( selector = identity , . . . args ) { <nl> if ( process . env . NODE_ENV = = = ' development ' & & arguments . length ) { <nl> - check ( arguments [ 0 ] , is . notUndef , ' select ( selector , [ . . . ] ) : argument selector is undefined ' ) <nl> - check ( selector , is . func , ` select ( selector , [ . . . ] ) : argument $ { selector } is not a function ` ) <nl> + check ( arguments [ 0 ] , is . notUndef , ' select ( selector , [ . . . ] ) : argument selector is undefined ' ) <nl> + check ( selector , is . func , ` select ( selector , [ . . . ] ) : argument $ { selector } is not a function ` ) <nl> } <nl> return effect ( SELECT , { selector , args } ) <nl> } <nl> <nl> / * * <nl> - channel ( pattern , [ buffer ] ) = > creates an event channel for store actions <nl> + channel ( pattern , [ buffer ] ) = > creates a proxy channel for store actions <nl> * * / <nl> export function actionChannel ( pattern , buffer ) { <nl> if ( process . env . NODE_ENV = = = ' development ' ) { <nl>\n", "msg": "Hid 1 more runtime check under development - only branch\n", "score": 1}
{"diff_id": 4770, "repo": "lodash/lodash\n", "sha": "da782398a26d4cf0f5e7f4ae655ab24296a3f1fd\n", "time": "2013-09-29T00:13:24Z\n", "diff": "mmm a / test / test . js <nl> ppp b / test / test . js <nl> <nl> / * * Detects if running in a PhantomJS web page * / <nl> var isPhantomPage = typeof callPhantom = = ' function ' ; <nl> <nl> + / * * Detect if running in Rhino * / <nl> + var isRhino = root . java & & typeof global = = ' function ' & & global ( ) . Array = = = root . Array ; <nl> + <nl> / * * Use a single \" load \" function * / <nl> var load = ! amd & & typeof require = = ' function ' ? require : root . load ; <nl> <nl> <nl> <nl> ( function ( ) { <nl> test ( ' subsequent \" immediate \" debounced calls return the last ` func ` result ' , function ( ) { <nl> - var debounced = _ . debounce ( _ . identity , 32 , true ) , <nl> - result = [ debounced ( ' x ' ) , debounced ( ' y ' ) ] ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var debounced = _ . debounce ( _ . identity , 32 , true ) , <nl> + result = [ debounced ( ' x ' ) , debounced ( ' y ' ) ] ; <nl> <nl> - deepEqual ( result , [ ' x ' , ' x ' ] ) ; <nl> + deepEqual ( result , [ ' x ' , ' x ' ] ) ; <nl> + } <nl> + else { <nl> + skipTest ( ) ; <nl> + } <nl> } ) ; <nl> <nl> asyncTest ( ' subsequent debounced calls return the last ` func ` result ' , function ( ) { <nl> - var debounced = _ . debounce ( _ . identity , 32 ) ; <nl> - debounced ( ' x ' ) ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var debounced = _ . debounce ( _ . identity , 32 ) ; <nl> + debounced ( ' x ' ) ; <nl> <nl> - setTimeout ( function ( ) { <nl> - equal ( debounced ( ' y ' ) , ' x ' ) ; <nl> + setTimeout ( function ( ) { <nl> + equal ( debounced ( ' y ' ) , ' x ' ) ; <nl> + QUnit . start ( ) ; <nl> + } , 64 ) ; <nl> + } <nl> + else { <nl> + skipTest ( ) ; <nl> QUnit . start ( ) ; <nl> - } , 64 ) ; <nl> + } <nl> } ) ; <nl> <nl> asyncTest ( ' should apply default options correctly ' , function ( ) { <nl> - var count = 0 ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var count = 0 ; <nl> <nl> - var debounced = _ . debounce ( function ( value ) { <nl> - count + + ; <nl> - return value ; <nl> - } , 32 , { } ) ; <nl> + var debounced = _ . debounce ( function ( value ) { <nl> + count + + ; <nl> + return value ; <nl> + } , 32 , { } ) ; <nl> <nl> - strictEqual ( debounced ( ' x ' ) , undefined ) ; <nl> + strictEqual ( debounced ( ' x ' ) , undefined ) ; <nl> <nl> - setTimeout ( function ( ) { <nl> - strictEqual ( count , 1 ) ; <nl> + setTimeout ( function ( ) { <nl> + strictEqual ( count , 1 ) ; <nl> + QUnit . start ( ) ; <nl> + } , 64 ) ; <nl> + } <nl> + else { <nl> + skipTest ( 2 ) ; <nl> QUnit . start ( ) ; <nl> - } , 64 ) ; <nl> + } <nl> } ) ; <nl> <nl> asyncTest ( ' should work with ` leading ` option ' , function ( ) { <nl> - var withLeadingAndTrailing , <nl> - counts = [ 0 , 0 , 0 ] ; <nl> - <nl> - _ . forEach ( [ true , { ' leading ' : true } ] , function ( options , index ) { <nl> - var debounced = _ . debounce ( function ( value ) { <nl> - counts [ index ] + + ; <nl> - return value ; <nl> - } , 32 , options ) ; <nl> - <nl> - if ( index = = 1 ) { <nl> - withLeadingAndTrailing = debounced ; <nl> - } <nl> - equal ( debounced ( ' x ' ) , ' x ' ) ; <nl> - } ) ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var withLeadingAndTrailing , <nl> + counts = [ 0 , 0 , 0 ] ; <nl> + <nl> + _ . forEach ( [ true , { ' leading ' : true } ] , function ( options , index ) { <nl> + var debounced = _ . debounce ( function ( value ) { <nl> + counts [ index ] + + ; <nl> + return value ; <nl> + } , 32 , options ) ; <nl> + <nl> + if ( index = = 1 ) { <nl> + withLeadingAndTrailing = debounced ; <nl> + } <nl> + equal ( debounced ( ' x ' ) , ' x ' ) ; <nl> + } ) ; <nl> <nl> - _ . times ( 2 , _ . debounce ( function ( ) { counts [ 2 ] + + ; } , 32 , { ' leading ' : true } ) ) ; <nl> - strictEqual ( counts [ 2 ] , 1 ) ; <nl> + _ . times ( 2 , _ . debounce ( function ( ) { counts [ 2 ] + + ; } , 32 , { ' leading ' : true } ) ) ; <nl> + strictEqual ( counts [ 2 ] , 1 ) ; <nl> <nl> - _ . forEach ( [ false , { ' leading ' : false } ] , function ( options ) { <nl> - var withoutLeading = _ . debounce ( _ . identity , 32 , options ) ; <nl> - strictEqual ( withoutLeading ( ' x ' ) , undefined ) ; <nl> - } ) ; <nl> + _ . forEach ( [ false , { ' leading ' : false } ] , function ( options ) { <nl> + var withoutLeading = _ . debounce ( _ . identity , 32 , options ) ; <nl> + strictEqual ( withoutLeading ( ' x ' ) , undefined ) ; <nl> + } ) ; <nl> <nl> - setTimeout ( function ( ) { <nl> - deepEqual ( counts , [ 1 , 1 , 2 ] ) ; <nl> + setTimeout ( function ( ) { <nl> + deepEqual ( counts , [ 1 , 1 , 2 ] ) ; <nl> <nl> - withLeadingAndTrailing ( ' x ' ) ; <nl> - equal ( counts [ 1 ] , 2 ) ; <nl> + withLeadingAndTrailing ( ' x ' ) ; <nl> + equal ( counts [ 1 ] , 2 ) ; <nl> <nl> + QUnit . start ( ) ; <nl> + } , 64 ) ; <nl> + } <nl> + else { <nl> + skipTest ( 5 ) ; <nl> QUnit . start ( ) ; <nl> - } , 64 ) ; <nl> + } <nl> } ) ; <nl> <nl> asyncTest ( ' should work with ` trailing ` option ' , function ( ) { <nl> - var withCount = 0 , <nl> - withoutCount = 0 ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var withCount = 0 , <nl> + withoutCount = 0 ; <nl> <nl> - var withTrailing = _ . debounce ( function ( value ) { <nl> - withCount + + ; <nl> - return value ; <nl> - } , 32 , { ' trailing ' : true } ) ; <nl> + var withTrailing = _ . debounce ( function ( value ) { <nl> + withCount + + ; <nl> + return value ; <nl> + } , 32 , { ' trailing ' : true } ) ; <nl> <nl> - var withoutTrailing = _ . debounce ( function ( value ) { <nl> - withoutCount + + ; <nl> - return value ; <nl> - } , 32 , { ' trailing ' : false } ) ; <nl> + var withoutTrailing = _ . debounce ( function ( value ) { <nl> + withoutCount + + ; <nl> + return value ; <nl> + } , 32 , { ' trailing ' : false } ) ; <nl> <nl> - strictEqual ( withTrailing ( ' x ' ) , undefined ) ; <nl> - strictEqual ( withoutTrailing ( ' x ' ) , undefined ) ; <nl> + strictEqual ( withTrailing ( ' x ' ) , undefined ) ; <nl> + strictEqual ( withoutTrailing ( ' x ' ) , undefined ) ; <nl> <nl> - setTimeout ( function ( ) { <nl> - strictEqual ( withCount , 1 ) ; <nl> - strictEqual ( withoutCount , 0 ) ; <nl> + setTimeout ( function ( ) { <nl> + strictEqual ( withCount , 1 ) ; <nl> + strictEqual ( withoutCount , 0 ) ; <nl> + QUnit . start ( ) ; <nl> + } , 64 ) ; <nl> + } <nl> + else { <nl> + skipTest ( 4 ) ; <nl> QUnit . start ( ) ; <nl> - } , 64 ) ; <nl> + } <nl> } ) ; <nl> <nl> asyncTest ( ' should work with ` maxWait ` option ' , function ( ) { <nl> - var limit = 100 , <nl> - withCount = 0 , <nl> - withoutCount = 0 ; <nl> - <nl> - var withMaxWait = _ . debounce ( function ( ) { <nl> - withCount + + ; <nl> - } , 32 , { ' maxWait ' : 64 } ) ; <nl> - <nl> - var withoutMaxWait = _ . debounce ( function ( ) { <nl> - withoutCount + + ; <nl> - } , 32 ) ; <nl> - <nl> - var start = new Date ; <nl> - while ( ( new Date - start ) < limit ) { <nl> - withMaxWait ( ) ; <nl> - withoutMaxWait ( ) ; <nl> - } <nl> - strictEqual ( withCount , 1 ) ; <nl> - strictEqual ( withoutCount , 0 ) ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var limit = 100 , <nl> + withCount = 0 , <nl> + withoutCount = 0 ; <nl> + <nl> + var withMaxWait = _ . debounce ( function ( ) { <nl> + withCount + + ; <nl> + } , 32 , { ' maxWait ' : 64 } ) ; <nl> + <nl> + var withoutMaxWait = _ . debounce ( function ( ) { <nl> + withoutCount + + ; <nl> + } , 32 ) ; <nl> <nl> - var lastWithCount = withCount , <nl> - lastWithoutCount = withoutCount ; <nl> + var start = new Date ; <nl> + while ( ( new Date - start ) < limit ) { <nl> + withMaxWait ( ) ; <nl> + withoutMaxWait ( ) ; <nl> + } <nl> + strictEqual ( withCount , 1 ) ; <nl> + strictEqual ( withoutCount , 0 ) ; <nl> <nl> - setTimeout ( function ( ) { <nl> - ok ( withCount > lastWithCount ) ; <nl> - ok ( withoutCount > lastWithoutCount & & withoutCount < withCount ) ; <nl> + var lastWithCount = withCount , <nl> + lastWithoutCount = withoutCount ; <nl> + <nl> + setTimeout ( function ( ) { <nl> + ok ( withCount > lastWithCount ) ; <nl> + ok ( withoutCount > lastWithoutCount & & withoutCount < withCount ) ; <nl> + QUnit . start ( ) ; <nl> + } , 64 ) ; <nl> + } <nl> + else { <nl> + skipTest ( 4 ) ; <nl> QUnit . start ( ) ; <nl> - } , 64 ) ; <nl> + } <nl> } ) ; <nl> } ( ) ) ; <nl> <nl> <nl> <nl> ( function ( ) { <nl> asyncTest ( ' should accept additional arguments ' , function ( ) { <nl> - _ . defer ( function ( ) { <nl> - deepEqual ( slice . call ( arguments ) , [ 1 , 2 , 3 ] ) ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + _ . defer ( function ( ) { <nl> + deepEqual ( slice . call ( arguments ) , [ 1 , 2 , 3 ] ) ; <nl> + QUnit . start ( ) ; <nl> + } , 1 , 2 , 3 ) ; <nl> + } else { <nl> + skipTest ( ) ; <nl> QUnit . start ( ) ; <nl> - } , 1 , 2 , 3 ) ; <nl> + } <nl> } ) ; <nl> } ( ) ) ; <nl> <nl> <nl> <nl> ( function ( ) { <nl> test ( ' subsequent calls should return the result of the first call ' , function ( ) { <nl> - var throttled = _ . throttle ( function ( value ) { return value ; } , 32 ) , <nl> - result = [ throttled ( ' x ' ) , throttled ( ' y ' ) ] ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var throttled = _ . throttle ( function ( value ) { return value ; } , 32 ) , <nl> + result = [ throttled ( ' x ' ) , throttled ( ' y ' ) ] ; <nl> <nl> - deepEqual ( result , [ ' x ' , ' x ' ] ) ; <nl> + deepEqual ( result , [ ' x ' , ' x ' ] ) ; <nl> + } <nl> + else { <nl> + skipTest ( ) ; <nl> + } <nl> } ) ; <nl> <nl> test ( ' should clear timeout when ` func ` is called ' , function ( ) { <nl> <nl> } ) ; <nl> <nl> asyncTest ( ' supports recursive calls ' , function ( ) { <nl> - var count = 0 ; <nl> - var throttled = _ . throttle ( function ( ) { <nl> - count + + ; <nl> - if ( count < 10 ) { <nl> - throttled ( ) ; <nl> - } <nl> - } , 32 ) ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var count = 0 ; <nl> + var throttled = _ . throttle ( function ( ) { <nl> + count + + ; <nl> + if ( count < 10 ) { <nl> + throttled ( ) ; <nl> + } <nl> + } , 32 ) ; <nl> <nl> - throttled ( ) ; <nl> - equal ( count , 1 ) ; <nl> + throttled ( ) ; <nl> + equal ( count , 1 ) ; <nl> <nl> - setTimeout ( function ( ) { <nl> - ok ( count < 3 ) <nl> + setTimeout ( function ( ) { <nl> + ok ( count < 3 ) <nl> + QUnit . start ( ) ; <nl> + } , 32 ) ; <nl> + } <nl> + else { <nl> + skipTest ( 2 ) ; <nl> QUnit . start ( ) ; <nl> - } , 32 ) ; <nl> + } <nl> } ) ; <nl> <nl> asyncTest ( ' should not trigger a trailing call when invoked once ' , function ( ) { <nl> - var count = 0 , <nl> - throttled = _ . throttle ( function ( ) { count + + ; } , 32 ) ; <nl> - <nl> - throttled ( ) ; <nl> - equal ( count , 1 ) ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var count = 0 , <nl> + throttled = _ . throttle ( function ( ) { count + + ; } , 32 ) ; <nl> <nl> - setTimeout ( function ( ) { <nl> + throttled ( ) ; <nl> equal ( count , 1 ) ; <nl> + <nl> + setTimeout ( function ( ) { <nl> + equal ( count , 1 ) ; <nl> + QUnit . start ( ) ; <nl> + } , 96 ) ; <nl> + } <nl> + else { <nl> + skipTest ( 2 ) ; <nl> QUnit . start ( ) ; <nl> - } , 96 ) ; <nl> + } <nl> } ) ; <nl> <nl> _ . times ( 2 , function ( index ) { <nl> asyncTest ( ' should trigger trailing call when invoked repeatedly ' + ( index ? ' and ` leading ` is ` false ` ' : ' ' ) , function ( ) { <nl> - var count = 0 , <nl> - limit = 160 , <nl> - options = index ? { ' leading ' : false } : { } , <nl> - throttled = _ . throttle ( function ( ) { count + + ; } , 64 , options ) , <nl> - start = new Date ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var count = 0 , <nl> + limit = 160 , <nl> + options = index ? { ' leading ' : false } : { } , <nl> + throttled = _ . throttle ( function ( ) { count + + ; } , 64 , options ) , <nl> + start = new Date ; <nl> + <nl> + while ( ( new Date - start ) < limit ) { <nl> + throttled ( ) ; <nl> + } <nl> + var lastCount = count ; <nl> + ok ( count > 1 ) ; <nl> <nl> - while ( ( new Date - start ) < limit ) { <nl> - throttled ( ) ; <nl> + setTimeout ( function ( ) { <nl> + ok ( count > lastCount ) ; <nl> + QUnit . start ( ) ; <nl> + } , 96 ) ; <nl> } <nl> - var lastCount = count ; <nl> - ok ( count > 1 ) ; <nl> - <nl> - setTimeout ( function ( ) { <nl> - ok ( count > lastCount ) ; <nl> + else { <nl> + skipTest ( 2 ) ; <nl> QUnit . start ( ) ; <nl> - } , 96 ) ; <nl> + } <nl> } ) ; <nl> } ) ; <nl> <nl> asyncTest ( ' should apply default options correctly ' , function ( ) { <nl> - var count = 0 ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var count = 0 ; <nl> <nl> - var throttled = _ . throttle ( function ( value ) { <nl> - count + + ; <nl> - return value ; <nl> - } , 32 , { } ) ; <nl> + var throttled = _ . throttle ( function ( value ) { <nl> + count + + ; <nl> + return value ; <nl> + } , 32 , { } ) ; <nl> <nl> - _ . times ( 2 , function ( ) { <nl> - equal ( throttled ( ' x ' ) , ' x ' ) ; <nl> - } ) ; <nl> + _ . times ( 2 , function ( ) { <nl> + equal ( throttled ( ' x ' ) , ' x ' ) ; <nl> + } ) ; <nl> <nl> - setTimeout ( function ( ) { <nl> - strictEqual ( count , 2 ) ; <nl> + setTimeout ( function ( ) { <nl> + strictEqual ( count , 2 ) ; <nl> + QUnit . start ( ) ; <nl> + } , 64 ) ; <nl> + } <nl> + else { <nl> + skipTest ( 3 ) ; <nl> QUnit . start ( ) ; <nl> - } , 64 ) ; <nl> + } <nl> } ) ; <nl> <nl> test ( ' should work with ` leading ` option ' , function ( ) { <nl> - _ . forEach ( [ true , { ' leading ' : true } ] , function ( options ) { <nl> - var withLeading = _ . throttle ( _ . identity , 32 , options ) ; <nl> - equal ( withLeading ( ' x ' ) , ' x ' ) ; <nl> - } ) ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + _ . forEach ( [ true , { ' leading ' : true } ] , function ( options ) { <nl> + var withLeading = _ . throttle ( _ . identity , 32 , options ) ; <nl> + equal ( withLeading ( ' x ' ) , ' x ' ) ; <nl> + } ) ; <nl> <nl> - _ . forEach ( [ false , { ' leading ' : false } ] , function ( options ) { <nl> - var withoutLeading = _ . throttle ( _ . identity , 32 , options ) ; <nl> - strictEqual ( withoutLeading ( ' x ' ) , undefined ) ; <nl> - } ) ; <nl> + _ . forEach ( [ false , { ' leading ' : false } ] , function ( options ) { <nl> + var withoutLeading = _ . throttle ( _ . identity , 32 , options ) ; <nl> + strictEqual ( withoutLeading ( ' x ' ) , undefined ) ; <nl> + } ) ; <nl> + } <nl> + else { <nl> + skipTest ( 4 ) ; <nl> + } <nl> } ) ; <nl> <nl> asyncTest ( ' should work with ` trailing ` option ' , function ( ) { <nl> - var withCount = 0 , <nl> - withoutCount = 0 ; <nl> - <nl> - var withTrailing = _ . throttle ( function ( value ) { <nl> - withCount + + ; <nl> - return value ; <nl> - } , 32 , { ' trailing ' : true } ) ; <nl> - <nl> - var withoutTrailing = _ . throttle ( function ( value ) { <nl> - withoutCount + + ; <nl> - return value ; <nl> - } , 32 , { ' trailing ' : false } ) ; <nl> - <nl> - _ . times ( 2 , function ( ) { <nl> - equal ( withTrailing ( ' x ' ) , ' x ' ) ; <nl> - equal ( withoutTrailing ( ' x ' ) , ' x ' ) ; <nl> - } ) ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var withCount = 0 , <nl> + withoutCount = 0 ; <nl> + <nl> + var withTrailing = _ . throttle ( function ( value ) { <nl> + withCount + + ; <nl> + return value ; <nl> + } , 32 , { ' trailing ' : true } ) ; <nl> <nl> - setTimeout ( function ( ) { <nl> - equal ( withCount , 2 ) ; <nl> - strictEqual ( withoutCount , 1 ) ; <nl> + var withoutTrailing = _ . throttle ( function ( value ) { <nl> + withoutCount + + ; <nl> + return value ; <nl> + } , 32 , { ' trailing ' : false } ) ; <nl> + <nl> + _ . times ( 2 , function ( ) { <nl> + equal ( withTrailing ( ' x ' ) , ' x ' ) ; <nl> + equal ( withoutTrailing ( ' x ' ) , ' x ' ) ; <nl> + } ) ; <nl> + <nl> + setTimeout ( function ( ) { <nl> + equal ( withCount , 2 ) ; <nl> + strictEqual ( withoutCount , 1 ) ; <nl> + QUnit . start ( ) ; <nl> + } , 64 ) ; <nl> + } <nl> + else { <nl> + skipTest ( 6 ) ; <nl> QUnit . start ( ) ; <nl> - } , 64 ) ; <nl> + } <nl> } ) ; <nl> <nl> asyncTest ( ' should not update ` lastCalled ` , at the end of the timeout , when ` trailing ` is ` false ` ' , function ( ) { <nl> - var count = 0 ; <nl> + if ( ! ( isRhino & & isModularize ) ) { <nl> + var count = 0 ; <nl> <nl> - var throttled = _ . throttle ( function ( ) { <nl> - count + + ; <nl> - } , 64 , { ' trailing ' : false } ) ; <nl> + var throttled = _ . throttle ( function ( ) { <nl> + count + + ; <nl> + } , 64 , { ' trailing ' : false } ) ; <nl> <nl> - _ . times ( 2 , throttled ) ; <nl> - setTimeout ( function ( ) { _ . times ( 2 , throttled ) ; } , 100 ) ; <nl> + _ . times ( 2 , throttled ) ; <nl> + setTimeout ( function ( ) { _ . times ( 2 , throttled ) ; } , 100 ) ; <nl> <nl> - setTimeout ( function ( ) { <nl> - equal ( count , 2 ) ; <nl> + setTimeout ( function ( ) { <nl> + equal ( count , 2 ) ; <nl> + QUnit . start ( ) ; <nl> + } , 128 ) ; <nl> + } <nl> + else { <nl> + skipTest ( ) ; <nl> QUnit . start ( ) ; <nl> - } , 128 ) ; <nl> + } <nl> } ) ; <nl> } ( ) ) ; <nl> <nl>\n", "msg": "Allow test . ' s to support ` rhino - require ` with modularized builds .\n", "score": 1}
{"diff_id": 4919, "repo": "codemirror/CodeMirror\n", "sha": "eb3ce5fdf58ad93cbb3cf10c37ddd46c2d813f8d\n", "time": "2011-11-28T12:42:41Z\n", "diff": "mmm a / lib / codemirror . js <nl> ppp b / lib / codemirror . js <nl> var CodeMirror = ( function ( ) { <nl> function updateCursor ( ) { <nl> var head = sel . inverted ? sel . from : sel . to , lh = textHeight ( ) ; <nl> var pos = localCoords ( head , true ) ; <nl> - var globalY = pos . y + displayOffset * textHeight ( ) ; <nl> - inputDiv . style . top = Math . max ( Math . min ( globalY , scroller . offsetHeight ) , 0 ) + \" px \" ; <nl> - inputDiv . style . left = pos . x + \" px \" ; <nl> + var wrapOff = eltOffset ( wrapper ) , lineOff = eltOffset ( lineDiv ) ; <nl> + inputDiv . style . top = ( pos . y + lineOff . top - wrapOff . top ) + \" px \" ; <nl> + inputDiv . style . left = ( pos . x + lineOff . left - wrapOff . left ) + \" px \" ; <nl> if ( posEq ( sel . from , sel . to ) ) { <nl> cursor . style . top = pos . y + \" px \" ; <nl> cursor . style . left = ( options . lineWrapping ? Math . min ( pos . x , lineSpace . offsetWidth ) : pos . x ) + \" px \" ; <nl>\n", "msg": "Be more precise about hidden input placement\n", "score": 1}
{"diff_id": 5654, "repo": "nolimits4web/swiper\n", "sha": "0a60f7e60f7852a2b3503a2944c53b28c796a21d\n", "time": "2015-07-11T20:00:54Z\n", "diff": "mmm a / src / js / core . js <nl> ppp b / src / js / core . js <nl> var defaults = { <nl> slidesPerColumnFill : ' column ' , <nl> slidesPerGroup : 1 , <nl> centeredSlides : false , <nl> + slidesOffsetBefore : 0 , / / in px <nl> + slidesOffsetAfter : 0 , / / in px <nl> / / Round length <nl> roundLengths : false , <nl> / / Touches <nl> s . updateContainerSize = function ( ) { <nl> if ( width = = = 0 & & isH ( ) | | height = = = 0 & & ! isH ( ) ) { <nl> return ; <nl> } <nl> + <nl> + / / Subtract paddings <nl> + width = width - parseInt ( s . container . css ( ' padding - left ' ) , 10 ) - parseInt ( s . container . css ( ' padding - right ' ) , 10 ) ; <nl> + height = height - parseInt ( s . container . css ( ' padding - top ' ) , 10 ) - parseInt ( s . container . css ( ' padding - bottom ' ) , 10 ) ; <nl> + <nl> + / / Store values <nl> s . width = width ; <nl> s . height = height ; <nl> s . size = isH ( ) ? s . width : s . height ; <nl> s . updateSlidesSize = function ( ) { <nl> s . slidesSizesGrid = [ ] ; <nl> <nl> var spaceBetween = s . params . spaceBetween , <nl> - slidePosition = 0 , <nl> + slidePosition = - s . params . slidesOffsetBefore , <nl> i , <nl> prevSlideSize = 0 , <nl> index = 0 ; <nl> s . updateSlidesSize = function ( ) { <nl> <nl> index + + ; <nl> } <nl> - s . virtualSize = Math . max ( s . virtualSize , s . size ) ; <nl> + s . virtualSize = Math . max ( s . virtualSize , s . size ) + s . params . slidesOffsetAfter ; <nl> <nl> var newSlidesGrid ; <nl> <nl>\n", "msg": "Support for slide offsets and padding on container\n", "score": 1}
{"diff_id": 5873, "repo": "meteor/meteor\n", "sha": "12e563664b9b7c68969b7dfccc9cc6ed5eca1856\n", "time": "2016-06-23T15:49:57Z\n", "diff": "mmm a / tools / meteor - services / deploy . js <nl> ppp b / tools / meteor - services / deploy . js <nl> var bundleAndDeploy = function ( options ) { <nl> qs : _ . extend ( { } , options . rawOptions , settings ! = = null ? { settings : settings } : { } ) , <nl> bodyStream : files . createTarGzStream ( files . pathJoin ( buildDir , ' bundle ' ) ) , <nl> expectPayload : [ ' url ' ] , <nl> - preflightPassword : preflight . preflightPassword <nl> + preflightPassword : preflight . preflightPassword , <nl> + / / Disable the HTTP timeout for this POST request . <nl> + timeout : null , <nl> } ) ; <nl> } ) ; <nl> <nl>\n", "msg": "Disable the HTTP timeout for the Galaxy upload POST .\n", "score": 1}
{"diff_id": 5931, "repo": "hexojs/hexo\n", "sha": "3028106fcc795173e20b93108ee78db56a52ca00\n", "time": "2013-01-10T09:18:58Z\n", "diff": "mmm a / lib / tag / code . js <nl> ppp b / lib / tag / code . js <nl> <nl> / / Based on : https : / / raw . github . com / imathis / octopress / master / plugins / code_block . rb <nl> <nl> var extend = require ( ' . . / extend ' ) , <nl> - highlight = require ( ' . . / util ' ) . highlight ; <nl> + highlight = require ( ' . . / util ' ) . highlight , <nl> + config = hexo . config , <nl> + highlightConfig = config . highlight , <nl> + lineNumConfig = highlightConfig ? highlightConfig . line_number : true ; <nl> <nl> var regex = { <nl> captionUrlTitle : / ( \\ S [ \\ S \\ s ] * ) \\ s + ( https ? : \\ / \\ / ) ( \\ S + ) \\ s + ( . + ) / i , <nl> var codeblock = function ( args , content ) { <nl> } <nl> } <nl> <nl> - return highlight ( content , { lang : lang , caption : caption } ) ; <nl> + return highlight ( content , { lang : lang , caption : caption , gutter : lineNumConfig } ) ; <nl> } ; <nl> <nl> extend . tag . register ( ' code ' , codeblock , true ) ; <nl>\n", "msg": "Apply highlight settings to code block tag\n", "score": 1}
{"diff_id": 5952, "repo": "TryGhost/Ghost\n", "sha": "4e664f0e1c55c11b46a89448f14cc9b059fcad06\n", "time": "2014-03-27T20:23:23Z\n", "diff": "mmm a / core / test / functional / api / posts_test . js <nl> ppp b / core / test / functional / api / posts_test . js <nl> describe ( ' Post API ' , function ( ) { <nl> headers : { ' X - CSRF - Token ' : csrfToken } , <nl> json : draftPost } , function ( error , response , publishedPost ) { <nl> response . should . have . status ( 200 ) ; <nl> - response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / ' + publishedPost . slug + ' / ' ) ; <nl> + response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / tag / * , / ' + publishedPost . slug + ' / ' ) ; <nl> response . should . be . json ; <nl> publishedPost . should . exist ; <nl> publishedPost . title . should . eql ( newTitle ) ; <nl> describe ( ' Post API ' , function ( ) { <nl> headers : { ' X - CSRF - Token ' : csrfToken } , <nl> json : publishedPost } , function ( error , response , updatedPost ) { <nl> response . should . have . status ( 200 ) ; <nl> - response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / ' + updatedPost . slug + ' / ' ) ; <nl> + response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / tag / * , / ' + updatedPost . slug + ' / ' ) ; <nl> response . should . be . json ; <nl> updatedPost . should . exist ; <nl> updatedPost . title . should . eql ( newTitle ) ; <nl> describe ( ' Post API ' , function ( ) { <nl> headers : { ' X - CSRF - Token ' : csrfToken } , <nl> json : jsonResponse } , function ( error , response , putBody ) { <nl> response . should . have . status ( 200 ) ; <nl> - response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / ' + putBody . slug + ' / ' ) ; <nl> + response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / tag / * , / ' + putBody . slug + ' / ' ) ; <nl> response . should . be . json ; <nl> putBody . should . exist ; <nl> putBody . title . should . eql ( changedValue ) ; <nl> describe ( ' Post API ' , function ( ) { <nl> headers : { ' X - CSRF - Token ' : csrfToken } , <nl> json : jsonResponse } , function ( error , response , putBody ) { <nl> response . should . have . status ( 200 ) ; <nl> - response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / ' + putBody . slug + ' / ' ) ; <nl> + response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / tag / * , / ' + putBody . slug + ' / ' ) ; <nl> response . should . be . json ; <nl> putBody . should . exist ; <nl> putBody . page . should . eql ( changedValue ) ; <nl> describe ( ' Post API ' , function ( ) { <nl> headers : { ' X - CSRF - Token ' : csrfToken } , <nl> json : jsonResponse } , function ( error , response , putBody ) { <nl> response . should . have . status ( 200 ) ; <nl> - response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / ' + putBody . slug + ' / ' ) ; <nl> + response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / tag / * , / ' + putBody . slug + ' / ' ) ; <nl> response . should . be . json ; <nl> putBody . should . exist ; <nl> putBody . page . should . eql ( changedValue ) ; <nl> describe ( ' Post API ' , function ( ) { <nl> headers : { ' X - CSRF - Token ' : csrfToken } , <nl> json : jsonResponse } , function ( error , response , putBody ) { <nl> response . should . have . status ( 200 ) ; <nl> - response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / ' + putBody . slug + ' / ' ) ; <nl> + response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / tag / * , / ' + putBody . slug + ' / ' ) ; <nl> response . should . be . json ; <nl> putBody . should . exist ; <nl> putBody . title . should . eql ( changedValue ) ; <nl> describe ( ' Post API ' , function ( ) { <nl> response . should . be . json ; <nl> var jsonResponse = JSON . parse ( body ) ; <nl> jsonResponse . should . exist ; <nl> - response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / ' + jsonResponse . slug + ' / ' ) ; <nl> + response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / tag / * , / ' + jsonResponse . slug + ' / ' ) ; <nl> testUtils . API . checkResponse ( jsonResponse , ' post ' ) ; <nl> jsonResponse . id . should . eql ( deletePostId ) ; <nl> done ( ) ; <nl> describe ( ' Post API ' , function ( ) { <nl> postLink = ' / ' + yyyy + ' / ' + mm + ' / ' + dd + ' / ' + putBody . slug + ' / ' ; <nl> <nl> response . should . have . status ( 200 ) ; <nl> - response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , ' + postLink ) ; <nl> + response . headers [ ' x - cache - invalidate ' ] . should . eql ( ' / , / page / * , / rss / , / rss / * , / tag / * , ' + postLink ) ; <nl> response . should . be . json ; <nl> putBody . should . exist ; <nl> putBody . title . should . eql ( changedValue ) ; <nl>\n", "msg": "Fixes tag cache test issues introduced in c6c4d5a8\n", "score": 1}
{"diff_id": 6590, "repo": "ReactTraining/react-router\n", "sha": "54007fd6e424fcce925891a79de6993afc733a32\n", "time": "2016-03-21T21:49:47Z\n", "diff": "mmm a / modules / PatternUtils . js <nl> ppp b / modules / PatternUtils . js <nl> function _compilePattern ( pattern ) { <nl> } <nl> <nl> if ( match [ 1 ] ) { <nl> - regexpSource + = ' ( [ ^ / ? # ] + ) ' <nl> + regexpSource + = ' ( [ ^ / ] + ) ' <nl> paramNames . push ( match [ 1 ] ) <nl> } else if ( match [ 0 ] = = = ' * * ' ) { <nl> regexpSource + = ' ( . * ) ' <nl> export function matchPattern ( pattern , pathname ) { <nl> regexpSource + = ' / * ' / / Capture path separators <nl> <nl> / / Special - case patterns like ' * ' for catch - all routes . <nl> - const captureRemaining = tokens [ tokens . length - 1 ] ! = = ' * ' <nl> - <nl> - if ( captureRemaining ) { <nl> - regexpSource + = ' ( . * ? ) ' <nl> + if ( tokens [ tokens . length - 1 ] = = = ' * ' ) { <nl> + regexpSource + = ' $ ' <nl> } <nl> <nl> - const match = pathname . match ( new RegExp ( ' ^ ' + regexpSource + ' $ ' , ' i ' ) ) <nl> + const match = pathname . match ( new RegExp ( ` ^ $ { regexpSource } ` , ' i ' ) ) <nl> <nl> let remainingPathname , paramValues <nl> if ( match ! = null ) { <nl> - if ( captureRemaining ) { <nl> - remainingPathname = match . pop ( ) <nl> - const matchedPath = <nl> - match [ 0 ] . substr ( 0 , match [ 0 ] . length - remainingPathname . length ) <nl> - <nl> - / / If we didn ' t match the entire pathname , then make sure that the match <nl> - / / we did get ends at a path separator ( potentially the one we added <nl> - / / above at the beginning of the path , if the actual match was empty ) . <nl> - if ( <nl> - remainingPathname & & <nl> - matchedPath . charAt ( matchedPath . length - 1 ) ! = = ' / ' <nl> - ) { <nl> - return { <nl> - remainingPathname : null , <nl> - paramNames , <nl> - paramValues : null <nl> - } <nl> + const matchedPath = match [ 0 ] <nl> + remainingPathname = pathname . substr ( matchedPath . length ) <nl> + <nl> + / / If we didn ' t match the entire pathname , then make sure that the match we <nl> + / / did get ends at a path separator ( potentially the one we added above at <nl> + / / the beginning of the path , if the actual match was empty ) . <nl> + if ( <nl> + remainingPathname & & <nl> + matchedPath . charAt ( matchedPath . length - 1 ) ! = = ' / ' <nl> + ) { <nl> + return { <nl> + remainingPathname : null , <nl> + paramNames , <nl> + paramValues : null <nl> } <nl> - } else { <nl> - / / If this matched at all , then the match was the entire pathname . <nl> - remainingPathname = ' ' <nl> } <nl> <nl> - paramValues = match . slice ( 1 ) . map ( <nl> - v = > v ! = null ? decodeURIComponent ( v ) : v <nl> - ) <nl> + paramValues = match . slice ( 1 ) . map ( v = > v & & decodeURIComponent ( v ) ) <nl> } else { <nl> remainingPathname = paramValues = null <nl> } <nl>\n", "msg": "Further simplify path matching logic\n", "score": 1}
{"diff_id": 7005, "repo": "select2/select2\n", "sha": "43e381ed3740ef5a72d3d2fa496dace89c9c1403\n", "time": "2014-03-06T02:02:06Z\n", "diff": "mmm a / select2 . js <nl> ppp b / select2 . js <nl> the specific language governing permissions and limitations under the Apache Lic <nl> throw new Error ( formatterName + \" must be a string , function , or falsy value \" ) ; <nl> } <nl> <nl> - function evaluate ( val ) { <nl> + / * * <nl> + * Returns a given value <nl> + * If given a function , returns its output <nl> + * <nl> + * @ param val string | function <nl> + * @ param context value of \" this \" to be passed to function <nl> + * @ returns { * } <nl> + * / <nl> + function evaluate ( val , context ) { <nl> if ( $ . isFunction ( val ) ) { <nl> - var args = Array . prototype . slice . call ( arguments , 1 ) ; <nl> - return val . apply ( null , args ) ; <nl> + var args = Array . prototype . slice . call ( arguments , 2 ) ; <nl> + return val . apply ( context , args ) ; <nl> } <nl> return val ; <nl> } <nl> the specific language governing permissions and limitations under the Apache Lic <nl> syncCssClasses ( this . container , this . opts . element , this . opts . adaptContainerCssClass ) ; <nl> <nl> this . container . attr ( \" style \" , opts . element . attr ( \" style \" ) ) ; <nl> - this . container . css ( evaluate ( opts . containerCss ) ) ; <nl> - this . container . addClass ( evaluate ( opts . containerCssClass ) ) ; <nl> + this . container . css ( evaluate ( opts . containerCss , this . opts . element ) ) ; <nl> + this . container . addClass ( evaluate ( opts . containerCssClass , this . opts . element ) ) ; <nl> <nl> this . elementTabIndex = this . opts . element . attr ( \" tabindex \" ) ; <nl> <nl> the specific language governing permissions and limitations under the Apache Lic <nl> <nl> syncCssClasses ( this . dropdown , this . opts . element , this . opts . adaptDropdownCssClass ) ; <nl> <nl> - this . dropdown . addClass ( evaluate ( opts . dropdownCssClass ) ) ; <nl> + this . dropdown . addClass ( evaluate ( opts . dropdownCssClass , this . opts . element ) ) ; <nl> this . dropdown . data ( \" select2 \" , this ) ; <nl> this . dropdown . on ( \" click \" , killEvent ) ; <nl> <nl> the specific language governing permissions and limitations under the Apache Lic <nl> this . readonly ( readonly ) ; <nl> <nl> syncCssClasses ( this . container , this . opts . element , this . opts . adaptContainerCssClass ) ; <nl> - this . container . addClass ( evaluate ( this . opts . containerCssClass ) ) ; <nl> + this . container . addClass ( evaluate ( this . opts . containerCssClass , this . opts . element ) ) ; <nl> <nl> syncCssClasses ( this . dropdown , this . opts . element , this . opts . adaptDropdownCssClass ) ; <nl> - this . dropdown . addClass ( evaluate ( this . opts . dropdownCssClass ) ) ; <nl> + this . dropdown . addClass ( evaluate ( this . opts . dropdownCssClass , this . opts . element ) ) ; <nl> <nl> } ) ; <nl> <nl> the specific language governing permissions and limitations under the Apache Lic <nl> this . container . removeClass ( \" select2 - drop - above \" ) ; <nl> $ dropdown . removeClass ( \" select2 - drop - above \" ) ; <nl> } <nl> - css = $ . extend ( css , evaluate ( this . opts . dropdownCss ) ) ; <nl> + css = $ . extend ( css , evaluate ( this . opts . dropdownCss , this . opts . element ) ) ; <nl> <nl> $ dropdown . css ( css ) ; <nl> } , <nl> the specific language governing permissions and limitations under the Apache Lic <nl> <nl> / / abstract <nl> getMaximumSelectionSize : function ( ) { <nl> - return evaluate ( this . opts . maximumSelectionSize ) ; <nl> + return evaluate ( this . opts . maximumSelectionSize , this . opts . element ) ; <nl> } , <nl> <nl> / / abstract <nl> the specific language governing permissions and limitations under the Apache Lic <nl> self . postprocessResults ( data , false , false ) ; <nl> <nl> if ( data . more = = = true ) { <nl> - more . detach ( ) . appendTo ( results ) . text ( evaluate ( self . opts . formatLoadMore , page + 1 ) ) ; <nl> + more . detach ( ) . appendTo ( results ) . text ( evaluate ( self . opts . formatLoadMore , self . opts . element , page + 1 ) ) ; <nl> window . setTimeout ( function ( ) { self . loadMoreIfNeeded ( ) ; } , 10 ) ; <nl> } else { <nl> more . remove ( ) ; <nl> the specific language governing permissions and limitations under the Apache Lic <nl> if ( maxSelSize > = 1 ) { <nl> data = this . data ( ) ; <nl> if ( $ . isArray ( data ) & & data . length > = maxSelSize & & checkFormatter ( opts . formatSelectionTooBig , \" formatSelectionTooBig \" ) ) { <nl> - render ( \" < li class = ' select2 - selection - limit ' > \" + evaluate ( opts . formatSelectionTooBig , maxSelSize ) + \" < / li > \" ) ; <nl> + render ( \" < li class = ' select2 - selection - limit ' > \" + evaluate ( opts . formatSelectionTooBig , opts . element , maxSelSize ) + \" < / li > \" ) ; <nl> return ; <nl> } <nl> } <nl> <nl> if ( search . val ( ) . length < opts . minimumInputLength ) { <nl> if ( checkFormatter ( opts . formatInputTooShort , \" formatInputTooShort \" ) ) { <nl> - render ( \" < li class = ' select2 - no - results ' > \" + evaluate ( opts . formatInputTooShort , search . val ( ) , opts . minimumInputLength ) + \" < / li > \" ) ; <nl> + render ( \" < li class = ' select2 - no - results ' > \" + evaluate ( opts . formatInputTooShort , opts . element , search . val ( ) , opts . minimumInputLength ) + \" < / li > \" ) ; <nl> } else { <nl> render ( \" \" ) ; <nl> } <nl> the specific language governing permissions and limitations under the Apache Lic <nl> <nl> if ( opts . maximumInputLength & & search . val ( ) . length > opts . maximumInputLength ) { <nl> if ( checkFormatter ( opts . formatInputTooLong , \" formatInputTooLong \" ) ) { <nl> - render ( \" < li class = ' select2 - no - results ' > \" + evaluate ( opts . formatInputTooLong , search . val ( ) , opts . maximumInputLength ) + \" < / li > \" ) ; <nl> + render ( \" < li class = ' select2 - no - results ' > \" + evaluate ( opts . formatInputTooLong , opts . element , search . val ( ) , opts . maximumInputLength ) + \" < / li > \" ) ; <nl> } else { <nl> render ( \" \" ) ; <nl> } <nl> the specific language governing permissions and limitations under the Apache Lic <nl> } <nl> <nl> if ( opts . formatSearching & & this . findHighlightableChoices ( ) . length = = = 0 ) { <nl> - render ( \" < li class = ' select2 - searching ' > \" + evaluate ( opts . formatSearching ) + \" < / li > \" ) ; <nl> + render ( \" < li class = ' select2 - searching ' > \" + evaluate ( opts . formatSearching , opts . element ) + \" < / li > \" ) ; <nl> } <nl> <nl> search . addClass ( \" select2 - active \" ) ; <nl> the specific language governing permissions and limitations under the Apache Lic <nl> } <nl> <nl> if ( data . results . length = = = 0 & & checkFormatter ( opts . formatNoMatches , \" formatNoMatches \" ) ) { <nl> - render ( \" < li class = ' select2 - no - results ' > \" + evaluate ( opts . formatNoMatches , search . val ( ) ) + \" < / li > \" ) ; <nl> + render ( \" < li class = ' select2 - no - results ' > \" + evaluate ( opts . formatNoMatches , opts . element , search . val ( ) ) + \" < / li > \" ) ; <nl> return ; <nl> } <nl> <nl> the specific language governing permissions and limitations under the Apache Lic <nl> self . opts . populateResults . call ( this , results , data . results , { term : search . val ( ) , page : this . resultsPage , context : null } ) ; <nl> <nl> if ( data . more = = = true & & checkFormatter ( opts . formatLoadMore , \" formatLoadMore \" ) ) { <nl> - results . append ( \" < li class = ' select2 - more - results ' > \" + self . opts . escapeMarkup ( evaluate ( opts . formatLoadMore , this . resultsPage ) ) + \" < / li > \" ) ; <nl> + results . append ( \" < li class = ' select2 - more - results ' > \" + opts . escapeMarkup ( evaluate ( opts . formatLoadMore , opts . element , this . resultsPage ) ) + \" < / li > \" ) ; <nl> window . setTimeout ( function ( ) { self . loadMoreIfNeeded ( ) ; } , 10 ) ; <nl> } <nl> <nl> the specific language governing permissions and limitations under the Apache Lic <nl> if ( ! this . opts . createSearchChoice & & ! choices . filter ( ' . select2 - result : not ( . select2 - selected ) ' ) . length > 0 ) { <nl> if ( ! data | | data & & ! data . more & & this . results . find ( \" . select2 - no - results \" ) . length = = = 0 ) { <nl> if ( checkFormatter ( self . opts . formatNoMatches , \" formatNoMatches \" ) ) { <nl> - this . results . append ( \" < li class = ' select2 - no - results ' > \" + evaluate ( self . opts . formatNoMatches , self . search . val ( ) ) + \" < / li > \" ) ; <nl> + this . results . append ( \" < li class = ' select2 - no - results ' > \" + evaluate ( self . opts . formatNoMatches , self . opts . element , self . search . val ( ) ) + \" < / li > \" ) ; <nl> } <nl> } <nl> } <nl>\n", "msg": "Provide context for evaluated functions\n", "score": 1}
{"diff_id": 7458, "repo": "balderdashy/sails\n", "sha": "2724de78c82e81c18011e74a710700a7b6e40634\n", "time": "2017-02-25T01:36:36Z\n", "diff": "mmm a / lib / hooks / http / initialize . js <nl> ppp b / lib / hooks / http / initialize . js <nl> module . exports = function ( sails ) { <nl> <nl> / / Set Express \" trust proxy \" if appropriate . <nl> / / > https : / / expressjs . com / en / guide / behind - proxies . html <nl> - if ( ! _ . isUndefined ( sails . config . http . trustProxy ) ) { <nl> + if ( sails . config . http . trustProxy ) { <nl> expressApp . set ( ' trust proxy ' , sails . config . http . trustProxy ) ; <nl> } <nl> <nl>\n", "msg": "Update to match change made here : https : / / github . com / balderdashy / sails / commit / 2adc0af4e57eaddd48e40ab78af3bd3cf76faab6\n", "score": 1}
{"diff_id": 7859, "repo": "Leaflet/Leaflet\n", "sha": "64333d2dc32e3be605c647e991caa2c3451f20d4\n", "time": "2015-07-22T16:41:01Z\n", "diff": "mmm a / src / layer / vector / Canvas . js <nl> ppp b / src / layer / vector / Canvas . js <nl> L . Canvas = L . Renderer . extend ( { <nl> var container = this . _container = document . createElement ( ' canvas ' ) ; <nl> <nl> L . DomEvent <nl> - . on ( container , ' mousemove ' , L . Util . throttle ( this . _onMouseMove , 66 , this ) , this ) <nl> + . on ( container , ' mousemove ' , L . Util . throttle ( this . _onMouseMove , 32 , this ) , this ) <nl> . on ( container , ' click dblclick mousedown mouseup contextmenu ' , this . _onClick , this ) <nl> . on ( container , ' mouseout ' , this . _handleMouseOut , this ) ; <nl> <nl>\n", "msg": "reduce the throttle for canvas layers\n", "score": 1}
{"diff_id": 7915, "repo": "atom/atom\n", "sha": "aefafdda4a584fc7d19ab8bff02638f8c818af16\n", "time": "2012-08-22T22:36:53Z\n", "diff": "mmm a / src / stdlib / native - handler . js <nl> ppp b / src / stdlib / native - handler . js <nl> <nl> var $ native = { } ; <nl> ( function ( ) { <nl> <nl> - native function exists ( ) ; <nl> + native function exists ( path ) ; <nl> $ native . exists = exists ; <nl> <nl> - native function alert ( ) ; <nl> + native function alert ( message , detailedMessage , buttonNamesAndCallbacks ) ; <nl> $ native . alert = alert ; <nl> <nl> - native function read ( ) ; <nl> + native function read ( path ) ; <nl> $ native . read = read ; <nl> <nl> - native function write ( ) ; <nl> + native function write ( path , content ) ; <nl> $ native . write = write ; <nl> <nl> - native function absolute ( ) ; <nl> + native function absolute ( path ) ; <nl> $ native . absolute = absolute ; <nl> <nl> - native function list ( ) ; <nl> + native function list ( path , recursive ) ; <nl> $ native . list = list ; <nl> <nl> - native function isFile ( ) ; <nl> + native function isFile ( path ) ; <nl> $ native . isFile = isFile ; <nl> <nl> - native function isDirectory ( ) ; <nl> + native function isDirectory ( path ) ; <nl> $ native . isDirectory = isDirectory ; <nl> <nl> - native function remove ( ) ; <nl> + native function remove ( path ) ; <nl> $ native . remove = remove ; <nl> <nl> - native function asyncList ( ) ; <nl> + native function asyncList ( path , recursive , callback ) ; <nl> $ native . asyncList = asyncList ; <nl> <nl> - native function open ( ) ; <nl> + native function open ( path ) ; <nl> $ native . open = open ; <nl> <nl> native function openDialog ( ) ; <nl> var $ native = { } ; <nl> native function quit ( ) ; <nl> $ native . quit = quit ; <nl> <nl> - native function writeToPasteboard ( ) ; <nl> + native function writeToPasteboard ( text ) ; <nl> $ native . writeToPasteboard = writeToPasteboard ; <nl> <nl> native function readFromPasteboard ( ) ; <nl> var $ native = { } ; <nl> native function saveDialog ( ) ; <nl> $ native . saveDialog = saveDialog ; <nl> <nl> - native function exit ( ) ; <nl> + native function exit ( status ) ; <nl> $ native . exit = exit ; <nl> <nl> - native function watchPath ( ) ; <nl> + native function watchPath ( path ) ; <nl> $ native . watchPath = watchPath ; <nl> <nl> - native function unwatchPath ( ) ; <nl> + native function unwatchPath ( path , callbackId ) ; <nl> $ native . unwatchPath = unwatchPath ; <nl> <nl> - native function makeDirectory ( ) ; <nl> + native function makeDirectory ( path ) ; <nl> $ native . makeDirectory = makeDirectory ; <nl> <nl> - native function move ( ) ; <nl> + native function move ( sourcePath , targetPath ) ; <nl> $ native . move = move ; <nl> <nl> - native function moveToTrash ( ) ; <nl> + native function moveToTrash ( path ) ; <nl> $ native . moveToTrash = moveToTrash ; <nl> <nl> native function reload ( ) ; <nl> $ native . reload = reload ; <nl> <nl> - native function lastModified ( ) ; <nl> + native function lastModified ( path ) ; <nl> $ native . lastModified = lastModified ; <nl> <nl> - native function md5ForPath ( ) ; <nl> + native function md5ForPath ( path ) ; <nl> $ native . md5ForPath = md5ForPath ; <nl> <nl> - native function exec ( ) ; <nl> + native function exec ( command , options , callback ) ; <nl> $ native . exec = exec ; <nl> <nl> native function getPlatform ( ) ; <nl>\n", "msg": "Add expected parameters to native function declarations\n", "score": 1}
{"diff_id": 8098, "repo": "request/request\n", "sha": "cd23ef722d7863f767a70b44bbfebbf397a12440\n", "time": "2014-11-18T08:49:50Z\n", "diff": "mmm a / tests / test - multipart . js <nl> ppp b / tests / test - multipart . js <nl> function runTest ( t , a ) { <nl> <nl> if ( a . headers ) { <nl> t . ok ( req . headers [ ' content - type ' ] . match ( / multipart \\ / mixed / ) ) <nl> - } <nl> - else { <nl> + } else { <nl> t . ok ( req . headers [ ' content - type ' ] . match ( / multipart \\ / related / ) ) <nl> } <nl> <nl> + if ( chunked ) { <nl> + t . ok ( req . headers [ ' transfer - encoding ' ] = = = ' chunked ' ) <nl> + t . notOk ( req . headers [ ' content - length ' ] ) <nl> + } else { <nl> + t . ok ( req . headers [ ' content - length ' ] ) <nl> + t . notOk ( req . headers [ ' transfer - encoding ' ] ) <nl> + } <nl> + <nl> / / temp workaround <nl> var data = ' ' <nl> req . setEncoding ( ' utf8 ' ) <nl>\n", "msg": "Add multipart test for transfer - encoding and content - length\n", "score": 1}
{"diff_id": 8240, "repo": "RocketChat/Rocket.Chat\n", "sha": "6b233f222ebe258d1dcc9372fb533ee27a4b39f0\n", "time": "2017-11-23T16:45:08Z\n", "diff": "mmm a / packages / rocketchat - internal - hubot / hubot . js <nl> ppp b / packages / rocketchat - internal - hubot / hubot . js <nl> const InternalHubotReceiver = ( message ) = > { <nl> const enabledForC = RocketChat . settings . get ( ' InternalHubot_EnableForChannels ' ) ; <nl> const enabledForD = RocketChat . settings . get ( ' InternalHubot_EnableForDirectMessages ' ) ; <nl> const enabledForP = RocketChat . settings . get ( ' InternalHubot_EnableForPrivateGroups ' ) ; <nl> + const subscribedToP = RocketChat . models . Subscriptions . findOneByRoomIdAndUserId ( room . _id , InternalHubot . user . _id ) ; <nl> <nl> if ( <nl> ( room . t = = = ' c ' & & enabledForC ) <nl> | | ( room . t = = = ' d ' & & enabledForD ) <nl> - | | ( room . t = = = ' p ' & & enabledForP ) <nl> + | | ( room . t = = = ' p ' & & enabledForP & & subscribedToP ) <nl> ) { <nl> const InternalHubotUser = new Hubot . User ( message . u . username , { room : message . rid } ) ; <nl> const InternalHubotTextMessage = new Hubot . TextMessage ( InternalHubotUser , message . msg , message . _id ) ; <nl>\n", "msg": "Add condition : bot should be subscribed to private groups\n", "score": 1}
{"diff_id": 8368, "repo": "TryGhost/Ghost\n", "sha": "caa121cae5e7b331a5b9e0294935acce1d14f858\n", "time": "2019-09-13T14:24:18Z\n", "diff": "mmm a / core / server / data / schema / commands . js <nl> ppp b / core / server / data / schema / commands . js <nl> function createColumnMigration ( . . . migrations ) { <nl> const hasColumn = await conn . schema . hasColumn ( table , column ) ; <nl> const isInCorrectState = dbIsInCorrectState ( hasColumn ) ; <nl> <nl> - const log = createLog ( isInCorrectState ? ' info ' : ' warn ' ) ; <nl> + const log = createLog ( isInCorrectState ? ' warn ' : ' info ' ) ; <nl> <nl> log ( ` $ { operationVerb } $ { table } . $ { column } ` ) ; <nl> <nl>\n", "msg": "Fixed log usage for columnMigration command\n", "score": 1}
{"diff_id": 8471, "repo": "ajaxorg/ace\n", "sha": "0d8865bcfe7626287bb092c396aab739fcdff275\n", "time": "2014-08-28T02:01:31Z\n", "diff": "mmm a / lib / ace / mode / sql_highlight_rules . js <nl> ppp b / lib / ace / mode / sql_highlight_rules . js <nl> var SqlHighlightRules = function ( ) { <nl> <nl> var keywords = ( <nl> \" select | insert | update | delete | from | where | and | or | group | by | order | limit | offset | having | as | case | \" + <nl> - \" when | else | end | type | left | right | join | on | outer | desc | asc \" <nl> + \" when | else | end | type | left | right | join | on | outer | desc | asc | union \" <nl> ) ; <nl> <nl> var builtinConstants = ( <nl>\n", "msg": "Adding highlight support for the UNION sql keyword\n", "score": 1}
{"diff_id": 8572, "repo": "sahat/hackathon-starter\n", "sha": "70894e1956e95b7db2a17bc291959baabdc8aeb4\n", "time": "2014-04-15T06:38:49Z\n", "diff": "mmm a / config / secrets . js <nl> ppp b / config / secrets . js <nl> module . exports = { <nl> sessionSecret : process . env . SESSION_SECRET | | ' Your Session Secret goes here ' , <nl> <nl> mailgun : { <nl> - login : process . env . MAILGUN_LOGIN | | ' Your Mailgun SMTP Username ' , <nl> - password : process . env . MAILGUN_PASSWORD | | ' Your Mailgun SMTP Password ' <nl> + login : process . env . MAILGUN_LOGIN | | ' postmaster @ sandbox697fcddc09814c6b83718b9fd5d4e5dc . mailgun . org ' , <nl> + password : process . env . MAILGUN_PASSWORD | | ' 29eldds1uri6 ' <nl> } , <nl> <nl> sendgrid : { <nl> - user : process . env . SENDGRID_USER | | ' Your SendGrid Username ' , <nl> - password : process . env . SENDGRID_PASSWORD | | ' Your SendGrid Password ' <nl> + user : process . env . SENDGRID_USER | | ' hslogin ' , <nl> + password : process . env . SENDGRID_PASSWORD | | ' hspassword00 ' <nl> } , <nl> <nl> nyt : { <nl> - key : process . env . NYT_KEY | | ' Your New York Times API Key ' <nl> + key : process . env . NYT_KEY | | ' 9548be6f3a64163d23e1539f067fcabd : 5 : 68537648 ' <nl> } , <nl> <nl> lastfm : { <nl> - api_key : process . env . LASTFM_KEY | | ' Your API Key ' , <nl> - secret : process . env . LASTFM_SECRET | | ' Your API Secret ' <nl> + api_key : process . env . LASTFM_KEY | | ' c8c0ea1c4a6b199b3429722512fbd17f ' , <nl> + secret : process . env . LASTFM_SECRET | | ' is cb7857b8fba83f819ea46ca13681fe71 ' <nl> } , <nl> <nl> facebook : { <nl> - clientID : process . env . FACEBOOK_ID | | ' Your App ID ' , <nl> - clientSecret : process . env . FACEBOOK_SECRET | | ' Your App Secret ' , <nl> + clientID : process . env . FACEBOOK_ID | | ' 754220301289665 ' , <nl> + clientSecret : process . env . FACEBOOK_SECRET | | ' 41860e58c256a3d7ad8267d3c1939a4a ' , <nl> callbackURL : ' / auth / facebook / callback ' , <nl> passReqToCallback : true <nl> } , <nl> <nl> github : { <nl> - clientID : process . env . GITHUB_ID | | ' Your Client ID ' , <nl> - clientSecret : process . env . GITHUB_SECRET | | ' Your Client Secret ' , <nl> + clientID : process . env . GITHUB_ID | | ' cb448b1d4f0c743a1e36 ' , <nl> + clientSecret : process . env . GITHUB_SECRET | | ' 815aa4606f476444691c5f1c16b9c70da6714dc6 ' , <nl> callbackURL : ' / auth / github / callback ' , <nl> passReqToCallback : true <nl> } , <nl> <nl> twitter : { <nl> - consumerKey : process . env . TWITTER_KEY | | ' Your Consumer Key ' , <nl> - consumerSecret : process . env . TWITTER_SECRET | | ' Your Consumer Secret ' , <nl> + consumerKey : process . env . TWITTER_KEY | | ' 6NNBDyJ2TavL407A3lWxPFKBI ' , <nl> + consumerSecret : process . env . TWITTER_SECRET | | ' ZHaYyK3DQCqv49Z9ofsYdqiUgeoICyh6uoBgFfu7OeYC7wTQKa ' , <nl> callbackURL : ' / auth / twitter / callback ' , <nl> passReqToCallback : true <nl> } , <nl> <nl> google : { <nl> - clientID : process . env . GOOGLE_ID | | ' Your Client ID ' , <nl> - clientSecret : process . env . GOOGLE_SECRET | | ' Your Client Secret ' , <nl> + clientID : process . env . GOOGLE_ID | | ' 828110519058 . apps . googleusercontent . com ' , <nl> + clientSecret : process . env . GOOGLE_SECRET | | ' JdZsIaWhUFIchmC1a_IZzOHb ' , <nl> callbackURL : ' / auth / google / callback ' , <nl> passReqToCallback : true <nl> } , <nl> <nl> linkedin : { <nl> - clientID : process . env . LINKEDIN_ID | | ' Your Client ID ' , <nl> - clientSecret : process . env . LINKEDIN_SECRET | | ' Your Client Secret ' , <nl> + clientID : process . env . LINKEDIN_ID | | ' 77chexmowru601 ' , <nl> + clientSecret : process . env . LINKEDIN_SECRET | | ' szdC8lN2s2SuMSy8 ' , <nl> callbackURL : ' / auth / linkedin / callback ' , <nl> scope : [ ' r_fullprofile ' , ' r_emailaddress ' , ' r_network ' ] , <nl> passReqToCallback : true <nl> } , <nl> <nl> steam : { <nl> - apiKey : process . env . STEAM_KEY | | ' Your Steam API Key ' <nl> + apiKey : process . env . STEAM_KEY | | ' D1240DEF4D41D416FD291D0075B6ED3F ' <nl> } , <nl> <nl> twilio : { <nl> - sid : process . env . TWILIO_SID | | ' Your Twilio SID ' , <nl> - token : process . env . TWILIO_TOKEN | | ' Your Twilio token ' <nl> + sid : process . env . TWILIO_SID | | ' AC92e12ae9029e8babae0d9fbb4079b1c1 ' , <nl> + token : process . env . TWILIO_TOKEN | | ' 2470e51c86e40ac49bbb08c00c00539d ' <nl> } , <nl> <nl> clockwork : { <nl> module . exports = { <nl> } , <nl> <nl> tumblr : { <nl> - consumerKey : process . env . TUMBLR_KEY | | ' Your Consumer Key ' , <nl> - consumerSecret : process . env . TUMBLR_SECRET | | ' Your Consumer Secret ' , <nl> + consumerKey : process . env . TUMBLR_KEY | | ' FaXbGf5gkhswzDqSMYI42QCPYoHsu5MIDciAhTyYjehotQpJvM ' , <nl> + consumerSecret : process . env . TUMBLR_SECRET | | ' QpCTs5IMMCsCImwdvFiqyGtIZwowF5o3UXonjPoNp4HVtJAL4o ' , <nl> callbackURL : ' / auth / tumblr / callback ' <nl> } , <nl> <nl> foursquare : { <nl> - clientId : process . env . FOURSQUARE_ID | | ' Your Client ID ' , <nl> - clientSecret : process . env . FOURSQUARE_SECRET | | ' Your Client Secret ' , <nl> + clientId : process . env . FOURSQUARE_ID | | ' 2STROLSFBMZLAHG3IBA141EM2HGRF0IRIBB4KXMOGA2EH3JG ' , <nl> + clientSecret : process . env . FOURSQUARE_SECRET | | ' 2STROLSFBMZLAHG3IBA141EM2HGRF0IRIBB4KXMOGA2EH3JG ' , <nl> redirectUrl : process . env . FOURSQUARE_REDIRECT_URL | | ' http : / / localhost : 3000 / auth / foursquare / callback ' <nl> } , <nl> <nl> venmo : { <nl> - clientId : process . env . VENMO_ID | | ' Your Venmo Client ID ' , <nl> - clientSecret : process . env . VENMO_SECRET | | ' Your Venmo Client Secret ' , <nl> + clientId : process . env . VENMO_ID | | ' 1688 ' , <nl> + clientSecret : process . env . VENMO_SECRET | | ' uQXtNBa6KVphDLAEx8suEush3scX8grs ' , <nl> redirectUrl : process . env . VENMO_REDIRECT_URL | | ' http : / / localhost : 3000 / auth / venmo / callback ' <nl> } <nl> } ; <nl>\n", "msg": "Added \" fake \" api keys to secrets . js to have login and demos work out of the box .\n", "score": 1}
{"diff_id": 8669, "repo": "photonstorm/phaser\n", "sha": "f8b3fcf539153ee4621141b20cc6d0a237194efe\n", "time": "2018-08-21T17:02:00Z\n", "diff": "mmm a / src / tilemaps / components / CullTiles . js <nl> ppp b / src / tilemaps / components / CullTiles . js <nl> var SnapFloor = require ( ' . . / . . / math / snap / SnapFloor ' ) ; <nl> var SnapCeil = require ( ' . . / . . / math / snap / SnapCeil ' ) ; <nl> <nl> / * * <nl> - * Returns the tiles in the given layer that are within the camera ' s viewport . This is used <nl> - * internally . <nl> + * Returns the tiles in the given layer that are within the camera ' s viewport . This is used internally . <nl> * <nl> * @ function Phaser . Tilemaps . Components . CullTiles <nl> * @ private <nl> var SnapCeil = require ( ' . . / . . / math / snap / SnapCeil ' ) ; <nl> * <nl> * @ return { Phaser . Tilemaps . Tile [ ] } An array of Tile objects . <nl> * / <nl> - var CullTiles = function ( layer , camera , outputArray ) <nl> + var CullTiles = function ( layer , camera , outputArray , renderOrder ) <nl> { <nl> if ( outputArray = = = undefined ) { outputArray = [ ] ; } <nl> + if ( renderOrder = = = undefined ) { renderOrder = 0 ; } <nl> <nl> outputArray . length = 0 ; <nl> <nl> var CullTiles = function ( layer , camera , outputArray ) <nl> drawBottom = Math . min ( mapHeight , boundsBottom ) ; <nl> } <nl> <nl> - for ( var y = drawTop ; y < drawBottom ; y + + ) <nl> + var x ; <nl> + var y ; <nl> + var tile ; <nl> + <nl> + if ( renderOrder = = = 0 ) <nl> { <nl> - for ( var x = drawLeft ; x < drawRight ; x + + ) <nl> + / / right - down <nl> + <nl> + for ( y = drawTop ; y < drawBottom ; y + + ) <nl> { <nl> - var tile = mapData [ y ] [ x ] ; <nl> + for ( x = drawLeft ; x < drawRight ; x + + ) <nl> + { <nl> + tile = mapData [ y ] [ x ] ; <nl> + <nl> + if ( ! tile | | tile . index = = = - 1 | | ! tile . visible | | tile . alpha = = = 0 ) <nl> + { <nl> + continue ; <nl> + } <nl> + <nl> + outputArray . push ( tile ) ; <nl> + } <nl> + } <nl> + } <nl> + else if ( renderOrder = = = 1 ) <nl> + { <nl> + / / left - down <nl> <nl> - if ( ! tile | | tile . index = = = - 1 | | ! tile . visible | | tile . alpha = = = 0 ) <nl> + for ( y = drawTop ; y < drawBottom ; y + + ) <nl> + { <nl> + for ( x = drawRight ; x > = drawLeft ; x - - ) <nl> { <nl> - continue ; <nl> + tile = mapData [ y ] [ x ] ; <nl> + <nl> + if ( ! tile | | tile . index = = = - 1 | | ! tile . visible | | tile . alpha = = = 0 ) <nl> + { <nl> + continue ; <nl> + } <nl> + <nl> + outputArray . push ( tile ) ; <nl> } <nl> + } <nl> + } <nl> + else if ( renderOrder = = = 2 ) <nl> + { <nl> + / / right - up <nl> <nl> - outputArray . push ( tile ) ; <nl> + for ( y = drawBottom ; y > = drawTop ; y - - ) <nl> + { <nl> + for ( x = drawLeft ; x < drawRight ; x + + ) <nl> + { <nl> + tile = mapData [ y ] [ x ] ; <nl> + <nl> + if ( ! tile | | tile . index = = = - 1 | | ! tile . visible | | tile . alpha = = = 0 ) <nl> + { <nl> + continue ; <nl> + } <nl> + <nl> + outputArray . push ( tile ) ; <nl> + } <nl> } <nl> } <nl> + else if ( renderOrder = = = 3 ) <nl> + { <nl> + / / left - up <nl> + <nl> + for ( y = drawBottom ; y > = drawTop ; y - - ) <nl> + { <nl> + for ( x = drawRight ; x > = drawLeft ; x - - ) <nl> + { <nl> + tile = mapData [ y ] [ x ] ; <nl> <nl> + if ( ! tile | | tile . index = = = - 1 | | ! tile . visible | | tile . alpha = = = 0 ) <nl> + { <nl> + continue ; <nl> + } <nl> + <nl> + outputArray . push ( tile ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> tilemapLayer . tilesDrawn = outputArray . length ; <nl> tilemapLayer . tilesTotal = mapWidth * mapHeight ; <nl> <nl>\n", "msg": "Cull Tiles now needs a render order for the layer data .\n", "score": 1}
{"diff_id": 9266, "repo": "facebook/react-native\n", "sha": "2424ef5654cffbe8c62465325c4c04eb00b40c01\n", "time": "2018-07-05T22:18:03Z\n", "diff": "mmm a / Libraries / Components / ScrollView / ScrollView . js <nl> ppp b / Libraries / Components / ScrollView / ScrollView . js <nl> type TouchableProps = $ ReadOnly < { | <nl> | } > ; <nl> <nl> type IOSProps = $ ReadOnly < { | <nl> + / * * <nl> + * Controls whether iOS should automatically adjust the content inset <nl> + * for scroll views that are placed behind a navigation bar or <nl> + * tab bar / toolbar . The default value is true . <nl> + * @ platform ios <nl> + * / <nl> automaticallyAdjustContentInsets ? : ? boolean , <nl> + / * * <nl> + * The amount by which the scroll view content is inset from the edges <nl> + * of the scroll view . Defaults to ` { top : 0 , left : 0 , bottom : 0 , right : 0 } ` . <nl> + * @ platform ios <nl> + * / <nl> contentInset ? : ? EdgeInsetsProp , <nl> + / * * <nl> + * Used to manually set the starting scroll offset . <nl> + * The default value is ` { x : 0 , y : 0 } ` . <nl> + * @ platform ios <nl> + * / <nl> contentOffset ? : ? PointProp , <nl> + / * * <nl> + * When true , the scroll view bounces when it reaches the end of the <nl> + * content if the content is larger then the scroll view along the axis of <nl> + * the scroll direction . When false , it disables all bouncing even if <nl> + * the ` alwaysBounce * ` props are true . The default value is true . <nl> + * @ platform ios <nl> + * / <nl> bounces ? : ? boolean , <nl> + / * * <nl> + * When true , gestures can drive zoom past min / max and the zoom will animate <nl> + * to the min / max value at gesture end , otherwise the zoom will not exceed <nl> + * the limits . <nl> + * @ platform ios <nl> + * / <nl> bouncesZoom ? : ? boolean , <nl> + / * * <nl> + * When true , the scroll view bounces horizontally when it reaches the end <nl> + * even if the content is smaller than the scroll view itself . The default <nl> + * value is true when ` horizontal = { true } ` and false otherwise . <nl> + * @ platform ios <nl> + * / <nl> alwaysBounceHorizontal ? : ? boolean , <nl> + / * * <nl> + * When true , the scroll view bounces vertically when it reaches the end <nl> + * even if the content is smaller than the scroll view itself . The default <nl> + * value is false when ` horizontal = { true } ` and true otherwise . <nl> + * @ platform ios <nl> + * / <nl> alwaysBounceVertical ? : ? boolean , <nl> + / * * <nl> + * When true , the scroll view automatically centers the content when the <nl> + * content is smaller than the scroll view bounds ; when the content is <nl> + * larger than the scroll view , this property has no effect . The default <nl> + * value is false . <nl> + * @ platform ios <nl> + * / <nl> centerContent ? : ? boolean , <nl> + / * * <nl> + * A floating - point number that determines how quickly the scroll view <nl> + * decelerates after the user lifts their finger . You may also use string <nl> + * shortcuts ` \" normal \" ` and ` \" fast \" ` which match the underlying iOS settings <nl> + * for ` UIScrollViewDecelerationRateNormal ` and <nl> + * ` UIScrollViewDecelerationRateFast ` respectively . <nl> + * <nl> + * - ` ' normal ' ` : 0 . 998 ( the default ) <nl> + * - ` ' fast ' ` : 0 . 99 <nl> + * <nl> + * @ platform ios <nl> + * / <nl> decelerationRate ? : ? ( ' fast ' | ' normal ' | number ) , <nl> + / * * <nl> + * The style of the scroll indicators . <nl> + * <nl> + * - ` ' default ' ` ( the default ) , same as ` black ` . <nl> + * - ` ' black ' ` , scroll indicator is black . This style is good against a light background . <nl> + * - ` ' white ' ` , scroll indicator is white . This style is good against a dark background . <nl> + * <nl> + * @ platform ios <nl> + * / <nl> indicatorStyle ? : ? ( ' default ' | ' black ' | ' white ' ) , <nl> + / * * <nl> + * When true , the ScrollView will try to lock to only vertical or horizontal <nl> + * scrolling while dragging . The default value is false . <nl> + * @ platform ios <nl> + * / <nl> directionalLockEnabled ? : ? boolean , <nl> + / * * <nl> + * When false , once tracking starts , won ' t try to drag if the touch moves . <nl> + * The default value is true . <nl> + * @ platform ios <nl> + * / <nl> canCancelContentTouches ? : ? boolean , <nl> + / * * <nl> + * When set , the scroll view will adjust the scroll position so that the first child that is <nl> + * currently visible and at or beyond ` minIndexForVisible ` will not change position . This is <nl> + * useful for lists that are loading content in both directions , e . g . a chat thread , where new <nl> + * messages coming in might otherwise cause the scroll position to jump . A value of 0 is common , <nl> + * but other values such as 1 can be used to skip loading spinners or other content that should <nl> + * not maintain position . <nl> + * <nl> + * The optional ` autoscrollToTopThreshold ` can be used to make the content automatically scroll <nl> + * to the top after making the adjustment if the user was within the threshold of the top before <nl> + * the adjustment was made . This is also useful for chat - like applications where you want to see <nl> + * new messages scroll into place , but not if the user has scrolled up a ways and it would be <nl> + * disruptive to scroll a bunch . <nl> + * <nl> + * Caveat 1 : Reordering elements in the scrollview with this enabled will probably cause <nl> + * jumpiness and jank . It can be fixed , but there are currently no plans to do so . For now , <nl> + * don ' t re - order the content of any ScrollViews or Lists that use this feature . <nl> + * <nl> + * Caveat 2 : This simply uses ` contentOffset ` and ` frame . origin ` in native code to compute <nl> + * visibility . Occlusion , transforms , and other complexity won ' t be taken into account as to <nl> + * whether content is \" visible \" or not . <nl> + * <nl> + * @ platform ios <nl> + * / <nl> maintainVisibleContentPosition ? : ? $ ReadOnly < { | <nl> minIndexForVisible : number , <nl> autoscrollToTopThreshold ? : ? number , <nl> | } > , <nl> + / * * <nl> + * The maximum allowed zoom scale . The default value is 1 . 0 . <nl> + * @ platform ios <nl> + * / <nl> maximumZoomScale ? : ? number , <nl> + / * * <nl> + * The minimum allowed zoom scale . The default value is 1 . 0 . <nl> + * @ platform ios <nl> + * / <nl> minimumZoomScale ? : ? number , <nl> + / * * <nl> + * When true , ScrollView allows use of pinch gestures to zoom in and out . <nl> + * The default value is true . <nl> + * @ platform ios <nl> + * / <nl> pinchGestureEnabled ? : ? boolean , <nl> + / * * <nl> + * This controls how often the scroll event will be fired while scrolling <nl> + * ( as a time interval in ms ) . A lower number yields better accuracy for code <nl> + * that is tracking the scroll position , but can lead to scroll performance <nl> + * problems due to the volume of information being send over the bridge . <nl> + * You will not notice a difference between values set between 1 - 16 as the <nl> + * JS run loop is synced to the screen refresh rate . If you do not need precise <nl> + * scroll position tracking , set this value higher to limit the information <nl> + * being sent across the bridge . The default value is zero , which results in <nl> + * the scroll event being sent only once each time the view is scrolled . <nl> + * @ platform ios <nl> + * / <nl> scrollEventThrottle ? : ? number , <nl> + / * * <nl> + * The amount by which the scroll view indicators are inset from the edges <nl> + * of the scroll view . This should normally be set to the same value as <nl> + * the ` contentInset ` . Defaults to ` { 0 , 0 , 0 , 0 } ` . <nl> + * @ platform ios <nl> + * / <nl> scrollIndicatorInsets ? : ? EdgeInsetsProp , <nl> + / * * <nl> + * When true , the scroll view scrolls to top when the status bar is tapped . <nl> + * The default value is true . <nl> + * @ platform ios <nl> + * / <nl> scrollsToTop ? : ? boolean , <nl> + / * * <nl> + * When true , shows a horizontal scroll indicator . <nl> + * The default value is true . <nl> + * / <nl> showsHorizontalScrollIndicator ? : ? boolean , <nl> + / * * <nl> + * When ` snapToInterval ` is set , ` snapToAlignment ` will define the relationship <nl> + * of the snapping to the scroll view . <nl> + * <nl> + * - ` ' start ' ` ( the default ) will align the snap at the left ( horizontal ) or top ( vertical ) <nl> + * - ` ' center ' ` will align the snap in the center <nl> + * - ` ' end ' ` will align the snap at the right ( horizontal ) or bottom ( vertical ) <nl> + * <nl> + * @ platform ios <nl> + * / <nl> snapToAlignment ? : ? ( ' start ' | ' center ' | ' end ' ) , <nl> + / * * <nl> + * The current scale of the scroll view content . The default value is 1 . 0 . <nl> + * @ platform ios <nl> + * / <nl> zoomScale ? : ? number , <nl> + / * * <nl> + * This property specifies how the safe area insets are used to modify the <nl> + * content area of the scroll view . The default value of this property is <nl> + * \" never \" . Available on iOS 11 and later . <nl> + * @ platform ios <nl> + * / <nl> contentInsetAdjustmentBehavior ? : ? ( <nl> | ' automatic ' <nl> | ' scrollableAxes ' <nl> | ' never ' <nl> | ' always ' <nl> ) , <nl> + / * * <nl> + * When true , ScrollView will emit updateChildFrames data in scroll events , <nl> + * otherwise will not compute or emit child frame data . This only exists <nl> + * to support legacy issues , ` onLayout ` should be used instead to retrieve <nl> + * frame data . <nl> + * The default value is false . <nl> + * @ platform ios <nl> + * / <nl> DEPRECATED_sendUpdatedChildFrames ? : ? boolean , <nl> | } > ; <nl> <nl> type AndroidProps = $ ReadOnly < { | <nl> + / * * <nl> + * Enables nested scrolling for Android API level 21 + . <nl> + * Nested scrolling is supported by default on iOS <nl> + * @ platform android <nl> + * / <nl> nestedScrollEnabled ? : ? boolean , <nl> + / * * <nl> + * Sometimes a scrollview takes up more space than its content fills . When this is <nl> + * the case , this prop will fill the rest of the scrollview with a color to avoid setting <nl> + * a background and creating unnecessary overdraw . This is an advanced optimization <nl> + * that is not needed in the general case . <nl> + * @ platform android <nl> + * / <nl> endFillColor ? : ? ColorValue , <nl> + / * * <nl> + * Tag used to log scroll performance on this scroll view . Will force <nl> + * momentum events to be turned on ( see sendMomentumEvents ) . This doesn ' t do <nl> + * anything out of the box and you need to implement a custom native <nl> + * FpsListener for it to be useful . <nl> + * @ platform android <nl> + * / <nl> scrollPerfTag ? : ? string , <nl> + / * * <nl> + * Used to override default value of overScroll mode . <nl> + * <nl> + * Possible values : <nl> + * <nl> + * - ` ' auto ' ` - Default value , allow a user to over - scroll <nl> + * this view only if the content is large enough to meaningfully scroll . <nl> + * - ` ' always ' ` - Always allow a user to over - scroll this view . <nl> + * - ` ' never ' ` - Never allow a user to over - scroll this view . <nl> + * <nl> + * @ platform android <nl> + * / <nl> overScrollMode ? : ? ( ' auto ' | ' always ' | ' never ' ) , <nl> | } > ; <nl> <nl> type VRProps = $ ReadOnly < { | <nl> - scrollBarThumbImage ? : ? ( $ ReadOnly < { | | } > | number ) , <nl> + / * * <nl> + * Optionally an image can be used for the scroll bar thumb . This will <nl> + * override the color . While the image is loading or the image fails to <nl> + * load the color will be used instead . Use an alpha of 0 in the color <nl> + * to avoid seeing it while the image is loading . <nl> + * <nl> + * - ` uri ` - a string representing the resource identifier for the image , which <nl> + * should be either a local file path or the name of a static image resource <nl> + * - ` number ` - Opaque type returned by something like <nl> + * ` import IMAGE from ' . / image . jpg ' ` . <nl> + * @ platform vr <nl> + * / <nl> + scrollBarThumbImage ? : ? ( $ ReadOnly < { | | } > | number ) , / / Opaque type returned by import IMAGE from ' . / image . jpg ' <nl> | } > ; <nl> <nl> export type Props = $ ReadOnly < { | <nl> export type Props = $ ReadOnly < { | <nl> . . . AndroidProps , <nl> . . . VRProps , <nl> <nl> + / * * <nl> + * These styles will be applied to the scroll view content container which <nl> + * wraps all of the child views . Example : <nl> + * <nl> + * ` ` ` <nl> + * return ( <nl> + * < ScrollView contentContainerStyle = { styles . contentContainer } > <nl> + * < / ScrollView > <nl> + * ) ; <nl> + * . . . <nl> + * const styles = StyleSheet . create ( { <nl> + * contentContainer : { <nl> + * paddingVertical : 20 <nl> + * } <nl> + * } ) ; <nl> + * ` ` ` <nl> + * / <nl> contentContainerStyle ? : ? ViewStyleProp , <nl> + / * * <nl> + * When true , the scroll view ' s children are arranged horizontally in a row <nl> + * instead of vertically in a column . The default value is false . <nl> + * / <nl> horizontal ? : ? boolean , <nl> + / * * <nl> + * If sticky headers should stick at the bottom instead of the top of the <nl> + * ScrollView . This is usually used with inverted ScrollViews . <nl> + * / <nl> invertStickyHeaders ? : ? boolean , <nl> + / * * <nl> + * Determines whether the keyboard gets dismissed in response to a drag . <nl> + * <nl> + * * Cross platform * <nl> + * <nl> + * - ` ' none ' ` ( the default ) , drags do not dismiss the keyboard . <nl> + * - ` ' on - drag ' ` , the keyboard is dismissed when a drag begins . <nl> + * <nl> + * * iOS Only * <nl> + * <nl> + * - ` ' interactive ' ` , the keyboard is dismissed interactively with the drag and moves in <nl> + * synchrony with the touch ; dragging upwards cancels the dismissal . <nl> + * On android this is not supported and it will have the same behavior as ' none ' . <nl> + * / <nl> keyboardDismissMode ? : ? ( <nl> | ' none ' / / default <nl> | ' on - drag ' / / cross - platform <nl> | ' interactive ' <nl> ) , / / ios only <nl> + / * * <nl> + * Determines when the keyboard should stay visible after a tap . <nl> + * <nl> + * - ` ' never ' ` ( the default ) , tapping outside of the focused text input when the keyboard <nl> + * is up dismisses the keyboard . When this happens , children won ' t receive the tap . <nl> + * - ` ' always ' ` , the keyboard will not dismiss automatically , and the scroll view will not <nl> + * catch taps , but children of the scroll view can catch taps . <nl> + * - ` ' handled ' ` , the keyboard will not dismiss automatically when the tap was handled by <nl> + * a children , ( or captured by an ancestor ) . <nl> + * - ` false ` , deprecated , use ' never ' instead <nl> + * - ` true ` , deprecated , use ' always ' instead <nl> + * / <nl> / / $ FlowFixMe Issues found when typing ScrollView <nl> keyboardShouldPersistTaps ? : ? ( ' always ' | ' never ' | ' handled ' | false | true ) , <nl> + / * * <nl> + * Called when the momentum scroll starts ( scroll which occurs as the ScrollView glides to a stop ) . <nl> + * / <nl> onMomentumScrollBegin ? : ? Function , <nl> + / * * <nl> + * Called when the momentum scroll ends ( scroll which occurs as the ScrollView glides to a stop ) . <nl> + * / <nl> onMomentumScrollEnd ? : ? Function , <nl> <nl> + / * * <nl> + * Fires at most once per frame during scrolling . The frequency of the <nl> + * events can be controlled using the ` scrollEventThrottle ` prop . <nl> + * / <nl> onScroll ? : ? Function , <nl> + / * * <nl> + * Called when the user begins to drag the scroll view . <nl> + * / <nl> onScrollBeginDrag ? : ? Function , <nl> + / * * <nl> + * Called when the user stops dragging the scroll view and it either stops <nl> + * or begins to glide . <nl> + * / <nl> onScrollEndDrag ? : ? Function , <nl> + / * * <nl> + * Called when scrollable content view of the ScrollView changes . <nl> + * <nl> + * Handler function is passed the content width and content height as parameters : <nl> + * ` ( contentWidth , contentHeight ) ` <nl> + * <nl> + * It ' s implemented using onLayout handler attached to the content container <nl> + * which this ScrollView renders . <nl> + * / <nl> onContentSizeChange ? : ? Function , <nl> onKeyboardDidShow ? : ( event : PressEvent ) = > void , <nl> + / * * <nl> + * When true , the scroll view stops on multiples of the scroll view ' s size <nl> + * when scrolling . This can be used for horizontal pagination . The default <nl> + * value is false . <nl> + * <nl> + * Note : Vertical pagination is not supported on Android . <nl> + * / <nl> pagingEnabled ? : ? boolean , <nl> + / * * <nl> + * When false , the view cannot be scrolled via touch interaction . <nl> + * The default value is true . <nl> + * <nl> + * Note that the view can always be scrolled by calling ` scrollTo ` . <nl> + * / <nl> scrollEnabled ? : ? boolean , <nl> + / * * <nl> + * When true , shows a vertical scroll indicator . <nl> + * The default value is true . <nl> + * / <nl> showsVerticalScrollIndicator ? : ? boolean , <nl> + / * * <nl> + * An array of child indices determining which children get docked to the <nl> + * top of the screen when scrolling . For example , passing <nl> + * ` stickyHeaderIndices = { [ 0 ] } ` will cause the first child to be fixed to the <nl> + * top of the scroll view . This property is not supported in conjunction <nl> + * with ` horizontal = { true } ` . <nl> + * / <nl> stickyHeaderIndices ? : ? $ ReadOnlyArray < number > , <nl> + / * * <nl> + * When set , causes the scroll view to stop at multiples of the value of <nl> + * ` snapToInterval ` . This can be used for paginating through children <nl> + * that have lengths smaller than the scroll view . Typically used in <nl> + * combination with ` snapToAlignment ` and ` decelerationRate = \" fast \" ` on ios . <nl> + * Overrides less configurable ` pagingEnabled ` prop . <nl> + * <nl> + * Supported for horizontal scrollview on android . <nl> + * / <nl> snapToInterval ? : ? number , <nl> + / * * <nl> + * Experimental : When true , offscreen child views ( whose ` overflow ` value is <nl> + * ` hidden ` ) are removed from their native backing superview when offscreen . <nl> + * This can improve scrolling performance on long lists . The default value is <nl> + * true . <nl> + * / <nl> removeClippedSubviews ? : ? boolean , <nl> + / * * <nl> + * A RefreshControl component , used to provide pull - to - refresh <nl> + * functionality for the ScrollView . Only works for vertical ScrollViews <nl> + * ( ` horizontal ` prop must be ` false ` ) . <nl> + * <nl> + * See [ RefreshControl ] ( docs / refreshcontrol . html ) . <nl> + * / <nl> refreshControl ? : ? React . Element < any > , <nl> style ? : ? ViewStyleProp , <nl> children ? : React . Node , <nl> const ScrollView = createReactClass ( { <nl> displayName : ' ScrollView ' , <nl> propTypes : { <nl> . . . ViewPropTypes , <nl> - / * * <nl> - * Controls whether iOS should automatically adjust the content inset <nl> - * for scroll views that are placed behind a navigation bar or <nl> - * tab bar / toolbar . The default value is true . <nl> - * @ platform ios <nl> - * / <nl> automaticallyAdjustContentInsets : PropTypes . bool , <nl> - / * * <nl> - * The amount by which the scroll view content is inset from the edges <nl> - * of the scroll view . Defaults to ` { top : 0 , left : 0 , bottom : 0 , right : 0 } ` . <nl> - * @ platform ios <nl> - * / <nl> contentInset : EdgeInsetsPropType , <nl> - / * * <nl> - * Used to manually set the starting scroll offset . <nl> - * The default value is ` { x : 0 , y : 0 } ` . <nl> - * @ platform ios <nl> - * / <nl> contentOffset : PointPropType , <nl> - / * * <nl> - * When true , the scroll view bounces when it reaches the end of the <nl> - * content if the content is larger then the scroll view along the axis of <nl> - * the scroll direction . When false , it disables all bouncing even if <nl> - * the ` alwaysBounce * ` props are true . The default value is true . <nl> - * @ platform ios <nl> - * / <nl> bounces : PropTypes . bool , <nl> - / * * <nl> - * When true , gestures can drive zoom past min / max and the zoom will animate <nl> - * to the min / max value at gesture end , otherwise the zoom will not exceed <nl> - * the limits . <nl> - * @ platform ios <nl> - * / <nl> bouncesZoom : PropTypes . bool , <nl> - / * * <nl> - * When true , the scroll view bounces horizontally when it reaches the end <nl> - * even if the content is smaller than the scroll view itself . The default <nl> - * value is true when ` horizontal = { true } ` and false otherwise . <nl> - * @ platform ios <nl> - * / <nl> alwaysBounceHorizontal : PropTypes . bool , <nl> - / * * <nl> - * When true , the scroll view bounces vertically when it reaches the end <nl> - * even if the content is smaller than the scroll view itself . The default <nl> - * value is false when ` horizontal = { true } ` and true otherwise . <nl> - * @ platform ios <nl> - * / <nl> alwaysBounceVertical : PropTypes . bool , <nl> - / * * <nl> - * When true , the scroll view automatically centers the content when the <nl> - * content is smaller than the scroll view bounds ; when the content is <nl> - * larger than the scroll view , this property has no effect . The default <nl> - * value is false . <nl> - * @ platform ios <nl> - * / <nl> centerContent : PropTypes . bool , <nl> - / * * <nl> - * These styles will be applied to the scroll view content container which <nl> - * wraps all of the child views . Example : <nl> - * <nl> - * ` ` ` <nl> - * return ( <nl> - * < ScrollView contentContainerStyle = { styles . contentContainer } > <nl> - * < / ScrollView > <nl> - * ) ; <nl> - * . . . <nl> - * const styles = StyleSheet . create ( { <nl> - * contentContainer : { <nl> - * paddingVertical : 20 <nl> - * } <nl> - * } ) ; <nl> - * ` ` ` <nl> - * / <nl> contentContainerStyle : StyleSheetPropType ( ViewStylePropTypes ) , <nl> - / * * <nl> - * A floating - point number that determines how quickly the scroll view <nl> - * decelerates after the user lifts their finger . You may also use string <nl> - * shortcuts ` \" normal \" ` and ` \" fast \" ` which match the underlying iOS settings <nl> - * for ` UIScrollViewDecelerationRateNormal ` and <nl> - * ` UIScrollViewDecelerationRateFast ` respectively . <nl> - * <nl> - * - ` ' normal ' ` : 0 . 998 ( the default ) <nl> - * - ` ' fast ' ` : 0 . 99 <nl> - * <nl> - * @ platform ios <nl> - * / <nl> decelerationRate : PropTypes . oneOfType ( [ <nl> PropTypes . oneOf ( [ ' fast ' , ' normal ' ] ) , <nl> PropTypes . number , <nl> ] ) , <nl> - / * * <nl> - * When true , the scroll view ' s children are arranged horizontally in a row <nl> - * instead of vertically in a column . The default value is false . <nl> - * / <nl> horizontal : PropTypes . bool , <nl> - / * * <nl> - * The style of the scroll indicators . <nl> - * <nl> - * - ` ' default ' ` ( the default ) , same as ` black ` . <nl> - * - ` ' black ' ` , scroll indicator is black . This style is good against a light background . <nl> - * - ` ' white ' ` , scroll indicator is white . This style is good against a dark background . <nl> - * <nl> - * @ platform ios <nl> - * / <nl> indicatorStyle : PropTypes . oneOf ( [ <nl> ' default ' , / / default <nl> ' black ' , <nl> ' white ' , <nl> ] ) , <nl> - / * * <nl> - * If sticky headers should stick at the bottom instead of the top of the <nl> - * ScrollView . This is usually used with inverted ScrollViews . <nl> - * / <nl> invertStickyHeaders : PropTypes . bool , <nl> - / * * <nl> - * When true , the ScrollView will try to lock to only vertical or horizontal <nl> - * scrolling while dragging . The default value is false . <nl> - * @ platform ios <nl> - * / <nl> directionalLockEnabled : PropTypes . bool , <nl> - / * * <nl> - * When false , once tracking starts , won ' t try to drag if the touch moves . <nl> - * The default value is true . <nl> - * @ platform ios <nl> - * / <nl> canCancelContentTouches : PropTypes . bool , <nl> - / * * <nl> - * Determines whether the keyboard gets dismissed in response to a drag . <nl> - * <nl> - * * Cross platform * <nl> - * <nl> - * - ` ' none ' ` ( the default ) , drags do not dismiss the keyboard . <nl> - * - ` ' on - drag ' ` , the keyboard is dismissed when a drag begins . <nl> - * <nl> - * * iOS Only * <nl> - * <nl> - * - ` ' interactive ' ` , the keyboard is dismissed interactively with the drag and moves in <nl> - * synchrony with the touch ; dragging upwards cancels the dismissal . <nl> - * On android this is not supported and it will have the same behavior as ' none ' . <nl> - * / <nl> keyboardDismissMode : PropTypes . oneOf ( [ <nl> ' none ' , / / default <nl> ' on - drag ' , / / Cross - platform <nl> ' interactive ' , / / iOS - only <nl> ] ) , <nl> - / * * <nl> - * Determines when the keyboard should stay visible after a tap . <nl> - * <nl> - * - ` ' never ' ` ( the default ) , tapping outside of the focused text input when the keyboard <nl> - * is up dismisses the keyboard . When this happens , children won ' t receive the tap . <nl> - * - ` ' always ' ` , the keyboard will not dismiss automatically , and the scroll view will not <nl> - * catch taps , but children of the scroll view can catch taps . <nl> - * - ` ' handled ' ` , the keyboard will not dismiss automatically when the tap was handled by <nl> - * a children , ( or captured by an ancestor ) . <nl> - * - ` false ` , deprecated , use ' never ' instead <nl> - * - ` true ` , deprecated , use ' always ' instead <nl> - * / <nl> keyboardShouldPersistTaps : PropTypes . oneOf ( [ <nl> ' always ' , <nl> ' never ' , <nl> const ScrollView = createReactClass ( { <nl> false , <nl> true , <nl> ] ) , <nl> - / * * <nl> - * When set , the scroll view will adjust the scroll position so that the first child that is <nl> - * currently visible and at or beyond ` minIndexForVisible ` will not change position . This is <nl> - * useful for lists that are loading content in both directions , e . g . a chat thread , where new <nl> - * messages coming in might otherwise cause the scroll position to jump . A value of 0 is common , <nl> - * but other values such as 1 can be used to skip loading spinners or other content that should <nl> - * not maintain position . <nl> - * <nl> - * The optional ` autoscrollToTopThreshold ` can be used to make the content automatically scroll <nl> - * to the top after making the adjustment if the user was within the threshold of the top before <nl> - * the adjustment was made . This is also useful for chat - like applications where you want to see <nl> - * new messages scroll into place , but not if the user has scrolled up a ways and it would be <nl> - * disruptive to scroll a bunch . <nl> - * <nl> - * Caveat 1 : Reordering elements in the scrollview with this enabled will probably cause <nl> - * jumpiness and jank . It can be fixed , but there are currently no plans to do so . For now , <nl> - * don ' t re - order the content of any ScrollViews or Lists that use this feature . <nl> - * <nl> - * Caveat 2 : This simply uses ` contentOffset ` and ` frame . origin ` in native code to compute <nl> - * visibility . Occlusion , transforms , and other complexity won ' t be taken into account as to <nl> - * whether content is \" visible \" or not . <nl> - * <nl> - * @ platform ios <nl> - * / <nl> maintainVisibleContentPosition : PropTypes . shape ( { <nl> minIndexForVisible : PropTypes . number . isRequired , <nl> autoscrollToTopThreshold : PropTypes . number , <nl> } ) , <nl> - / * * <nl> - * The maximum allowed zoom scale . The default value is 1 . 0 . <nl> - * @ platform ios <nl> - * / <nl> maximumZoomScale : PropTypes . number , <nl> - / * * <nl> - * The minimum allowed zoom scale . The default value is 1 . 0 . <nl> - * @ platform ios <nl> - * / <nl> minimumZoomScale : PropTypes . number , <nl> - / * * <nl> - * Enables nested scrolling for Android API level 21 + . <nl> - * Nested scrolling is supported by default on iOS <nl> - * @ platform android <nl> - * / <nl> nestedScrollEnabled : PropTypes . bool , <nl> - / * * <nl> - * Called when the momentum scroll starts ( scroll which occurs as the ScrollView glides to a stop ) . <nl> - * / <nl> onMomentumScrollBegin : PropTypes . func , <nl> - / * * <nl> - * Called when the momentum scroll ends ( scroll which occurs as the ScrollView glides to a stop ) . <nl> - * / <nl> onMomentumScrollEnd : PropTypes . func , <nl> - / * * <nl> - * Fires at most once per frame during scrolling . The frequency of the <nl> - * events can be controlled using the ` scrollEventThrottle ` prop . <nl> - * / <nl> onScroll : PropTypes . func , <nl> - / * * <nl> - * Called when the user begins to drag the scroll view . <nl> - * / <nl> onScrollBeginDrag : PropTypes . func , <nl> - / * * <nl> - * Called when the user stops dragging the scroll view and it either stops <nl> - * or begins to glide . <nl> - * / <nl> onScrollEndDrag : PropTypes . func , <nl> - / * * <nl> - * Called when scrollable content view of the ScrollView changes . <nl> - * <nl> - * Handler function is passed the content width and content height as parameters : <nl> - * ` ( contentWidth , contentHeight ) ` <nl> - * <nl> - * It ' s implemented using onLayout handler attached to the content container <nl> - * which this ScrollView renders . <nl> - * / <nl> onContentSizeChange : PropTypes . func , <nl> - / * * <nl> - * When true , the scroll view stops on multiples of the scroll view ' s size <nl> - * when scrolling . This can be used for horizontal pagination . The default <nl> - * value is false . <nl> - * <nl> - * Note : Vertical pagination is not supported on Android . <nl> - * / <nl> pagingEnabled : PropTypes . bool , <nl> - / * * <nl> - * When true , ScrollView allows use of pinch gestures to zoom in and out . <nl> - * The default value is true . <nl> - * @ platform ios <nl> - * / <nl> pinchGestureEnabled : PropTypes . bool , <nl> - / * * <nl> - * When false , the view cannot be scrolled via touch interaction . <nl> - * The default value is true . <nl> - * <nl> - * Note that the view can always be scrolled by calling ` scrollTo ` . <nl> - * / <nl> scrollEnabled : PropTypes . bool , <nl> - / * * <nl> - * This controls how often the scroll event will be fired while scrolling <nl> - * ( as a time interval in ms ) . A lower number yields better accuracy for code <nl> - * that is tracking the scroll position , but can lead to scroll performance <nl> - * problems due to the volume of information being send over the bridge . <nl> - * You will not notice a difference between values set between 1 - 16 as the <nl> - * JS run loop is synced to the screen refresh rate . If you do not need precise <nl> - * scroll position tracking , set this value higher to limit the information <nl> - * being sent across the bridge . The default value is zero , which results in <nl> - * the scroll event being sent only once each time the view is scrolled . <nl> - * @ platform ios <nl> - * / <nl> scrollEventThrottle : PropTypes . number , <nl> - / * * <nl> - * The amount by which the scroll view indicators are inset from the edges <nl> - * of the scroll view . This should normally be set to the same value as <nl> - * the ` contentInset ` . Defaults to ` { 0 , 0 , 0 , 0 } ` . <nl> - * @ platform ios <nl> - * / <nl> scrollIndicatorInsets : EdgeInsetsPropType , <nl> - / * * <nl> - * When true , the scroll view scrolls to top when the status bar is tapped . <nl> - * The default value is true . <nl> - * @ platform ios <nl> - * / <nl> scrollsToTop : PropTypes . bool , <nl> - / * * <nl> - * When true , shows a horizontal scroll indicator . <nl> - * The default value is true . <nl> - * / <nl> showsHorizontalScrollIndicator : PropTypes . bool , <nl> - / * * <nl> - * When true , shows a vertical scroll indicator . <nl> - * The default value is true . <nl> - * / <nl> showsVerticalScrollIndicator : PropTypes . bool , <nl> - / * * <nl> - * An array of child indices determining which children get docked to the <nl> - * top of the screen when scrolling . For example , passing <nl> - * ` stickyHeaderIndices = { [ 0 ] } ` will cause the first child to be fixed to the <nl> - * top of the scroll view . This property is not supported in conjunction <nl> - * with ` horizontal = { true } ` . <nl> - * / <nl> stickyHeaderIndices : PropTypes . arrayOf ( PropTypes . number ) , <nl> - / * * <nl> - * When set , causes the scroll view to stop at multiples of the value of <nl> - * ` snapToInterval ` . This can be used for paginating through children <nl> - * that have lengths smaller than the scroll view . Typically used in <nl> - * combination with ` snapToAlignment ` and ` decelerationRate = \" fast \" ` on ios . <nl> - * Overrides less configurable ` pagingEnabled ` prop . <nl> - * <nl> - * Supported for horizontal scrollview on android . <nl> - * / <nl> snapToInterval : PropTypes . number , <nl> - / * * <nl> - * When ` snapToInterval ` is set , ` snapToAlignment ` will define the relationship <nl> - * of the snapping to the scroll view . <nl> - * <nl> - * - ` ' start ' ` ( the default ) will align the snap at the left ( horizontal ) or top ( vertical ) <nl> - * - ` ' center ' ` will align the snap in the center <nl> - * - ` ' end ' ` will align the snap at the right ( horizontal ) or bottom ( vertical ) <nl> - * <nl> - * @ platform ios <nl> - * / <nl> snapToAlignment : PropTypes . oneOf ( [ <nl> ' start ' , / / default <nl> ' center ' , <nl> ' end ' , <nl> ] ) , <nl> - / * * <nl> - * Experimental : When true , offscreen child views ( whose ` overflow ` value is <nl> - * ` hidden ` ) are removed from their native backing superview when offscreen . <nl> - * This can improve scrolling performance on long lists . The default value is <nl> - * true . <nl> - * / <nl> removeClippedSubviews : PropTypes . bool , <nl> - / * * <nl> - * The current scale of the scroll view content . The default value is 1 . 0 . <nl> - * @ platform ios <nl> - * / <nl> zoomScale : PropTypes . number , <nl> - / * * <nl> - * This property specifies how the safe area insets are used to modify the <nl> - * content area of the scroll view . The default value of this property is <nl> - * \" never \" . Available on iOS 11 and later . <nl> - * @ platform ios <nl> - * / <nl> contentInsetAdjustmentBehavior : PropTypes . oneOf ( [ <nl> ' automatic ' , <nl> ' scrollableAxes ' , <nl> ' never ' , / / default <nl> ' always ' , <nl> ] ) , <nl> - / * * <nl> - * A RefreshControl component , used to provide pull - to - refresh <nl> - * functionality for the ScrollView . Only works for vertical ScrollViews <nl> - * ( ` horizontal ` prop must be ` false ` ) . <nl> - * <nl> - * See [ RefreshControl ] ( docs / refreshcontrol . html ) . <nl> - * / <nl> refreshControl : PropTypes . element , <nl> <nl> - / * * <nl> - * Sometimes a scrollview takes up more space than its content fills . When this is <nl> - * the case , this prop will fill the rest of the scrollview with a color to avoid setting <nl> - * a background and creating unnecessary overdraw . This is an advanced optimization <nl> - * that is not needed in the general case . <nl> - * @ platform android <nl> - * / <nl> endFillColor : ColorPropType , <nl> <nl> - / * * <nl> - * Tag used to log scroll performance on this scroll view . Will force <nl> - * momentum events to be turned on ( see sendMomentumEvents ) . This doesn ' t do <nl> - * anything out of the box and you need to implement a custom native <nl> - * FpsListener for it to be useful . <nl> - * @ platform android <nl> - * / <nl> scrollPerfTag : PropTypes . string , <nl> <nl> - / * * <nl> - * Used to override default value of overScroll mode . <nl> - * <nl> - * Possible values : <nl> - * <nl> - * - ` ' auto ' ` - Default value , allow a user to over - scroll <nl> - * this view only if the content is large enough to meaningfully scroll . <nl> - * - ` ' always ' ` - Always allow a user to over - scroll this view . <nl> - * - ` ' never ' ` - Never allow a user to over - scroll this view . <nl> - * <nl> - * @ platform android <nl> - * / <nl> overScrollMode : PropTypes . oneOf ( [ ' auto ' , ' always ' , ' never ' ] ) , <nl> - / * * <nl> - * When true , ScrollView will emit updateChildFrames data in scroll events , <nl> - * otherwise will not compute or emit child frame data . This only exists <nl> - * to support legacy issues , ` onLayout ` should be used instead to retrieve <nl> - * frame data . <nl> - * The default value is false . <nl> - * @ platform ios <nl> - * / <nl> DEPRECATED_sendUpdatedChildFrames : PropTypes . bool , <nl> - / * * <nl> - * Optionally an image can be used for the scroll bar thumb . This will <nl> - * override the color . While the image is loading or the image fails to <nl> - * load the color will be used instead . Use an alpha of 0 in the color <nl> - * to avoid seeing it while the image is loading . <nl> - * <nl> - * - ` uri ` - a string representing the resource identifier for the image , which <nl> - * should be either a local file path or the name of a static image resource <nl> - * - ` number ` - Opaque type returned by something like <nl> - * ` import IMAGE from ' . / image . jpg ' ` . <nl> - * @ platform vr <nl> - * / <nl> scrollBarThumbImage : PropTypes . oneOfType ( [ <nl> PropTypes . shape ( { <nl> uri : PropTypes . string , <nl>\n", "msg": "Move ScrollView prop comments from propTypes to flow types\n", "score": 1}
{"diff_id": 9416, "repo": "Leaflet/Leaflet\n", "sha": "f9920c87f09f24c703cab230b8ffea532f057705\n", "time": "2013-06-20T21:38:44Z\n", "diff": "mmm a / src / map / Map . js <nl> ppp b / src / map / Map . js <nl> L . Map = L . Class . extend ( { <nl> } else { <nl> if ( ! changeCenter ) { <nl> this . _rawPanBy ( offset ) ; <nl> + } <nl> <nl> this . fire ( ' move ' ) ; <nl> - } <nl> <nl> clearTimeout ( this . _sizeTimer ) ; <nl> this . _sizeTimer = setTimeout ( L . bind ( this . fire , this , ' moveend ' ) , 200 ) ; <nl> } <nl> + <nl> this . fire ( ' resize ' , { <nl> oldSize : oldSize , <nl> newSize : newSize <nl>\n", "msg": "Moving brace to correct position .\n", "score": 1}
{"diff_id": 9619, "repo": "vuejs/vue\n", "sha": "f764db4b01861f79a347b14ecf6313cc174cc12c\n", "time": "2016-08-15T16:49:21Z\n", "diff": "mmm a / src / platforms / web / runtime / components / transition . js <nl> ppp b / src / platforms / web / runtime / components / transition . js <nl> function placeholder ( h , rawChild ) { <nl> : null <nl> } <nl> <nl> + function hasParentTransition ( vnode ) { <nl> + while ( ( vnode = vnode . parent ) ) { <nl> + if ( vnode . data . transition ) { <nl> + return true <nl> + } <nl> + } <nl> + } <nl> + <nl> export default { <nl> name : ' transition ' , <nl> props : transitionProps , <nl> export default { <nl> <nl> / / if this is a component root node and the component ' s <nl> / / parent container node also has transition , skip . <nl> - if ( this . $ vnode . parent & & this . $ vnode . parent . data . transition ) { <nl> + if ( hasParentTransition ( this . $ vnode ) ) { <nl> return rawChild <nl> } <nl> <nl>\n", "msg": "more robust parent transition skip check\n", "score": 1}
{"diff_id": 9855, "repo": "Leaflet/Leaflet\n", "sha": "2e9141fa985dc074f61ddbf5441614c17bd4f59f\n", "time": "2013-12-18T17:03:23Z\n", "diff": "mmm a / src / layer / vector / Path . js <nl> ppp b / src / layer / vector / Path . js <nl> L . Path = L . Layer . extend ( { <nl> <nl> options : { <nl> stroke : true , <nl> - color : ' # 0033ff ' , <nl> - / / dashArray : null , <nl> + color : ' # 3377ff ' , <nl> + weight : 3 , <nl> + opacity : 1 , <nl> lineCap : ' round ' , <nl> lineJoin : ' round ' , <nl> - weight : 5 , <nl> - opacity : 0 . 5 , <nl> + / / dashArray : null <nl> <nl> - / / fill : false , <nl> - / / fillColor : null , same as color by default <nl> + / / fill : false <nl> + / / fillColor : same as color by default <nl> fillOpacity : 0 . 2 , <nl> <nl> / / className : ' ' <nl>\n", "msg": "better style defaults for vector features\n", "score": 1}
{"diff_id": 9985, "repo": "atom/atom\n", "sha": "2d455ac5ee6b566ff982c514e87cecfa6f4dfeec\n", "time": "2019-06-05T14:08:31Z\n", "diff": "mmm a / src / ripgrep - directory - searcher . js <nl> ppp b / src / ripgrep - directory - searcher . js <nl> module . exports = class RipgrepDirectorySearcher { <nl> args . push ( ' - - no - ignore - vcs ' ) ; <nl> } <nl> <nl> + args . push ( ' . ' ) ; <nl> + <nl> const child = spawn ( this . rgPath , args , { <nl> cwd : directoryPath , <nl> stdio : [ ' pipe ' , ' pipe ' , ' pipe ' ] <nl>\n", "msg": "Use ' . ' as the directory for ripgrep to scan\n", "score": 1}
{"diff_id": 9988, "repo": "meteor/meteor\n", "sha": "3257bafc84de9624d69cff50c93aec23b7cbc5c9\n", "time": "2017-03-29T22:46:42Z\n", "diff": "mmm a / tools / fs / files . js <nl> ppp b / tools / fs / files . js <nl> wrapFsFunc ( \" readFile \" , [ 0 ] , { <nl> wrapFsFunc ( \" stat \" , [ 0 ] ) ; <nl> wrapFsFunc ( \" lstat \" , [ 0 ] ) ; <nl> wrapFsFunc ( \" rename \" , [ 0 , 1 ] ) ; <nl> - wrapFsFunc ( \" move \" , [ 0 ] ) ; <nl> + wrapFsFunc ( \" move \" , [ 0 , 1 ] ) ; <nl> <nl> / / After the outermost files . withCache call returns , the withCacheCache is <nl> / / reset to null so that it does not survive server restarts . <nl>\n", "msg": "Change ` wrapFsFunc ` for \" move \" to acknowledge _both_ arguments as paths .\n", "score": 1}
{"diff_id": 10042, "repo": "adobe/brackets\n", "sha": "5e645f923a15580d7ed532277b912dd08688a3fe\n", "time": "2013-03-19T21:40:33Z\n", "diff": "mmm a / src / LiveDevelopment / LiveDevelopment . js <nl> ppp b / src / LiveDevelopment / LiveDevelopment . js <nl> define ( function LiveDevelopment ( require , exports , module ) { <nl> } <nl> <nl> $ ( Inspector . Inspector ) . on ( \" detached \" , _onDetached ) ; <nl> - <nl> + $ ( Inspector . Page ) . on ( \" frameNavigated . DOMAgent \" , _onFrameNavigated ) ; <nl> + <nl> waitForInterstitialPageLoad ( ) <nl> . fail ( function ( ) { <nl> close ( ) ; <nl>\n", "msg": "restore binding for frameNavigated event\n", "score": 1}
{"diff_id": 10363, "repo": "adobe/brackets\n", "sha": "7d85bdb84a54a4e52a31bf4fece878197e9e6ec9\n", "time": "2014-12-11T14:50:44Z\n", "diff": "mmm a / src / command / DefaultMenus . js <nl> ppp b / src / command / DefaultMenus . js <nl> define ( function ( require , exports , module ) { <nl> <nl> var AppInit = require ( \" utils / AppInit \" ) , <nl> Commands = require ( \" command / Commands \" ) , <nl> - EditorManager = require ( \" editor / EditorManager \" ) , <nl> Menus = require ( \" command / Menus \" ) , <nl> Strings = require ( \" strings \" ) ; <nl> <nl> define ( function ( require , exports , module ) { <nl> * an existing selection <nl> * / <nl> $ ( \" # editor - holder \" ) . on ( \" contextmenu \" , function ( e ) { <nl> - if ( $ ( e . target ) . parents ( \" . CodeMirror - gutter \" ) . length ! = = 0 ) { <nl> - return ; <nl> - } <nl> - <nl> - / / Note : on mousedown before this event , CodeMirror automatically checks mouse pos , and <nl> - / / if not clicking on a selection moves the cursor to click location . When triggered <nl> - / / from keyboard , no pre - processing occurs and the cursor / selection is left as is . <nl> - <nl> - var editor = EditorManager . getFocusedEditor ( ) , <nl> - inlineWidget = EditorManager . getFocusedInlineWidget ( ) ; <nl> - <nl> - if ( editor ) { <nl> - / / If there ' s just an insertion point select the word token at the cursor pos so <nl> - / / it ' s more clear what the context menu applies to . <nl> - if ( ! editor . hasSelection ( ) ) { <nl> - editor . selectWordAt ( editor . getCursorPos ( ) ) ; <nl> - <nl> - / / Prevent menu from overlapping text by moving it down a little <nl> - / / Temporarily backout this change for now to help mitigate issue # 1111 , <nl> - / / which only happens if mouse is not over context menu . Better fix <nl> - / / requires change to bootstrap , which is too risky for now . <nl> - / / e . pageY + = 6 ; <nl> + require ( [ \" editor / EditorManager \" ] , function ( EditorManager ) { <nl> + if ( $ ( e . target ) . parents ( \" . CodeMirror - gutter \" ) . length ! = = 0 ) { <nl> + return ; <nl> } <nl> - <nl> - / / Inline text editors have a different context menu ( safe to assume it ' s not some other <nl> - / / type of inline widget since we already know an Editor has focus ) <nl> - if ( inlineWidget ) { <nl> - inline_editor_cmenu . open ( e ) ; <nl> - } else { <nl> - editor_cmenu . open ( e ) ; <nl> + <nl> + / / Note : on mousedown before this event , CodeMirror automatically checks mouse pos , and <nl> + / / if not clicking on a selection moves the cursor to click location . When triggered <nl> + / / from keyboard , no pre - processing occurs and the cursor / selection is left as is . <nl> + <nl> + var editor = EditorManager . getFocusedEditor ( ) , <nl> + inlineWidget = EditorManager . getFocusedInlineWidget ( ) ; <nl> + <nl> + if ( editor ) { <nl> + / / If there ' s just an insertion point select the word token at the cursor pos so <nl> + / / it ' s more clear what the context menu applies to . <nl> + if ( ! editor . hasSelection ( ) ) { <nl> + editor . selectWordAt ( editor . getCursorPos ( ) ) ; <nl> + <nl> + / / Prevent menu from overlapping text by moving it down a little <nl> + / / Temporarily backout this change for now to help mitigate issue # 1111 , <nl> + / / which only happens if mouse is not over context menu . Better fix <nl> + / / requires change to bootstrap , which is too risky for now . <nl> + / / e . pageY + = 6 ; <nl> + } <nl> + <nl> + / / Inline text editors have a different context menu ( safe to assume it ' s not some other <nl> + / / type of inline widget since we already know an Editor has focus ) <nl> + if ( inlineWidget ) { <nl> + inline_editor_cmenu . open ( e ) ; <nl> + } else { <nl> + editor_cmenu . open ( e ) ; <nl> + } <nl> } <nl> - } <nl> + } ) ; <nl> } ) ; <nl> <nl> / * * <nl>\n", "msg": "Attempt to break cycle by async require EditorManager in DefaultMenus\n", "score": 1}
{"diff_id": 10781, "repo": "Automattic/mongoose\n", "sha": "4237515684bbab8401e579125f2a3b204765bd83\n", "time": "2016-02-12T01:59:17Z\n", "diff": "mmm a / test / docs / promises . test . js <nl> ppp b / test / docs / promises . test . js <nl> describe ( ' promises docs ' , function ( ) { <nl> done ( ) ; <nl> / / acquit : ignore : end <nl> } ) ; <nl> + <nl> + / * * <nl> + * The ` mongoose . Promise ` property sets the promises mongoose uses . However , <nl> + * this does * * not * * affect the underlying MongoDB driver . If you use the <nl> + * underlying driver , for instance ` Model . collection . db . insert ( ) ` , you <nl> + * need to do a little extra work to change the underlying promises library . <nl> + * Note that the below code assumes mongoose > = 4 . 4 . 4 . <nl> + * / <nl> + it ( ' Promises for the MongoDB Driver ' , function ( done ) { <nl> + / / acquit : ignore : start <nl> + if ( ! global . Promise ) { <nl> + return done ( ) ; <nl> + } <nl> + / / acquit : ignore : end <nl> + var uri = ' mongodb : / / localhost : 27017 / mongoose_test ' ; <nl> + / / Use bluebird <nl> + var options = { promiseLibrary : require ( ' bluebird ' ) } ; <nl> + var db = mongoose . createConnection ( uri , options ) ; <nl> + <nl> + Band = db . model ( ' band - promises ' , { name : String } ) ; <nl> + <nl> + db . on ( ' open ' , function ( ) { <nl> + assert . equal ( Band . collection . findOne ( ) . constructor , require ( ' bluebird ' ) ) ; <nl> + / / acquit : ignore : start <nl> + done ( ) ; <nl> + / / acquit : ignore : end <nl> + } ) ; <nl> + } ) ; <nl> } ) ; <nl>\n", "msg": "docs : clarify promiseLibrary for underlying driver re\n", "score": 1}
{"diff_id": 10916, "repo": "photonstorm/phaser\n", "sha": "2e7a336ef91844c7de88e5ebd9b5debdd9685c0f\n", "time": "2017-11-30T17:17:29Z\n", "diff": "mmm a / v3 / src / gameobjects / text / static / Text . js <nl> ppp b / v3 / src / gameobjects / text / static / Text . js <nl> var Class = require ( ' . . / . . / . . / utils / Class ' ) ; <nl> var Components = require ( ' . . / . . / components ' ) ; <nl> var GameObject = require ( ' . . / . . / GameObject ' ) ; <nl> var GetTextSize = require ( ' . . / GetTextSize ' ) ; <nl> + var GetValue = require ( ' . . / . . / . . / utils / object / GetValue ' ) ; <nl> var RemoveFromDOM = require ( ' . . / . . / . . / dom / RemoveFromDOM ' ) ; <nl> var TextRender = require ( ' . / TextRender ' ) ; <nl> var TextStyle = require ( ' . . / TextStyle ' ) ; <nl> var Text = new Class ( { <nl> <nl> / * * <nl> * Specify a padding value which is added to the line width and height when calculating the Text size . <nl> - * Allows you to add extra spacing if Phaser is unable to accurately determine the true font dimensions . <nl> + * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions . <nl> * @ property { Phaser . Point } padding <nl> * / <nl> - this . padding = { x : 0 , y : 0 } ; <nl> + this . padding = { left : 0 , right : 0 , top : 0 , bottom : 0 } ; <nl> <nl> this . width = 1 ; <nl> this . height = 1 ; <nl> var Text = new Class ( { <nl> <nl> this . initRTL ( ) ; <nl> <nl> + if ( style & & style . padding ) <nl> + { <nl> + this . setPadding ( style . padding ) ; <nl> + } <nl> + <nl> this . setText ( text ) ; <nl> <nl> var _this = this ; <nl> var Text = new Class ( { <nl> return this . style . setFont ( font ) ; <nl> } , <nl> <nl> + setFontFamily : function ( family ) <nl> + { <nl> + return this . style . setFontFamily ( family ) ; <nl> + } , <nl> + <nl> + setFontSize : function ( size ) <nl> + { <nl> + return this . style . setFontSize ( size ) ; <nl> + } , <nl> + <nl> + setFontStyle : function ( style ) <nl> + { <nl> + return this . style . setFontStyle ( style ) ; <nl> + } , <nl> + <nl> setFixedSize : function ( width , height ) <nl> { <nl> return this . style . setFixedSize ( width , height ) ; <nl> var Text = new Class ( { <nl> return this . style . setBackgroundColor ( color ) ; <nl> } , <nl> <nl> - setFill : function ( color ) <nl> + setColor : function ( color ) <nl> { <nl> - return this . style . setFill ( color ) ; <nl> + return this . style . setColor ( color ) ; <nl> } , <nl> <nl> setStroke : function ( color , thickness ) <nl> var Text = new Class ( { <nl> return this . style . setAlign ( align ) ; <nl> } , <nl> <nl> + / / ' left ' can be an object <nl> + / / if only ' left ' and ' top ' are given they are treated as ' x ' and ' y ' <nl> + setPadding : function ( left , top , right , bottom ) <nl> + { <nl> + if ( typeof left = = = ' object ' ) <nl> + { <nl> + var config = left ; <nl> + <nl> + / / If they specify x and / or y this applies to all <nl> + var x = GetValue ( config , ' x ' , null ) ; <nl> + <nl> + if ( x ! = = null ) <nl> + { <nl> + left = x ; <nl> + right = x ; <nl> + } <nl> + else <nl> + { <nl> + left = GetValue ( config , ' left ' , 0 ) ; <nl> + right = GetValue ( config , ' right ' , left ) ; <nl> + } <nl> + <nl> + var y = GetValue ( config , ' y ' , null ) ; <nl> + <nl> + if ( y ! = = null ) <nl> + { <nl> + top = y ; <nl> + bottom = y ; <nl> + } <nl> + else <nl> + { <nl> + top = GetValue ( config , ' top ' , 0 ) ; <nl> + bottom = GetValue ( config , ' bottom ' , top ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + if ( left = = = undefined ) { left = 0 ; } <nl> + if ( top = = = undefined ) { top = left ; } <nl> + if ( right = = = undefined ) { right = left ; } <nl> + if ( bottom = = = undefined ) { bottom = top ; } <nl> + } <nl> + <nl> + this . padding . left = left ; <nl> + this . padding . top = top ; <nl> + this . padding . right = right ; <nl> + this . padding . bottom = bottom ; <nl> + <nl> + console . log ( this . padding ) ; <nl> + <nl> + return this . updateText ( ) ; <nl> + } , <nl> + <nl> setMaxLines : function ( max ) <nl> { <nl> return this . style . setMaxLines ( max ) ; <nl> var Text = new Class ( { <nl> <nl> var padding = this . padding ; <nl> <nl> - var w = ( textSize . width + ( padding . x * 2 ) ) * this . resolution ; <nl> - var h = ( textSize . height + ( padding . y * 2 ) ) * this . resolution ; <nl> + var w = ( textSize . width + padding . left + padding . right ) * this . resolution ; <nl> + var h = ( textSize . height + padding . top + padding . bottom ) * this . resolution ; <nl> <nl> if ( canvas . width ! = = w | | canvas . height ! = = h ) <nl> { <nl> var Text = new Class ( { <nl> context . textBaseline = ' alphabetic ' ; <nl> <nl> / / Apply padding <nl> - context . translate ( padding . x , padding . y ) ; <nl> + context . translate ( padding . left , padding . top ) ; <nl> <nl> var linePositionX ; <nl> var linePositionY ; <nl> var Text = new Class ( { <nl> { <nl> linePositionX = w - linePositionX ; <nl> } <nl> - else <nl> + else if ( style . align = = = ' right ' ) <nl> + { <nl> + linePositionX + = textSize . width - textSize . lineWidths [ i ] ; <nl> + } <nl> + else if ( style . align = = = ' center ' ) <nl> { <nl> - if ( style . align = = = ' right ' ) <nl> - { <nl> - linePositionX + = textSize . width - textSize . lineWidths [ i ] ; <nl> - } <nl> - else if ( style . align = = = ' center ' ) <nl> - { <nl> - linePositionX + = ( textSize . width - textSize . lineWidths [ i ] ) / 2 ; <nl> - } <nl> + linePositionX + = ( textSize . width - textSize . lineWidths [ i ] ) / 2 ; <nl> } <nl> <nl> if ( this . autoRound ) <nl> var Text = new Class ( { <nl> context . strokeText ( lines [ i ] , linePositionX , linePositionY ) ; <nl> } <nl> <nl> - if ( style . fill ) <nl> + if ( style . color ) <nl> { <nl> this . style . syncShadow ( context , style . shadowFill ) ; <nl> <nl> var Text = new Class ( { <nl> style : this . style . toJSON ( ) , <nl> resolution : this . resolution , <nl> padding : { <nl> - x : this . padding . x , <nl> - y : this . padding . y <nl> + left : this . padding . left , <nl> + right : this . padding . right , <nl> + top : this . padding . top , <nl> + bottom : this . padding . bottom <nl> } <nl> } ; <nl> <nl>\n", "msg": "Handling new style settings for fonts and padding .\n", "score": 1}
{"diff_id": 10984, "repo": "meteor/meteor\n", "sha": "bf04ffa16979fcef36d8577e42a49d8ed1408494\n", "time": "2015-06-04T08:19:10Z\n", "diff": "mmm a / tools / compiler - plugin . js <nl> ppp b / tools / compiler - plugin . js <nl> _ . extend ( ResourceSlot . prototype , { <nl> files . pathJoin ( <nl> serveRoot , <nl> / / XXX BBP should we decide in our API that everything is / ? <nl> - files . convertToStandardPath ( options . path , true ) ) ) <nl> + files . convertToStandardPath ( options . path , true ) ) ) , <nl> + / / XXX BBP convertSourceMapPaths ? ? ? <nl> + sourceMap : options . sourceMap <nl> } ) ; <nl> } <nl> } ) ; <nl>\n", "msg": "CSS source maps for compiler plugins\n", "score": 1}
{"diff_id": 11006, "repo": "twbs/bootstrap\n", "sha": "696fc2e53c0664ef04123167c1dcb1d22ae24d18\n", "time": "2015-02-24T22:09:08Z\n", "diff": "mmm a / js / tests / unit / dropdown . js <nl> ppp b / js / tests / unit / dropdown . js <nl> $ ( function ( ) { <nl> assert . ok ( ! $ dropdown . parent ( ' . dropdown ' ) . hasClass ( ' open ' ) , ' \" open \" class added on click ' ) <nl> } ) <nl> <nl> + QUnit . test ( ' should set aria - expanded = \" true \" on target when dropdown menu is shown ' , function ( assert ) { <nl> + var dropdownHTML = ' < ul class = \" tabs \" > ' <nl> + + ' < li class = \" dropdown \" > ' <nl> + + ' < a href = \" # \" class = \" dropdown - toggle \" data - toggle = \" dropdown \" aria - expanded = \" false \" > Dropdown < / a > ' <nl> + + ' < ul class = \" dropdown - menu \" > ' <nl> + + ' < li > < a href = \" # \" > Secondary link < / a > < / li > ' <nl> + + ' < li > < a href = \" # \" > Something else here < / a > < / li > ' <nl> + + ' < li class = \" divider \" / > ' <nl> + + ' < li > < a href = \" # \" > Another link < / a > < / li > ' <nl> + + ' < / ul > ' <nl> + + ' < / li > ' <nl> + + ' < / ul > ' <nl> + var $ dropdown = $ ( dropdownHTML ) . find ( ' [ data - toggle = \" dropdown \" ] ' ) . bootstrapDropdown ( ) . click ( ) <nl> + <nl> + assert . strictEqual ( $ dropdown . attr ( ' aria - expanded ' ) , ' true ' , ' aria - expanded is set to string \" true \" on click ' ) <nl> + } ) <nl> + <nl> + QUnit . test ( ' should set aria - expanded = \" false \" on target when dropdown menu is hidden ' , function ( assert ) { <nl> + var dropdownHTML = ' < ul class = \" tabs \" > ' <nl> + + ' < li class = \" dropdown \" > ' <nl> + + ' < a href = \" # \" class = \" dropdown - toggle \" aria - expanded = \" false \" data - toggle = \" dropdown \" > Dropdown < / a > ' <nl> + + ' < ul class = \" dropdown - menu \" > ' <nl> + + ' < li > < a href = \" # \" > Secondary link < / a > < / li > ' <nl> + + ' < li > < a href = \" # \" > Something else here < / a > < / li > ' <nl> + + ' < li class = \" divider \" / > ' <nl> + + ' < li > < a href = \" # \" > Another link < / a > < / li > ' <nl> + + ' < / ul > ' <nl> + + ' < / li > ' <nl> + + ' < / ul > ' <nl> + var $ dropdown = $ ( dropdownHTML ) <nl> + . appendTo ( ' # qunit - fixture ' ) <nl> + . find ( ' [ data - toggle = \" dropdown \" ] ' ) <nl> + . bootstrapDropdown ( ) <nl> + <nl> + var done = assert . async ( ) <nl> + <nl> + $ dropdown <nl> + . parent ( ' . dropdown ' ) <nl> + . on ( ' hidden . bs . dropdown ' , function ( ) { <nl> + assert . strictEqual ( $ dropdown . attr ( ' aria - expanded ' ) , ' false ' , ' aria - expanded is set to string \" false \" on hide ' ) <nl> + done ( ) <nl> + } ) <nl> + <nl> + $ dropdown . click ( ) <nl> + $ ( document . body ) . click ( ) <nl> + } ) <nl> + <nl> QUnit . test ( ' should not open dropdown if target is disabled via class ' , function ( assert ) { <nl> var dropdownHTML = ' < ul class = \" tabs \" > ' <nl> + ' < li class = \" dropdown \" > ' <nl>\n", "msg": "Add unit test of aria - expanded to dropdown suite\n", "score": 1}
{"diff_id": 11099, "repo": "photonstorm/phaser\n", "sha": "196258b8ac8aac959bccb2c861124dc50a484654\n", "time": "2018-01-11T16:43:56Z\n", "diff": "mmm a / src / sound / html5 / HTML5AudioSound . js <nl> ppp b / src / sound / html5 / HTML5AudioSound . js <nl> var HTML5AudioSound = new Class ( { <nl> / / TODO implement pause method <nl> this . events . dispatch ( new SoundEvent ( this , ' SOUND_PAUSE ' ) ) ; <nl> return true ; <nl> + } , <nl> + resume : function ( ) { <nl> + if ( ! BaseSound . prototype . resume . call ( this ) ) { <nl> + return false ; <nl> + } <nl> + / / \\ / \\ / \\ / isPlaying = true , isPaused = false \\ / \\ / \\ / <nl> + / / TODO implement resume method <nl> + this . events . dispatch ( new SoundEvent ( this , ' SOUND_RESUME ' ) ) ; <nl> + return true ; <nl> } <nl> } ) ; <nl> module . exports = HTML5AudioSound ; <nl>\n", "msg": "Added resume method implementation that calls super method and dispatches resume event\n", "score": 1}
{"diff_id": 11122, "repo": "mozilla/pdf.js\n", "sha": "792ef1b14dc7f48b3828d61cbcae0539ad95ece2\n", "time": "2012-07-20T22:53:39Z\n", "diff": "mmm a / src / fonts . js <nl> ppp b / src / fonts . js <nl> var Type1Parser = function type1Parser ( ) { <nl> for ( var i = 0 ; i < numArgs ; i + + ) { <nl> if ( index < 0 ) { <nl> args . unshift ( { arg : [ 0 ] , <nl> - value : 0 } ) ; <nl> + value : 0 , <nl> + offset : 0 } ) ; <nl> warn ( ' Malformed charstring stack : not enough values on stack . ' ) ; <nl> continue ; <nl> } <nl> var Type1Parser = function type1Parser ( ) { <nl> b = 1 ; <nl> } <nl> args . unshift ( { arg : [ a , b , ' div ' ] , <nl> - value : a / b } ) ; <nl> + value : a / b , <nl> + offset : index - 2 } ) ; <nl> index - = 3 ; <nl> } else if ( isInt ( token ) ) { <nl> args . unshift ( { arg : stack . slice ( index , index + 1 ) , <nl> - value : token } ) ; <nl> + value : token , <nl> + offset : index } ) ; <nl> index - - ; <nl> } else { <nl> warn ( ' Malformed charsting stack : found bad token ' + token + ' . ' ) ; <nl> var Type1Parser = function type1Parser ( ) { <nl> } else if ( escape = = 6 ) { <nl> / / seac is like type 2 ' s special endchar but it doesn ' t use the <nl> / / first argument asb , so remove it . <nl> - charstring . splice ( charstring . length - 5 , 1 ) ; <nl> + var args = breakUpArgs ( charstring , 5 ) ; <nl> + var arg0 = args [ 0 ] ; <nl> + charstring . splice ( arg0 . offset , arg0 . arg . length ) ; <nl> } else if ( ! kHintingEnabled & & ( escape = = 1 | | escape = = 2 ) ) { <nl> charstring . push ( ' drop ' , ' drop ' , ' drop ' , ' drop ' , ' drop ' , ' drop ' ) ; <nl> continue ; <nl>\n", "msg": "Support div number format for seac operator .\n", "score": 1}
{"diff_id": 11129, "repo": "expressjs/express\n", "sha": "d31de1e65408389d682531b0a3c3ce36affd7d10\n", "time": "2010-03-29T14:55:37Z\n", "diff": "mmm a / lib / express / plugins / session . js <nl> ppp b / lib / express / plugins / session . js <nl> exports . Session = Plugin . extend ( { <nl> * / <nl> <nl> init : function ( options ) { <nl> + this . cookie = { httpOnly : true } <nl> this . merge ( options | | { } ) <nl> - this . cookie = this . cookie | | { } <nl> - this . cookie . httpOnly = true <nl> this . store = new ( this . dataStore | | exports . Store . Memory ) ( options ) <nl> this . startReaper ( ) <nl> } , <nl>\n", "msg": "Defaulting httpOnly for Session cookies , however overridable\n", "score": 1}
{"diff_id": 11462, "repo": "impress/impress.js\n", "sha": "811e045c60ff32afb4b7f287a4b054cf089b94fe\n", "time": "2012-03-07T22:51:20Z\n", "diff": "mmm a / js / impress . js <nl> ppp b / js / impress . js <nl> <nl> return \" scale ( \" + s + \" ) \" ; <nl> } ; <nl> <nl> + var perspective = function ( p ) { <nl> + return \" perspective ( \" + p + \" px ) \" ; <nl> + } ; <nl> + <nl> var getElementFromUrl = function ( ) { <nl> / / get id from url # by removing ` # ` or ` # / ` from the beginning , <nl> / / so both ` # slide - id ` and \" legacy \" ` # / slide - id ` will work <nl> <nl> css ( root , { <nl> top : \" 50 % \" , <nl> left : \" 50 % \" , <nl> - perspective : \" 1000px \" <nl> + transform : perspective ( 1000 ) <nl> } ) ; <nl> css ( canvas , props ) ; <nl> <nl> <nl> css ( root , { <nl> / / to keep the perspective look similar for different scales <nl> / / we need to ' scale ' the perspective , too <nl> - perspective : step . scale * ( 1 / windowScale ) * 1000 + \" px \" , <nl> - transform : scale ( target . scale * windowScale ) , <nl> + transform : perspective ( 1000 / ( target . scale * windowScale ) ) + scale ( target . scale * windowScale ) , <nl> transitionDuration : duration , <nl> transitionDelay : ( zoomin ? \" 500ms \" : \" 0ms \" ) <nl> } ) ; <nl>\n", "msg": "perspective as a function for better Firefox support\n", "score": 1}
{"diff_id": 11765, "repo": "ajaxorg/ace\n", "sha": "5708ef899e9324db07ed5c3f1734db7d2f8b697d\n", "time": "2013-08-14T20:57:38Z\n", "diff": "mmm a / lib / ace / ext / chromevox . js <nl> ppp b / lib / ace / ext / chromevox . js <nl> var rules = { <nl> ' meta ' : { <nl> prop : DEFAULT_PROP , <nl> replace : [ <nl> - { <nl> - substr : ' < ' , <nl> - newSubstr : ' tag start ' <nl> - } , <nl> - { <nl> - substr : ' > ' , <nl> - newSubstr : ' tag end ' <nl> - } , <nl> { <nl> substr : ' < / ' , <nl> newSubstr : ' closing tag ' <nl> var rules = { <nl> { <nl> substr : ' / > ' , <nl> newSubstr : ' close tag ' <nl> + } , <nl> + { <nl> + substr : ' < ' , <nl> + newSubstr : ' tag start ' <nl> + } , <nl> + { <nl> + substr : ' > ' , <nl> + newSubstr : ' tag end ' <nl> } <nl> ] <nl> } <nl> var expand = function ( value , replaceRules ) { <nl> var newValue = value ; <nl> for ( var i = 0 ; i < replaceRules . length ; i + + ) { <nl> var replaceRule = replaceRules [ i ] ; <nl> - newValue = newValue . replace ( replaceRule . substr , replaceRule . newSubstr ) ; <nl> + var regexp = new RegExp ( replaceRule . substr , ' g ' ) ; <nl> + newValue = newValue . replace ( regexp , replaceRule . newSubstr ) ; <nl> } <nl> return newValue ; <nl> } ; <nl> var SHORTCUTS = [ <nl> } <nl> ] ; <nl> <nl> + / * * <nl> + * Event handler for focus events . <nl> + * / <nl> + var onFocus = function ( ) { <nl> + cvoxAce . editor = editor ; <nl> + <nl> + / * Set up listeners . * / <nl> + editor . getSession ( ) . selection . on ( ' changeCursor ' , onCursorChange ) ; <nl> + editor . getSession ( ) . on ( ' change ' , onChange ) ; <nl> + editor . getSession ( ) . on ( ' changeAnnotation ' , onAnnotationChange ) ; <nl> + editor . on ( ' changeStatus ' , onChangeStatus ) ; <nl> + editor . on ( ' findSearchBox ' , onFindSearchbox ) ; <nl> + editor . container . addEventListener ( ' keydown ' , onKeyDown ) ; <nl> + <nl> + lastCursor = editor . selection . getCursor ( ) ; <nl> + } ; <nl> + <nl> / * * <nl> * Initialize the theme . <nl> * @ param { Object } editor Editor to use . <nl> * / <nl> var init = function ( editor ) { <nl> - cvoxAce . editor = editor ; <nl> - lastCursor = editor . selection . getCursor ( ) ; <nl> + onFocus ( ) ; <nl> + <nl> / * Construct maps . * / <nl> SHORTCUTS . forEach ( function ( shortcut ) { <nl> keyCodeToShortcutMap [ shortcut . keyCode ] = shortcut ; <nl> cmdToShortcutMap [ shortcut . cmd ] = shortcut ; <nl> } ) ; <nl> <nl> - / * Set up listeners . * / <nl> - cvoxAce . editor . getSession ( ) . selection . on ( ' changeCursor ' , onCursorChange ) ; <nl> - cvoxAce . editor . getSession ( ) . on ( ' change ' , onChange ) ; <nl> - cvoxAce . editor . getSession ( ) . on ( ' changeAnnotation ' , onAnnotationChange ) ; <nl> - cvoxAce . editor . on ( ' changeStatus ' , onChangeStatus ) ; <nl> - cvoxAce . editor . on ( ' findSearchBox ' , onFindSearchbox ) ; <nl> - editor . container . addEventListener ( ' keydown ' , onKeyDown ) ; <nl> + editor . on ( ' focus ' , onFocus ) ; <nl> <nl> / * Assume we start in command mode if vim . * / <nl> if ( isVimMode ( ) ) { <nl> cvox . Api . setKeyEcho ( false ) ; <nl> } <nl> initContextMenu ( ) ; <nl> - <nl> - cvoxAce . editor . focus ( ) ; <nl> } ; <nl> <nl> / * * <nl>\n", "msg": "Support for multiple editors , reorder rules , and use replace all .\n", "score": 1}
{"diff_id": 12269, "repo": "lodash/lodash\n", "sha": "a21456580303f43f5d50094617fa2ecfa6d74ca7\n", "time": "2013-10-08T06:49:03Z\n", "diff": "mmm a / test / test . js <nl> ppp b / test / test . js <nl> <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> <nl> + QUnit . module ( ' lodash . compact ' ) ; <nl> + <nl> + ( function ( ) { <nl> + test ( ' should filter falsey values ' , 1 , function ( ) { <nl> + var array = [ ' 0 ' , ' 1 ' , ' 2 ' ] ; <nl> + deepEqual ( _ . compact ( falsey . concat ( array ) ) , array ) ; <nl> + } ) ; <nl> + } ( ) ) ; <nl> + <nl> + / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> + <nl> QUnit . module ( ' lodash . contains ' ) ; <nl> <nl> ( function ( ) { <nl> <nl> QUnit . module ( ' lodash . difference ' ) ; <nl> <nl> ( function ( ) { <nl> + test ( ' should return the difference of the given arrays ' , 2 , function ( ) { <nl> + var actual = _ . difference ( [ 1 , 2 , 3 , 4 , 5 ] , [ 5 , 2 , 10 ] ) ; <nl> + deepEqual ( actual , [ 1 , 3 , 4 ] ) ; <nl> + <nl> + actual = _ . difference ( [ 1 , 2 , 3 , 4 , 5 ] , [ 5 , 2 , 10 ] , [ 8 , 4 ] ) ; <nl> + deepEqual ( actual , [ 1 , 3 ] ) ; <nl> + } ) ; <nl> + <nl> test ( ' should work with large arrays ' , 1 , function ( ) { <nl> var array1 = _ . range ( largeArraySize ) , <nl> array2 = array1 . slice ( ) , <nl> <nl> } ) ; <nl> <nl> test ( ' should return an empty array when ` n ` < ` 1 ` ' , 3 , function ( ) { <nl> - _ . each ( [ 0 , - 1 , - 2 ] , function ( n ) { <nl> + _ . forEach ( [ 0 , - 1 , - 2 ] , function ( n ) { <nl> deepEqual ( _ . first ( array , n ) , [ ] ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> test ( ' should return all elements when ` n ` > = ` array . length ` ' , 2 , function ( ) { <nl> - _ . each ( [ 3 , 4 ] , function ( n ) { <nl> + _ . forEach ( [ 3 , 4 ] , function ( n ) { <nl> deepEqual ( _ . first ( array , n ) , array . slice ( ) ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> test ( ' should work with a string for ` callback ` ' , 1 , function ( ) { <nl> deepEqual ( _ . first ( objects , ' b ' ) , objects . slice ( 0 , 2 ) ) ; <nl> } ) ; <nl> + <nl> + test ( ' should be aliases as ` _ . head ` and ` _ . take ` ' , 2 , function ( ) { <nl> + strictEqual ( _ . head , _ . first ) ; <nl> + strictEqual ( _ . take , _ . first ) ; <nl> + } ) ; <nl> } ( ) ) ; <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> <nl> var actual = _ . flatten ( [ [ ] , [ [ ] ] , [ [ ] , [ [ [ ] ] ] ] ] ) ; <nl> deepEqual ( actual , [ ] ) ; <nl> } ) ; <nl> + <nl> + test ( ' should flatten nested arrays ' , 1 , function ( ) { <nl> + var array = [ 1 , [ 2 ] , [ 3 , [ [ 4 ] ] ] ] , <nl> + expected = [ 1 , 2 , 3 , 4 ] ; <nl> + <nl> + deepEqual ( _ . flatten ( array ) , expected ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should support shallow flattening nested arrays ' , 1 , function ( ) { <nl> + var array = [ 1 , [ 2 ] , [ 3 , [ 4 ] ] ] , <nl> + expected = [ 1 , 2 , 3 , [ 4 ] ] ; <nl> + <nl> + deepEqual ( _ . flatten ( array , true ) , expected ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should support shallow flattening arrays of other arrays ' , 1 , function ( ) { <nl> + var array = [ [ 1 ] , [ 2 ] , [ 3 ] , [ [ 4 ] ] ] , <nl> + expected = [ 1 , 2 , 3 , [ 4 ] ] ; <nl> + <nl> + deepEqual ( _ . flatten ( array , true ) , expected ) ; <nl> + } ) ; <nl> } ( 1 , 2 , 3 ) ) ; <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> <nl> + QUnit . module ( ' lodash . has ' ) ; <nl> + <nl> + ( function ( ) { <nl> + test ( ' should return ` false ` for primitives ' , 9 , function ( ) { <nl> + _ . forEach ( falsey . concat ( 1 , ' a ' ) , function ( value ) { <nl> + strictEqual ( _ . has ( value , ' valueOf ' ) , false ) ; <nl> + } ) ; <nl> + } ) ; <nl> + } ( ) ) ; <nl> + <nl> + / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> + <nl> QUnit . module ( ' lodash . indexBy ' ) ; <nl> <nl> ( function ( ) { <nl> <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> <nl> - QUnit . module ( ' lodash . has ' ) ; <nl> - <nl> - ( function ( ) { <nl> - test ( ' should return ` false ` for primitives ' , 9 , function ( ) { <nl> - _ . forEach ( falsey . concat ( 1 , ' a ' ) , function ( value ) { <nl> - strictEqual ( _ . has ( value , ' valueOf ' ) , false ) ; <nl> - } ) ; <nl> - } ) ; <nl> - } ( ) ) ; <nl> - <nl> - / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> - <nl> QUnit . module ( ' lodash . indexOf ' ) ; <nl> <nl> ( function ( ) { <nl> var array = [ 1 , 2 , 3 , 1 , 2 , 3 ] ; <nl> <nl> + test ( ' should return the index of the first matched value ' , 1 , function ( ) { <nl> + equal ( _ . indexOf ( array , 3 ) , 2 ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should return ` - 1 ` for an unmatched value ' , 1 , function ( ) { <nl> + equal ( _ . indexOf ( array , 4 ) , - 1 ) ; <nl> + } ) ; <nl> + <nl> test ( ' should work with a positive ` fromIndex ` ' , 1 , function ( ) { <nl> equal ( _ . indexOf ( array , 1 , 2 ) , 3 ) ; <nl> } ) ; <nl> <nl> { ' a ' : 2 , ' b ' : 2 } <nl> ] ; <nl> <nl> - test ( ' should accept a falsey ` array ` argument ' , 7 , function ( ) { <nl> - _ . forEach ( falsey , function ( index , value ) { <nl> + test ( ' should accept a falsey ` array ` argument ' , 1 , function ( ) { <nl> + var actual = [ ] , <nl> + expected = _ . map ( falsey , function ( ) { return [ ] ; } ) ; <nl> + <nl> + _ . forEach ( falsey , function ( value , index ) { <nl> try { <nl> - var actual = index ? _ . initial ( value ) : _ . initial ( ) ; <nl> + actual . push ( index ? _ . initial ( value ) : _ . initial ( ) ) ; <nl> } catch ( e ) { } <nl> - deepEqual ( actual , [ ] ) ; <nl> - } ) <nl> + } ) ; <nl> + <nl> + deepEqual ( actual , expected ) ; <nl> } ) ; <nl> <nl> test ( ' should exclude last element ' , 1 , function ( ) { <nl> <nl> } ) ; <nl> <nl> test ( ' should return all elements when ` n ` < ` 1 ` ' , 3 , function ( ) { <nl> - _ . each ( [ 0 , - 1 , - 2 ] , function ( n ) { <nl> + _ . forEach ( [ 0 , - 1 , - 2 ] , function ( n ) { <nl> deepEqual ( _ . initial ( array , n ) , array . slice ( ) ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> test ( ' should return an empty array when ` n ` > = ` array . length ` ' , 2 , function ( ) { <nl> - _ . each ( [ 3 , 4 ] , function ( n ) { <nl> + _ . forEach ( [ 3 , 4 ] , function ( n ) { <nl> deepEqual ( _ . initial ( array , n ) , [ ] ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> <nl> + QUnit . module ( ' lodash . intersection ' ) ; <nl> + <nl> + ( function ( ) { <nl> + test ( ' should return the intersection of the given arrays ' , 1 , function ( ) { <nl> + var actual = _ . intersection ( [ 1 , 3 , 2 ] , [ 101 , 2 , 1 , 10 ] , [ 2 , 1 ] ) ; <nl> + deepEqual ( actual , [ 1 , 2 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should return an array of unique values ' , 1 , function ( ) { <nl> + var actual = _ . intersection ( [ 1 , 1 , 3 , 2 , 2 ] , [ 101 , 2 , 2 , 1 , 101 ] , [ 2 , 1 , 1 ] ) ; <nl> + deepEqual ( actual , [ 1 , 2 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should return a wrapped value when chaining ' , 2 , function ( ) { <nl> + if ( ! isNpm ) { <nl> + var actual = _ ( [ 1 , 3 , 2 ] ) . intersection ( [ 101 , 2 , 1 , 10 ] ) ; <nl> + ok ( actual instanceof _ ) ; <nl> + deepEqual ( actual . value ( ) , [ 1 , 2 ] ) ; <nl> + } <nl> + else { <nl> + skipTest ( 2 ) ; <nl> + } <nl> + } ) ; <nl> + } ( ) ) ; <nl> + <nl> + / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> + <nl> QUnit . module ( ' lodash . invoke ' ) ; <nl> <nl> ( function ( ) { <nl> <nl> } ) ; <nl> <nl> test ( ' should return an empty array when ` n ` < ` 1 ` ' , 3 , function ( ) { <nl> - _ . each ( [ 0 , - 1 , - 2 ] , function ( n ) { <nl> + _ . forEach ( [ 0 , - 1 , - 2 ] , function ( n ) { <nl> deepEqual ( _ . last ( array , n ) , [ ] ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> test ( ' should return all elements when ` n ` > = ` array . length ` ' , 2 , function ( ) { <nl> - _ . each ( [ 3 , 4 ] , function ( n ) { <nl> + _ . forEach ( [ 3 , 4 ] , function ( n ) { <nl> deepEqual ( _ . last ( array , n ) , array . slice ( ) ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> ( function ( ) { <nl> var array = [ 1 , 2 , 3 , 1 , 2 , 3 ] ; <nl> <nl> + test ( ' should return the index of the last matched value ' , 1 , function ( ) { <nl> + equal ( _ . lastIndexOf ( array , 3 ) , 5 ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should return ` - 1 ` for an unmatched value ' , 1 , function ( ) { <nl> + equal ( _ . lastIndexOf ( array , 4 ) , - 1 ) ; <nl> + } ) ; <nl> + <nl> test ( ' should work with a positive ` fromIndex ` ' , 1 , function ( ) { <nl> strictEqual ( _ . lastIndexOf ( array , 1 , 2 ) , 0 ) ; <nl> } ) ; <nl> <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> <nl> + QUnit . module ( ' indexOf methods ' ) ; <nl> + <nl> + ( function ( ) { <nl> + _ . forEach ( [ ' indexOf ' , ' lastIndexOf ' ] , function ( methodName ) { <nl> + var func = _ [ methodName ] ; <nl> + <nl> + test ( ' ` _ . ' + methodName + ' ` should accept a falsey ` array ` argument ' , 1 , function ( ) { <nl> + var actual = [ ] , <nl> + expected = _ . map ( falsey , function ( ) { return - 1 ; } ) ; <nl> + <nl> + _ . forEach ( falsey , function ( value , index ) { <nl> + try { <nl> + actual . push ( index ? func ( value ) : func ( ) ) ; <nl> + } catch ( e ) { } <nl> + } ) ; <nl> + <nl> + deepEqual ( actual , expected ) ; <nl> + } ) ; <nl> + } ) ; <nl> + } ( ) ) ; <nl> + <nl> + / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> + <nl> QUnit . module ( ' lodash . map ' ) ; <nl> <nl> ( function ( ) { <nl> <nl> ( function ( ) { <nl> var func = _ . range ; <nl> <nl> + test ( ' should work when passing a single ` end ` argument ' , 1 , function ( ) { <nl> + deepEqual ( _ . range ( 4 ) , [ 0 , 1 , 2 , 3 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should work when passing ` start ` and ` end ` arguments ' , 1 , function ( ) { <nl> + deepEqual ( _ . range ( 1 , 5 ) , [ 1 , 2 , 3 , 4 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should work when passing ` start ` , ` end ` , and ` step ` arguments ' , 1 , function ( ) { <nl> + deepEqual ( _ . range ( 1 , 20 , 5 ) , [ 0 , 5 , 10 , 15 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should support a ` step ` of ` 0 ` ' , 1 , function ( ) { <nl> + deepEqual ( _ . range ( 1 , 4 , 0 ) , [ 1 , 1 , 1 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should work when passing ` step ` larger than ` end ` ' , 1 , function ( ) { <nl> + deepEqual ( _ . range ( 1 , 5 , 20 ) , [ 1 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should work when passing a negative ` step ` argument ' , 2 , function ( ) { <nl> + deepEqual ( _ . range ( 0 , - 4 , - 1 ) , [ 0 , - 1 , - 2 , - 3 ] ) ; <nl> + deepEqual ( _ . range ( 21 , 10 , - 3 ) , [ 21 , 18 , 15 , 12 ] ) ; <nl> + } ) ; <nl> + <nl> test ( ' should treat falsey ` start ` arguments as ` 0 ` ' , 13 , function ( ) { <nl> _ . forEach ( falsey , function ( value , index ) { <nl> if ( index ) { <nl> <nl> var actual = [ func ( ' 0 ' , 1 ) , func ( ' 1 ' ) , func ( 0 , 1 , ' 1 ' ) ] ; <nl> deepEqual ( actual , [ [ 0 ] , [ 0 ] , [ 0 ] ] ) ; <nl> } ) ; <nl> - <nl> - test ( ' should support a ` step ` of ` 0 ` ' , 1 , function ( ) { <nl> - deepEqual ( _ . range ( 1 , 4 , 0 ) , [ 1 , 1 , 1 ] ) ; <nl> - } ) ; <nl> } ( ) ) ; <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> <nl> } ) ; <nl> <nl> test ( ' should return all elements when ` n ` < ` 1 ` ' , 3 , function ( ) { <nl> - _ . each ( [ 0 , - 1 , - 2 ] , function ( n ) { <nl> + _ . forEach ( [ 0 , - 1 , - 2 ] , function ( n ) { <nl> deepEqual ( _ . rest ( array , n ) , [ 1 , 2 , 3 ] ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> test ( ' should return an empty array when ` n ` > = ` array . length ` ' , 2 , function ( ) { <nl> - _ . each ( [ 3 , 4 ] , function ( n ) { <nl> + _ . forEach ( [ 3 , 4 ] , function ( n ) { <nl> deepEqual ( _ . rest ( array , n ) , [ ] ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> test ( ' should work with a string for ` callback ` ' , 1 , function ( ) { <nl> deepEqual ( _ . rest ( objects , ' b ' ) , objects . slice ( - 1 ) ) ; <nl> } ) ; <nl> + <nl> + test ( ' should be aliases as ` _ . drop ` and ` _ . tail ` ' , 2 , function ( ) { <nl> + strictEqual ( _ . drop , _ . rest ) ; <nl> + strictEqual ( _ . tail , _ . rest ) ; <nl> + } ) ; <nl> } ( ) ) ; <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> <nl> } ) ; <nl> <nl> test ( ' should return an empty array when ` n ` < ` 1 ` ' , 3 , function ( ) { <nl> - _ . each ( [ 0 , - 1 , - 2 ] , function ( n ) { <nl> + _ . forEach ( [ 0 , - 1 , - 2 ] , function ( n ) { <nl> deepEqual ( _ . sample ( array , n ) , [ ] ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> test ( ' should return all elements when ` n ` > = ` array . length ` ' , 2 , function ( ) { <nl> - _ . each ( [ 3 , 4 ] , function ( n ) { <nl> + _ . forEach ( [ 3 , 4 ] , function ( n ) { <nl> deepEqual ( _ . sample ( array , n ) . sort ( ) , array . slice ( ) ) ; <nl> } ) ; <nl> } ) ; <nl> <nl> QUnit . module ( ' lodash . union ' ) ; <nl> <nl> ( function ( ) { <nl> + test ( ' should return the union of the given arrays ' , 1 , function ( ) { <nl> + var actual = _ . union ( [ 1 , 2 , 3 ] , [ 101 , 2 , 1 , 10 ] , [ 2 , 1 ] ) ; <nl> + deepEqual ( actual , [ 1 , 2 , 3 , 101 , 10 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should not flatten nested arrays ' , 1 , function ( ) { <nl> + var actual = _ . union ( [ 1 , 2 , 3 ] , [ 1 , [ 4 ] ] , [ 2 , [ 5 ] ] ) ; <nl> + deepEqual ( actual , [ 1 , 2 , 3 , [ 4 ] , [ 5 ] ] ) ; <nl> + } ) ; <nl> + <nl> test ( ' should produce correct results when provided a falsey ` array ` argument ' , 1 , function ( ) { <nl> var expected = [ 1 , 2 , 3 ] , <nl> actual = _ . union ( null , expected ) ; <nl> <nl> QUnit . module ( ' lodash . uniq ' ) ; <nl> <nl> ( function ( ) { <nl> + var objects = [ { ' a ' : 2 } , { ' a ' : 3 } , { ' a ' : 1 } , { ' a ' : 2 } , { ' a ' : 3 } , { ' a ' : 1 } ] ; <nl> + <nl> + test ( ' should return unique values of an unsorted array ' , 1 , function ( ) { <nl> + var array = [ 2 , 3 , 1 , 2 , 3 , 1 ] ; <nl> + deepEqual ( _ . uniq ( array ) , [ 2 , 3 , 1 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should return unique values of a sorted array ' , 1 , function ( ) { <nl> + var array = [ 1 , 1 , 2 , 2 , 3 ] ; <nl> + deepEqual ( _ . uniq ( array ) , [ 1 , 2 , 3 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should work with a ` callback ` ' , 1 , function ( ) { <nl> + var actual = _ . uniq ( objects , false , function ( object ) { <nl> + return object . a ; <nl> + } ) ; <nl> + <nl> + deepEqual ( actual , objects . slice ( 0 , 3 ) ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should work with a ` callback ` without specifying ` isSorted ` ' , 1 , function ( ) { <nl> + var actual = _ . uniq ( objects , function ( object ) { <nl> + return object . a ; <nl> + } ) ; <nl> + <nl> + deepEqual ( actual , objects . slice ( 0 , 3 ) ) ; <nl> + } ) ; <nl> + <nl> test ( ' should support the ` thisArg ` argument ' , 1 , function ( ) { <nl> var actual = _ . uniq ( [ 1 , 2 , 1 . 5 , 3 , 2 . 5 ] , function ( num ) { <nl> return this . floor ( num ) ; <nl> <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> <nl> + QUnit . module ( ' lodash . without ' ) ; <nl> + <nl> + ( function ( ) { <nl> + test ( ' should use strict equality to determine the values to reject ' , 2 , function ( ) { <nl> + var object1 = { ' a ' : 1 } , <nl> + object2 = { ' b ' : 2 } , <nl> + array = [ object1 , object2 ] ; <nl> + <nl> + deepEqual ( _ . without ( array , { ' a ' : 1 } ) , array ) ; <nl> + deepEqual ( _ . without ( array , object1 ) , [ object2 ] ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should remove all occurrences of each value from an array ' , 1 , function ( ) { <nl> + var array = [ 1 , 2 , 3 , 1 , 2 , 3 ] ; <nl> + deepEqual ( _ . without ( array , 1 , 2 ) , [ 3 , 3 ] ) ; <nl> + } ) ; <nl> + } ( ) ) ; <nl> + <nl> + / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl> + <nl> QUnit . module ( ' lodash . zip ' ) ; <nl> <nl> ( function ( ) { <nl> <nl> deepEqual ( actual , [ [ ' moe ' , 30 , undefined ] , [ ' larry ' , 40 , false ] ] ) ; <nl> } ) ; <nl> <nl> - test ( ' should correctly consume it \\ ' s output ' , 1 , function ( ) { <nl> + test ( ' should support consuming it \\ ' s return value ' , 1 , function ( ) { <nl> var expected = [ [ ' moe ' , ' larry ' ] , [ 30 , 40 ] ] ; <nl> deepEqual ( _ . zip ( _ . zip ( _ . zip ( _ . zip ( expected ) ) ) ) , expected ) ; <nl> } ) ; <nl> <nl> QUnit . module ( ' lodash . zipObject ' ) ; <nl> <nl> ( function ( ) { <nl> + var object = { ' moe ' : 30 , ' larry ' : 40 } , <nl> + array = [ [ ' moe ' , 30 ] , [ ' larry ' , 40 ] ] ; <nl> + <nl> test ( ' should skip falsey elements in a given two dimensional array ' , 1 , function ( ) { <nl> - var actual = _ . zipObject ( [ [ ' a ' , 1 ] , [ ' b ' , 2 ] ] . concat ( falsey ) ) ; <nl> - deepEqual ( actual , { ' a ' : 1 , ' b ' : 2 } ) ; <nl> + var actual = _ . zipObject ( array . concat ( falsey ) ) ; <nl> + deepEqual ( actual , object ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should zip together key / value arrays into an object ' , 1 , function ( ) { <nl> + var actual = _ . zipObject ( [ ' moe ' , ' larry ' ] , [ 30 , 40 ] ) ; <nl> + deepEqual ( actual , object ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should accept a two dimensional array ' , 1 , function ( ) { <nl> + var actual = _ . zipObject ( array ) ; <nl> + deepEqual ( actual , object ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should accept a falsey ` array ` argument ' , 1 , function ( ) { <nl> + var actual = [ ] , <nl> + expected = _ . map ( falsey , function ( ) { return { } ; } ) ; <nl> + <nl> + _ . forEach ( falsey , function ( value , index ) { <nl> + try { <nl> + actual . push ( index ? _ . zipObject ( value ) : _ . zipObject ( ) ) ; <nl> + } catch ( e ) { } <nl> + } ) ; <nl> + <nl> + deepEqual ( actual , expected ) ; <nl> + } ) ; <nl> + <nl> + test ( ' should support consuming the return value of ` _ . pairs ` ' , 1 , function ( ) { <nl> + deepEqual ( _ . zipObject ( _ . pairs ( object ) ) , object ) ; <nl> } ) ; <nl> } ( ) ) ; <nl> <nl> <nl> } ) ; <nl> <nl> / / skip tests for missing methods of modularized builds <nl> - _ . each ( [ ' runInContext ' , ' tap ' ] , function ( methodName ) { <nl> + _ . forEach ( [ ' runInContext ' , ' tap ' ] , function ( methodName ) { <nl> if ( ! _ [ methodName ] ) { <nl> skipTest ( ) ; <nl> } <nl>\n", "msg": "Add Underscore ' s \" Array \" method category tests to test / test . js .\n", "score": 1}
{"diff_id": 12296, "repo": "meteor/meteor\n", "sha": "b8341fb024c2af55135d934056de566a64fd8252\n", "time": "2014-03-07T02:24:52Z\n", "diff": "mmm a / packages / constraint - solver / constraint - solver - tests . js <nl> ppp b / packages / constraint - solver / constraint - solver - tests . js <nl> var insertVersion = function ( name , version , ecv , deps ) { <nl> Versions . insert ( { packageName : name , version : version , earliestCompatibleVersion : ecv , <nl> dependencies : constructedDeps } ) ; <nl> } ; <nl> - insertVersion ( \" sparky - forms \" , \" 1 . 1 . 2 \" , \" 1 . 1 . 0 \" , { \" forms \" : \" = 1 . 0 . 1 \" , \" sparkle \" : \" = 2 . 1 . 1 \" } ) ; <nl> + insertVersion ( \" sparky - forms \" , \" 1 . 1 . 2 \" , \" 1 . 0 . 0 \" , { \" forms \" : \" = 1 . 0 . 1 \" , \" sparkle \" : \" = 2 . 1 . 1 \" } ) ; <nl> insertVersion ( \" forms \" , \" 1 . 0 . 1 \" , \" 1 . 0 . 0 \" , { \" sparkle \" : \" 2 . 1 . 0 \" , \" jquery - widgets \" : \" 1 . 0 . 0 \" } ) ; <nl> insertVersion ( \" sparkle \" , \" 2 . 1 . 0 \" , \" 2 . 1 . 0 \" , { \" jquery \" : \" 1 . 8 . 2 \" } ) ; <nl> insertVersion ( \" sparkle \" , \" 2 . 1 . 1 \" , \" 2 . 1 . 0 \" , { \" jquery \" : \" 1 . 8 . 2 \" } ) ; <nl> Tinytest . add ( \" constraint solver - simple exact + regular deps \" , function ( test ) <nl> \" dropdown \" : \" 1 . 2 . 2 \" <nl> } ) ; <nl> } ) ; <nl> + <nl> + Tinytest . add ( \" constraint solver - non - exact direct dependency \" , function ( test ) { <nl> + currentTest = test ; <nl> + / / sparky - forms 1 . 0 . 0 won ' t be chosen because it depends on a very old <nl> + / / jquery , which is not compatible with the jquery that <nl> + / / awesome - dropdown uses . <nl> + t ( { \" sparky - forms \" : \" 1 . 0 . 0 \" , \" awesome - dropdown \" : \" = 1 . 5 . 0 \" } , { <nl> + \" sparky - forms \" : \" 1 . 1 . 2 \" , <nl> + \" forms \" : \" 1 . 0 . 1 \" , <nl> + \" sparkle \" : \" 2 . 1 . 1 \" , <nl> + \" jquery - widgets \" : \" 1 . 0 . 0 \" , <nl> + \" jquery \" : \" 1 . 8 . 2 \" , <nl> + \" awesome - dropdown \" : \" 1 . 5 . 0 \" , <nl> + \" dropdown \" : \" 1 . 2 . 2 \" <nl> + } ) ; <nl> + } ) ; <nl>\n", "msg": "Add constraint solver test for nonexact direct dependency\n", "score": 1}
{"diff_id": 12519, "repo": "meteor/meteor\n", "sha": "1bc08a9e766c210d5af0cb0c9dacb17de2dc7c6f\n", "time": "2015-04-21T21:58:54Z\n", "diff": "mmm a / packages / minimongo / projection . js <nl> ppp b / packages / minimongo / projection . js <nl> LocalCollection . _checkSupportedProjection = function ( fields ) { <nl> _ . each ( fields , function ( val , keyPath ) { <nl> if ( _ . contains ( keyPath . split ( ' . ' ) , ' $ ' ) ) <nl> throw MinimongoError ( \" Minimongo doesn ' t support $ operator in projections yet . \" ) ; <nl> - if ( typeof val = = = ' object ' & & _ . contains ( [ ' $ elemMatch ' , ' $ meta ' , ' $ slice ' ] , _ . keys ( val ) [ 0 ] ) ) <nl> + if ( typeof val = = = ' object ' & & _ . intersection ( [ ' $ elemMatch ' , ' $ meta ' , ' $ slice ' ] , _ . keys ( val ) ) . length > 0 ) <nl> throw MinimongoError ( \" Minimongo doesn ' t support operators in projections yet . \" ) ; <nl> if ( _ . indexOf ( [ 1 , 0 , true , false ] , val ) = = = - 1 ) <nl> throw MinimongoError ( \" Projection values should be one of 1 , 0 , true , or false \" ) ; <nl>\n", "msg": "Allow for multiple projection operators .\n", "score": 1}
{"diff_id": 12818, "repo": "meteor/meteor\n", "sha": "dbb24f5788b017408430b3f6b5b1fe4643fe002e\n", "time": "2017-07-13T22:26:05Z\n", "diff": "mmm a / packages / mongo / mongo_driver . js <nl> ppp b / packages / mongo / mongo_driver . js <nl> var simulateUpsertWithInsertedId = function ( collection , selector , mod , <nl> var tries = NUM_OPTIMISTIC_TRIES ; <nl> <nl> var doUpdate = function ( ) { <nl> - collection . update ( selector , mod , mongoOptsForUpdate , <nl> + tries - - ; <nl> + if ( ! tries ) { <nl> + callback ( new Error ( \" Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries . \" ) ) ; <nl> + } else { <nl> + collection . update ( selector , mod , mongoOptsForUpdate , <nl> bindEnvironmentForWrite ( function ( err , result ) { <nl> if ( err ) { <nl> callback ( err ) ; <nl> var simulateUpsertWithInsertedId = function ( collection , selector , mod , <nl> doConditionalInsert ( ) ; <nl> } <nl> } ) ) ; <nl> + } <nl> } ; <nl> <nl> var doConditionalInsert = function ( ) { <nl> - tries - - ; <nl> - if ( ! tries ) { <nl> - callback ( new Error ( \" Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries . \" ) ) ; <nl> - } else { <nl> - collection . update ( selector , replacementWithId , mongoOptsForInsert , <nl> - bindEnvironmentForWrite ( function ( err , result ) { <nl> - if ( err ) { <nl> - / / figure out if this is a <nl> - / / \" cannot change _id of document \" error , and <nl> - / / if so , try doUpdate ( ) again , up to 3 times . <nl> - if ( MongoConnection . _isCannotChangeIdError ( err ) ) { <nl> - doUpdate ( ) ; <nl> - } else { <nl> - callback ( err ) ; <nl> - } <nl> + collection . update ( selector , replacementWithId , mongoOptsForInsert , <nl> + bindEnvironmentForWrite ( function ( err , result ) { <nl> + if ( err ) { <nl> + / / figure out if this is a <nl> + / / \" cannot change _id of document \" error , and <nl> + / / if so , try doUpdate ( ) again , up to 3 times . <nl> + if ( MongoConnection . _isCannotChangeIdError ( err ) ) { <nl> + doUpdate ( ) ; <nl> } else { <nl> - callback ( null , { <nl> - numberAffected : result . result . upserted . length , <nl> - insertedId : insertedId , <nl> - } ) ; <nl> + callback ( err ) ; <nl> } <nl> - } ) ) ; <nl> - } <nl> + } else { <nl> + callback ( null , { <nl> + numberAffected : result . result . upserted . length , <nl> + insertedId : insertedId , <nl> + } ) ; <nl> + } <nl> + } ) ) ; <nl> } ; <nl> <nl> - doConditionalInsert ( ) ; <nl> + doUpdate ( ) ; <nl> } ; <nl> <nl> _ . each ( [ \" insert \" , \" update \" , \" remove \" , \" dropCollection \" , \" dropDatabase \" ] , function ( method ) { <nl>\n", "msg": "Revert order of simulated upsert to original order\n", "score": 1}
{"diff_id": 13355, "repo": "photonstorm/phaser\n", "sha": "13b54403f36087ec789891c3fe6c63206ee52ec4\n", "time": "2017-11-09T09:58:50Z\n", "diff": "mmm a / v3 / src / loader / filetypes / AudioFile . js <nl> ppp b / v3 / src / loader / filetypes / AudioFile . js <nl> var AudioFile = new Class ( { <nl> <nl> } ) ; <nl> <nl> - AudioFile . create = function ( loader , key , urls , config , xhrSettings ) { <nl> + AudioFile . create = function ( loader , key , urls , config , xhrSettings ) <nl> + { <nl> <nl> var url = AudioFile . findAudioURL ( urls ) ; <nl> <nl> AudioFile . findAudioURL = function ( urls ) <nl> { <nl> if ( urls . constructor ! = = Array ) <nl> { <nl> - urls = [ urls ] ; <nl> + urls = [ urls ] ; <nl> } <nl> <nl> for ( var i = 0 ; i < urls . length ; i + + ) <nl> AudioFile . findAudioURL = function ( urls ) <nl> return url ; <nl> } <nl> <nl> - var audioType = url . match ( / \\ . ( [ ^ \\ . ? ] + ) ( $ | \\ ? ) / ) ; <nl> + var audioType = url . match ( / \\ . ( [ a - zA - Z0 - 9 ] + ) ( $ | \\ ? ) / ) ; <nl> <nl> audioType = GetFastValue ( urls [ i ] , ' type ' , audioType ? audioType [ 1 ] : ' ' ) . toLowerCase ( ) ; <nl> <nl>\n", "msg": "using better regex for extracting file extension\n", "score": 1}
{"diff_id": 13588, "repo": "adobe/brackets\n", "sha": "11dbdfdb5d84ecaee826bd722b1053ede0fba60e\n", "time": "2013-07-05T19:25:09Z\n", "diff": "mmm a / src / extensions / default / JSLint / main . js <nl> ppp b / src / extensions / default / JSLint / main . js <nl> define ( function ( require , exports , module ) { <nl> DocumentManager = brackets . getModule ( \" document / DocumentManager \" ) , <nl> EditorManager = brackets . getModule ( \" editor / EditorManager \" ) , <nl> LanguageManager = brackets . getModule ( \" language / LanguageManager \" ) , <nl> + NativeFileSystem = brackets . getModule ( \" file / NativeFileSystem \" ) . NativeFileSystem , <nl> PreferencesManager = brackets . getModule ( \" preferences / PreferencesManager \" ) , <nl> PerfUtils = brackets . getModule ( \" utils / PerfUtils \" ) , <nl> + ProjectManager = brackets . getModule ( \" project / ProjectManager \" ) , <nl> Strings = brackets . getModule ( \" strings \" ) , <nl> StringUtils = brackets . getModule ( \" utils / StringUtils \" ) , <nl> AppInit = brackets . getModule ( \" utils / AppInit \" ) , <nl> define ( function ( require , exports , module ) { <nl> * @ type { boolean } <nl> * / <nl> var _gotoEnabled = false ; <nl> - <nl> + <nl> + / * * <nl> + * @ private <nl> + * @ type { string } <nl> + * / <nl> + var _configFileName = \" . jslint . json \" ; <nl> + <nl> + / * * <nl> + * @ private <nl> + * @ type { object } <nl> + * / <nl> + var _jsLintConfig = null ; <nl> + <nl> / * * <nl> * Enable or disable the \" Go to First JSLint Error \" command <nl> * @ param { boolean } gotoEnabled Whether it is enabled . <nl> define ( function ( require , exports , module ) { <nl> CommandManager . get ( GOTO_FIRST_ERROR ) . setEnabled ( gotoEnabled ) ; <nl> _gotoEnabled = gotoEnabled ; <nl> } <nl> + <nl> + / * * <nl> + * Load project - wide JSLint configuration . <nl> + * <nl> + * Brackets JSLint configuration should be in JSON format , with all the <nl> + * JSLint options specified according to JSLint documentation . <nl> + * <nl> + * JSLint project file should be located at < Project Root > / . jslint . json . It <nl> + * is loaded each time project is changed or the configuration file is <nl> + * modified . <nl> + * <nl> + * @ return Promise to return JSLint configuration object . <nl> + * <nl> + * @ see < a href = \" http : / / www . jslint . com / lint . html # options \" > JSLint option <nl> + * reference < / a > . <nl> + * / <nl> + function _loadProjectConfig ( ) { <nl> + <nl> + var projectRootEntry = ProjectManager . getProjectRoot ( ) , <nl> + result = new $ . Deferred ( ) , <nl> + config ; <nl> + <nl> + projectRootEntry . getFile ( _configFileName , <nl> + { create : false } , <nl> + function ( configFileEntry ) { <nl> + var reader = new NativeFileSystem . FileReader ( ) ; <nl> + configFileEntry . file ( function ( file ) { <nl> + reader . onload = function ( event ) { <nl> + try { <nl> + config = JSON . parse ( event . target . result ) ; <nl> + result . resolve ( config ) ; <nl> + } catch ( e ) { <nl> + result . reject ( e ) ; <nl> + } <nl> + } ; <nl> + reader . onerror = function ( event ) { <nl> + result . reject ( event . target . error ) ; <nl> + } ; <nl> + reader . readAsText ( file ) ; <nl> + } ) ; <nl> + } , <nl> + function ( err ) { <nl> + result . reject ( err ) ; <nl> + } ) ; <nl> + <nl> + return result . promise ( ) ; <nl> + <nl> + } <nl> <nl> / * * <nl> * Run JSLint on the current document . Reports results to the main UI . Displays <nl> define ( function ( require , exports , module ) { <nl> } <nl> text = arr . join ( \" \\ n \" ) ; <nl> <nl> - var result = JSLINT ( text , null ) ; <nl> + var result = JSLINT ( text , _jsLintConfig ) ; <nl> <nl> PerfUtils . addMeasurement ( perfTimerLint ) ; <nl> perfTimerDOM = PerfUtils . markStart ( \" JSLint DOM : \\ t \" + ( ! currentDoc | | currentDoc . file . fullPath ) ) ; <nl> define ( function ( require , exports , module ) { <nl> setGotoEnabled ( false ) ; <nl> } <nl> } <nl> - <nl> + <nl> / * * <nl> - * Update DocumentManager listeners . <nl> + * Update DocumentManager and ProjectManager listeners . <nl> * / <nl> function updateListeners ( ) { <nl> if ( _enabled ) { <nl> define ( function ( require , exports , module ) { <nl> run ( ) ; <nl> } ) <nl> . on ( \" documentSaved . jslint documentRefreshed . jslint \" , function ( event , document ) { <nl> + / / if this project ' s JSLint config has been updated , reload <nl> + if ( document . file . fullPath = = = <nl> + ProjectManager . getProjectRoot ( ) . fullPath + _configFileName ) { <nl> + _loadProjectConfig ( ) <nl> + . done ( function ( config ) { <nl> + _jsLintConfig = config ; <nl> + } ) <nl> + . fail ( function ( ) { <nl> + _jsLintConfig = null ; <nl> + } ) ; <nl> + } <nl> if ( document = = = DocumentManager . getCurrentDocument ( ) ) { <nl> run ( ) ; <nl> } <nl> } ) ; <nl> + $ ( ProjectManager ) <nl> + . on ( \" projectOpen . jslint \" , function ( ) { <nl> + _loadProjectConfig ( ) <nl> + . done ( function ( config ) { <nl> + _jsLintConfig = config ; <nl> + } ) <nl> + . fail ( function ( ) { <nl> + _jsLintConfig = null ; <nl> + } ) ; <nl> + } ) ; <nl> } else { <nl> $ ( DocumentManager ) . off ( \" . jslint \" ) ; <nl> + $ ( ProjectManager ) . off ( \" . jslint \" ) ; <nl> } <nl> } <nl> <nl>\n", "msg": "Add support for project - wide JSLint config .\n", "score": 1}
{"diff_id": 13624, "repo": "adobe/brackets\n", "sha": "4687f56186251ba32314e87f9e72f55f15524c97\n", "time": "2013-08-03T13:30:21Z\n", "diff": "mmm a / src / nls / de / strings . js <nl> ppp b / src / nls / de / strings . js <nl> define ( { <nl> <nl> / / Extension Management strings <nl> \" INSTALL \" : \" Installieren \" , <nl> - \" UPDATE \" : \" Aktualisieren \" , <nl> + \" UPDATE \" : \" Updaten \" , <nl> \" REMOVE \" : \" Entfernen \" , <nl> \" OVERWRITE \" : \" berschreiben \" , <nl> \" CANT_REMOVE_DEV \" : \" Erweiterungen im \\ \" dev \\ \" - Ordner mssen manuell gelscht werden . \" , <nl> \" CANT_UPDATE \" : \" Das Update ist nicht kompatibel mit dieser Version von { APP_NAME } . \" , <nl> \" INSTALL_EXTENSION_TITLE \" : \" Erweiterung installieren \" , <nl> - \" UPDATE_EXTENSION_TITLE \" : \" Erweiterung aktualisieren \" , <nl> + \" UPDATE_EXTENSION_TITLE \" : \" Erweiterung updaten \" , <nl> \" INSTALL_EXTENSION_LABEL \" : \" Erweiterungs - URL \" , <nl> \" INSTALL_EXTENSION_HINT \" : \" URL der Erweiterungs - ZIP - Datei oder GitHub - Repo \" , <nl> \" INSTALLING_FROM \" : \" Erweiterung installieren von { 0 } \\ u2026 \" , <nl> define ( { <nl> \" BROWSE_EXTENSIONS \" : \" Erweiterungen durchsuchen \" , <nl> \" EXTENSION_MANAGER_REMOVE \" : \" Erweiterung entfernen \" , <nl> \" EXTENSION_MANAGER_REMOVE_ERROR \" : \" Fehler beim Entfernen der Erweiterung : { 0 } . { APP_NAME } wird trotzdem beendet . \" , <nl> - \" EXTENSION_MANAGER_UPDATE \" : \" Erweiterung aktualisieren \" , <nl> - \" EXTENSION_MANAGER_UPDATE_ERROR \" : \" Fehler beim Aktualisieren von einer oder mehreren Erweiterung ( en ) : { 0 } . { APP_NAME } wird trotzdem beendet . \" , <nl> + \" EXTENSION_MANAGER_UPDATE \" : \" Erweiterung updaten \" , <nl> + \" EXTENSION_MANAGER_UPDATE_ERROR \" : \" Fehler beim Update einer oder mehrerer Erweiterung ( en ) : { 0 } . { APP_NAME } wird trotzdem beendet . \" , <nl> \" MARKED_FOR_REMOVAL \" : \" Zur Entfernung markiert \" , <nl> \" UNDO_REMOVE \" : \" Rckgngig \" , <nl> - \" MARKED_FOR_UPDATE \" : \" Zur Aktualisierung markiert \" , <nl> + \" MARKED_FOR_UPDATE \" : \" Zum Update markiert \" , <nl> \" UNDO_UPDATE \" : \" Rckgngig \" , <nl> \" CHANGE_AND_QUIT_TITLE \" : \" Erweiterungen ndern \" , <nl> - \" CHANGE_AND_QUIT_MESSAGE \" : \" Um die markierten Erweiterungen zu aktualisieren oder zu entfernen , mssen Sie { APP_NAME } beenden und neu starten . Sie werden gefragt , ob ungespeicherte nderungen gespeichert werden sollen . \" , <nl> + \" CHANGE_AND_QUIT_MESSAGE \" : \" Um die markierten Erweiterungen zu updaten oder zu entfernen , mssen Sie { APP_NAME } beenden und neu starten . Sie werden gefragt , ob ungespeicherte nderungen gespeichert werden sollen . \" , <nl> \" REMOVE_AND_QUIT \" : \" Erweiterungen entfernen und beenden \" , <nl> \" CHANGE_AND_QUIT \" : \" Erweiterungen ndern und beenden \" , <nl> - \" UPDATE_AND_QUIT \" : \" Erweiterungen aktualisieren und beenden \" , <nl> + \" UPDATE_AND_QUIT \" : \" Erweiterungen updaten und beenden \" , <nl> \" EXTENSION_NOT_INSTALLED \" : \" Die Erweiterung { 0 } konnte nicht entfernt werden , weil sie nicht installiert ist . \" , <nl> \" NO_EXTENSIONS \" : \" Momentan sind keine Erweiterungen installiert . < br > Klicken Sie oben auf den Tab \\ \" Verfgbar \\ \" , um zu beginnen . \" , <nl> \" NO_EXTENSION_MATCHES \" : \" Keine Erweiterungen passen auf Ihre Suchanfrage . \" , <nl>\n", "msg": "' de ' locale : Use consistent wording for \" [ to ] update \" and \" update ( s ) \"\n", "score": 1}
{"diff_id": 13941, "repo": "TryGhost/Ghost\n", "sha": "dc3345b1c59d03261ecd678a9cbad0ec91ef5a38\n", "time": "2019-08-09T06:39:01Z\n", "diff": "mmm a / core / server / models / post . js <nl> ppp b / core / server / models / post . js <nl> Post = ghostBookshelf . Model . extend ( { <nl> status : ' draft ' , <nl> featured : false , <nl> page : false , <nl> + type : ' post ' , <nl> visibility : ' public ' <nl> } ; <nl> } , <nl>\n", "msg": "Added type property to post model defaults\n", "score": 1}
{"diff_id": 13942, "repo": "nuxt/nuxt.js\n", "sha": "5cd0827b20e0ee3a8e22c7dd80835149a18431ff\n", "time": "2017-01-31T23:45:30Z\n", "diff": "mmm a / lib / webpack / base . config . js <nl> ppp b / lib / webpack / base . config . js <nl> export default function ( { isClient , isServer } ) { <nl> ' assets ' : join ( this . srcDir , ' assets ' ) , / / use in template with < img src = \" ~ static / nuxt . png \" / > <nl> ' ~ assets ' : join ( this . srcDir , ' assets ' ) , <nl> ' ~ plugins ' : join ( this . srcDir , ' plugins ' ) , <nl> - ' ~ store ' : join ( this . srcDir , ' store ' ) , <nl> + ' ~ store ' : join ( this . dir , ' . nuxt / store ' ) , <nl> ' ~ router ' : join ( this . dir , ' . nuxt / router ' ) , <nl> ' ~ pages ' : join ( this . srcDir , ' pages ' ) , <nl> ' ~ components ' : join ( this . srcDir , ' components ' ) <nl>\n", "msg": "~ store is now an alias for the store instance\n", "score": 1}
{"diff_id": 13963, "repo": "atom/atom\n", "sha": "8f9ab771a79d7b9f26604ed5333943de03e0b690\n", "time": "2016-03-15T14:44:00Z\n", "diff": "mmm a / src / git - repository - async . js <nl> ppp b / src / git - repository - async . js <nl> export default class GitRepositoryAsync { <nl> / / Returns a { Promise } which resolves to a { Boolean } that ' s true if the ` path ` <nl> / / is ignored . <nl> isPathIgnored ( _path ) { <nl> - / / NB : We ' re matching the behavior of ` GitRepository ` here . <nl> - if ( ! _path ) return Promise . resolve ( false ) <nl> - <nl> return this . getRepo ( ) <nl> . then ( repo = > { <nl> const relativePath = this . relativize ( _path , repo . workdir ( ) ) <nl> export default class GitRepositoryAsync { <nl> / / Returns a { Promise } which resolves to a status { Number } or null if the <nl> / / path is not in the cache . <nl> getCachedPathStatus ( _path ) { <nl> - / / NB : I don ' t love this , but we ' re matching the behavior of <nl> - / / ` GitRepository ` here for API compatibility . <nl> - if ( ! _path ) return null <nl> - <nl> return this . relativizeToWorkingDirectory ( _path ) <nl> . then ( relativePath = > this . pathStatusCache [ relativePath ] ) <nl> } <nl>\n", "msg": "Revert \" Match GitRepository ' s responses to null paths . \"\n", "score": 1}
{"diff_id": 14646, "repo": "adobe/brackets\n", "sha": "4895a7645b43aa205dcf7b4add53d2fec9458075\n", "time": "2013-04-25T00:04:47Z\n", "diff": "mmm a / src / command / Menus . js <nl> ppp b / src / command / Menus . js <nl> define ( function ( require , exports , module ) { <nl> <nl> <nl> / * * <nl> - * Insertion position constants <nl> - * Used by addMenu ( ) , addMenuItem ( ) , and addSubMenu ( ) to <nl> - * specify the relative position of a newly created menu object <nl> - * @ enum { string } <nl> - * / <nl> - var BEFORE = \" before \" ; <nl> - var AFTER = \" after \" ; <nl> - var FIRST = \" first \" ; <nl> - var LAST = \" last \" ; <nl> - var FIRST_IN_SECTION = \" firstInSection \" ; <nl> - var LAST_IN_SECTION = \" lastInSection \" ; <nl> - <nl> - / * * <nl> - * Other constants <nl> - * / <nl> - var DIVIDER = \" mmm \" ; <nl> + * Insertion position constants <nl> + * Used by addMenu ( ) , addMenuItem ( ) , and addSubMenu ( ) to <nl> + * specify the relative position of a newly created menu object <nl> + * @ enum { string } <nl> + * / <nl> + var BEFORE = \" before \" ; <nl> + var AFTER = \" after \" ; <nl> + var FIRST = \" first \" ; <nl> + var LAST = \" last \" ; <nl> + var FIRST_IN_SECTION = \" firstInSection \" ; <nl> + var LAST_IN_SECTION = \" lastInSection \" ; <nl> <nl> + / * * <nl> + * Other constants <nl> + * / <nl> + var DIVIDER = \" mmm \" ; <nl> + <nl> + / * * <nl> + * Error Codes from Brackets Shell <nl> + * @ enum { number } <nl> + * / <nl> + var NO_ERROR = 0 ; <nl> + var ERR_UNKNOWN = 1 ; <nl> + var ERR_INVALID_PARAMS = 2 ; <nl> + var ERR_NOT_FOUND = 3 ; <nl> + <nl> / * * <nl> * Maps menuID ' s to Menu objects <nl> * @ type { Object . < string , Menu > } <nl> define ( function ( require , exports , module ) { <nl> * @ return { MenuItem } the newly created MenuItem <nl> * / <nl> Menu . prototype . addMenuItem = function ( command , keyBindings , position , relativeID ) { <nl> - var id , <nl> + var menuID = this . id , <nl> + id , <nl> $ menuItem , <nl> $ link , <nl> menuItem , <nl> define ( function ( require , exports , module ) { <nl> } <nl> <nl> brackets . app . addMenuItem ( this . id , name , commandID , bindingStr , displayStr , position , relativeID , function ( err ) { <nl> - if ( err ) { <nl> - console . error ( \" addMenuItem ( ) - - error : \" + err + \" when adding command : \" + commandID ) ; <nl> + switch ( err ) { <nl> + case ERR_INVALID_PARAMS : <nl> + console . error ( \" addMenuItem ( ) : Invalid Parameters when adding the command \" + commandID ) ; <nl> + break ; <nl> + case ERR_NOT_FOUND : <nl> + console . error ( \" _getRelativeMenuItem ( ) : MenuItem with Command id \" + relativeID + \" not found in the Menu \" + menuID ) ; <nl> + break ; <nl> } <nl> } ) ; <nl> menuItem . isNative = true ; <nl> define ( function ( require , exports , module ) { <nl> <nl> if ( ! _isHTMLMenu ( id ) ) { <nl> brackets . app . addMenu ( name , id , position , relativeID , function ( err ) { <nl> - if ( err ) { <nl> - console . error ( \" addMenu ( ) - - error : \" + err + \" when adding menu with ID : \" + id ) ; <nl> - } else { <nl> + switch ( err ) { <nl> + case ERR_UNKNOWN : <nl> + console . error ( \" addMenu ( ) : Unknown Error when adding the menu \" + id ) ; <nl> + break ; <nl> + case ERR_INVALID_PARAMS : <nl> + console . error ( \" addMenu ( ) : Invalid Parameters when adding the menu \" + id ) ; <nl> + break ; <nl> + case ERR_NOT_FOUND : <nl> + console . error ( \" addMenu ( ) : Menu with command \" + relativeID + \" could not be found when adding the menu \" + id ) ; <nl> + break ; <nl> + case NO_ERROR : <nl> / / Make sure name is up to date <nl> brackets . app . setMenuTitle ( id , name , function ( err ) { <nl> if ( err ) { <nl> console . error ( \" setMenuTitle ( ) - - error : \" + err ) ; <nl> } <nl> } ) ; <nl> + break ; <nl> } <nl> } ) ; <nl> return menu ; <nl>\n", "msg": "Better error messages for AddMenu and AddMenuItem\n", "score": 1}
{"diff_id": 14666, "repo": "TryGhost/Ghost\n", "sha": "79f75865a1a7fe130f521e2030adaf9dbb2ef010\n", "time": "2013-09-17T00:54:36Z\n", "diff": "mmm a / core / server / controllers / frontend . js <nl> ppp b / core / server / controllers / frontend . js <nl> var Ghost = require ( ' . . / . . / ghost ' ) , <nl> api = require ( ' . . / api ' ) , <nl> RSS = require ( ' rss ' ) , <nl> _ = require ( ' underscore ' ) , <nl> + errors = require ( ' . . / errorHandling ' ) , <nl> + when = require ( ' when ' ) , <nl> <nl> ghost = new Ghost ( ) , <nl> frontendControllers ; <nl> <nl> frontendControllers = { <nl> - ' homepage ' : function ( req , res ) { <nl> + ' homepage ' : function ( req , res , next ) { <nl> / / Parse the page number <nl> var pageParam = req . params . page ! = = undefined ? parseInt ( req . params . page , 10 ) : 1 , <nl> postsPerPage = parseInt ( ghost . settings ( ' postsPerPage ' ) , 10 ) , <nl> frontendControllers = { <nl> ghost . doFilter ( ' prePostsRender ' , page . posts , function ( posts ) { <nl> res . render ( ' index ' , { posts : posts , pagination : { page : page . page , prev : page . prev , next : page . next , limit : page . limit , total : page . total , pages : page . pages } } ) ; <nl> } ) ; <nl> + } ) . otherwise ( function ( err ) { <nl> + return next ( new Error ( err ) ) ; <nl> } ) ; <nl> } , <nl> - ' single ' : function ( req , res ) { <nl> + ' single ' : function ( req , res , next ) { <nl> api . posts . read ( { ' slug ' : req . params . slug } ) . then ( function ( post ) { <nl> - ghost . doFilter ( ' prePostsRender ' , post . toJSON ( ) , function ( post ) { <nl> - res . render ( ' post ' , { post : post } ) ; <nl> - } ) ; <nl> + if ( post ) { <nl> + ghost . doFilter ( ' prePostsRender ' , post . toJSON ( ) , function ( post ) { <nl> + res . render ( ' post ' , { post : post } ) ; <nl> + } ) ; <nl> + } else { <nl> + next ( ) ; <nl> + } <nl> + <nl> + } ) . otherwise ( function ( err ) { <nl> + return next ( new Error ( err ) ) ; <nl> } ) ; <nl> } , <nl> - ' rss ' : function ( req , res ) { <nl> + ' rss ' : function ( req , res , next ) { <nl> / / Initialize RSS <nl> var siteUrl = ghost . config ( ) . url , <nl> pageParam = req . params . page ! = = undefined ? parseInt ( req . params . page , 10 ) : 1 , <nl> frontendControllers = { <nl> res . send ( feed . xml ( ) ) ; <nl> } ) ; <nl> } ) ; <nl> + } ) . otherwise ( function ( err ) { <nl> + return next ( new Error ( err ) ) ; <nl> } ) ; <nl> } <nl> } ; <nl>\n", "msg": "Error handling for the frontend routes\n", "score": 1}
{"diff_id": 14943, "repo": "mozilla/pdf.js\n", "sha": "84fe442b35cf113868d5b1bc80db5db5c36ce4cd\n", "time": "2017-08-31T07:20:05Z\n", "diff": "mmm a / src / display / fetch_stream . js <nl> ppp b / src / display / fetch_stream . js <nl> function createFetchOptions ( headers , withCredentials ) { <nl> method : ' GET ' , <nl> headers , <nl> mode : ' cors ' , <nl> - credentials : withCredentials ? ' omit ' : ' include ' , <nl> + credentials : withCredentials ? ' include ' : ' omit ' , <nl> redirect : ' follow ' , <nl> } ; <nl> } <nl>\n", "msg": "Correctly set the ` credentials ` of a fetch request , when the ` withCredentials ` parameter was passed to ` getDocument `\n", "score": 1}
{"diff_id": 15042, "repo": "ajaxorg/ace\n", "sha": "2c9404224be707c02ca94f468db12ecf4ed39861\n", "time": "2011-05-10T18:43:49Z\n", "diff": "mmm a / lib / ace / layer / text . js <nl> ppp b / lib / ace / layer / text . js <nl> var Text = function ( parentEl ) { <nl> this . config = config ; <nl> <nl> var html = [ ] ; <nl> - var tokens = this . session . getTokens ( config . firstRow , config . lastRow ) <nl> - var fragment = this . $ renderLinesFragment ( config , config . firstRow , config . lastRow ) ; <nl> + var firstRow = config . firstRow , lastRow = config . lastRow ; <nl> + var tokens = this . session . getTokens ( firstRow , lastRow ) <nl> <nl> - / / Clear the current content of the element and add the rendered fragment . <nl> - this . element . innerHTML = \" \" ; <nl> - this . element . appendChild ( fragment ) ; <nl> + for ( var row = firstRow ; row < = lastRow ; row + + ) { <nl> + html . push ( \" < div class = ' ace_line ' style = ' height : \" , <nl> + this . session . getRowHeight ( config , row ) + \" px ; \" , \" width \" , config . width + \" px ' > \" <nl> + ) <nl> + / / Get the tokens per line as there might be some lines in between <nl> + / / beeing folded . <nl> + / / OPTIMIZE : If there is a long block of unfolded lines , just make <nl> + / / this call once for that big block of unfolded lines . <nl> + var tokens = this . session . getTokens ( row , row ) ; <nl> + if ( tokens . length = = 1 ) <nl> + this . $ renderLine ( html , row , tokens [ 0 ] . tokens ) ; <nl> + html . push ( \" < / div > \" ) <nl> + row = this . session . getRowFoldEnd ( row ) ; <nl> + } <nl> + this . element = dom . setInnerHtml ( this . element , html . join ( \" \" ) ) ; <nl> } ; <nl> <nl> this . $ textToken = { <nl>\n", "msg": "restore setInnerHtml optimization for text layer\n", "score": 1}
{"diff_id": 15257, "repo": "lodash/lodash\n", "sha": "844fe1d9793cad1d60f97222108b2af2f86160e4\n", "time": "2015-12-22T07:04:26Z\n", "diff": "mmm a / lodash . js <nl> ppp b / lodash . js <nl> <nl> stringProto = context . String . prototype ; <nl> <nl> / * * Used to resolve the decompiled source of functions . * / <nl> - var fnToString = context . Function . prototype . toString ; <nl> + var funcToString = context . Function . prototype . toString ; <nl> <nl> / * * Used to check objects for own properties . * / <nl> var hasOwnProperty = objectProto . hasOwnProperty ; <nl> <nl> var idCounter = 0 ; <nl> <nl> / * * Used to infer the ` Object ` constructor . * / <nl> - var objCtorString = fnToString . call ( Object ) ; <nl> + var objectCtorString = funcToString . call ( Object ) ; <nl> <nl> / * * <nl> * Used to resolve the [ ` toStringTag ` ] ( http : / / ecma - international . org / ecma - 262 / 6 . 0 / # sec - object . prototype . tostring ) <nl> * of values . <nl> * / <nl> - var objToString = objectProto . toString ; <nl> + var objectToString = objectProto . toString ; <nl> <nl> / * * Used to restore the original ` _ ` reference in ` _ . noConflict ` . * / <nl> var oldDash = root . _ ; <nl> <nl> / * * Used to detect if a method is native . * / <nl> var reIsNative = RegExp ( ' ^ ' + <nl> - fnToString . call ( hasOwnProperty ) . replace ( reRegExpChar , ' \\ \\ $ & ' ) <nl> + funcToString . call ( hasOwnProperty ) . replace ( reRegExpChar , ' \\ \\ $ & ' ) <nl> . replace ( / hasOwnProperty | ( function ) . * ? ( ? = \\ \\ \\ ( ) | for . + ? ( ? = \\ \\ \\ ] ) / g , ' $ 1 . * ? ' ) + ' $ ' <nl> ) ; <nl> <nl> <nl> var metaMap = WeakMap & & new WeakMap ; <nl> <nl> / * * Used to detect maps and sets . * / <nl> - var mapCtorString = Map ? fnToString . call ( Map ) : ' ' , <nl> - setCtorString = Set ? fnToString . call ( Set ) : ' ' ; <nl> + var mapCtorString = Map ? funcToString . call ( Map ) : ' ' , <nl> + setCtorString = Set ? funcToString . call ( Set ) : ' ' ; <nl> <nl> / * * Used to convert symbols to strings . * / <nl> var symbolToString = Symbol ? Symbol . prototype . toString : undefined ; <nl> <nl> * @ returns { string } Returns the ` toStringTag ` . <nl> * / <nl> function getTag ( value ) { <nl> - return objToString . call ( value ) ; <nl> + return objectToString . call ( value ) ; <nl> } <nl> <nl> / / Fallback for IE 11 providing ` toStringTag ` values for maps and sets . <nl> if ( ( Map & & getTag ( new Map ) ! = mapTag ) | | ( Set & & getTag ( new Set ) ! = setTag ) ) { <nl> getTag = function ( value ) { <nl> - var result = objToString . call ( value ) , <nl> + var result = objectToString . call ( value ) , <nl> Ctor = result = = objectTag ? value . constructor : null , <nl> - ctorString = typeof Ctor = = ' function ' ? fnToString . call ( Ctor ) : ' ' ; <nl> + ctorString = typeof Ctor = = ' function ' ? funcToString . call ( Ctor ) : ' ' ; <nl> <nl> if ( ctorString ) { <nl> if ( ctorString = = mapCtorString ) { <nl> <nl> function isArguments ( value ) { <nl> / / Safari 8 . 1 incorrectly makes ` arguments . callee ` enumerable in strict mode . <nl> return isArrayLikeObject ( value ) & & hasOwnProperty . call ( value , ' callee ' ) & & <nl> - ( ! propertyIsEnumerable . call ( value , ' callee ' ) | | objToString . call ( value ) = = argsTag ) ; <nl> + ( ! propertyIsEnumerable . call ( value , ' callee ' ) | | objectToString . call ( value ) = = argsTag ) ; <nl> } <nl> <nl> / * * <nl> <nl> * / <nl> function isBoolean ( value ) { <nl> return value = = = true | | value = = = false | | <nl> - ( isObjectLike ( value ) & & objToString . call ( value ) = = boolTag ) ; <nl> + ( isObjectLike ( value ) & & objectToString . call ( value ) = = boolTag ) ; <nl> } <nl> <nl> / * * <nl> <nl> * / / = > false <nl> * / <nl> function isDate ( value ) { <nl> - return isObjectLike ( value ) & & objToString . call ( value ) = = dateTag ; <nl> + return isObjectLike ( value ) & & objectToString . call ( value ) = = dateTag ; <nl> } <nl> <nl> / * * <nl> <nl> * / <nl> function isError ( value ) { <nl> return isObjectLike ( value ) & & <nl> - typeof value . message = = ' string ' & & objToString . call ( value ) = = errorTag ; <nl> + typeof value . message = = ' string ' & & objectToString . call ( value ) = = errorTag ; <nl> } <nl> <nl> / * * <nl> <nl> / / The use of ` Object # toString ` avoids issues with the ` typeof ` operator <nl> / / in Safari 8 which returns ' object ' for typed array constructors , and <nl> / / PhantomJS 1 . 9 which returns ' function ' for ` NodeList ` instances . <nl> - var tag = isObject ( value ) ? objToString . call ( value ) : ' ' ; <nl> + var tag = isObject ( value ) ? objectToString . call ( value ) : ' ' ; <nl> return tag = = funcTag | | tag = = genTag ; <nl> } <nl> <nl> <nl> return false ; <nl> } <nl> if ( isFunction ( value ) ) { <nl> - return reIsNative . test ( fnToString . call ( value ) ) ; <nl> + return reIsNative . test ( funcToString . call ( value ) ) ; <nl> } <nl> return isObjectLike ( value ) & & <nl> ( isHostObject ( value ) ? reIsNative : reIsHostCtor ) . test ( value ) ; <nl> <nl> * / <nl> function isNumber ( value ) { <nl> return typeof value = = ' number ' | | <nl> - ( isObjectLike ( value ) & & objToString . call ( value ) = = numberTag ) ; <nl> + ( isObjectLike ( value ) & & objectToString . call ( value ) = = numberTag ) ; <nl> } <nl> <nl> / * * <nl> <nl> * / / = > true <nl> * / <nl> function isPlainObject ( value ) { <nl> - if ( ! isObjectLike ( value ) | | objToString . call ( value ) ! = objectTag | | isHostObject ( value ) ) { <nl> + if ( ! isObjectLike ( value ) | | objectToString . call ( value ) ! = objectTag | | isHostObject ( value ) ) { <nl> return false ; <nl> } <nl> var proto = objectProto ; <nl> <nl> } <nl> var Ctor = proto . constructor ; <nl> return ( typeof Ctor = = ' function ' & & <nl> - Ctor instanceof Ctor & & fnToString . call ( Ctor ) = = objCtorString ) ; <nl> + Ctor instanceof Ctor & & funcToString . call ( Ctor ) = = objectCtorString ) ; <nl> } <nl> <nl> / * * <nl> <nl> * / / = > false <nl> * / <nl> function isRegExp ( value ) { <nl> - return isObject ( value ) & & objToString . call ( value ) = = regexpTag ; <nl> + return isObject ( value ) & & objectToString . call ( value ) = = regexpTag ; <nl> } <nl> <nl> / * * <nl> <nl> * / <nl> function isString ( value ) { <nl> return typeof value = = ' string ' | | <nl> - ( ! isArray ( value ) & & isObjectLike ( value ) & & objToString . call ( value ) = = stringTag ) ; <nl> + ( ! isArray ( value ) & & isObjectLike ( value ) & & objectToString . call ( value ) = = stringTag ) ; <nl> } <nl> <nl> / * * <nl> <nl> * / / = > false <nl> * / <nl> function isTypedArray ( value ) { <nl> - return isObjectLike ( value ) & & isLength ( value . length ) & & ! ! typedArrayTags [ objToString . call ( value ) ] ; <nl> + return isObjectLike ( value ) & & isLength ( value . length ) & & ! ! typedArrayTags [ objectToString . call ( value ) ] ; <nl> } <nl> <nl> / * * <nl>\n", "msg": "Make var name changes for consistency .\n", "score": 1}
{"diff_id": 15328, "repo": "photonstorm/phaser\n", "sha": "6c7f7ae7326886526c348b2822c5e07717728ed6\n", "time": "2017-12-05T18:45:33Z\n", "diff": "mmm a / v3 / src / sound / webaudio / WebAudioSound . js <nl> ppp b / v3 / src / sound / webaudio / WebAudioSound . js <nl> var WebAudioSound = new Class ( { <nl> return false ; <nl> } <nl> this . stopAndRemoveBufferSource ( ) ; <nl> - this . pausedTime = this . manager . context . currentTime - this . startTime ; <nl> + this . pausedTime = this . seek ; <nl> return true ; <nl> } , <nl> resume : function ( ) { <nl>\n", "msg": "Setting pausedTime to current seek value\n", "score": 1}
{"diff_id": 15423, "repo": "facebook/react\n", "sha": "34f6fa4fab502497b6ffd5d04cf0547bb9569fc2\n", "time": "2019-05-23T18:22:02Z\n", "diff": "new file mode 100644 <nl> index 00000000000 . . 1a9b4b949a5 <nl> mmm / dev / null <nl> ppp b / src / __tests__ / bridge - test . js <nl> <nl> + / / @ flow <nl> + <nl> + describe ( ' Bridge ' , ( ) = > { <nl> + let Bridge ; <nl> + <nl> + beforeEach ( ( ) = > { <nl> + Bridge = require ( ' src / bridge ' ) . default ; <nl> + } ) ; <nl> + <nl> + it ( ' should shutdown properly ' , ( ) = > { <nl> + const wall = { <nl> + listen : jest . fn ( ( ) = > ( ) = > { } ) , <nl> + send : jest . fn ( ) , <nl> + } ; <nl> + const bridge = new Bridge ( wall ) ; <nl> + <nl> + / / Check that we ' re wired up correctly . <nl> + bridge . send ( ' init ' ) ; <nl> + jest . runAllTimers ( ) ; <nl> + expect ( wall . send ) . toHaveBeenCalledWith ( ' init ' , undefined , undefined ) ; <nl> + <nl> + / / Should flush pending messages and then shut down . <nl> + wall . send . mockClear ( ) ; <nl> + bridge . send ( ' update ' , ' 1 ' ) ; <nl> + bridge . send ( ' update ' , ' 2 ' ) ; <nl> + bridge . shutdown ( ) ; <nl> + jest . runAllTimers ( ) ; <nl> + expect ( wall . send ) . toHaveBeenCalledWith ( ' update ' , ' 1 ' , undefined ) ; <nl> + expect ( wall . send ) . toHaveBeenCalledWith ( ' update ' , ' 2 ' , undefined ) ; <nl> + expect ( wall . send ) . toHaveBeenCalledWith ( ' shutdown ' , undefined , undefined ) ; <nl> + <nl> + / / Verify that the Bridge doesn ' t send messages after shutdown . <nl> + spyOn ( console , ' warn ' ) ; <nl> + wall . send . mockClear ( ) ; <nl> + bridge . send ( ' should not send ' ) ; <nl> + jest . runAllTimers ( ) ; <nl> + expect ( wall . send ) . not . toHaveBeenCalled ( ) ; <nl> + expect ( console . warn ) . toHaveBeenCalledWith ( <nl> + ' Cannot send message \" should not send \" through a Bridge that has been shutdown . ' <nl> + ) ; <nl> + } ) ; <nl> + } ) ; <nl>\n", "msg": "Added a sanity test for Bridge shutdown\n", "score": 1}
{"diff_id": 15534, "repo": "facebook/react-native\n", "sha": "254b1ec6b318d9a47c729a0888fca3f9b02b7a8e\n", "time": "2016-10-22T13:13:42Z\n", "diff": "mmm a / packager / react - packager / src / node - haste / DependencyGraph / ResolutionRequest . js <nl> ppp b / packager / react - packager / src / node - haste / DependencyGraph / ResolutionRequest . js <nl> class ResolutionRequest { <nl> <nl> const searchQueue = [ ] ; <nl> for ( let currDir = path . dirname ( fromModule . path ) ; <nl> - currDir ! = = realPath . parse ( fromModule . path ) . root ; <nl> + currDir ! = = ' . ' & & currDir ! = = realPath . parse ( fromModule . path ) . root ; <nl> currDir = path . dirname ( currDir ) ) { <nl> const searchPath = path . join ( currDir , ' node_modules ' ) ; <nl> if ( this . _fastfs . dirExists ( searchPath ) ) { <nl>\n", "msg": "Add support for relative paths to ResolutionRequest\n", "score": 1}
{"diff_id": 15537, "repo": "meteor/meteor\n", "sha": "be644e474ee4cac3c92807a04a7a47ba6ed23666\n", "time": "2014-11-12T23:31:10Z\n", "diff": "mmm a / tools / utils . js <nl> ppp b / tools / utils . js <nl> exports . mobileServerForRun = function ( options ) { <nl> } ; <nl> } ; <nl> <nl> - exports . escapePackageName = function ( packageName ) { <nl> + exports . escapePackageNameForPath = function ( packageName ) { <nl> return packageName . replace ( \" : \" , \" _ \" ) ; <nl> } ; <nl> <nl> - exports . unescapePackageName = function ( escapedPackageName ) { <nl> + exports . unescapePackageNameForPath = function ( escapedPackageName ) { <nl> return escapedPackageName . replace ( \" _ \" , \" : \" ) ; <nl> } ; <nl>\n", "msg": "Improve name of escape function for package names\n", "score": 1}
{"diff_id": 15740, "repo": "Unitech/pm2\n", "sha": "858f9ec8e32f227d984e75bccd5f25522045a248\n", "time": "2014-10-28T11:48:35Z\n", "diff": "mmm a / lib / sample - conf . js <nl> ppp b / lib / sample - conf . js <nl> module . exports = function ( DEFAULT_HOME ) { <nl> INTERACTOR_RPC_PORT : p . join ( PM2_HOME , ' interactor . sock ' ) , <nl> <nl> GRACEFUL_TIMEOUT : parseInt ( process . env . PM2_GRACEFUL_TIMEOUT ) | | 8000 , <nl> + GRACEFUL_LISTEN_TIMEOUT : parseInt ( process . env . PM2_GRACEFUL_LISTEN_TIMEOUT ) | | 4000 , <nl> <nl> DEBUG : process . env . PM2_DEBUG | | false , <nl> WEB_INTERFACE : parseInt ( process . env . PM2_API_PORT ) | | 9615 , <nl>\n", "msg": "add GRACEFUL_LISTEN_TIMEOUT variable to conf file\n", "score": 1}
{"diff_id": 15760, "repo": "gorhill/uBlock\n", "sha": "38e1bbbe68586d88f8d385d93b4c45b086c1eea0\n", "time": "2020-10-16T14:06:00Z\n", "diff": "mmm a / src / js / codemirror / ubo - static - filtering . js <nl> ppp b / src / js / codemirror / ubo - static - filtering . js <nl> CodeMirror . registerHelper ( ' fold ' , ' ubo - static - filtering ' , ( ( ) = > { <nl> } <nl> <nl> / / Better word selection for cosmetic filters <nl> - if ( / \\ bext \\ b / . test ( token ) ) { <nl> + else if ( / \\ bext \\ b / . test ( token ) ) { <nl> if ( / \\ bvalue \\ b / . test ( token ) ) { <nl> const l = / [ ^ , . ] * $ / i . exec ( s . slice ( 0 , ch ) ) ; <nl> const r = / ^ [ ^ # , ] * / i . exec ( s . slice ( ch ) ) ; <nl> CodeMirror . registerHelper ( ' fold ' , ' ubo - static - filtering ' , ( ( ) = > { <nl> beg = l . index ; <nl> end = ch + r [ 0 ] . length ; <nl> } <nl> - } <nl> - if ( / \\ bvariable \\ b / . test ( token ) ) { <nl> + } else if ( / \\ bvariable \\ b / . test ( token ) ) { <nl> const l = / [ # . ] ? [ a - z0 - 9_ - ] + $ / i . exec ( s . slice ( 0 , ch ) ) ; <nl> const r = / ^ [ a - z0 - 9_ - ] + / i . exec ( s . slice ( ch ) ) ; <nl> if ( l & & r ) { <nl> CodeMirror . registerHelper ( ' fold ' , ' ubo - static - filtering ' , ( ( ) = > { <nl> } <nl> } <nl> <nl> - / / TODO : add more convenient word - matching cases here <nl> + / / Better word selection for network filters <nl> + else if ( / \\ bnet \\ b / . test ( token ) ) { <nl> + if ( / \\ bvalue \\ b / . test ( token ) ) { <nl> + const l = / [ ^ , . = | ] * $ / i . exec ( s . slice ( 0 , ch ) ) ; <nl> + const r = / ^ [ ^ # , | ] * / i . exec ( s . slice ( ch ) ) ; <nl> + if ( l & & r ) { <nl> + beg = l . index ; <nl> + end = ch + r [ 0 ] . length ; <nl> + } <nl> + } else if ( / \\ bdef \\ b / . test ( token ) ) { <nl> + const l = / [ a - z0 - 9 - ] + $ / i . exec ( s . slice ( 0 , ch ) ) ; <nl> + const r = / ^ [ ^ , ] * = [ ^ , ] + / i . exec ( s . slice ( ch ) ) ; <nl> + if ( l & & r ) { <nl> + beg = l . index ; <nl> + end = ch + r [ 0 ] . length ; <nl> + } <nl> + } <nl> + } <nl> <nl> if ( beg = = = undefined ) { return Pass ; } <nl> cm . setSelection ( <nl>\n", "msg": "Better word selection for static network filters\n", "score": 1}
{"diff_id": 16044, "repo": "atom/atom\n", "sha": "9c9625eb766bb75f53d1a2e807cc4efa66f1e66e\n", "time": "2017-08-01T19:08:03Z\n", "diff": "mmm a / spec / async - spec - helpers . js <nl> ppp b / spec / async - spec - helpers . js <nl> export function emitterEventPromise ( emitter , event , timeout = 15000 ) { <nl> } ) <nl> } ) <nl> } <nl> + <nl> + export function promisify ( original ) { <nl> + return function ( . . . args ) { <nl> + return new Promise ( ( resolve , reject ) = > { <nl> + args . push ( ( err , . . . results ) = > { <nl> + if ( err ) { <nl> + reject ( err ) <nl> + } else { <nl> + resolve ( . . . results ) <nl> + } <nl> + } ) <nl> + <nl> + return original ( . . . args ) <nl> + } ) <nl> + } <nl> + } <nl> + <nl> + export function promisifySome ( obj , fnNames ) { <nl> + const result = { } <nl> + for ( fnName of fnNames ) { <nl> + result [ fnName ] = promisify ( obj [ fnName ] ) <nl> + } <nl> + return result <nl> + } <nl>\n", "msg": "Helpers to promisify functions in specs\n", "score": 1}
{"diff_id": 16727, "repo": "facebook/react\n", "sha": "bb3a326ecd38698ac02d93019f7ff126e8ef4a11\n", "time": "2015-10-23T02:47:17Z\n", "diff": "mmm a / src / renderers / dom / shared / HTMLDOMPropertyConfig . js <nl> ppp b / src / renderers / dom / shared / HTMLDOMPropertyConfig . js <nl> var HTMLDOMPropertyConfig = { <nl> crossOrigin : null , <nl> data : null , / / For ` < object / > ` acts as ` src ` . <nl> dateTime : MUST_USE_ATTRIBUTE , <nl> + default : HAS_BOOLEAN_VALUE , <nl> defer : HAS_BOOLEAN_VALUE , <nl> dir : null , <nl> disabled : MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE , <nl>\n", "msg": "add default attribute for use with track element\n", "score": 1}
{"diff_id": 16753, "repo": "RocketChat/Rocket.Chat\n", "sha": "b5b07943df81d2b4bb591d3d696a5cf3f43574e1\n", "time": "2018-01-17T00:13:25Z\n", "diff": "mmm a / packages / rocketchat - lib / server / models / Subscriptions . js <nl> ppp b / packages / rocketchat - lib / server / models / Subscriptions . js <nl> class ModelSubscriptions extends RocketChat . models . _Base { <nl> rid : room . _id , <nl> name : room . name , <nl> fname : room . fname , <nl> + customFields : room . customFields , <nl> t : room . t , <nl> u : { <nl> _id : user . _id , <nl>\n", "msg": "Add customFields from Room to Subscription to enable query\n", "score": 1}
{"diff_id": 16952, "repo": "meteor/meteor\n", "sha": "8e57ecb7318ee98dbc00d3228cb2a2fcddc18703\n", "time": "2016-09-27T00:12:46Z\n", "diff": "mmm a / tools / isobuild / builder . js <nl> ppp b / tools / isobuild / builder . js <nl> import { WatchSet , readAndWatchFile , sha1 } from ' . . / fs / watch . js ' ; <nl> import files from ' . . / fs / files . js ' ; <nl> import NpmDiscards from ' . / npm - discards . js ' ; <nl> import { Profile } from ' . . / tool - env / profile . js ' ; <nl> + import { <nl> + optimisticReadFile , <nl> + optimisticReaddir , <nl> + optimisticLStat , <nl> + } from \" . . / fs / optimistic . js \" ; <nl> <nl> / / Builder is in charge of writing \" bundles \" to disk , which are <nl> / / directory trees such as site archives , programs , and packages . In <nl> Previous builder : $ { previousBuilder . outputPath } , this builder : $ { outputPath } ` <nl> <nl> this . _ensureDirectory ( relTo ) ; <nl> <nl> - files . readdir ( absFrom ) . forEach ( item = > { <nl> + optimisticReaddir ( absFrom ) . forEach ( item = > { <nl> const thisAbsFrom = files . pathResolve ( absFrom , item ) ; <nl> const thisRelTo = files . pathJoin ( relTo , item ) ; <nl> <nl> Previous builder : $ { previousBuilder . outputPath } , this builder : $ { outputPath } ` <nl> return ; <nl> } <nl> <nl> - const fileStatus = files . lstat ( thisAbsFrom ) ; <nl> + const fileStatus = optimisticLStat ( thisAbsFrom ) ; <nl> <nl> let itemForMatch = item ; <nl> const isDirectory = fileStatus . isDirectory ( ) ; <nl> Previous builder : $ { previousBuilder . outputPath } , this builder : $ { outputPath } ` <nl> } else { <nl> / / XXX can ' t really optimize this copying without reading <nl> / / the file into memory to calculate the hash . <nl> - files . copyFile ( thisAbsFrom , <nl> - files . pathResolve ( this . buildPath , thisRelTo ) , <nl> - fileStatus . mode ) ; <nl> + files . writeFile ( <nl> + files . pathResolve ( this . buildPath , thisRelTo ) , <nl> + optimisticReadFile ( thisAbsFrom ) , <nl> + { mode : fileStatus . mode } , <nl> + ) ; <nl> <nl> this . usedAsFile [ thisRelTo ] = true ; <nl> } <nl>\n", "msg": "Use optimistic functions in Builder # copyDirectory .\n", "score": 1}
{"diff_id": 17082, "repo": "codemirror/CodeMirror\n", "sha": "aa46ff58b8c91aa99c565b1304993e41c3301a79\n", "time": "2015-02-13T09:36:02Z\n", "diff": "mmm a / mode / verilog / verilog . js <nl> ppp b / mode / verilog / verilog . js <nl> CodeMirror . defineMode ( \" verilog \" , function ( config , parserConfig ) { <nl> statementIndentUnit = parserConfig . statementIndentUnit | | indentUnit , <nl> dontAlignCalls = parserConfig . dontAlignCalls , <nl> noIndentKeywords = parserConfig . noIndentKeywords | | [ ] , <nl> - multiLineStrings = parserConfig . multiLineStrings ; <nl> + multiLineStrings = parserConfig . multiLineStrings , <nl> + hooks = parserConfig . hooks | | { } ; <nl> <nl> function words ( str ) { <nl> var obj = { } , words = str . split ( \" \" ) ; <nl> CodeMirror . defineMode ( \" verilog \" , function ( config , parserConfig ) { <nl> var statementKeywords = words ( \" always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while \" ) ; <nl> <nl> function tokenBase ( stream , state ) { <nl> - var ch = stream . peek ( ) ; <nl> + var ch = stream . peek ( ) , style ; <nl> + if ( hooks [ ch ] & & ( ( style = hooks [ ch ] ( stream , state ) ) ! = false ) ) { return style ; } <nl> + if ( hooks [ \" tokenBase \" ] & & ( ( style = hooks [ \" tokenBase \" ] ( stream , state ) ) ! = false ) ) { return style ; } <nl> + <nl> if ( / [ , ; : \\ . ] / . test ( ch ) ) { <nl> curPunc = stream . next ( ) ; <nl> return null ; <nl> CodeMirror . defineMode ( \" verilog \" , function ( config , parserConfig ) { <nl> tokenize : null , <nl> context : new Context ( ( basecolumn | | 0 ) - indentUnit , 0 , \" top \" , false ) , <nl> indented : 0 , <nl> - startOfLine : true <nl> + startOfLine : true , <nl> + vxContext : ( hooks [ \" startStateContext \" ] ) ? new hooks [ \" startStateContext \" ] ( parserConfig ) : null <nl> } ; <nl> } , <nl> <nl> CodeMirror . defineMode ( \" verilog \" , function ( config , parserConfig ) { <nl> state . indented = stream . indentation ( ) ; <nl> state . startOfLine = true ; <nl> } <nl> + if ( hooks [ \" token \" ] ) { hooks [ \" token \" ] ( stream , state ) ; } <nl> if ( stream . eatSpace ( ) ) return null ; <nl> curPunc = null ; <nl> curKeyword = null ; <nl> CodeMirror . defineMode ( \" verilog \" , function ( config , parserConfig ) { <nl> <nl> indent : function ( state , textAfter ) { <nl> if ( state . tokenize ! = tokenBase & & state . tokenize ! = null ) return CodeMirror . Pass ; <nl> + if ( hooks [ \" indent \" ] & & hooks [ \" indent \" ] ( state ) > = 0 ) { return ( hooks [ \" indent \" ] ( state ) ) ; } ; <nl> var ctx = state . context , firstChar = textAfter & & textAfter . charAt ( 0 ) ; <nl> if ( ctx . type = = \" statement \" & & firstChar = = \" } \" ) ctx = ctx . prev ; <nl> var closing = false ; <nl> CodeMirror . defineMode ( \" verilog \" , function ( config , parserConfig ) { <nl> } ; <nl> } ) ; <nl> <nl> - CodeMirror . defineMIME ( \" text / x - verilog \" , { <nl> - name : \" verilog \" <nl> - } ) ; <nl> - CodeMirror . defineMIME ( \" text / x - systemverilog \" , { <nl> - name : \" systemverilog \" <nl> - } ) ; <nl> - <nl> + CodeMirror . defineMIME ( \" text / x - verilog \" , { <nl> + name : \" verilog \" <nl> + } ) ; <nl> + <nl> + CodeMirror . defineMIME ( \" text / x - systemverilog \" , { <nl> + name : \" verilog \" <nl> + } ) ; <nl> + <nl> + CodeMirror . defineMIME ( \" text / x - svx \" , { <nl> + name : \" verilog \" , <nl> + vxModeIsOn : true , <nl> + isSvxChangeScopePrefix : function ( str ) { <nl> + var svxchScopePrefixs = { <nl> + \" > \" : \" property \" , \" - > \" : \" property \" , \" - \" : \" hr \" , \" | \" : \" link \" , \" ? $ \" : \" qualifier \" , \" ? * \" : \" qualifier \" , <nl> + \" @ - \" : \" variable - 3 \" , \" @ \" : \" variable - 3 \" , \" ? \" : \" qualifier \" } ; <nl> + var x = svxchScopePrefixs [ str ] ; <nl> + return ( x = = = undefined ? false : x ) ; <nl> + } , <nl> + svxGenIndent : function ( stream , state ) { <nl> + var svxindentUnit = 2 ; <nl> + var rtnIndent = - 1 , indentUnitRq = 0 , curIndent = stream . indentation ( ) , ctx = state . vxContext ; <nl> + switch ( ctx . svxCurCtlFlowChar ) { <nl> + case \" \\ \\ \" : <nl> + curIndent = 0 ; <nl> + break ; <nl> + case \" | \" : <nl> + if ( ctx . svxPrevPrevCtlFlowChar = = \" @ \" ) { <nl> + indentUnitRq = - 2 ; / / - 2 new pipe rq after cur pipe <nl> + break ; <nl> + } <nl> + if ( ctx . thisMode . isSvxChangeScopePrefix ( ctx . svxPrevCtlFlowChar ) ! = false ) <nl> + indentUnitRq = 1 ; / / + 1 new scope <nl> + break ; <nl> + case \" M \" : / / m4 <nl> + if ( ctx . svxPrevPrevCtlFlowChar = = \" @ \" ) { <nl> + indentUnitRq = - 2 ; / / - 2 new inst rq after pipe <nl> + break ; <nl> + } <nl> + if ( ctx . thisMode . isSvxChangeScopePrefix ( ctx . svxPrevCtlFlowChar ) ! = false ) <nl> + indentUnitRq = 1 ; / / + 1 new scope <nl> + break ; <nl> + case \" @ \" : <nl> + if ( ctx . svxPrevCtlFlowChar = = \" S \" ) { <nl> + indentUnitRq = - 1 ; / / new pipe stage after stmts <nl> + } <nl> + if ( ctx . svxPrevCtlFlowChar = = \" | \" ) { <nl> + indentUnitRq = 1 ; / / 1st pipe stage <nl> + } <nl> + break ; <nl> + case \" S \" : <nl> + if ( ctx . svxPrevCtlFlowChar = = \" @ \" ) { <nl> + indentUnitRq = 1 ; / / flow in pipe stage <nl> + } <nl> + if ( ctx . thisMode . isSvxChangeScopePrefix ( ctx . svxPrevCtlFlowChar ) ! = false ) <nl> + indentUnitRq = 1 ; / / + 1 new scope <nl> + break ; <nl> + } <nl> + var statementIndentUnit = svxindentUnit ; <nl> + rtnIndent = curIndent + ( indentUnitRq * statementIndentUnit ) ; <nl> + return ( ( rtnIndent > = 0 ) ? rtnIndent : curIndent ) ; <nl> + } , <nl> + hooks : { <nl> + \" \\ \\ \" : function ( stream , state ) { <nl> + var vxIndent = 0 , style = false ; <nl> + var curPunc = stream . string ; <nl> + if ( ( stream . sol ( ) ) & & ( / \\ \\ SV / . test ( stream . string ) ) ) { <nl> + curPunc = ( / \\ \\ SVX_version / . test ( stream . string ) ) <nl> + ? \" \\ \\ SVX_version \" : stream . string ; <nl> + stream . skipToEnd ( ) ; <nl> + if ( curPunc = = \" \\ \\ SV \" & & state . vxContext . vxCodeActive ) { state . vxContext . vxCodeActive = false ; } ; <nl> + if ( ( / \\ \\ SVX / . test ( curPunc ) & & ! state . vxContext . vxCodeActive ) <nl> + | | ( curPunc = = \" \\ \\ SVX_version \" & & state . vxContext . vxCodeActive ) ) { state . vxContext . vxCodeActive = true ; } ; <nl> + style = \" keyword \" ; <nl> + state . vxContext . svxCurCtlFlowChar = state . vxContext . svxPrevPrevCtlFlowChar <nl> + = state . vxContext . svxPrevCtlFlowChar = \" \" ; <nl> + if ( state . vxContext . vxCodeActive = = true ) { <nl> + state . vxContext . svxCurCtlFlowChar = \" \\ \\ \" ; <nl> + vxIndent = state . vxContext . thisMode . svxGenIndent ( stream , state ) ; <nl> + } <nl> + state . vxContext . vxIndentRq = vxIndent ; <nl> + } <nl> + return style ; <nl> + } , <nl> + \" tokenBase \" : function ( stream , state ) { <nl> + var vxIndent = 0 , style = false , ctx = state . vxContext ; <nl> + var svxisOperatorChar = / [ \\ [ \\ ] = : ] / ; <nl> + var svxkpScopePrefixs = { <nl> + \" * * \" : \" variable - 2 \" , \" * \" : \" variable - 2 \" , \" $ $ \" : \" variable \" , \" $ \" : \" variable \" , <nl> + \" ^ ^ \" : \" attribute \" , \" ^ \" : \" attribute \" } ; <nl> + var ch = stream . peek ( ) ; <nl> + var vxCurCtlFlowCharValueAtStart = ctx . svxCurCtlFlowChar ; <nl> + if ( state . vxContext . vxCodeActive = = true ) { <nl> + switch ( true ) { <nl> + case / [ \\ [ \\ ] { } \\ ( \\ ) ; \\ : ] / . test ( ch ) : <nl> + / / bypass nesting and 1 char punc <nl> + style = \" meta \" ; <nl> + stream . next ( ) ; <nl> + break ; <nl> + case ch = = \" / \" : <nl> + stream . next ( ) ; <nl> + if ( stream . eat ( \" / \" ) ) { <nl> + stream . skipToEnd ( ) ; <nl> + style = \" comment \" ; <nl> + ctx . svxCurCtlFlowChar = \" S \" ; <nl> + } else <nl> + stream . backUp ( 1 ) ; <nl> + break ; <nl> + case / @ / . test ( ch ) : <nl> + / / pipeline stage <nl> + style = ctx . thisMode . isSvxChangeScopePrefix ( ch ) ; <nl> + ctx . svxCurCtlFlowChar = \" @ \" ; <nl> + stream . next ( ) ; <nl> + stream . eatWhile ( / [ \\ w \\ $ _ ] / ) ; <nl> + break ; <nl> + case ( stream . match ( / \\ b [ mM ] 4 + / , true ) ) : / / match : function ( pattern , consume , caseInsensitive ) <nl> + / / m4 pre proc <nl> + stream . skipTo ( \" ( \" ) ; <nl> + style = \" def \" ; <nl> + ctx . svxCurCtlFlowChar = \" M \" ; <nl> + break ; <nl> + case ch = = \" ! \" & & stream . sol ( ) : <nl> + / / v stmt in svx region <nl> + / / ctx . svxCurCtlFlowChar = \" S \" ; <nl> + style = \" comment \" ; <nl> + stream . next ( ) ; <nl> + break ; <nl> + case svxisOperatorChar . test ( ch ) : <nl> + / / operators <nl> + stream . eatWhile ( svxisOperatorChar ) ; <nl> + style = \" operator \" ; <nl> + break ; <nl> + case ch = = \" # \" : <nl> + / / phy hier <nl> + ctx . svxCurCtlFlowChar = ( ctx . svxCurCtlFlowChar = = \" \" ) <nl> + ? ch : ctx . svxCurCtlFlowChar ; <nl> + stream . next ( ) ; <nl> + stream . eatWhile ( / [ + - ] \\ d / ) ; <nl> + style = \" tag \" ; <nl> + break ; <nl> + case svxkpScopePrefixs . propertyIsEnumerable ( ch ) : <nl> + / / special SVX operators <nl> + style = svxkpScopePrefixs [ ch ] ; <nl> + ctx . svxCurCtlFlowChar = ( ctx . svxCurCtlFlowChar = = \" \" ) <nl> + ? \" S \" : ctx . svxCurCtlFlowChar ; / / stmt <nl> + stream . next ( ) ; <nl> + stream . match ( / [ a - zA - Z_0 - 9 ] + / ) ; <nl> + break ; <nl> + case ( ctx . thisMode . isSvxChangeScopePrefix ( ch ) ! = false ) : <nl> + / / special SVX operators <nl> + style = ctx . thisMode . isSvxChangeScopePrefix ( ch ) ; <nl> + ctx . svxCurCtlFlowChar = ( ctx . svxCurCtlFlowChar = = \" \" ) <nl> + ? ch : ctx . svxCurCtlFlowChar ; <nl> + stream . next ( ) ; <nl> + stream . match ( / [ a - zA - Z_0 - 9 ] + / ) ; <nl> + break ; <nl> + } <nl> + if ( ctx . svxCurCtlFlowChar ! = vxCurCtlFlowCharValueAtStart ) { / / flow change <nl> + vxIndent = ctx . thisMode . svxGenIndent ( stream , state ) ; <nl> + ctx . vxIndentRq = vxIndent ; <nl> + } <nl> + } <nl> + return style ; <nl> + } , <nl> + \" startStateContext \" : function ( thisMode ) { <nl> + this . svxCurCtlFlowChar = \" \" ; <nl> + this . svxPrevCtlFlowChar = \" \" ; <nl> + this . svxPrevPrevCtlFlowChar = \" \" ; <nl> + this . vxCodeActive = thisMode . vxModeIsOn ; <nl> + this . vxIndentRq = 0 ; <nl> + this . thisMode = thisMode ; <nl> + } , <nl> + \" token \" : function ( stream , state ) { <nl> + var ctx = state . vxContext ; <nl> + if ( ctx . vxCodeActive = = true & & stream . sol ( ) & & ctx . svxCurCtlFlowChar ! = \" \" ) { <nl> + ctx . svxPrevPrevCtlFlowChar = ctx . svxPrevCtlFlowChar ; <nl> + ctx . svxPrevCtlFlowChar = ctx . svxCurCtlFlowChar ; <nl> + ctx . svxCurCtlFlowChar = \" \" ; <nl> + } <nl> + } , <nl> + \" indent \" : function ( state ) { <nl> + return ( ( state . vxContext . vxCodeActive = = true ) ? state . vxContext . vxIndentRq : - 1 ) ; <nl> + } <nl> + } <nl> + } ) ; <nl> } ) ; <nl>\n", "msg": "Add svx submode to verilog mode\n", "score": 1}
{"diff_id": 17123, "repo": "photonstorm/phaser\n", "sha": "8efed59271e4cc3ffe7fb23ce979f9072e0e66e1\n", "time": "2017-06-29T13:05:49Z\n", "diff": "mmm a / v3 / src / time / TimerEvent . js <nl> ppp b / v3 / src / time / TimerEvent . js <nl> var TimerEvent = new Class ( { <nl> { <nl> / * * <nl> * @ property { number } delay - The delay in ms at which this TimerEvent fires . <nl> + * @ readOnly <nl> * / <nl> this . delay = 0 ; <nl> <nl> / * * <nl> - * @ property { number } repeatCount - If this TimerEvent repeats it will do so this many times . <nl> + * @ property { number } repeat - The total number of times this TimerEvent will repeat before finishing . <nl> + * @ readOnly <nl> + * / <nl> + this . repeat = 0 ; <nl> + <nl> + / * * <nl> + * @ property { number } repeatCount - If repeating this contains the current repeat count . <nl> * / <nl> this . repeatCount = 0 ; <nl> <nl> / * * <nl> * @ property { boolean } loop - True if this TimerEvent loops , otherwise false . <nl> + * @ readOnly <nl> * / <nl> this . loop = false ; <nl> <nl> var TimerEvent = new Class ( { <nl> { <nl> this . delay = GetFastValue ( config , ' delay ' , 0 ) ; <nl> <nl> - this . repeatCount = GetFastValue ( config , ' repeat ' , 0 ) ; <nl> + / / Can also be set to - 1 for an infinite loop ( same as setting loop : true ) <nl> + this . repeat = GetFastValue ( config , ' repeat ' , 0 ) ; <nl> <nl> this . loop = GetFastValue ( config , ' loop ' , false ) ; <nl> <nl> var TimerEvent = new Class ( { <nl> <nl> this . paused = GetFastValue ( config , ' paused ' , false ) ; <nl> <nl> - / / This works for setting an infinite repeat too <nl> - if ( this . repeatCount = = = - 1 ) <nl> - { <nl> - this . loop = true ; <nl> - } <nl> - <nl> this . elapsed = 0 ; <nl> this . hasDispatched = false ; <nl> + this . repeatCount = ( this . repeat = = = - 1 | | this . loop ) ? 999999999999 : this . repeat ; <nl> <nl> return this ; <nl> } , <nl> <nl> + / / Gets the progress of the current iteration , not factoring in repeats <nl> getProgress : function ( ) <nl> { <nl> return ( this . elapsed / this . delay ) ; <nl> } , <nl> <nl> + / / Gets the progress of the timer overall , factoring in repeats . <nl> + getOverallProgress : function ( ) <nl> + { <nl> + if ( this . repeat > 0 ) <nl> + { <nl> + var totalDuration = this . delay + ( this . delay * this . repeat ) ; <nl> + var totalElapsed = this . elapsed + ( this . delay * ( this . repeat - this . repeatCount ) ) ; <nl> + <nl> + return ( totalElapsed / totalDuration ) ; <nl> + } <nl> + else <nl> + { <nl> + return this . getProgress ( ) ; <nl> + } <nl> + } , <nl> + <nl> + getRepeatCount : function ( ) <nl> + { <nl> + return this . repeatCount ; <nl> + } , <nl> + <nl> getElapsed : function ( ) <nl> { <nl> return this . elapsed ; <nl>\n", "msg": "Better repeat handling and new getOverallProgress method .\n", "score": 1}
{"diff_id": 17182, "repo": "mozilla/pdf.js\n", "sha": "d60cba5065202f01a5b82bee42096677466cb408\n", "time": "2018-01-04T21:57:14Z\n", "diff": "mmm a / web / app . js <nl> ppp b / web / app . js <nl> function webViewerKeyDown ( evt ) { <nl> handled = true ; <nl> } <nl> break ; <nl> + case 13 : / / enter key <nl> case 40 : / / down arrow <nl> case 34 : / / pg down <nl> case 32 : / / spacebar <nl> function webViewerKeyDown ( evt ) { <nl> <nl> if ( cmd = = = 4 ) { / / shift - key <nl> switch ( evt . keyCode ) { <nl> + case 13 : / / enter key <nl> case 32 : / / spacebar <nl> if ( ! isViewerInPresentationMode & & <nl> pdfViewer . currentScaleValue ! = = ' page - fit ' ) { <nl>\n", "msg": "Added enter key functionality for presentation mode\n", "score": 1}
{"diff_id": 18651, "repo": "photonstorm/phaser\n", "sha": "16eae3887e45c697d7f8cd2dde2d2043f2df6582\n", "time": "2018-07-21T10:50:47Z\n", "diff": "mmm a / src / animations / Animation . js <nl> ppp b / src / animations / Animation . js <nl> var GetValue = require ( ' . . / utils / object / GetValue ' ) ; <nl> * @ property { boolean } [ yoyo = false ] - Should the animation yoyo ? ( reverse back down to the start ) before repeating ? <nl> * @ property { boolean } [ showOnStart = false ] - Should sprite . visible = true when the animation starts to play ? <nl> * @ property { boolean } [ hideOnComplete = false ] - Should sprite . visible = false when the animation finishes ? <nl> + * @ property { boolean } [ reverse = false ] - Should the animation be played in reversed sequence ? <nl> * / <nl> <nl> / * * <nl> var Animation = new Class ( { <nl> * / <nl> this . type = ' frame ' ; <nl> <nl> + / / if config . reverse is true , reverse sequence of AnimationFrameConfig [ ] <nl> + var animFrames = GetValue ( config , ' frames ' , [ ] ) ; <nl> + if ( GetValue ( config , ' reverse ' , false ) ) <nl> + { <nl> + animFrames . reverse ( ) ; <nl> + } <nl> + <nl> / * * <nl> * Extract all the frame data into the frames array <nl> * <nl> var Animation = new Class ( { <nl> * / <nl> this . frames = this . getFrames ( <nl> manager . textureManager , <nl> - GetValue ( config , ' frames ' , [ ] ) , <nl> + animFrames , <nl> GetValue ( config , ' defaultTextureKey ' , null ) <nl> ) ; <nl> <nl>\n", "msg": "Add ability to play animations in reverse\n", "score": 1}
{"diff_id": 18772, "repo": "RocketChat/Rocket.Chat\n", "sha": "b77cbb524b8c5bc0740e60ae0e627cafadd4819e\n", "time": "2016-01-06T20:19:50Z\n", "diff": "mmm a / packages / rocketchat - livechat / client / ui . js <nl> ppp b / packages / rocketchat - livechat / client / ui . js <nl> RocketChat . roomTypes . add ( ' l ' , 5 , { <nl> <nl> AccountBox . addItem ( { <nl> name : ' Livechat ' , <nl> - icon : ' icon - chat - empty ' , <nl> + icon : ' octicon octicon - info ' , <nl> href : ' livechat - users ' , <nl> sideNav : ' livechatFlex ' , <nl> condition : ( ) = > { <nl>\n", "msg": "changed icon for visitor information tabbar\n", "score": 1}
{"diff_id": 19342, "repo": "balderdashy/sails\n", "sha": "6b1be9d57611f5b2d17d2ad890c3f971ea0b1ae6\n", "time": "2013-10-10T13:11:57Z\n", "diff": "mmm a / bin / boilerplates / config / adapters . js <nl> ppp b / bin / boilerplates / config / adapters . js <nl> module . exports . adapters = { <nl> / / in a model definition , ' default ' will be used . <nl> ' default ' : ' disk ' , <nl> <nl> - / / In - memory adapter for DEVELOPMENT ONLY <nl> - memory : { <nl> - module : ' sails - memory ' <nl> - } , <nl> - <nl> / / Persistent adapter for DEVELOPMENT ONLY <nl> - / / ( data IS preserved when the server shuts down ) <nl> + / / ( data is preserved when the server shuts down ) <nl> disk : { <nl> module : ' sails - disk ' <nl> } , <nl> <nl> / / MySQL is the world ' s most popular relational database . <nl> / / Learn more : http : / / en . wikipedia . org / wiki / MySQL <nl> - mysql : { <nl> + myLocalMySQLDatabase : { <nl> <nl> module : ' sails - mysql ' , <nl> host : ' YOUR_MYSQL_SERVER_HOSTNAME_OR_IP_ADDRESS ' , <nl>\n", "msg": "Slight improvement to config . adapters boilerplate .\n", "score": 1}
{"diff_id": 19407, "repo": "transloadit/uppy\n", "sha": "4537233880690f7d7adee3dde00d3cc6f27d1fa7\n", "time": "2018-02-09T22:53:29Z\n", "diff": "mmm a / src / core / Core . js <nl> ppp b / src / core / Core . js <nl> class Uppy { <nl> } ) <nl> . catch ( ( err ) = > { <nl> const message = typeof err = = = ' object ' ? err . message : err <nl> - this . info ( message , ' error ' , 5000 ) <nl> + this . log ( message ) <nl> + this . info ( message , ' error ' , 4000 ) <nl> return Promise . reject ( typeof err = = = ' object ' ? err : new Error ( err ) ) <nl> } ) <nl> } <nl>\n", "msg": "add console logging for restrictions error\n", "score": 1}
{"diff_id": 19675, "repo": "Leaflet/Leaflet\n", "sha": "65fe7a8e5b57f73adfec639b914aed6cec3d4256\n", "time": "2012-06-18T21:20:28Z\n", "diff": "mmm a / src / layer / Popup . js <nl> ppp b / src / layer / Popup . js <nl> L . Popup = L . Class . extend ( { <nl> } <nl> <nl> this . _containerWidth = this . _container . offsetWidth ; <nl> + this . _containerBottom = - this . options . offset . y ; <nl> + this . _containerLeft = - Math . round ( this . _containerWidth / 2 ) + this . options . offset . x ; <nl> } , <nl> <nl> _updatePosition : function ( ) { <nl> var pos = this . _map . latLngToLayerPoint ( this . _latlng ) ; <nl> <nl> - this . _containerBottom = - pos . y - this . options . offset . y ; <nl> - this . _containerLeft = pos . x - Math . round ( this . _containerWidth / 2 ) + this . options . offset . x ; <nl> - <nl> this . _container . style . bottom = this . _containerBottom + ' px ' ; <nl> this . _container . style . left = this . _containerLeft + ' px ' ; <nl> + <nl> + L . DomUtil . setPosition ( this . _container , pos ) ; <nl> } , <nl> <nl> _adjustPan : function ( ) { <nl>\n", "msg": "Position Popup using L . DomUtil . setPosition for Hardware Accel .\n", "score": 1}
{"diff_id": 19714, "repo": "balderdashy/sails\n", "sha": "b25fb16e86a87c6901bb1c1459c05f41fbc385a9\n", "time": "2017-12-15T17:55:19Z\n", "diff": "mmm a / lib / app / configuration / load . js <nl> ppp b / lib / app / configuration / load . js <nl> module . exports = function ( sails ) { <nl> } ) ( ) , <nl> <nl> / / ` - - prod ` command - line shortcut <nl> + / / ` - - staging ` command - line shortcut <nl> / / ` - - dev ` command - line shortcut <nl> - environment : overrides . prod ? ' production ' : ( overrides . dev ? ' development ' : undefined ) <nl> + environment : ( function ( ) { <nl> + if ( overrides . staging ) { / / - - staging <nl> + return ' staging ' ; <nl> + } else if ( overrides . prod ) { / / - - prod ( but it ' s cleaner to use NODE_ENV = production with no other environment instead ) <nl> + return ' production ' ; <nl> + } else if ( overrides . dev ) { / / - - dev ( deprecated ) <nl> + console . warn ( ' ` - - dev ` option is deprecated : Please do not use it . ' ) ; <nl> + / / Note : we use ` console . warn ` here because we ' re not guaranteed <nl> + / / to have a working logger yet . <nl> + return ' development ' ; <nl> + } else { <nl> + return undefined ; <nl> + } <nl> + } ) ( ) / /  <nl> <nl> } ) ; <nl> <nl>\n", "msg": "Add support for - - staging shortcut , and add deprecation warning for - - dev\n", "score": 1}
{"diff_id": 19919, "repo": "emberjs/ember.js\n", "sha": "e485de2ba4835ffe88638fb283a2ce60029e5dd5\n", "time": "2014-12-21T19:57:05Z\n", "diff": "mmm a / packages / ember - application / lib / system / application . js <nl> ppp b / packages / ember - application / lib / system / application . js <nl> <nl> @ submodule ember - application <nl> * / <nl> import DAG from ' dag - map ' ; <nl> + import Registry from ' container / registry ' ; <nl> import Container from ' container / container ' ; <nl> <nl> - <nl> import Ember from \" ember - metal \" ; / / Ember . FEATURES , Ember . deprecate , Ember . assert , Ember . libraries , LOG_VERSION , Namespace , BOOTED <nl> import { get } from \" ember - metal / property_get \" ; <nl> import { set } from \" ember - metal / property_set \" ; <nl> var Application = Namespace . extend ( DeferredMixin , { <nl> if ( ! this . $ ) { <nl> this . $ = jQuery ; <nl> } <nl> - this . __container__ = this . buildContainer ( ) ; <nl> + <nl> + this . buildRegistry ( ) ; <nl> + this . buildContainer ( ) ; <nl> <nl> this . Router = this . defaultRouter ( ) ; <nl> <nl> var Application = Namespace . extend ( DeferredMixin , { <nl> } , <nl> <nl> / * * <nl> - Build the container for the current application . <nl> + Build and configure the registry for the current application . <nl> + <nl> + @ private <nl> + @ method buildRegistry <nl> + @ return { Ember . Registry } the configured registry <nl> + * / <nl> + buildRegistry : function ( ) { <nl> + var registry = this . __registry__ = Application . buildRegistry ( this ) ; <nl> + <nl> + return registry ; <nl> + } , <nl> <nl> - Also register a default application view in case the application <nl> - itself does not . <nl> + / * * <nl> + Create a container for the current application ' s registry . <nl> <nl> @ private <nl> @ method buildContainer <nl> @ return { Ember . Container } the configured container <nl> * / <nl> buildContainer : function ( ) { <nl> - var container = this . __container__ = Application . buildContainer ( this ) ; <nl> + var container = this . __container__ = new Container ( { registry : this . __registry__ } ) ; <nl> <nl> return container ; <nl> } , <nl> var Application = Namespace . extend ( DeferredMixin , { <nl> defaultRouter : function ( ) { <nl> if ( this . Router = = = false ) { return ; } <nl> var container = this . __container__ ; <nl> + var registry = this . __registry__ ; <nl> <nl> if ( this . Router ) { <nl> - container . unregister ( ' router : main ' ) ; <nl> - container . register ( ' router : main ' , this . Router ) ; <nl> + registry . register ( ' router : main ' , this . Router ) ; <nl> } <nl> <nl> return container . lookupFactory ( ' router : main ' ) ; <nl> var Application = Namespace . extend ( DeferredMixin , { <nl> @ param options { Object } ( optional ) disable instantiation or singleton usage <nl> * * / <nl> register : function ( ) { <nl> - var container = this . __container__ ; <nl> - container . register . apply ( container , arguments ) ; <nl> + var registry = this . __registry__ ; <nl> + registry . register . apply ( registry , arguments ) ; <nl> } , <nl> <nl> / * * <nl> var Application = Namespace . extend ( DeferredMixin , { <nl> @ param injectionName { String } <nl> * * / <nl> inject : function ( ) { <nl> - var container = this . __container__ ; <nl> - container . injection . apply ( container , arguments ) ; <nl> + var registry = this . __registry__ ; <nl> + registry . injection . apply ( registry , arguments ) ; <nl> } , <nl> <nl> / * * <nl> var Application = Namespace . extend ( DeferredMixin , { <nl> <nl> / / At this point , the App . Router must already be assigned <nl> if ( this . Router ) { <nl> + var registry = this . __registry__ ; <nl> var container = this . __container__ ; <nl> - container . unregister ( ' router : main ' ) ; <nl> - container . register ( ' router : main ' , this . Router ) ; <nl> + <nl> + registry . register ( ' router : main ' , this . Router ) ; <nl> + container . reset ( ' router : main ' ) ; <nl> } <nl> <nl> this . runInitializers ( ) ; <nl> var Application = Namespace . extend ( DeferredMixin , { <nl> runInitializers : function ( ) { <nl> var initializersByName = get ( this . constructor , ' initializers ' ) ; <nl> var initializers = props ( initializersByName ) ; <nl> - var container = this . __container__ ; <nl> + var registry = this . __registry__ ; <nl> var graph = new DAG ( ) ; <nl> var namespace = this ; <nl> var initializer ; <nl> var Application = Namespace . extend ( DeferredMixin , { <nl> graph . topsort ( function ( vertex ) { <nl> var initializer = vertex . value ; <nl> Ember . assert ( \" No application initializer named ' \" + vertex . name + \" ' \" , ! ! initializer ) ; <nl> - initializer ( container , namespace ) ; <nl> + initializer ( registry , namespace ) ; <nl> } ) ; <nl> } , <nl> <nl> Application . reopenClass ( { <nl> } , <nl> <nl> / * * <nl> - This creates a container with the default Ember naming conventions . <nl> + This creates a registry with the default Ember naming conventions . <nl> <nl> - It also configures the container : <nl> + It also configures the registry : <nl> <nl> * registered views are created every time they are looked up ( they are <nl> not singletons ) <nl> Application . reopenClass ( { <nl> ` defaultTemplate ` property <nl> <nl> @ private <nl> - @ method buildContainer <nl> + @ method buildRegistry <nl> @ static <nl> - @ param { Ember . Application } namespace the application to build the <nl> - container for . <nl> - @ return { Ember . Container } the built container <nl> + @ param { Ember . Application } namespace the application for which to <nl> + build the registry <nl> + @ return { Ember . Registry } the built registry <nl> * / <nl> - buildContainer : function ( namespace ) { <nl> - var container = new Container ( ) ; <nl> + buildRegistry : function ( namespace ) { <nl> + var registry = new Registry ( ) ; <nl> <nl> - container . set = set ; <nl> - container . resolver = resolverFor ( namespace ) ; <nl> - container . normalizeFullName = container . resolver . normalize ; <nl> - container . describe = container . resolver . describe ; <nl> - container . makeToString = container . resolver . makeToString ; <nl> + registry . set = set ; <nl> + registry . resolver = resolverFor ( namespace ) ; <nl> + registry . normalizeFullName = registry . resolver . normalize ; <nl> + registry . describe = registry . resolver . describe ; <nl> + registry . makeToString = registry . resolver . makeToString ; <nl> <nl> - container . optionsForType ( ' component ' , { singleton : false } ) ; <nl> - container . optionsForType ( ' view ' , { singleton : false } ) ; <nl> - container . optionsForType ( ' template ' , { instantiate : false } ) ; <nl> - container . optionsForType ( ' helper ' , { instantiate : false } ) ; <nl> + registry . optionsForType ( ' component ' , { singleton : false } ) ; <nl> + registry . optionsForType ( ' view ' , { singleton : false } ) ; <nl> + registry . optionsForType ( ' template ' , { instantiate : false } ) ; <nl> + registry . optionsForType ( ' helper ' , { instantiate : false } ) ; <nl> <nl> - container . register ( ' application : main ' , namespace , { instantiate : false } ) ; <nl> + registry . register ( ' application : main ' , namespace , { instantiate : false } ) ; <nl> <nl> - container . register ( ' controller : basic ' , Controller , { instantiate : false } ) ; <nl> - container . register ( ' controller : object ' , ObjectController , { instantiate : false } ) ; <nl> - container . register ( ' controller : array ' , ArrayController , { instantiate : false } ) ; <nl> + registry . register ( ' controller : basic ' , Controller , { instantiate : false } ) ; <nl> + registry . register ( ' controller : object ' , ObjectController , { instantiate : false } ) ; <nl> + registry . register ( ' controller : array ' , ArrayController , { instantiate : false } ) ; <nl> <nl> - container . register ( ' view : select ' , SelectView ) ; <nl> + registry . register ( ' view : select ' , SelectView ) ; <nl> <nl> - container . register ( ' route : basic ' , Route , { instantiate : false } ) ; <nl> - container . register ( ' event_dispatcher : main ' , EventDispatcher ) ; <nl> + registry . register ( ' route : basic ' , Route , { instantiate : false } ) ; <nl> + registry . register ( ' event_dispatcher : main ' , EventDispatcher ) ; <nl> <nl> - container . register ( ' router : main ' , Router ) ; <nl> - container . injection ( ' router : main ' , ' namespace ' , ' application : main ' ) ; <nl> + registry . register ( ' router : main ' , Router ) ; <nl> + registry . injection ( ' router : main ' , ' namespace ' , ' application : main ' ) ; <nl> <nl> - container . register ( ' location : auto ' , AutoLocation ) ; <nl> - container . register ( ' location : hash ' , HashLocation ) ; <nl> - container . register ( ' location : history ' , HistoryLocation ) ; <nl> - container . register ( ' location : none ' , NoneLocation ) ; <nl> + registry . register ( ' location : auto ' , AutoLocation ) ; <nl> + registry . register ( ' location : hash ' , HashLocation ) ; <nl> + registry . register ( ' location : history ' , HistoryLocation ) ; <nl> + registry . register ( ' location : none ' , NoneLocation ) ; <nl> <nl> - container . injection ( ' controller ' , ' target ' , ' router : main ' ) ; <nl> - container . injection ( ' controller ' , ' namespace ' , ' application : main ' ) ; <nl> + registry . injection ( ' controller ' , ' target ' , ' router : main ' ) ; <nl> + registry . injection ( ' controller ' , ' namespace ' , ' application : main ' ) ; <nl> <nl> - container . register ( ' - bucket - cache : main ' , BucketCache ) ; <nl> - container . injection ( ' router ' , ' _bucketCache ' , ' - bucket - cache : main ' ) ; <nl> - container . injection ( ' route ' , ' _bucketCache ' , ' - bucket - cache : main ' ) ; <nl> - container . injection ( ' controller ' , ' _bucketCache ' , ' - bucket - cache : main ' ) ; <nl> + registry . register ( ' - bucket - cache : main ' , BucketCache ) ; <nl> + registry . injection ( ' router ' , ' _bucketCache ' , ' - bucket - cache : main ' ) ; <nl> + registry . injection ( ' route ' , ' _bucketCache ' , ' - bucket - cache : main ' ) ; <nl> + registry . injection ( ' controller ' , ' _bucketCache ' , ' - bucket - cache : main ' ) ; <nl> <nl> - container . injection ( ' route ' , ' router ' , ' router : main ' ) ; <nl> - container . injection ( ' location ' , ' rootURL ' , ' - location - setting : root - url ' ) ; <nl> + registry . injection ( ' route ' , ' router ' , ' router : main ' ) ; <nl> + registry . injection ( ' location ' , ' rootURL ' , ' - location - setting : root - url ' ) ; <nl> <nl> / / DEBUGGING <nl> - container . register ( ' resolver - for - debugging : main ' , container . resolver . __resolver__ , { instantiate : false } ) ; <nl> - container . injection ( ' container - debug - adapter : main ' , ' resolver ' , ' resolver - for - debugging : main ' ) ; <nl> - container . injection ( ' data - adapter : main ' , ' containerDebugAdapter ' , ' container - debug - adapter : main ' ) ; <nl> + registry . register ( ' resolver - for - debugging : main ' , registry . resolver . __resolver__ , { instantiate : false } ) ; <nl> + registry . injection ( ' container - debug - adapter : main ' , ' resolver ' , ' resolver - for - debugging : main ' ) ; <nl> + registry . injection ( ' data - adapter : main ' , ' containerDebugAdapter ' , ' container - debug - adapter : main ' ) ; <nl> / / Custom resolver authors may want to register their own ContainerDebugAdapter with this key <nl> <nl> - container . register ( ' container - debug - adapter : main ' , ContainerDebugAdapter ) ; <nl> + registry . register ( ' container - debug - adapter : main ' , ContainerDebugAdapter ) ; <nl> <nl> - return container ; <nl> + return registry ; <nl> } <nl> } ) ; <nl> <nl>\n", "msg": "Convert Application to use both Registry & Container\n", "score": 1}
{"diff_id": 20172, "repo": "adobe/brackets\n", "sha": "8558fa7fa1d1ad1d55f35983f694d42e573e2fa3\n", "time": "2012-02-23T02:15:44Z\n", "diff": "mmm a / src / FileIndexManager . js <nl> ppp b / src / FileIndexManager . js <nl> <nl> * / <nl> <nl> / * jslint vars : true , plusplus : true , devel : true , browser : true , nomen : true , indent : 4 , maxerr : 50 * / <nl> - / * global define : false , $ : false , brackets * / <nl> + / * global define : false , $ : false , brackets , PathUtils * / <nl> <nl> / * <nl> * Manages a collection of FileIndexes where each index maintains a list of information about <nl> define ( function ( require , exports , module ) { <nl> \" css \" , <nl> function ( entry ) { <nl> var filename = entry . name ; <nl> - return filename . slice ( filename . length - 4 , filename . length ) = = = \" . css \" ; <nl> + return PathUtils . filenameExtension ( filename ) ; <nl> } <nl> ) ; <nl> <nl>\n", "msg": "using PathUtils for file extension\n", "score": 1}
{"diff_id": 20312, "repo": "Automattic/mongoose\n", "sha": "5cdb6fa33cf689cf41e508b5d278f0b85dea6179\n", "time": "2011-01-17T17:28:27Z\n", "diff": "mmm a / lib / mongoose / types / array . js <nl> ppp b / lib / mongoose / types / array . js <nl> MongooseArray . prototype . __defineGetter__ ( ' _doAtomics ' , function ( ) { <nl> * / <nl> <nl> [ ' push ' , ' unshift ' ] . forEach ( function ( method ) { <nl> - var oldMethod = Mongoose . prototype [ method ] ; <nl> + var oldMethod = MongooseArray . prototype [ method ] ; <nl> <nl> MongooseArray . prototype [ method ] = function ( ) { <nl> var ret = oldMethod . apply ( this , arguments ) ; <nl>\n", "msg": "Fixed reference to old method\n", "score": 1}
{"diff_id": 20646, "repo": "vercel/next.js\n", "sha": "c689bc9f8bb555a844eada2c279b4616ba804196\n", "time": "2017-08-19T16:02:40Z\n", "diff": "mmm a / examples / with - mobx / store . js <nl> ppp b / examples / with - mobx / store . js <nl> class Store { <nl> } <nl> <nl> export function initStore ( isServer , lastUpdate = Date . now ( ) ) { <nl> - if ( isServer & & typeof window = = = ' undefined ' ) { <nl> + if ( isServer ) { <nl> return new Store ( isServer , lastUpdate ) <nl> } else { <nl> if ( store = = = null ) { <nl>\n", "msg": "Simplify condition in mobx example ( )\n", "score": 1}
{"diff_id": 20736, "repo": "balderdashy/sails\n", "sha": "2a31ab62ab0fd1e19fc5187d6b8e3919067c71b2\n", "time": "2012-12-23T13:45:55Z\n", "diff": "mmm a / lib / router . js <nl> ppp b / lib / router . js <nl> function reroute ( routePlan , req , res , next ) { <nl> if ( plan ) plan ( req , res , next ) ; <nl> else throw new Error ( ' Trying to use unknown middleware : : ' + routePlan ) ; <nl> } <nl> + / / Support multiple middleware policies applied in a list <nl> + else if ( _ . isArray ( routePlan ) ) { <nl> + require ( ' async ' ) . forEach ( routePlan , function ( item , cb ) { <nl> + reroute ( item , req , res , function ( req , res , next ) { <nl> + cb ( ) ; <nl> + } ) ; <nl> + } , function ( err ) { <nl> + if ( err ) sails . log . error ( err ) ; <nl> + next ( ) ; <nl> + } ) ; <nl> + } <nl> + <nl> } <nl> \\ No newline at end of file <nl>\n", "msg": "Added ordered list support for policies / middleware .\n", "score": 1}
{"diff_id": 20962, "repo": "nuxt/nuxt.js\n", "sha": "a4c28ac52bffbc8c9107e4994d7f3249c67a43c9\n", "time": "2016-12-27T13:53:36Z\n", "diff": "mmm a / lib / build / index . js <nl> ppp b / lib / build / index . js <nl> function getWebpackServerConfig ( ) { <nl> function createWebpackMiddlewares ( ) { <nl> const clientConfig = getWebpackClientConfig . call ( this ) <nl> / / setup on the fly compilation + hot - reload <nl> - clientConfig . entry . app = [ ' webpack - hot - middleware / client ? reload = true ' , clientConfig . entry . app ] <nl> + clientConfig . entry . app = _ . flatten ( [ ' webpack - hot - middleware / client ? reload = true ' , clientConfig . entry . app ] ) <nl> clientConfig . plugins . push ( <nl> new webpack . HotModuleReplacementPlugin ( ) , <nl> new webpack . NoErrorsPlugin ( ) <nl>\n", "msg": "flatten entry app to avoid build error\n", "score": 1}
{"diff_id": 21030, "repo": "mozilla/pdf.js\n", "sha": "a23079c2dd0ea039ee9b2d80de8ab52ca204821d\n", "time": "2020-08-27T14:30:15Z\n", "diff": "mmm a / web / pdf_attachment_viewer . js <nl> ppp b / web / pdf_attachment_viewer . js <nl> import { createPromiseCapability , getFilenameFromUrl } from \" pdfjs - lib \" ; <nl> import { BaseTreeViewer } from \" . / base_tree_viewer . js \" ; <nl> import { viewerCompatibilityParams } from \" . / viewer_compatibility . js \" ; <nl> <nl> + const PdfFileRegExp = / \\ . pdf $ / i ; <nl> + <nl> / * * <nl> * @ typedef { Object } PDFAttachmentViewerOptions <nl> * @ property { HTMLDivElement } container - The viewer element . <nl> class PDFAttachmentViewer extends BaseTreeViewer { <nl> * / <nl> _bindLink ( element , { content , filename } ) { <nl> element . onclick = ( ) = > { <nl> - this . downloadManager . downloadData ( content , filename , \" \" ) ; <nl> + const contentType = PdfFileRegExp . test ( filename ) ? \" application / pdf \" : \" \" ; <nl> + this . downloadManager . downloadData ( content , filename , contentType ) ; <nl> return false ; <nl> } ; <nl> } <nl> class PDFAttachmentViewer extends BaseTreeViewer { <nl> <nl> const element = document . createElement ( \" a \" ) ; <nl> if ( <nl> - / \\ . pdf $ / i . test ( filename ) & & <nl> + PdfFileRegExp . test ( filename ) & & <nl> ! viewerCompatibilityParams . disableCreateObjectURL <nl> ) { <nl> this . _bindPdfLink ( element , { content : item . content , filename } ) ; <nl>\n", "msg": "Ensure that ` PDFAttachmentViewer . _bindLink ` assigns the correct contentType when downloading PDF attachments\n", "score": 1}
{"diff_id": 21299, "repo": "facebook/react-native\n", "sha": "ba89d9bb7e50d023957046029f4eac0601210547\n", "time": "2016-02-02T19:05:33Z\n", "diff": "mmm a / website / src / react - native / showcase . js <nl> ppp b / website / src / react - native / showcase . js <nl> var apps = [ <nl> author : ' CANDDi LTD . ' , <nl> } , <nl> { <nl> - name : ' CBS Sports Franchise Football ' , <nl> + name : ' CaratLane ' , <nl> icon : ' http : / / a2 . mzstatic . com / us / r30 / Purple69 / v4 / 7b / 0c / a0 / 7b0ca007 - 885a - 7cfc - 9fa2 - 2ec4394c2ecc / icon175x175 . png ' , <nl> + link : ' https : / / play . google . com / store / apps / details ? id = com . caratlane . android & hl = en ' , <nl> + author : ' CaratLane ' , <nl> + } , <nl> + { <nl> + name : ' CBS Sports Franchise Football ' , <nl> + icon : ' https : / / lh3 . googleusercontent . com / wEN - Vvpbnw_n89dbXPxWkNnXB7sALKBKvpX_hbzrWbuC4tFi5tVkWHq8k5TAvdbf5UQ = w300 - rw ' , <nl> link : ' https : / / play . google . com / store / apps / details ? id = com . cbssports . fantasy . franchisefootball2015 ' , <nl> author : ' CBS Sports ' , <nl> } , <nl>\n", "msg": "Adding CaratLane app to react - native showcase\n", "score": 1}
{"diff_id": 21470, "repo": "Automattic/mongoose\n", "sha": "42b9ee00d91b607684b20c8e17aeb5e60f1659e3\n", "time": "2012-06-15T22:18:03Z\n", "diff": "mmm a / test / model . findAndUpdateOne . test . js <nl> ppp b / test / model . findAndUpdateOne . test . js <nl> module . exports = { <nl> } <nl> } , <nl> <nl> + ' findOneAndUpdate executes when a callback is passed to a succeeding function ' : function ( ) { <nl> + var db = start ( ) <nl> + , M = db . model ( modelname , collection + random ( ) ) <nl> + , pending = 6 <nl> + <nl> + M . findOneAndUpdate ( { name : ' aaron ' } , { $ set : { name : ' Aaron ' } } , { new : false } ) . exec ( done ) ; <nl> + M . findOneAndUpdate ( { name : ' aaron ' } , { $ set : { name : ' Aaron ' } } ) . exec ( done ) ; <nl> + M . where ( ) . findOneAndUpdate ( { name : ' aaron ' } , { $ set : { name : ' Aaron ' } } , { new : false } ) . exec ( done ) ; <nl> + M . where ( ) . findOneAndUpdate ( { name : ' aaron ' } , { $ set : { name : ' Aaron ' } } ) . exec ( done ) ; <nl> + M . where ( ) . findOneAndUpdate ( { $ set : { name : ' Aaron ' } } ) . exec ( done ) ; <nl> + M . where ( ' name ' , ' aaron ' ) . findOneAndUpdate ( { $ set : { name : ' Aaron ' } } ) . exec ( done ) ; <nl> + <nl> + function done ( err , doc ) { <nl> + should . strictEqual ( null , err ) ; <nl> + should . strictEqual ( null , doc ) ; / / not an upsert , no previously existing doc <nl> + if ( - - pending ) return ; <nl> + db . close ( ) ; <nl> + } <nl> + } , <nl> + <nl> ' Model . findOneAndUpdate ( callback ) throws ' : function ( ) { <nl> var db = start ( ) <nl> , M = db . model ( modelname , collection ) <nl>\n", "msg": "updated tests exercising fix for issue 931\n", "score": 1}
{"diff_id": 21625, "repo": "meteor/meteor\n", "sha": "a359c725090746930aa27ee2627889f4b17cbd80\n", "time": "2015-07-21T02:44:35Z\n", "diff": "mmm a / tools / isobuild / isopack . js <nl> ppp b / tools / isobuild / isopack . js <nl> _ . extend ( Isopack . prototype , { <nl> * Documentation for CompileStep is available [ on the GitHub Wiki ] ( https : / / github . com / meteor / meteor / wiki / CompileStep - API - for - Build - Plugin - Source - Handlers ) . <nl> * @ memberOf Plugin <nl> * @ locus Build Plugin <nl> + * @ deprecated since 1 . 2 <nl> + * XXX COMPAT WITH 1 . 1 <nl> * / <nl> registerSourceHandler : function ( extension , options , handler ) { <nl> if ( ! handler ) { <nl> _ . extend ( Isopack . prototype , { <nl> / / plugin compiler use the isobuild : compiler - plugin fake package , so that <nl> / / Version Solver will not let you use registerCompiler plugins with old <nl> / / versions of the tool . <nl> + <nl> + / * * <nl> + * @ summary Inside a build plugin source file specified in <nl> + * [ Package . registerBuildPlugin ] ( # Package - registerBuildPlugin ) , <nl> + * add a compiler that will handle files with ceratin extensions or <nl> + * filenames . <nl> + * @ param { Object } options <nl> + * @ param { [ String ] } options . extensions The file extensions that this <nl> + * plugin should handle , without the first dot . <nl> + * Examples : ` [ \" coffee \" , \" coffee . md \" ] ` . <nl> + * @ param { [ String ] } options . filenames The list of filenames <nl> + * that this plugin should handle . Examples : ` [ \" config . json \" ] ` . <nl> + * @ param { Function } factory A function that returns an instance <nl> + * of a compiler class . <nl> + * <nl> + * More detailed documentation for build plugins is available [ on the GitHub Wiki ] ( https : / / github . com / meteor / meteor / wiki / Build - Plugins - API ) . <nl> + * @ memberOf Plugin <nl> + * @ locus Build Plugin <nl> + * / <nl> registerCompiler : function ( options , factory ) { <nl> Plugin . _registerSourceProcessor ( options | | { } , factory , { <nl> sourceProcessorSet : isopack . sourceProcessors . compiler , <nl> _ . extend ( Isopack . prototype , { <nl> / / - globals - a list of strings - global variables that can be <nl> / / used in the target ' s scope as they are dependencies of the <nl> / / package or the app . e . g . : \" Minimongo \" or \" Webapp \" . <nl> + <nl> + / * * <nl> + * @ summary Inside a build plugin source file specified in <nl> + * [ Package . registerBuildPlugin ] ( # Package - registerBuildPlugin ) , <nl> + * add a linter that will handle files with ceratin extensions or <nl> + * filenames . <nl> + * @ param { Object } options <nl> + * @ param { [ String ] } options . extensions The file extensions that this <nl> + * plugin should handle , without the first dot . <nl> + * Examples : ` [ \" js \" , \" es6 \" , \" jsx \" ] ` . <nl> + * @ param { Function } factory A function that returns an instance <nl> + * of a linter class . <nl> + * <nl> + * More detailed documentation for build plugins is available [ on the GitHub Wiki ] ( https : / / github . com / meteor / meteor / wiki / Build - Plugins - API ) . <nl> + * @ memberOf Plugin <nl> + * @ locus Build Plugin <nl> + * / <nl> registerLinter : function ( options , factory ) { <nl> Plugin . _registerSourceProcessor ( options | | { } , factory , { <nl> sourceProcessorSet : isopack . sourceProcessors . linter , <nl> _ . extend ( Isopack . prototype , { <nl> / / - options - Object <nl> / / - minifyMode - string - ' development ' or ' production ' , based <nl> / / on the bundling mode <nl> + <nl> + / * * <nl> + * @ summary Inside a build plugin source file specified in <nl> + * [ Package . registerBuildPlugin ] ( # Package - registerBuildPlugin ) , <nl> + * add a linter that will handle files with ceratin extensions or <nl> + * filenames . <nl> + * @ param { Object } options <nl> + * @ param { [ String ] } options . extensions The file extensions that this <nl> + * plugin should handle , without the first dot . Can only be \" js \" or \" css \" . <nl> + * Examples : ` [ \" js \" , \" css \" ] ` . <nl> + * @ param { [ String ] } options . filenames The list of filenames <nl> + * that this plugin should handle . Examples : ` [ \" config . json \" ] ` . <nl> + * @ param { Function } factory A function that returns an instance <nl> + * of a minifier class . <nl> + * <nl> + * More detailed documentation for build plugins is available [ on the GitHub Wiki ] ( https : / / github . com / meteor / meteor / wiki / Build - Plugins - API ) . <nl> + * @ memberOf Plugin <nl> + * @ locus Build Plugin <nl> + * / <nl> registerMinifier : function ( options , factory ) { <nl> var badUsedExtension = _ . find ( options . extensions , function ( ext ) { <nl> return ! _ . contains ( [ ' js ' , ' css ' ] , ext ) ; <nl>\n", "msg": "Public docs comments for register { Compiler , Minifier , Linter }\n", "score": 1}
{"diff_id": 22216, "repo": "facebook/react\n", "sha": "c530639dd21543ab8d7d9e83d53197cda234b26b\n", "time": "2019-04-25T15:24:01Z\n", "diff": "mmm a / scripts / rollup / bundles . js <nl> ppp b / scripts / rollup / bundles . js <nl> const bundleTypes = { <nl> RN_FB_PROFILING : ' RN_FB_PROFILING ' , <nl> } ; <nl> <nl> - const UMD_DEV = bundleTypes . UMD_DEV ; <nl> - const UMD_PROD = bundleTypes . UMD_PROD ; <nl> - const UMD_PROFILING = bundleTypes . UMD_PROFILING ; <nl> - const NODE_DEV = bundleTypes . NODE_DEV ; <nl> - const NODE_PROD = bundleTypes . NODE_PROD ; <nl> - const NODE_PROFILING = bundleTypes . NODE_PROFILING ; <nl> - const FB_WWW_DEV = bundleTypes . FB_WWW_DEV ; <nl> - const FB_WWW_PROD = bundleTypes . FB_WWW_PROD ; <nl> - const FB_WWW_PROFILING = bundleTypes . FB_WWW_PROFILING ; <nl> - const RN_OSS_DEV = bundleTypes . RN_OSS_DEV ; <nl> - const RN_OSS_PROD = bundleTypes . RN_OSS_PROD ; <nl> - const RN_OSS_PROFILING = bundleTypes . RN_OSS_PROFILING ; <nl> - const RN_FB_DEV = bundleTypes . RN_FB_DEV ; <nl> - const RN_FB_PROD = bundleTypes . RN_FB_PROD ; <nl> - const RN_FB_PROFILING = bundleTypes . RN_FB_PROFILING ; <nl> + const { <nl> + UMD_DEV , <nl> + UMD_PROD , <nl> + UMD_PROFILING , <nl> + NODE_DEV , <nl> + NODE_PROD , <nl> + NODE_PROFILING , <nl> + FB_WWW_DEV , <nl> + FB_WWW_PROD , <nl> + FB_WWW_PROFILING , <nl> + RN_OSS_DEV , <nl> + RN_OSS_PROD , <nl> + RN_OSS_PROFILING , <nl> + RN_FB_DEV , <nl> + RN_FB_PROD , <nl> + RN_FB_PROFILING , <nl> + } = bundleTypes ; <nl> <nl> const moduleTypes = { <nl> + / / React <nl> ISOMORPHIC : ' ISOMORPHIC ' , <nl> + / / Individual renderers . They bundle the reconciler . ( e . g . ReactDOM ) <nl> RENDERER : ' RENDERER ' , <nl> + / / Helper packages that access specific renderer ' s internals . ( e . g . TestUtils ) <nl> RENDERER_UTILS : ' RENDERER_UTILS ' , <nl> + / / Standalone reconciler for third - party renderers . <nl> RECONCILER : ' RECONCILER ' , <nl> + / / Non - Fiber implementations like SSR and Shallow renderers . <nl> NON_FIBER_RENDERER : ' NON_FIBER_RENDERER ' , <nl> } ; <nl> <nl> - / / React <nl> - const ISOMORPHIC = moduleTypes . ISOMORPHIC ; <nl> - / / Individual renderers . They bundle the reconciler . ( e . g . ReactDOM ) <nl> - const RENDERER = moduleTypes . RENDERER ; <nl> - / / Helper packages that access specific renderer ' s internals . ( e . g . TestUtils ) <nl> - const RENDERER_UTILS = moduleTypes . RENDERER_UTILS ; <nl> - / / Standalone reconciler for third - party renderers . <nl> - const RECONCILER = moduleTypes . RECONCILER ; <nl> - / / Non - Fiber implementations like SSR and Shallow renderers . <nl> - const NON_FIBER_RENDERER = moduleTypes . NON_FIBER_RENDERER ; <nl> + const { <nl> + ISOMORPHIC , <nl> + RENDERER , <nl> + RENDERER_UTILS , <nl> + RECONCILER , <nl> + NON_FIBER_RENDERER , <nl> + } = moduleTypes ; <nl> <nl> const bundles = [ <nl> / * * * * * * * Isomorphic * * * * * * * / <nl> const bundles = [ <nl> global : ' ReactDOMServer ' , <nl> externals : [ ' react ' ] , <nl> } , <nl> - <nl> { <nl> bundleTypes : [ NODE_DEV , NODE_PROD ] , <nl> moduleType : NON_FIBER_RENDERER , <nl> const bundles = [ <nl> ' ReactNativeViewConfigRegistry ' , <nl> ] , <nl> } , <nl> - <nl> { <nl> bundleTypes : [ RN_OSS_DEV , RN_OSS_PROD , RN_OSS_PROFILING ] , <nl> moduleType : RENDERER , <nl> const bundles = [ <nl> ' ReactNativeViewConfigRegistry ' , <nl> ] , <nl> } , <nl> - <nl> { <nl> bundleTypes : [ RN_OSS_DEV , RN_OSS_PROD , RN_OSS_PROFILING ] , <nl> moduleType : RENDERER , <nl> const bundles = [ <nl> global : ' ReactTestRenderer ' , <nl> externals : [ ' react ' , ' scheduler ' , ' scheduler / unstable_mock ' ] , <nl> } , <nl> - <nl> { <nl> bundleTypes : [ FB_WWW_DEV , NODE_DEV , NODE_PROD , UMD_DEV , UMD_PROD ] , <nl> moduleType : NON_FIBER_RENDERER , <nl> const bundles = [ <nl> <nl> / * * * * * * * ESLint Plugin for Hooks ( proposal ) * * * * * * * / <nl> { <nl> - / / TODO : it ' s awkward to create a bundle for this <nl> - / / but if we don ' t , the package won ' t get copied . <nl> - / / We also can ' t create just DEV bundle because <nl> - / / it contains a NODE_ENV check inside . <nl> - / / We should probably tweak our build process <nl> - / / to allow \" raw \" packages that don ' t get bundled . <nl> + / / TODO : it ' s awkward to create a bundle for this but if we don ' t , the package <nl> + / / won ' t get copied . We also can ' t create just DEV bundle because it contains a <nl> + / / NODE_ENV check inside . We should probably tweak our build process to allow <nl> + / / \" raw \" packages that don ' t get bundled . <nl> bundleTypes : [ NODE_DEV , NODE_PROD , FB_WWW_DEV ] , <nl> moduleType : ISOMORPHIC , <nl> entry : ' eslint - plugin - react - hooks ' , <nl> global : ' ESLintPluginReactHooks ' , <nl> externals : [ ] , <nl> } , <nl> - <nl> { <nl> bundleTypes : [ <nl> FB_WWW_DEV , <nl> function deepFreeze ( o ) { <nl> <nl> / / Don ' t accidentally mutate config as part of the build <nl> deepFreeze ( bundles ) ; <nl> + deepFreeze ( bundleTypes ) ; <nl> + deepFreeze ( moduleTypes ) ; <nl> <nl> module . exports = { <nl> bundleTypes , <nl>\n", "msg": "Minor code structure adjustments to the bundles . js file ( )\n", "score": 1}
{"diff_id": 22532, "repo": "meteor/meteor\n", "sha": "9fc6642f5a9a2baeb6f83892fb780081f73bc7ca\n", "time": "2019-05-17T14:59:17Z\n", "diff": "mmm a / tools / isobuild / import - scanner . js <nl> ppp b / tools / isobuild / import - scanner . js <nl> class DefaultHandlers { <nl> cacheDir , <nl> bundleArch , <nl> } ) { <nl> - Object . assign ( this , { <nl> - cacheDir , <nl> - isWeb : ! archMatches ( bundleArch , \" os \" ) , <nl> - } ) ; <nl> + if ( cacheDir ) { <nl> + mkdir_p ( this . cacheDir = pathJoin ( <nl> + cacheDir , <nl> + bundleArch , <nl> + ) ) ; <nl> + } <nl> } <nl> <nl> getCacheFileName ( file ) { <nl> - return pathJoin ( <nl> - this . cacheDir , <nl> - \" reify - \" + file . hash + \" . js \" , <nl> - ) ; <nl> + return pathJoin ( this . cacheDir , \" reify - \" + file . hash + \" . js \" ) ; <nl> } <nl> <nl> js ( file ) { <nl> - if ( ! this . isWeb ) { <nl> - / / Since we don ' t use the \" module \" entry point in package . json for <nl> - / / server packages yet , we don ' t need to compile ESM syntax on the <nl> - / / server yet . <nl> - return stripHashBang ( file . dataString ) ; <nl> - } <nl> - <nl> if ( this . cacheDir ) { <nl> const cacheFileName = this . getCacheFileName ( file ) ; <nl> try { <nl> export default class ImportScanner { <nl> this . sourceRoot = sourceRoot ; <nl> this . nodeModulesPaths = nodeModulesPaths ; <nl> this . watchSet = watchSet ; <nl> + this . cacheDir = cacheDir ; <nl> this . absPathToOutputIndex = Object . create ( null ) ; <nl> this . realPathToFiles = Object . create ( null ) ; <nl> this . realPathCache = Object . create ( null ) ; <nl> this . allMissingModules = Object . create ( null ) ; <nl> this . outputFiles = [ ] ; <nl> <nl> - if ( cacheDir ) { <nl> - mkdir_p ( cacheDir = pathJoin ( <nl> - cacheDir , <nl> - bundleArch , <nl> - ) ) ; <nl> - } <nl> - this . cacheDir = cacheDir ; <nl> - <nl> this . defaultHandlers = new DefaultHandlers ( { <nl> cacheDir , <nl> bundleArch , <nl>\n", "msg": "Compile unhandled JS imports for server bundles , too .\n", "score": 1}
{"diff_id": 22866, "repo": "moment/moment\n", "sha": "effe9ce7e9ec2e95b971898e5f01e6d660522a2e\n", "time": "2013-07-13T21:44:16Z\n", "diff": "mmm a / test / moment / min_max . js <nl> ppp b / test / moment / min_max . js <nl> exports . min_max = { <nl> <nl> var now = moment ( ) , <nl> future = now . clone ( ) . add ( 1 , ' month ' ) , <nl> - past = now . clone ( ) . subtract ( 1 , ' month ' ) ; <nl> + past = now . clone ( ) . subtract ( 1 , ' month ' ) , <nl> + eps = 10 ; <nl> <nl> - / / we use Math . abs ( a . diff ( b ) ) < 2 to prevent issues where <nl> + / / we use Math . abs ( a . diff ( b ) ) < eps to prevent issues where <nl> / / two moments are off by a millisecond . <nl> <nl> - test . ok ( Math . abs ( past . min ( now ) . diff ( now ) ) < 2 , \" A past date with the minimum of now should be now \" ) ; <nl> - test . ok ( Math . abs ( past . min ( ) . diff ( now ) ) < 2 , \" A past date with the minimum of implied now should be now \" ) ; <nl> - test . ok ( Math . abs ( past . min ( future ) . diff ( future ) ) < 2 , \" A past date with the minimum of the future should be the future date \" ) ; <nl> + test . ok ( Math . abs ( past . min ( now ) . diff ( now ) ) < eps , \" A past date with the minimum of now should be now \" ) ; <nl> + test . ok ( Math . abs ( past . min ( ) . diff ( now ) ) < eps , \" A past date with the minimum of implied now should be now \" ) ; <nl> + test . ok ( Math . abs ( past . min ( future ) . diff ( future ) ) < eps , \" A past date with the minimum of the future should be the future date \" ) ; <nl> <nl> - test . ok ( Math . abs ( future . min ( now ) . diff ( future ) ) < 2 , \" A future date with the minimum of now should be the future \" ) ; <nl> - test . ok ( Math . abs ( future . min ( ) . diff ( future ) ) < 2 , \" A future date with the minimum of implied now should be the future \" ) ; <nl> - test . ok ( Math . abs ( future . min ( past ) . diff ( future ) ) < 2 , \" A future date with the minimum of the past should be the future \" ) ; <nl> + test . ok ( Math . abs ( future . min ( now ) . diff ( future ) ) < eps , \" A future date with the minimum of now should be the future \" ) ; <nl> + test . ok ( Math . abs ( future . min ( ) . diff ( future ) ) < eps , \" A future date with the minimum of implied now should be the future \" ) ; <nl> + test . ok ( Math . abs ( future . min ( past ) . diff ( future ) ) < eps , \" A future date with the minimum of the past should be the future \" ) ; <nl> <nl> - test . ok ( Math . abs ( now . min ( past ) . diff ( now ) ) < 2 , \" Now with the minimum of the past should be now \" ) ; <nl> - test . ok ( Math . abs ( now . min ( future ) . diff ( future ) ) < 2 , \" Now with the minimum of the future should be the future \" ) ; <nl> + test . ok ( Math . abs ( now . min ( past ) . diff ( now ) ) < eps , \" Now with the minimum of the past should be now \" ) ; <nl> + test . ok ( Math . abs ( now . min ( future ) . diff ( future ) ) < eps , \" Now with the minimum of the future should be the future \" ) ; <nl> <nl> test . done ( ) ; <nl> } , <nl> exports . min_max = { <nl> <nl> var now = moment ( ) , <nl> future = now . clone ( ) . add ( 1 , ' month ' ) , <nl> - past = now . clone ( ) . subtract ( 1 , ' month ' ) ; <nl> + past = now . clone ( ) . subtract ( 1 , ' month ' ) , <nl> + eps = 10 ; <nl> <nl> - / / we use Math . abs ( a . diff ( b ) ) < 2 to prevent issues where <nl> + / / we use Math . abs ( a . diff ( b ) ) < eps to prevent issues where <nl> / / two moments are off by a millisecond . <nl> <nl> - test . ok ( Math . abs ( past . max ( now ) . diff ( past ) ) < 2 , \" A past date with the maximum of now should be the past \" ) ; <nl> - test . ok ( Math . abs ( past . max ( ) . diff ( past ) ) < 2 , \" A past date with the maximum of implied now should be the past \" ) ; <nl> - test . ok ( Math . abs ( past . max ( future ) . diff ( past ) ) < 2 , \" A past date with the maximum of the future should be the past \" ) ; <nl> + test . ok ( Math . abs ( past . max ( now ) . diff ( past ) ) < eps , \" A past date with the maximum of now should be the past \" ) ; <nl> + test . ok ( Math . abs ( past . max ( ) . diff ( past ) ) < eps , \" A past date with the maximum of implied now should be the past \" ) ; <nl> + test . ok ( Math . abs ( past . max ( future ) . diff ( past ) ) < eps , \" A past date with the maximum of the future should be the past \" ) ; <nl> <nl> - test . ok ( Math . abs ( future . max ( now ) . diff ( now ) ) < 2 , \" A future date with the maximum of now should be now \" ) ; <nl> - test . ok ( Math . abs ( future . max ( ) . diff ( now ) ) < 2 , \" A future date with the maximum of implied now should be now \" ) ; <nl> - test . ok ( Math . abs ( future . max ( past ) . diff ( past ) ) < 2 , \" A future date with the maximum of the past should be the past \" ) ; <nl> + test . ok ( Math . abs ( future . max ( now ) . diff ( now ) ) < eps , \" A future date with the maximum of now should be now \" ) ; <nl> + test . ok ( Math . abs ( future . max ( ) . diff ( now ) ) < eps , \" A future date with the maximum of implied now should be now \" ) ; <nl> + test . ok ( Math . abs ( future . max ( past ) . diff ( past ) ) < eps , \" A future date with the maximum of the past should be the past \" ) ; <nl> <nl> - test . ok ( Math . abs ( now . max ( past ) . diff ( past ) ) < 2 , \" Now with the maximum of the past should be the past \" ) ; <nl> - test . ok ( Math . abs ( now . max ( future ) . diff ( now ) ) < 2 , \" Now with the maximum of the future should be now \" ) ; <nl> + test . ok ( Math . abs ( now . max ( past ) . diff ( past ) ) < eps , \" Now with the maximum of the past should be the past \" ) ; <nl> + test . ok ( Math . abs ( now . max ( future ) . diff ( now ) ) < eps , \" Now with the maximum of the future should be now \" ) ; <nl> <nl> test . done ( ) ; <nl> } <nl>\n", "msg": "Increase epsilon for min_max tests\n", "score": 1}
{"diff_id": 22987, "repo": "Leaflet/Leaflet\n", "sha": "41a85b0128ce5d3f7e1ce2738fb9c6e0dce9a3b0\n", "time": "2012-11-15T21:57:28Z\n", "diff": "mmm a / src / dom / Draggable . js <nl> ppp b / src / dom / Draggable . js <nl> L . Draggable = L . Class . extend ( { <nl> <nl> statics : { <nl> START : L . Browser . touch ? [ ' touchstart ' , ' mousedown ' ] : [ ' mousedown ' ] , <nl> - END : L . Browser . touch ? [ ' touchend ' , ' mouseup ' ] : [ ' mouseup ' ] , <nl> - MOVE : L . Browser . touch ? [ ' touchmove ' , ' mousemove ' ] : [ ' mousemove ' ] , <nl> + END : { ' mousedown ' : ' mouseup ' , ' touchstart ' : ' touchend ' , ' MSPointerDown ' : ' touchend ' } , <nl> + MOVE : { ' mousedown ' : ' mousemove ' , ' touchstart ' : ' touchmove ' , ' MSPointerDown ' : ' touchmove ' } , <nl> TAP_TOLERANCE : 15 <nl> } , <nl> <nl> L . Draggable = L . Class . extend ( { <nl> } , this ) , 1000 ) ; <nl> } <nl> <nl> - for ( var i = L . Draggable . MOVE . length - 1 ; i > = 0 ; i - - ) { <nl> - L . DomEvent . on ( document , L . Draggable . MOVE [ i ] , this . _onMove , this ) ; <nl> - L . DomEvent . on ( document , L . Draggable . END [ i ] , this . _onUp , this ) ; <nl> - } <nl> + L . DomEvent . on ( document , L . Draggable . MOVE [ e . type ] , this . _onMove , this ) ; <nl> + L . DomEvent . on ( document , L . Draggable . END [ e . type ] , this . _onUp , this ) ; <nl> } , <nl> <nl> _onMove : function ( e ) { <nl> L . Draggable = L . Class . extend ( { <nl> this . _restoreCursor ( ) ; <nl> } <nl> <nl> - for ( var i = L . Draggable . MOVE . length - 1 ; i > = 0 ; i - - ) { <nl> - L . DomEvent . off ( document , L . Draggable . MOVE [ i ] , this . _onMove ) ; <nl> - L . DomEvent . off ( document , L . Draggable . END [ i ] , this . _onUp ) ; <nl> + for ( var i in L . Draggable . MOVE ) { <nl> + if ( L . Draggable . MOVE . hasOwnProperty ( i ) ) <nl> + { <nl> + L . DomEvent . off ( document , L . Draggable . MOVE [ i ] , this . _onMove ) ; <nl> + L . DomEvent . off ( document , L . Draggable . END [ i ] , this . _onUp ) ; <nl> + } <nl> } <nl> <nl> if ( this . _moved ) { <nl>\n", "msg": "Only wire move / end listeners for the thing we want to listen to .\n", "score": 1}
{"diff_id": 23034, "repo": "balderdashy/sails\n", "sha": "3b33fe1ab06ca2d1c73358c86045c09f93a027db\n", "time": "2016-10-27T20:07:12Z\n", "diff": "mmm a / lib / hooks / views / add - shim - for - layout - and - partials . js <nl> ppp b / lib / hooks / views / add - shim - for - layout - and - partials . js <nl> function renderFile ( file , options , fn ) { <nl> <nl> / / Make sure the absolute path to view is always available . <nl> / / ( needed for partials ) <nl> - options . absPathToView = file ; <nl> + options . filename = file ; <nl> <nl> if ( ! options . locals . blocks ) { <nl> / / one set of blocks no matter how often we recurse <nl> function partial ( view , options ) { <nl> / / after ejs - locals was inlined , perhaps due to changed in EJS . <nl> / / The ` options . absPathToView ` value is set above in the <nl> / / main ` renderFile ` function . - SMG 10 / 27 / 2016 <nl> - var root = dirname ( options . absPathToView ) <nl> + var root = dirname ( options . filename ) <nl> / / var root = dirname ( options . filename ) <nl> , file = lookup ( root , view , options ) <nl> , key = file + ' : string ' ; <nl> function partial ( view , options ) { <nl> ? cache [ key ] | | ( cache [ key ] = fs . readFileSync ( file , ' utf8 ' ) ) <nl> : fs . readFileSync ( file , ' utf8 ' ) ; <nl> <nl> - / / Update the absPathToView to point to the current partial , <nl> + / / Update the options . filename to point to the current partial , <nl> / / so that relative paths can work in calling nested partials . <nl> / / - SMG 10 / 27 / 2016 <nl> - options . absPathToView = file ; <nl> + options . filename = file ; <nl> <nl> / / re - bind partial for relative partial paths <nl> options . partial = partial . bind ( options ) ; <nl>\n", "msg": "Change ` options . absPathToView ` option back to ` filename ` because it ' s expected by EJS\n", "score": 1}
{"diff_id": 23263, "repo": "preactjs/preact\n", "sha": "af826a495909a7211843bc6577dec81524a72140\n", "time": "2020-09-11T22:19:16Z\n", "diff": "mmm a / src / diff / props . js <nl> ppp b / src / diff / props . js <nl> export function diffProps ( dom , newProps , oldProps , isSvg , hydrate ) { <nl> i ! = = ' key ' & & <nl> i ! = = ' value ' & & <nl> i ! = = ' checked ' & & <nl> - oldProps [ i ] ! = = newProps [ i ] <nl> + oldProps [ i ] ! = newProps [ i ] <nl> ) { <nl> setProperty ( dom , i , newProps [ i ] , oldProps [ i ] , isSvg ) ; <nl> } <nl>\n", "msg": "use loose equality for prop comparison\n", "score": 1}
{"diff_id": 23609, "repo": "TryGhost/Ghost\n", "sha": "942324b60e2689900eea8638ecb5c833f323a9ae\n", "time": "2019-03-07T10:44:47Z\n", "diff": "mmm a / core / server / data / importer / importers / data / settings . js <nl> ppp b / core / server / data / importer / importers / data / settings . js <nl> class SettingsImporter extends BaseImporter { <nl> if ( obj . key = = = ' slack ' ) { <nl> obj . value = JSON . stringify ( [ { url : ' ' } ] ) ; <nl> } <nl> + <nl> + / / CASE : export files might contain \" 0 \" or \" 1 \" for booleans <nl> + / / transform \" 0 \" to false <nl> + / / transform \" false \" to false <nl> + / / transform \" null \" to null <nl> + if ( obj . value = = = ' 0 ' | | obj . value = = = ' 1 ' ) { <nl> + obj . value = ! ! + obj . value ; <nl> + } <nl> } ) ; <nl> <nl> return super . beforeImport ( ) ; <nl>\n", "msg": " Fixed private blogging getting enabled after import\n", "score": 1}
{"diff_id": 23674, "repo": "jashkenas/backbone\n", "sha": "c4f55849b409da8e0b9d7a472643fa4cabc81a98\n", "time": "2012-05-01T16:54:33Z\n", "diff": "mmm a / backbone . js <nl> ppp b / backbone . js <nl> <nl> / / Proxy to _ ' s chain . Can ' t be proxied the same way the rest of the <nl> / / underscore methods are proxied because it relies on the underscore <nl> / / constructor . <nl> - chain : function ( ) { <nl> + chain : function ( ) { <nl> return _ ( this . models ) . chain ( ) ; <nl> } , <nl> <nl> <nl> } ) ; <nl> <nl> / / The self - propagating extend function that Backbone classes use . <nl> - var extend = function ( protoProps , classProps ) { <nl> + var extend = function ( protoProps , classProps ) { <nl> var child = inherits ( this , protoProps , classProps ) ; <nl> child . extend = this . extend ; <nl> return child ; <nl>\n", "msg": "Whitespace cleanup for extend Collection . prototype . chain function definitions .\n", "score": 1}
{"diff_id": 23744, "repo": "lodash/lodash\n", "sha": "f7263047bfd45f7fdd08d416872cacc4901148c5\n", "time": "2016-12-21T21:23:54Z\n", "diff": "mmm a / lodash . js <nl> ppp b / lodash . js <nl> <nl> thisArg = newData [ 2 ] ; <nl> partials = newData [ 3 ] ; <nl> holders = newData [ 4 ] ; <nl> - arity = newData [ 9 ] = newData [ 9 ] = = null <nl> + arity = newData [ 9 ] = newData [ 9 ] = = = undefined <nl> ? ( isBindKey ? 0 : func . length ) <nl> : nativeMax ( newData [ 9 ] - length , 0 ) ; <nl> <nl>\n", "msg": "Use a strict ` undefined ` check for ` arity ` in ` createWrap ` .\n", "score": 1}
{"diff_id": 24234, "repo": "lodash/lodash\n", "sha": "1626cec08949a05b7c3a26b9abbcc48624fb952a\n", "time": "2013-07-28T17:09:35Z\n", "diff": "mmm a / lodash . js <nl> ppp b / lodash . js <nl> <nl> * <nl> * @ static <nl> * @ memberOf _ <nl> + * @ type Function <nl> * @ category Objects <nl> * @ param { Mixed } value The value to check . <nl> * @ returns { Boolean } Returns ` true ` , if the ` value ` is an array , else ` false ` . <nl>\n", "msg": "Add @ type to ` _ . isArray ` , required for modern builds .\n", "score": 1}
{"diff_id": 24248, "repo": "atom/atom\n", "sha": "c2810b626c7407caee775f765286357ea227f12d\n", "time": "2017-08-01T19:08:05Z\n", "diff": "mmm a / src / filesystem - manager . js <nl> ppp b / src / filesystem - manager . js <nl> class NativeWatcher { <nl> return this . emitter . on ( ' did - stop ' , callback ) <nl> } <nl> <nl> + / / Private : Register a callback to be invoked with any errors reported from the watcher . <nl> + / / <nl> + / / Returns : A { Disposable } to revoke the subscription . <nl> + onDidError ( callback ) { <nl> + return this . emitter . on ( ' did - error ' , callback ) <nl> + } <nl> + <nl> / / Private : Broadcast an ` onShouldDetach ` event to prompt any { Watcher } instances bound here to attach to a new <nl> / / { NativeWatcher } instead . <nl> reattachTo ( other ) { <nl> class NativeWatcher { <nl> / / <nl> / / * ` err ` The native filesystem error . <nl> onError ( err ) { <nl> - if ( ! this . isRunning ( ) ) { <nl> - return <nl> - } <nl> - <nl> - console . error ( err ) <nl> + this . emitter . emit ( ' did - error ' , err ) <nl> } <nl> } <nl> <nl> class Watcher { <nl> } ) <nl> } <nl> <nl> + onDidError ( callback ) { <nl> + return this . emitter . on ( ' did - error ' , callback ) <nl> + } <nl> + <nl> attachToNative ( native ) { <nl> this . subs . dispose ( ) <nl> this . native = native <nl> class Watcher { <nl> formerSub . dispose ( ) <nl> } <nl> <nl> + this . subs . add ( native . onDidError ( err = > { <nl> + this . emitter . emit ( ' did - error ' , err ) <nl> + } ) ) <nl> + <nl> this . subs . add ( native . onShouldDetach ( replacement = > { <nl> if ( replacement ! = = native ) { <nl> this . attachToNative ( replacement ) <nl>\n", "msg": "Propagate errors to subscribers with an onDidError callback\n", "score": 1}
{"diff_id": 24561, "repo": "photonstorm/phaser\n", "sha": "4b32505383ec14c30a2521e8d42a278e9abd448f\n", "time": "2015-01-18T05:15:10Z\n", "diff": "mmm a / src / physics / p2 / Body . js <nl> ppp b / src / physics / p2 / Body . js <nl> Phaser . Physics . P2 . Body . prototype = { <nl> adjustCenterOfMass : function ( ) { <nl> <nl> this . data . adjustCenterOfMass ( ) ; <nl> + this . shapeChanged ( ) ; <nl> <nl> } , <nl> <nl>\n", "msg": "calling adjust mass desyncs the debug graphics from the real positions of bodies\n", "score": 1}
{"diff_id": 24878, "repo": "meteor/meteor\n", "sha": "8e4f4fb650ce53564de59436c6e3a498dccecc83\n", "time": "2017-11-10T22:08:02Z\n", "diff": "mmm a / packages / ddp - client / server / stream_client_nodejs . js <nl> ppp b / packages / ddp - client / server / stream_client_nodejs . js <nl> export default class ClientStream extends StreamClientCommon { <nl> headers : this . headers , <nl> extensions : [ deflate ] <nl> } ; <nl> - fayeOptions = { . . . fayeOptions , . . . this . npmFayeOptions } ; <nl> + fayeOptions = Object . assign ( fayeOptions , this . npmFayeOptions ) ; <nl> var proxyUrl = this . _getProxyUrl ( targetUrl ) ; <nl> if ( proxyUrl ) { <nl> fayeOptions . proxy = { origin : proxyUrl } ; <nl>\n", "msg": "Use assign to avoid an extra object copy\n", "score": 1}
{"diff_id": 24881, "repo": "serverless/serverless\n", "sha": "afcb5118413ce5d0bdd1947d039327cae8960703\n", "time": "2018-04-05T20:22:53Z\n", "diff": "mmm a / lib / plugins / aws / package / lib / mergeIamTemplates . test . js <nl> ppp b / lib / plugins / aws / package / lib / mergeIamTemplates . test . js <nl> describe ( ' # mergeIamTemplates ( ) ' , ( ) = > { <nl> { ' Fn : : Join ' : [ ' : ' , [ ' arn : aws : iam : ' , { Ref : ' AWSAccountId ' } , ' some / path ' ] ] } , <nl> ] ; <nl> awsPackage . serverless . service . provider . iamManagedPolicies = iamManagedPolicies ; <nl> - const expectedManagedPolicyArns = [ . . . iamManagedPolicies , { <nl> - ' Fn : : Join ' : [ ' ' , <nl> + const expectedManagedPolicyArns = [ <nl> + ' some : aws : arn : xxx : * : * ' , <nl> + ' someOther : aws : arn : xxx : * : * ' , <nl> + { ' Fn : : Join ' : [ ' : ' , [ ' arn : aws : iam : ' , { Ref : ' AWSAccountId ' } , ' some / path ' ] ] } , <nl> + { ' Fn : : Join ' : [ ' ' , <nl> [ <nl> ' arn : ' , <nl> { Ref : ' AWS : : Partition ' } , <nl> ' : iam : : aws : policy / service - role / AWSLambdaVPCAccessExecutionRole ' , <nl> ] , <nl> ] , <nl> - } ] ; <nl> + } , <nl> + ] ; <nl> return awsPackage . mergeIamTemplates ( ) <nl> . then ( ( ) = > { <nl> expect ( awsPackage . serverless . service . provider . compiledCloudFormationTemplate <nl>\n", "msg": "removed spread operator to support older versions\n", "score": 1}
{"diff_id": 25019, "repo": "facebook/react-native\n", "sha": "158e9c4ddeeff5a6e561cc9612036998f8b488cd\n", "time": "2018-08-22T20:03:15Z\n", "diff": "mmm a / Libraries / Renderer / shims / ReactNativeTypes . js <nl> ppp b / Libraries / Renderer / shims / ReactNativeTypes . js <nl> type DirectEventType = { <nl> registrationName : string , <nl> } ; <nl> <nl> - export type ReactNativeBaseComponentViewConfig = { <nl> - validAttributes : Object , <nl> + type AttributeType = <nl> + | true <nl> + | $ ReadOnly < { | <nl> + diff : ? < T > ( arg1 : T , arg2 : T ) = > boolean , <nl> + process : ? ( arg1 : any ) = > any , <nl> + | } > ; <nl> + <nl> + export type ReactNativeBaseComponentViewConfig = $ ReadOnly < { | <nl> + baseModuleName ? : string , <nl> + bubblingEventTypes ? : $ ReadOnly < { <nl> + [ eventName : string ] : $ ReadOnly < { | <nl> + phasedRegistrationNames : $ ReadOnly < { | <nl> + captured : string , <nl> + bubbled : string , <nl> + | } > , <nl> + | } > , <nl> + } > , <nl> + Commands ? : $ ReadOnly < { <nl> + [ commandName : string ] : number , <nl> + } > , <nl> + directEventTypes ? : $ ReadOnly < { <nl> + [ eventName : string ] : $ ReadOnly < { | <nl> + registrationName : string , <nl> + | } > , <nl> + } > , <nl> + NativeProps ? : $ ReadOnly < { <nl> + [ propName : string ] : string , <nl> + } > , <nl> uiViewClassName : string , <nl> - bubblingEventTypes ? : { [ topLevelType : string ] : BubblingEventType } , <nl> - directEventTypes ? : { [ topLevelType : string ] : DirectEventType } , <nl> - propTypes ? : Object , <nl> - } ; <nl> + validAttributes : $ ReadOnly < { <nl> + [ propName : string ] : AttributeType , <nl> + style : $ ReadOnly < { <nl> + [ propName : string ] : AttributeType , <nl> + } > , <nl> + } > , <nl> + | } > ; <nl> <nl> export type ViewConfigGetter = ( ) = > ReactNativeBaseComponentViewConfig ; <nl> <nl>\n", "msg": "Adding a more complete type for ReactNativeBaseComponentViewConfig\n", "score": 1}
{"diff_id": 25503, "repo": "mozilla/pdf.js\n", "sha": "acc0a0fe9509fc0f9ef0df989f25c7bda64724df\n", "time": "2018-04-02T12:29:34Z\n", "diff": "mmm a / src / display / svg . js <nl> ppp b / src / display / svg . js <nl> SVGGraphics = ( function SVGGraphicsClosure ( ) { <nl> case OPS . beginText : <nl> this . beginText ( ) ; <nl> break ; <nl> + case OPS . dependency : <nl> + / / Handled in loadDependencies , warning should not be thrown <nl> + break ; <nl> case OPS . setLeading : <nl> this . setLeading ( args ) ; <nl> break ; <nl>\n", "msg": "Prevent warning on unimplemented operator thrown for OPS . dependency\n", "score": 1}
{"diff_id": 25522, "repo": "atom/atom\n", "sha": "d5287651612bb1d5a4767582e4bda7c8e7ce04a0\n", "time": "2015-09-19T02:48:52Z\n", "diff": "mmm a / vendor / jasmine - jquery . js <nl> ppp b / vendor / jasmine - jquery . js <nl> var jQueryMatchers = { <nl> } <nl> } , <nl> <nl> - toContain : function ( selector ) { <nl> + toContain : function ( contained ) { <nl> if ( this . actual instanceof HTMLElement ) { <nl> - return ! ! this . actual . querySelector ( selector ) <nl> + if ( typeof contained = = = ' string ' ) { <nl> + return this . actual . querySelector ( contained ) <nl> + } else { <nl> + return this . actual . contains ( contained ) <nl> + } <nl> } else { <nl> - return this . actual . find ( selector ) . size ( ) > 0 <nl> + return this . actual . find ( contained ) . size ( ) > 0 <nl> } <nl> } , <nl> <nl>\n", "msg": "Allow elements to be passed to toContain matcher\n", "score": 1}
{"diff_id": 25648, "repo": "socketio/socket.io\n", "sha": "b9e138dc349ac48ff3b76e89a8e002a9e604072b\n", "time": "2011-06-10T21:14:31Z\n", "diff": "mmm a / lib / transports / websocket . js <nl> ppp b / lib / transports / websocket . js <nl> WebSocket . prototype . write = function ( data ) { <nl> this . buffered . push ( data ) ; <nl> return this ; <nl> } <nl> + <nl> + var length = Buffer . byteLength ( data ) <nl> + , buffer = new Buffer ( 2 + length ) ; <nl> + <nl> + buffer . write ( ' \\ u0000 ' , ' binary ' ) ; <nl> + buffer . write ( data , 1 , ' utf8 ' ) ; <nl> + buffer . write ( ' \\ uffff ' , 1 + length , ' binary ' ) ; <nl> <nl> try { <nl> - this . socket . write ( ' \\ u0000 ' , ' binary ' ) ; <nl> - this . socket . write ( data , ' utf8 ' ) ; <nl> - this . socket . write ( ' \\ uffff ' , ' binary ' ) ; <nl> + if ( this . socket . write ( buffer ) ) { <nl> + this . drained = true ; <nl> + } <nl> } catch ( e ) { <nl> this . end ( ) ; <nl> } <nl> + <nl> + this . log . debug ( ' websocket writing ' , data ) ; <nl> } <nl> } ; <nl> <nl>\n", "msg": "Added optimization to write one buffer .\n", "score": 1}
{"diff_id": 25835, "repo": "RocketChat/Rocket.Chat\n", "sha": "b4a24a2b73dd9dad6809d362000cb12177282d0d\n", "time": "2015-10-27T14:08:32Z\n", "diff": "mmm a / packages / rocketchat - ldap / ldap_server . js <nl> ppp b / packages / rocketchat - ldap / ldap_server . js <nl> Accounts . registerLoginHandler ( \" ldap \" , function ( loginRequest ) { <nl> } <nl> <nl> / / LDAP sync data logic <nl> - syncUserData = RocketChat . settings . get ( ' LDAP_Sync_User_Data ' ) ; <nl> - syncUserDataFieldMap = RocketChat . settings . get ( ' LDAP_Sync_User_Data_FieldMap ' ) . trim ( ) ; <nl> + var syncUserData = RocketChat . settings . get ( ' LDAP_Sync_User_Data ' ) ; <nl> + var syncUserDataFieldMap = RocketChat . settings . get ( ' LDAP_Sync_User_Data_FieldMap ' ) . trim ( ) ; <nl> if ( userId & & syncUserData & & syncUserDataFieldMap ) { <nl> - userData = { } ; <nl> - fieldMap = JSON . parse ( syncUserDataFieldMap ) ; <nl> + var userData = { } ; <nl> + var fieldMap = JSON . parse ( syncUserDataFieldMap ) ; <nl> <nl> - emailList = [ ] ; <nl> + var = emailList = [ ] ; <nl> _ . map ( fieldMap , function ( userField , ldapField ) { <nl> if ( ! ldapResponse . searchResults . hasOwnProperty ( ldapField ) ) { <nl> return ; <nl>\n", "msg": "Explicitly declaring vars to limit scope .\n", "score": 1}
{"diff_id": 25907, "repo": "TryGhost/Ghost\n", "sha": "8418c829de7ab7ab7d58468fd0ee4c15bed0bc00\n", "time": "2020-08-20T07:01:17Z\n", "diff": "mmm a / core / server / services / members / importer / bulk - operations . js <nl> ppp b / core / server / services / members / importer / bulk - operations . js <nl> const db = require ( ' . . / . . / . . / data / db ' ) ; <nl> <nl> const CHUNK_SIZE = 100 ; <nl> <nl> + async function insertChunkSequential ( table , chunk , result ) { <nl> + for ( const record of chunk ) { <nl> + try { <nl> + await db . knex ( table ) . insert ( record ) ; <nl> + result . successful + = 1 ; <nl> + } catch ( err ) { <nl> + result . errors . push ( err ) ; <nl> + result . unsuccessfulIds . push ( record . id ) ; <nl> + result . unsuccessful + = 1 ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + async function insertChunk ( table , chunk , result ) { <nl> + try { <nl> + await db . knex ( table ) . insert ( chunk ) ; <nl> + result . successful + = chunk . length ; <nl> + } catch ( err ) { <nl> + await insertChunkSequential ( table , chunk , result ) ; <nl> + } <nl> + } <nl> + <nl> async function insert ( table , data ) { <nl> const result = { <nl> successful : 0 , <nl> unsuccessful : 0 , <nl> + unsuccessfulIds : [ ] , <nl> errors : [ ] <nl> } ; <nl> <nl> for ( const chunk of _ . chunk ( data , CHUNK_SIZE ) ) { <nl> - try { <nl> - await db . knex ( table ) . insert ( chunk ) ; <nl> - result . successful + = chunk . length ; <nl> - } catch ( error ) { <nl> - result . unsuccessful + = chunk . length ; <nl> - result . errors . push ( error ) ; <nl> - } <nl> + await insertChunk ( table , chunk , result ) ; <nl> } <nl> <nl> return result ; <nl>\n", "msg": "Improved error handling for batch inserted records\n", "score": 1}
{"diff_id": 26014, "repo": "facebook/react-native\n", "sha": "bccc4548e4d22b275f28a9beaf573f74d8b69213\n", "time": "2018-11-07T19:21:55Z\n", "diff": "mmm a / Libraries / polyfills / console . js <nl> ppp b / Libraries / polyfills / console . js <nl> if ( global . nativeLoggingHook ) { <nl> } ; <nl> } <nl> } ) ; <nl> + <nl> + / / The following methods are not supported by this polyfill but <nl> + / / we still should pass them to original console if they are <nl> + / / supported by it . <nl> + [ <nl> + ' assert ' , <nl> + ' clear ' , <nl> + ' dir ' , <nl> + ' dirxml ' , <nl> + ' groupCollapsed ' , <nl> + ' profile ' , <nl> + ' profileEnd ' , <nl> + ] . forEach ( methodName = > { <nl> + if ( typeof originalConsole [ methodName ] = = = ' function ' ) { <nl> + console [ methodName ] = function ( ) { <nl> + originalConsole [ methodName ] ( . . . arguments ) ; <nl> + } ; <nl> + } <nl> + } ) ; <nl> } <nl> } else if ( ! global . console ) { <nl> const log = global . print | | function consoleLoggingStub ( ) { } ; <nl>\n", "msg": "console polyfill : pass unsupported messages to original console\n", "score": 1}
{"diff_id": 26184, "repo": "balderdashy/sails\n", "sha": "f5175d9850af7999b9e27e9b7d7eedcd6939be90\n", "time": "2013-10-08T14:19:17Z\n", "diff": "mmm a / lib / hooks / orm / index . js <nl> ppp b / lib / hooks / orm / index . js <nl> module . exports = function ( sails ) { <nl> _loadModules : loadAppModelsAndAdapters , <nl> <nl> / / Normalize model definitions and merge in defaults from ` sails . config . model ` <nl> - modelDefs : [ ' _loadModules ' , function normalizeModelDefs ( cb ) { <nl> + _modelDefs : [ ' _loadModules ' , function normalizeModelDefs ( cb ) { <nl> util . each ( sails . models , self . normalizeModelDef ) ; <nl> cb ( ) ; <nl> } ] , <nl> <nl> / / Once all user model definitions are loaded into sails . models , <nl> / / go ahead and start the ORM , instantiate the models <nl> - instantiatedCollections : [ ' modelDefs ' , this . startORM ] , <nl> + instantiatedCollections : [ ' _modelDefs ' , this . startORM ] , <nl> <nl> <nl> _exposeModels : [ ' instantiatedCollections ' , this . exposeModels ] <nl> module . exports = function ( sails ) { <nl> * @ param { Function } cb <nl> * - > err / / Error , if one occurred , or null <nl> * <nl> + * @ param { Object } stack <nl> + * stack . instantiatedCollections { } <nl> + * <nl> * @ global { Object } sails <nl> - * | ___ . models { } <nl> + * sails . models { } <nl> * / <nl> startORM : function ( cb ) { <nl> <nl> + / / TODO : global not necessary here - - replace w / async stack reference <nl> var modelDefs = sails . models ; <nl> <nl> <nl> module . exports = function ( sails ) { <nl> * - > err / / Error , if one occurred , or null <nl> * <nl> * @ param { Object } stack <nl> - * | __ . instantiatedCollections { } <nl> + * stack . instantiatedCollections { } <nl> * / <nl> exposeModels : function ( cb , stack ) { <nl> var collections = stack . instantiatedCollections ; <nl> module . exports = function ( sails ) { <nl> * / / Optional , improves quality of error messages <nl> * <nl> * @ global sails <nl> - * | ___ . config <nl> - * | ___ . connections { } <nl> + * sails . config <nl> + * sails . config . connections { } <nl> * <nl> * @ throws { FatalError } __UnknownConnection__ <nl> * @ api private <nl> module . exports = function ( sails ) { <nl> * ( handles deprecation warnings / validation errors and making types consistent ) <nl> * <nl> * @ param { Object } connection <nl> - * | ___ . adapter <nl> - * | ___ . module <nl> + * connection . adapter / / Name of adapter module used by this connection <nl> + * connection . module / / Deprecated - equivalent to ` connection . adapter ` <nl> * <nl> * @ param { String } modelID <nl> * / / Optional , improves quality of error messages <nl> - * / / Identity of the model this conncetion came from <nl> + * / / Identity of the model this connection came from <nl> * <nl> * @ throws { FatalError } __UnknownConnection__ <nl> * @ throws { FatalError } __InvalidConnection__ <nl>\n", "msg": "Some work normalizing more complete documentation style .\n", "score": 1}
{"diff_id": 26278, "repo": "hexojs/hexo\n", "sha": "c32b5fa5aa7f782ec19eff363357ebac6b149cdd\n", "time": "2019-07-19T08:18:07Z\n", "diff": "mmm a / lib / plugins / filter / post_permalink . js <nl> ppp b / lib / plugins / filter / post_permalink . js <nl> function postPermalinkFilter ( data ) { <nl> year : data . date . format ( ' YYYY ' ) , <nl> month : data . date . format ( ' MM ' ) , <nl> day : data . date . format ( ' DD ' ) , <nl> + hour : data . date . format ( ' HH ' ) , <nl> + minute : data . date . format ( ' mm ' ) , <nl> i_month : data . date . format ( ' M ' ) , <nl> i_day : data . date . format ( ' D ' ) <nl> } ; <nl>\n", "msg": "Add hour and minute for the post permalink .\n", "score": 1}
{"diff_id": 26715, "repo": "meteor/meteor\n", "sha": "c2e3c52dd3eb8ed19fdf4142f849b730c6325f5b\n", "time": "2018-03-01T19:27:30Z\n", "diff": "mmm a / tools / isobuild / compiler - plugin . js <nl> ppp b / tools / isobuild / compiler - plugin . js <nl> class ResourceSlot { <nl> return lazy ; <nl> } <nl> <nl> - / / If file . lazy was not previously defined , mark the file lazy if <nl> - / / it is contained by an imports directory . Note that any files <nl> - / / contained by a node_modules directory will already have been <nl> - / / marked lazy in PackageSource # _inferFileOptions . Same for <nl> - / / non - test files if running ( non - full - app ) tests ( ` meteor test ` ) <nl> - if ( ! this . packageSourceBatch . useMeteorInstall ) { <nl> + const isApp = ! this . packageSourceBatch . unibuild . pkg . name ; <nl> + if ( ! isApp ) { <nl> + / / Meteor package files must be explicitly added by api . addFiles or <nl> + / / api . mainModule , and are implicitly eager unless specified <nl> + / / otherwise via this . inputResource . fileOptions . lazy , which we <nl> + / / already checked above . <nl> + return false ; <nl> + } <nl> + <nl> + / / The rest of this method assumes we ' re considering a resource in an <nl> + / / application rather than a Meteor package . <nl> + <nl> + if ( ! this . packageSourceBatch . useMeteorInstall ) { <nl> + / / If this application is somehow still not using the module system , <nl> + / / then everything is eagerly loaded . <nl> return false ; <nl> } <nl> <nl>\n", "msg": "Simplify ResourceSlot # _isLazy for package resources .\n", "score": 1}
{"diff_id": 26756, "repo": "facebook/react\n", "sha": "07299828c9e0d9050e6a8c63ed129b16a4d4bf0d\n", "time": "2019-04-10T13:57:39Z\n", "diff": "mmm a / src / devtools / views / Components / TreeContext . js <nl> ppp b / src / devtools / views / Components / TreeContext . js <nl> function reduceSearchState ( store : Store , state : State , action : Action ) : State { <nl> const prevSearchText = searchText ; <nl> const numPrevSearchResults = searchResults . length ; <nl> <nl> + / / We track explicitly whether search was requested because <nl> + / / we might want to search even if search index didn ' t change . <nl> + / / For example , if you press \" next result \" on a search with a single <nl> + / / result but a different current selection , we ' ll set this to true . <nl> + let didRequestSearch = false ; <nl> + <nl> / / Search isn ' t supported when the owner ' s tree is active . <nl> if ( ownerStack . length = = = 0 ) { <nl> switch ( type ) { <nl> case ' GO_TO_NEXT_SEARCH_RESULT ' : <nl> if ( numPrevSearchResults > 0 ) { <nl> + didRequestSearch = true ; <nl> searchIndex = <nl> searchIndex + 1 < numPrevSearchResults ? searchIndex + 1 : 0 ; <nl> } <nl> break ; <nl> case ' GO_TO_PREVIOUS_SEARCH_RESULT ' : <nl> if ( numPrevSearchResults > 0 ) { <nl> + didRequestSearch = true ; <nl> searchIndex = <nl> ( ( searchIndex : any ) : number ) > 0 <nl> ? ( ( searchIndex : any ) : number ) - 1 <nl> function reduceSearchState ( store : Store , state : State , action : Action ) : State { <nl> } <nl> <nl> / / Changes in search index or typing should override the selected element . <nl> - const didAddToSearchText = <nl> + if ( searchIndex ! = = prevSearchIndex ) { <nl> + didRequestSearch = true ; <nl> + } <nl> + if ( <nl> + / / Did the user type more ? <nl> searchText . length > prevSearchText . length & & <nl> - searchText . indexOf ( prevSearchText ) = = = 0 ; <nl> - if ( searchIndex ! = = prevSearchIndex | | didAddToSearchText ) { <nl> + searchText . indexOf ( prevSearchText ) = = = 0 <nl> + ) { <nl> + didRequestSearch = true ; <nl> + } <nl> + if ( didRequestSearch ) { <nl> if ( searchIndex = = = null ) { <nl> selectedElementIndex = null ; <nl> selectedElementID = null ; <nl>\n", "msg": "Pressing next forces search to select\n", "score": 1}
{"diff_id": 27160, "repo": "photonstorm/phaser\n", "sha": "e4ca4d4b75f1495b8561ebca3bbe542721821e85\n", "time": "2017-12-07T19:57:05Z\n", "diff": "mmm a / v3 / src / sound / BaseSound . js <nl> ppp b / v3 / src / sound / BaseSound . js <nl> var BaseSound = new Class ( { <nl> * / <nl> this . currentConfig = this . config ; <nl> / * * <nl> - * [ description ] <nl> + * Boolean indicating whether the sound is muted or not . <nl> + * Gets or sets the muted state of this sound . <nl> * <nl> * @ property { boolean } mute <nl> * / <nl>\n", "msg": "Updated description for mute property\n", "score": 1}
{"diff_id": 27255, "repo": "lodash/lodash\n", "sha": "ba58f35f37385cc786fe995cfcb7fa2805d31567\n", "time": "2016-04-19T00:48:26Z\n", "diff": "mmm a / test / test . js <nl> ppp b / test / test . js <nl> <nl> <nl> lodashStable . each ( [ ' values ' , ' valuesIn ' ] , function ( methodName ) { <nl> var args = ( function ( ) { return arguments ; } ( 1 , 2 , 3 ) ) , <nl> + strictArgs = ( function ( ) { ' use strict ' ; return arguments ; } ( 1 , 2 , 3 ) ) , <nl> func = _ [ methodName ] , <nl> isValues = methodName = = ' values ' ; <nl> <nl> <nl> <nl> assert . deepEqual ( actual , expected ) ; <nl> } ) ; <nl> + <nl> + QUnit . test ( ' ` _ . ' + methodName + ' ` should work with ` arguments ` objects ' , function ( assert ) { <nl> + assert . expect ( 1 ) ; <nl> + <nl> + var values = [ args , strictArgs ] , <nl> + expected = lodashStable . map ( values , lodashStable . constant ( [ 1 , 2 , 3 ] ) ) ; <nl> + <nl> + var actual = lodashStable . map ( values , function ( value ) { <nl> + return func ( value ) . sort ( ) ; <nl> + } ) ; <nl> + <nl> + assert . deepEqual ( actual , expected ) ; <nl> + } ) ; <nl> } ) ; <nl> <nl> / * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - * / <nl>\n", "msg": "Add arguments object test for values methods .\n", "score": 1}
{"diff_id": 27552, "repo": "angular/angular.js\n", "sha": "d3f7bd699e2e0edf93887ddf5302b27254a1ec81\n", "time": "2011-01-18T19:15:36Z\n", "diff": "mmm a / src / apis . js <nl> ppp b / src / apis . js <nl> var angularGlobal = { <nl> * @ function <nl> * <nl> * @ description <nl> - * Utility functions for manipulation with JavaScript objects . <nl> + * angular . Object is a namespace for utility functions for manipulation with JavaScript objects . <nl> * <nl> * These functions are exposed in two ways : <nl> * <nl> var angularObject = { <nl> } ; <nl> <nl> / * * <nl> - * @ workInProgress <nl> * @ ngdoc overview <nl> * @ name angular . Array <nl> * <nl> * @ description <nl> - * Utility functions for manipulation with JavaScript Array objects . <nl> + * angular . Array is a namespace for utility functions for manipulation of JavaScript ` Array ` <nl> + * objects . <nl> * <nl> * These functions are exposed in two ways : <nl> * <nl> var angularObject = { <nl> * type as array methods . The names of these methods are prefixed with ` $ ` character to minimize <nl> * naming collisions . To call a method , invoke ` myArrayObject . $ foo ( params ) ` . <nl> * <nl> - * - * * in JavaScript code * * : the functions don ' t augment the Array type and must be invoked as <nl> + * Because ` Array ` type is a subtype of the Object type , all { @ link angular . Object } functions <nl> + * augment the ` Array ` type in angular expressions as well . <nl> + * <nl> + * - * * in JavaScript code * * : the functions don ' t augment the ` Array ` type and must be invoked as <nl> * functions of ` angular . Array ` as ` angular . Array . foo ( myArrayObject , params ) ` . <nl> * <nl> * / <nl> var angularArray = { <nl> <nl> <nl> / * * <nl> - * @ workInProgress <nl> * @ ngdoc function <nl> * @ name angular . Array . indexOf <nl> * @ function <nl> var angularArray = { <nl> * @ description <nl> * Determines the index of ` value ` in ` array ` . <nl> * <nl> - * Note : this function is used to augment the Array type in angular expressions . See <nl> + * Note : this function is used to augment the ` Array ` type in angular expressions . See <nl> * { @ link angular . Array } for more info . <nl> * <nl> * @ param { Array } array Array to search . <nl> var angularArray = { <nl> <nl> <nl> / * * <nl> - * @ workInProgress <nl> * @ ngdoc function <nl> * @ name angular . Array . sum <nl> * @ function <nl> var angularArray = { <nl> * This function calculates the sum of all numbers in ` array ` . If the ` expressions ` is supplied , <nl> * it is evaluated once for each element in ` array ` and then the sum of these values is returned . <nl> * <nl> - * Note : this function is used to augment the Array type in angular expressions . See <nl> + * Note : this function is used to augment the ` Array ` type in angular expressions . See <nl> * { @ link angular . Array } for more info . <nl> * <nl> * @ param { Array } array The source array . <nl> var angularArray = { <nl> <nl> <nl> / * * <nl> - * @ workInProgress <nl> * @ ngdoc function <nl> * @ name angular . Array . remove <nl> * @ function <nl> var angularArray = { <nl> * { @ link angular . Array . indexOf indexOf } function on the ` array ` and only the first instance of <nl> * the element will be removed . <nl> * <nl> - * Note : this function is used to augment the Array type in angular expressions . See <nl> + * Note : this function is used to augment the ` Array ` type in angular expressions . See <nl> * { @ link angular . Array } for more info . <nl> * <nl> * @ param { Array } array Array from which an element should be removed . <nl> var angularArray = { <nl> <nl> <nl> / * * <nl> - * @ workInProgress <nl> * @ ngdoc function <nl> * @ name angular . Array . filter <nl> * @ function <nl> var angularArray = { <nl> * @ description <nl> * Selects a subset of items from ` array ` and returns it as a new array . <nl> * <nl> - * Note : this function is used to augment the Array type in angular expressions . See <nl> + * Note : this function is used to augment the ` Array ` type in angular expressions . See <nl> * { @ link angular . Array } for more info . <nl> * <nl> * @ param { Array } array The source array . <nl> var angularArray = { <nl> * <nl> * @ description <nl> * ` add ` is a function similar to JavaScript ' s ` Array # push ` method , in that it appends a new <nl> - * element to an array , but it differs in that the value being added is optional and defaults to <nl> - * an emty object . <nl> + * element to an array . The difference is that the value being added is optional and defaults to <nl> + * an empty object . <nl> * <nl> - * Note : this function is used to augment the Array type in angular expressions . See <nl> + * Note : this function is used to augment the ` Array ` type in angular expressions . See <nl> * { @ link angular . Array } for more info . <nl> * <nl> * @ param { Array } array The array expand . <nl> * @ param { * = } [ value = { } ] The value to be added . <nl> * @ returns { Array } The expanded array . <nl> * <nl> + * @ TODO simplify the example . <nl> + * <nl> * @ exampleDescription <nl> * This example shows how an initially empty array can be filled with objects created from user <nl> * input via the ` $ add ` method . <nl> var angularArray = { <nl> <nl> <nl> / * * <nl> - * @ workInProgress <nl> * @ ngdoc function <nl> * @ name angular . Array . count <nl> * @ function <nl> * <nl> * @ description <nl> * Determines the number of elements in an array . Optionally it will count only those elements <nl> - * for which the ` condition ` evaluets to ` true ` . <nl> + * for which the ` condition ` evaluates to ` true ` . <nl> * <nl> - * Note : this function is used to augment the Array type in angular expressions . See <nl> + * Note : this function is used to augment the ` Array ` type in angular expressions . See <nl> * { @ link angular . Array } for more info . <nl> * <nl> * @ param { Array } array The array to count elements in . <nl> var angularArray = { <nl> <nl> <nl> / * * <nl> - * @ workInProgress <nl> * @ ngdoc function <nl> * @ name angular . Array . orderBy <nl> * @ function <nl> var angularArray = { <nl> * @ description <nl> * Orders ` array ` by the ` expression ` predicate . <nl> * <nl> - * Note : this function is used to augment the Array type in angular expressions . See <nl> + * Note : this function is used to augment the ` Array ` type in angular expressions . See <nl> * { @ link angular . Array } for more info . <nl> * <nl> * @ param { Array } array The array to sort . <nl> - * @ param { function ( ) | string | Array . < ( function ( ) | string ) > } expression A predicate to be used by the <nl> - * comparator to determine the order of elements . <nl> + * @ param { function ( * , * ) | string | Array . < ( function ( * , * ) | string ) > } expression A predicate to be <nl> + * used by the comparator to determine the order of elements . <nl> * <nl> * Can be one of : <nl> * <nl> var angularArray = { <nl> <nl> <nl> / * * <nl> - * @ workInProgress <nl> * @ ngdoc function <nl> * @ name angular . Array . limitTo <nl> * @ function <nl> var angularArray = { <nl> * Creates a new array containing only the first , or last ` limit ` number of elements of the <nl> * source ` array ` . <nl> * <nl> - * Note : this function is used to augment the Array type in angular expressions . See <nl> + * Note : this function is used to augment the ` Array ` type in angular expressions . See <nl> * { @ link angular . Array } for more info . <nl> * <nl> * @ param { Array } array Source array to be limited . <nl> * @ param { string | Number } limit The length of the returned array . If the number is positive , the <nl> * first ` limit ` items from the source array will be copied , if the number is negative , the <nl> * last ` limit ` items will be copied . <nl> - * @ returns { Array } New array of length ` limit ` . <nl> + * @ returns { Array } A new sub - array of length ` limit ` . <nl> * <nl> + * @ example <nl> + < div ng : init = \" numbers = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] \" > <nl> + Limit [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] to : < input name = \" limit \" value = \" 3 \" / > <nl> + < p > Output : { { numbers . $ limitTo ( limit ) | json } } < / p > <nl> + < / div > <nl> + <nl> + * @ scenario <nl> + it ( ' should limit the numer array to first three items ' , function ( ) { <nl> + expect ( element ( ' . doc - example input [ name = limit ] ' ) . val ( ) ) . toBe ( ' 3 ' ) ; <nl> + expect ( binding ( ' numbers . $ limitTo ( limit ) | json ' ) ) . toEqual ( ' [ 1 , 2 , 3 ] ' ) ; <nl> + } ) ; <nl> + <nl> + it ( ' should update the output when - 3 is entered ' , function ( ) { <nl> + input ( ' limit ' ) . enter ( - 3 ) ; <nl> + expect ( binding ( ' numbers . $ limitTo ( limit ) | json ' ) ) . toEqual ( ' [ 7 , 8 , 9 ] ' ) ; <nl> + } ) ; <nl> * / <nl> limitTo : function ( array , limit ) { <nl> limit = parseInt ( limit , 10 ) ; <nl>\n", "msg": "various doc fixes for angular . Array . * apis + example and spec limitTo\n", "score": 1}
{"diff_id": 27967, "repo": "photonstorm/phaser\n", "sha": "c919d331a6b2aa558973771c773e1bff4ce7b1f7\n", "time": "2018-01-04T18:44:22Z\n", "diff": "mmm a / v3 / src / sound / BaseSoundManager . js <nl> ppp b / v3 / src / sound / BaseSoundManager . js <nl> var BaseSoundManager = new Class ( { <nl> sound . events . once ( ' SOUND_ENDED ' , sound . destroy . bind ( sound ) ) ; <nl> sound . play ( spriteName , config ) ; <nl> } , <nl> + / * * <nl> + * <nl> + * <nl> + * @ param { ISound } sound <nl> + * @ returns { boolean } True if the sound was removed successfully , otherwise false . <nl> + * / <nl> remove : function ( sound ) { <nl> var index = this . sounds . indexOf ( sound ) ; <nl> if ( index ! = = - 1 ) { <nl> var BaseSoundManager = new Class ( { <nl> } <nl> return false ; <nl> } , <nl> + / * * <nl> + * <nl> + * @ param { string } key <nl> + * @ returns { number } The number of matching sound objects that were removed . <nl> + * / <nl> removeByKey : function ( key ) { <nl> var removed = 0 ; <nl> for ( var i = this . sounds . length - 1 ; i > = 0 ; i - - ) { <nl> var BaseSoundManager = new Class ( { <nl> * @ param { number } delta - The delta time elapsed since the last frame . <nl> * / <nl> update : function ( time , delta ) { <nl> - / / TODO remove pending sounds <nl> + this . sounds . sort ( function ( s1 , s2 ) { <nl> + return ( s1 . pendingRemove = = = s2 . pendingRemove ) ? 0 : s1 ? 1 : - 1 ; <nl> + } ) ; <nl> + for ( var i = this . sounds . length - 1 ; i > = 0 ; i - - ) { <nl> + if ( ! this . sounds [ i ] . pendingRemove ) { <nl> + this . sounds . splice ( this . sounds . length - 1 - i ) ; <nl> + break ; <nl> + } <nl> + } <nl> this . sounds . forEach ( function ( sound ) { <nl> sound . update ( time , delta ) ; <nl> } ) ; <nl>\n", "msg": "Added docs for remove and removeByKey methods\n", "score": 1}
{"diff_id": 28133, "repo": "mozilla/pdf.js\n", "sha": "5c772329d8e5f558f1af9a8bca5f3f0945b8edca\n", "time": "2011-09-22T20:01:16Z\n", "diff": "mmm a / pdf . js <nl> ppp b / pdf . js <nl> var CanvasGraphics = ( function canvasGraphics ( ) { <nl> ctx . scale ( 1 / textHScale , 1 ) ; <nl> <nl> var width = 0 ; <nl> - for ( var i = 0 ; i < glyphs . length ; i + + ) { <nl> + var glyphsLength = glyphs . length ; <nl> + for ( var i = 0 ; i < glyphsLength ; + + i ) { <nl> var glyph = glyphs [ i ] ; <nl> if ( glyph = = = null ) { <nl> / / word break <nl> var CanvasGraphics = ( function canvasGraphics ( ) { <nl> } <nl> <nl> var unicode = glyph . unicode ; <nl> - var char = unicode > = 0x10000 ? <nl> + var char = ( unicode > = 0x10000 ) ? <nl> String . fromCharCode ( 0xD800 | ( ( unicode - 0x10000 ) > > 10 ) , <nl> 0xDC00 | ( unicode & 0x3FF ) ) : String . fromCharCode ( unicode ) ; <nl> <nl> - var charWidth = glyph . width * fontSize * 0 . 001 ; <nl> - charWidth + = charSpacing ; <nl> - <nl> ctx . fillText ( char , width , 0 ) ; <nl> - width + = charWidth ; <nl> + width + = glyph . width * fontSize * 0 . 001 + charSpacing ; <nl> } <nl> current . x + = width ; <nl> <nl> this . ctx . restore ( ) ; <nl> } , <nl> showSpacedText : function canvasGraphicsShowSpacedText ( arr ) { <nl> - for ( var i = 0 ; i < arr . length ; + + i ) { <nl> + var ctx = this . ctx ; <nl> + var current = this . current ; <nl> + var fontSize = current . fontSize ; <nl> + var textHScale = current . textHScale ; <nl> + var arrLength = arr . length ; <nl> + for ( var i = 0 ; i < arrLength ; + + i ) { <nl> var e = arr [ i ] ; <nl> if ( IsNum ( e ) ) { <nl> - if ( this . ctx . $ addCurrentX ) { <nl> - this . ctx . $ addCurrentX ( - e * 0 . 001 * this . current . fontSize ) ; <nl> + if ( ctx . $ addCurrentX ) { <nl> + ctx . $ addCurrentX ( - e * 0 . 001 * fontSize ) ; <nl> } else { <nl> - this . current . x - = e * 0 . 001 * this . current . fontSize * <nl> - this . current . textHScale ; <nl> + current . x - = e * 0 . 001 * fontSize * textHScale ; <nl> } <nl> } else if ( IsString ( e ) ) { <nl> this . showText ( e ) ; <nl> } else { <nl> - malformed ( ' TJ array element ' + e + \" isn ' t string or num \" ) ; <nl> + malformed ( ' TJ array element ' + e + ' is not string or num ' ) ; <nl> } <nl> } <nl> } , <nl>\n", "msg": "Make showText and showSpacedText slightly faster .\n", "score": 1}
{"diff_id": 28509, "repo": "Automattic/mongoose\n", "sha": "373bb6fe40cdd7d64ea58ffaa009aeb1efab1ac3\n", "time": "2017-05-18T14:24:45Z\n", "diff": "mmm a / lib / schema . js <nl> ppp b / lib / schema . js <nl> Schema . prototype . clone = function ( ) { <nl> s . methods = utils . clone ( this . methods ) ; <nl> s . statics = utils . clone ( this . statics ) ; <nl> s . _plugins = utils . clone ( this . _plugins ) ; <nl> + s . _indexes = utils . clone ( this . _indexes ) ; <nl> s . s . hooks = this . s . hooks . clone ( ) ; <nl> return s ; <nl> } ; <nl>\n", "msg": "Update clone method to include indexes\n", "score": 1}
{"diff_id": 28572, "repo": "meteor/meteor\n", "sha": "cf68cd755f1cc0fdaa153be06ed42e7ce4d36e80\n", "time": "2014-09-23T06:27:08Z\n", "diff": "mmm a / tools / compiler . js <nl> ppp b / tools / compiler . js <nl> var compileUnibuild = function ( unipkg , inputSourceArch , packageLoader , <nl> source : options . data , <nl> sourcePath : options . sourcePath , <nl> servePath : path . join ( inputSourceArch . pkg . serveRoot , options . path ) , <nl> - bare : ! ! options . bare , <nl> + bare : ! ! fileOptions . bare , <nl> sourceMap : options . sourceMap <nl> } ) ; <nl> } , <nl>\n", "msg": "Pass through ' bare ' option to compiled js source files\n", "score": 1}
{"diff_id": 28990, "repo": "emberjs/ember.js\n", "sha": "642637c9dbad1b7b33a5c0800ca6bb55a317c6cb\n", "time": "2012-04-25T21:11:24Z\n", "diff": "mmm a / packages / ember - states / lib / state_manager . js <nl> ppp b / packages / ember - states / lib / state_manager . js <nl> Ember . StateManager = Ember . State . extend ( <nl> <nl> var action = currentState [ event ] ; <nl> <nl> - if ( action ) { <nl> + / / Test to see if the action is a method that <nl> + / / can be invoked . Don ' t blindly check just for <nl> + / / existence , because it is possible the state <nl> + / / manager has a child state of the given name , <nl> + / / and we should still raise an exception in that <nl> + / / case . <nl> + if ( typeof action = = = ' function ' ) { <nl> if ( log ) { console . log ( fmt ( \" STATEMANAGER : Sending event ' % @ ' to state % @ . \" , [ event , get ( currentState , ' path ' ) ] ) ) ; } <nl> action . call ( currentState , this , context ) ; <nl> } else { <nl>\n", "msg": "Improve error when sending an unimplemented event\n", "score": 1}
{"diff_id": 29360, "repo": "lodash/lodash\n", "sha": "f57dadc3629a3319250a3589dd0bfb35794439c7\n", "time": "2015-06-26T13:59:16Z\n", "diff": "mmm a / test / test . js <nl> ppp b / test / test . js <nl> <nl> asyncTest ( ' _ . ' + methodName + ' supports recursive calls ' , 2 , function ( ) { <nl> if ( ! ( isRhino & & isModularize ) ) { <nl> var actual = [ ] , <nl> - args = _ . map ( [ ' a ' , ' b ' , ' c ' ] , function ( chr ) { return [ { ' a ' : 1 } , chr ] ; } ) , <nl> + args = _ . map ( [ ' a ' , ' b ' , ' c ' ] , function ( chr ) { return [ { } , chr ] ; } ) , <nl> expected = args . slice ( ) , <nl> queue = args . slice ( ) ; <nl> <nl> <nl> if ( next ) { <nl> funced . call ( next [ 0 ] , next [ 1 ] ) ; <nl> } <nl> - } , 64 ) ; <nl> + } , 32 ) ; <nl> <nl> var next = queue . shift ( ) ; <nl> funced . call ( next [ 0 ] , next [ 1 ] ) ; <nl> deepEqual ( actual , expected . slice ( 0 , isDebounce ? 0 : 1 ) ) ; <nl> <nl> setTimeout ( function ( ) { <nl> - deepEqual ( actual , expected . slice ( 0 , isDebounce ? 2 : 3 ) ) ; <nl> + deepEqual ( actual , expected . slice ( 0 , actual . length ) ) ; <nl> QUnit . start ( ) ; <nl> - } , 192 ) ; <nl> + } , 256 ) ; <nl> } <nl> else { <nl> skipTest ( 2 ) ; <nl>\n", "msg": "Adjust recursive test for older VMs .\n", "score": 1}
{"diff_id": 29383, "repo": "gatsbyjs/gatsby\n", "sha": "28e84f3aed480d1f5a8f9859172d1c6f531696d4\n", "time": "2016-11-03T01:20:59Z\n", "diff": "mmm a / lib / intermediate - representation - dir / production - app . js <nl> ppp b / lib / intermediate - representation - dir / production - app . js <nl> runtime . install ( { <nl> const rootElement = document . getElementById ( ` react - mount ` ) <nl> const rootRoute = require ( ` . / split - child - routes ` ) <nl> <nl> + / / If you try to load the split - child - routes module in other <nl> + / / modules , Webpack freezes in some sort of infinite loop when <nl> + / / you try to build the javascript for production . No idea <nl> + / / why . . . so for now we ' ll pop the routes on window . I hope no <nl> + / / one feels overly dirty from reading this ; - ) <nl> + if ( typeof window ! = = ' undefined ' ) { <nl> + window . gatsbyRootRoute = rootRoute <nl> + } <nl> + <nl> let currentLocation <nl> browserHistory . listen ( location = > { <nl> currentLocation = location <nl>\n", "msg": "Make routes module available to other modules\n", "score": 1}
{"diff_id": 29737, "repo": "balderdashy/sails\n", "sha": "fbcb3e88fd40c7e5b528061f98f82cf8aea33262\n", "time": "2012-07-30T15:24:30Z\n", "diff": "mmm a / lib / router . js <nl> ppp b / lib / router . js <nl> function processExpressRequest ( controllerName , actionName ) { <nl> <nl> / / Apply view middleware <nl> _ . each ( viewMiddleware , function ( middleware ) { <nl> - middleware ( res ) ; <nl> + middleware ( config , res ) ; <nl> } ) ; <nl> <nl> <nl>\n", "msg": "Passed in config to view middleware .\n", "score": 1}
{"diff_id": 30298, "repo": "gorhill/uBlock\n", "sha": "1888033070003cd5e6a3687a4029448bf41fccea\n", "time": "2019-05-20T17:46:36Z\n", "diff": "mmm a / src / js / static - net - filtering . js <nl> ppp b / src / js / static - net - filtering . js <nl> const typeNameToTypeValue = { <nl> ' webrtc ' : 19 < < 4 , <nl> ' unsupported ' : 20 < < 4 <nl> } ; <nl> + <nl> const otherTypeBitValue = typeNameToTypeValue . other ; <nl> <nl> + / / All network request types to bitmap <nl> + / / bring origin to 0 ( from 4 - - see typeNameToTypeValue ) <nl> + / / left - shift 1 by the above - calculated value <nl> + / / subtract 1 to set all type bits <nl> + const allNetworkTypesBits = <nl> + ( 1 < < ( otherTypeBitValue > > > 4 ) ) - 1 ; <nl> + <nl> + const allTypesBits = <nl> + allNetworkTypesBits | <nl> + 1 < < ( typeNameToTypeValue [ ' popup ' ] > > > 4 ) - 1 | <nl> + 1 < < ( typeNameToTypeValue [ ' main_frame ' ] > > > 4 ) - 1 | <nl> + 1 < < ( typeNameToTypeValue [ ' inline - font ' ] > > > 4 ) - 1 | <nl> + 1 < < ( typeNameToTypeValue [ ' inline - script ' ] > > > 4 ) - 1 ; <nl> + <nl> + const unsupportedTypeBit = <nl> + 1 < < ( typeNameToTypeValue [ ' unsupported ' ] > > > 4 ) - 1 ; <nl> + <nl> const typeValueToTypeName = { <nl> 1 : ' stylesheet ' , <nl> 2 : ' image ' , <nl> const FilterParser = function ( ) { <nl> this . reBadCSP = / ( ? : ^ | ; ) \\ s * report - ( ? : to | uri ) \\ b / ; <nl> this . domainOpt = ' ' ; <nl> this . noTokenHash = b . urlTokenizer . noTokenHash ; <nl> - this . unsupportedTypeBit = this . bitFromType ( ' unsupported ' ) ; <nl> - / / All network request types to bitmap <nl> - / / bring origin to 0 ( from 4 - - see typeNameToTypeValue ) <nl> - / / left - shift 1 by the above - calculated value <nl> - / / subtract 1 to set all type bits <nl> - this . allNetRequestTypeBits = ( 1 < < ( otherTypeBitValue > > > 4 ) ) - 1 ; <nl> this . reset ( ) ; <nl> } ; <nl> <nl> const FilterParser = function ( ) { <nl> / / Transpose ` ping ` into ` other ` for now . <nl> <nl> FilterParser . prototype . toNormalizedType = { <nl> + ' all ' : ' all ' , <nl> ' beacon ' : ' other ' , <nl> ' css ' : ' stylesheet ' , <nl> ' data ' : ' data ' , <nl> FilterParser . prototype . toNormalizedType = { <nl> ' xhr ' : ' xmlhttprequest ' , <nl> ' xmlhttprequest ' : ' xmlhttprequest ' , <nl> ' webrtc ' : ' unsupported ' , <nl> - ' websocket ' : ' websocket ' <nl> + ' websocket ' : ' websocket ' , <nl> } ; <nl> <nl> / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / <nl> FilterParser . prototype . bitFromType = function ( type ) { <nl> / / Be ready to handle multiple negated types <nl> <nl> FilterParser . prototype . parseTypeOption = function ( raw , not ) { <nl> - var typeBit = this . bitFromType ( this . toNormalizedType [ raw ] ) ; <nl> + const typeBit = raw ! = = ' all ' <nl> + ? this . bitFromType ( this . toNormalizedType [ raw ] ) <nl> + : allTypesBits ; <nl> <nl> if ( ! not ) { <nl> this . types | = typeBit ; <nl> return ; <nl> } <nl> <nl> - / / Non - discrete network types can ' t be negated . <nl> - if ( ( typeBit & this . allNetRequestTypeBits ) = = = 0 ) { <nl> + / / Non - network types can only toggle themselves . <nl> + if ( ( typeBit & allNetworkTypesBits ) = = = 0 ) { <nl> + this . types & = ~ typeBit ; <nl> return ; <nl> } <nl> <nl> - / / Negated type : set all valid network request type bits to 1 <nl> + / / Negated network type : the first negation imply all network types are <nl> + / / toggled on . <nl> if ( <nl> - ( typeBit & this . allNetRequestTypeBits ) ! = = 0 & & <nl> - ( this . types & this . allNetRequestTypeBits ) = = = 0 <nl> + ( typeBit & allNetworkTypesBits ) ! = = 0 & & <nl> + ( this . types & allNetworkTypesBits ) = = = 0 <nl> ) { <nl> - this . types | = this . allNetRequestTypeBits ; <nl> + this . types | = allNetworkTypesBits ; <nl> } <nl> this . types & = ~ typeBit ; <nl> } ; <nl> FilterParser . prototype . parse = function ( raw ) { <nl> / / https : / / github . com / gorhill / uBlock / issues / 2283 <nl> / / Abort if type is only for unsupported types , otherwise <nl> / / toggle off ` unsupported ` bit . <nl> - if ( this . types & this . unsupportedTypeBit ) { <nl> - this . types & = ~ this . unsupportedTypeBit ; <nl> + if ( this . types & unsupportedTypeBit ) { <nl> + this . types & = ~ unsupportedTypeBit ; <nl> if ( this . types = = = 0 ) { <nl> this . unsupported = true ; <nl> return this ; <nl> FilterContainer . prototype . compileToAtomicFilter = function ( <nl> return ; <nl> } <nl> <nl> + / / If all network types are set , just use ` no_type ` . <nl> + if ( ( type & allNetworkTypesBits ) = = = allNetworkTypesBits ) { <nl> + writer . push ( [ descBits , parsed . tokenHash , fdata ] ) ; <nl> + type & = ~ allNetworkTypesBits ; <nl> + } <nl> + <nl> / / Specific type ( s ) <nl> let bitOffset = 1 ; <nl> do { <nl> FilterContainer . prototype . compileToAtomicFilter = function ( <nl> / / Only static filter with an explicit type can be redirected . If we reach <nl> / / this point , it ' s because there is one or more explicit type . <nl> if ( parsed . redirect ) { <nl> - let redirects = b . redirectEngine . compileRuleFromStaticFilter ( parsed . raw ) ; <nl> + const redirects = b . redirectEngine . compileRuleFromStaticFilter ( parsed . raw ) ; <nl> if ( Array . isArray ( redirects ) ) { <nl> - for ( let redirect of redirects ) { <nl> + for ( const redirect of redirects ) { <nl> writer . push ( [ typeNameToTypeValue . redirect , redirect ] ) ; <nl> } <nl> } <nl>\n", "msg": "Add support for ` all ` filter option\n", "score": 1}
{"diff_id": 30376, "repo": "balderdashy/sails\n", "sha": "bf0289b430223c2dc0bb164d2f845ae7ccddcb1c\n", "time": "2013-09-15T00:00:34Z\n", "diff": "mmm a / bin / sails . js <nl> ppp b / bin / sails . js <nl> require ( ' . . / lib / configuration ' ) ( sails ) . load ( function ( err ) { <nl> <nl> <nl> / / Start this app <nl> - if ( argv . _ [ 0 ] & & _ . contains ( [ ' lift ' , ' raise ' , ' launch ' , ' start ' , ' server ' , ' run ' , ' s ' , ' l ' ] , argv . _ [ 0 ] ) ) { <nl> + if ( argv . _ [ 0 ] & & _ . contains ( [ ' lift ' , ' raise ' , ' start ' , ' server ' , ' s ' , ' l ' ] , argv . _ [ 0 ] ) ) { <nl> <nl> require ( ' . / lift . js ' ) ( sails ) ( argv ) ; <nl> } <nl> require ( ' . . / lib / configuration ' ) ( sails ) . load ( function ( err ) { <nl> * Usage : sails issue < foo > <nl> *  where < foo > is exported from < sails . config . appPath > / commands <nl> * / <nl> - else if ( argv . _ [ 0 ] . match ( / ^ issue $ / ) ) { <nl> + else if ( argv . _ [ 0 ] . match ( / ^ ( issue | run ) $ / ) ) { <nl> <nl> - verifyArg ( 1 , ' Please specity the name of the command to run : e . g . \\ n sails issue < command > ' ) ; <nl> + verifyArg ( 1 , ' Please specify the name of the command to run : e . g . \\ n sails run < command > ' ) ; <nl> <nl> var command = argv . _ [ 1 ] , <nl> commands ; <nl> require ( ' . . / lib / configuration ' ) ( sails ) . load ( function ( err ) { <nl> } <nl> <nl> var usage = ' Usage : sails < command > \\ n \\ n ' ; <nl> - usage + = leftColumn ( ' sails lift ' ) + ' Run this Sails app ( in the current dir ) \\ n ' ; <nl> + usage + = leftColumn ( ' sails lift ' ) + ' Run the Sails app in the current dir ( if node_modules / sails exists , it will be used instead of the global install ) \\ n ' ; <nl> usage + = leftColumn ( ' [ - - dev ] ' ) + ' in development environment \\ n ' ; <nl> usage + = leftColumn ( ' [ - - prod ] ' ) + ' in production environment \\ n ' ; <nl> usage + = leftColumn ( ' [ - - port 9000 ] ' ) + ' on port 9000 \\ n ' ; <nl> require ( ' . . / lib / configuration ' ) ( sails ) . load ( function ( err ) { <nl> usage + = leftColumn ( ' sails generate model < foo > ' ) + ' Generate api / models / Foo . js \\ n ' ; <nl> usage + = leftColumn ( ' sails generate controller < foo > ' ) + ' Generate api / controllers / FooController . js \\ n ' ; <nl> usage + = leftColumn ( ' sails version ' ) + ' Get the current globally installed Sails version \\ n ' ; <nl> - usage + = leftColumn ( ' sails issue < command > ' ) + ' Run a management command ( exported by commands / index . js ) ' ; <nl> + usage + = leftColumn ( ' sails run < command > ' ) + ' Run a management command ( exported by YOUR_APP / commands / index . js ) ' ; <nl> <nl> sails . log . info ( usage ) ; <nl> } <nl>\n", "msg": "Removed run synonym for lift and replaced issue with run re related PR\n", "score": 1}
{"diff_id": 30513, "repo": "Leaflet/Leaflet\n", "sha": "9e5903db405319e462f2d813d0908b2f39493f13\n", "time": "2016-12-21T23:36:58Z\n", "diff": "mmm a / src / map / Map . js <nl> ppp b / src / map / Map . js <nl> L . Map = L . Evented . extend ( { <nl> getSize : function ( ) { <nl> if ( ! this . _size | | this . _sizeChanged ) { <nl> this . _size = new L . Point ( <nl> - this . _container . clientWidth , <nl> - this . _container . clientHeight ) ; <nl> + this . _container . clientWidth | | 0 , <nl> + this . _container . clientHeight | | 0 ) ; <nl> <nl> this . _sizeChanged = false ; <nl> } <nl>\n", "msg": "adds graceful fallback to clientWidth & clinetHeight in getSize ( )\n", "score": 1}
{"diff_id": 30564, "repo": "TryGhost/Ghost\n", "sha": "706d47fb5b9d102dbbcd55e92e2824c96a6652f5\n", "time": "2016-06-18T17:35:51Z\n", "diff": "mmm a / Gruntfile . js <nl> ppp b / Gruntfile . js <nl> var _ = require ( ' lodash ' ) , <nl> ember : { <nl> command : function ( mode ) { <nl> switch ( mode ) { <nl> - case ' init ' : <nl> - return ' echo Installing client dependencies . . . & & npm install & & bower install ' ; <nl> - <nl> case ' prod ' : <nl> return emberPath + ' build - - environment = production - - silent ' ; <nl> <nl> var _ = require ( ' lodash ' ) , <nl> / / # # # grunt - subgrunt <nl> / / Run grunt tasks in submodule Gruntfiles <nl> subgrunt : { <nl> + init : { <nl> + ' core / client ' : ' init ' <nl> + } , <nl> + <nl> lint : { <nl> ' core / client ' : ' lint ' <nl> } <nl> var _ = require ( ' lodash ' ) , <nl> / / ` bower ` does have some quirks , such as not running as root . If you have problems please try running <nl> / / ` grunt init - - verbose ` to see if there are any errors . <nl> grunt . registerTask ( ' init ' , ' Prepare the project for development ' , <nl> - [ ' update_submodules ' , ' shell : ember : init ' , ' assets ' , ' default ' ] ) ; <nl> + [ ' update_submodules ' , ' subgrunt : init ' , ' assets ' , ' default ' ] ) ; <nl> <nl> / / # # # Basic Asset Building <nl> / / Builds and moves necessary client assets . Prod additionally builds the ember app . <nl>\n", "msg": "Use subgrunt to install client dependencies\n", "score": 1}
{"diff_id": 30922, "repo": "Automattic/mongoose\n", "sha": "a5c4fb0a3cfc94325d18d7c5eeb45b3c84234f32\n", "time": "2020-02-03T21:31:20Z\n", "diff": "mmm a / test / schematype . test . js <nl> ppp b / test / schematype . test . js <nl> describe ( ' schematype ' , function ( ) { <nl> const schema = new mongoose . Schema ( { test : type } ) ; <nl> <nl> / / Assert <nl> - assert . equal ( schema . path ( ' test ' ) . options . required , true ) ; <nl> + assert . equal ( schema . path ( ' test ' ) . options . someRandomOption , true ) ; <nl> } ) ; <nl> } ) ; <nl> } ) ; <nl>\n", "msg": "Use a fake option for testing\n", "score": 1}
{"diff_id": 31053, "repo": "meteor/meteor\n", "sha": "e1a7c2ff465aed7216651586f83aa38fd0155f10\n", "time": "2012-09-20T14:33:08Z\n", "diff": "mmm a / packages / absolute - url / package . js <nl> ppp b / packages / absolute - url / package . js <nl> <nl> Package . describe ( { <nl> - summary : \" DEPRECATED : Generate absolute URLs pointing to the application \" <nl> + summary : \" DEPRECATED : Generate absolute URLs pointing to the application \" , <nl> + internal : true <nl> } ) ; <nl> <nl> Package . on_use ( function ( api ) { <nl> console . log ( ' DEPRECATED . The ` absolute - url ` package has been folded into ' <nl> - + ' the ` meteor ` package and should not be used directly . ' ) ; <nl> + + ' the ` meteor ` package and should not be used directly . Run ' <nl> + + ' ` meteor remove absolute - url ` to resolve this . ' ) ; <nl> } ) ; <nl>\n", "msg": "Minor changes to deprecated absolute - url package based on code review comments\n", "score": 1}
{"diff_id": 31433, "repo": "atom/atom\n", "sha": "77fd29647a6f756a668268551fd11bc88600be60\n", "time": "2017-12-06T01:01:49Z\n", "diff": "mmm a / src / tree - sitter - language - mode . js <nl> ppp b / src / tree - sitter - language - mode . js <nl> class TreeSitterLanguageMode { <nl> } <nl> <nl> bufferDidChange ( { oldRange , newRange , oldText , newText } ) { <nl> - this . isFoldableCache . length = 0 <nl> + const startRow = oldRange . start . row <nl> + const oldEndRow = oldRange . end . row <nl> + const newEndRow = newRange . end . row <nl> + this . isFoldableCache . splice ( startRow , oldEndRow - startRow , . . . new Array ( newEndRow - startRow ) ) <nl> this . document . edit ( { <nl> startIndex : this . buffer . characterIndexForPosition ( oldRange . start ) , <nl> lengthRemoved : oldText . length , <nl> class TreeSitterLanguageMode { <nl> buildHighlightIterator ( ) { <nl> const invalidatedRanges = this . document . parse ( ) <nl> for ( let i = 0 , n = invalidatedRanges . length ; i < n ; i + + ) { <nl> - this . emitter . emit ( ' did - change - highlighting ' , invalidatedRanges [ i ] ) <nl> + const range = invalidatedRanges [ i ] <nl> + const startRow = range . start . row <nl> + const endRow = range . end . row <nl> + for ( let row = startRow ; row < endRow ; row + + ) { <nl> + this . isFoldableCache [ row ] = undefined <nl> + } <nl> + this . emitter . emit ( ' did - change - highlighting ' , range ) <nl> } <nl> return new TreeSitterHighlightIterator ( this ) <nl> } <nl>\n", "msg": "Cache foldability more intelligently\n", "score": 1}
{"diff_id": 32723, "repo": "preactjs/preact\n", "sha": "95c2d684fca960aaba0690eda576fab60c54b978\n", "time": "2019-03-08T20:12:47Z\n", "diff": "mmm a / hooks / src / index . js <nl> ppp b / hooks / src / index . js <nl> function scheduleFlushAfterPaint ( ) { <nl> setTimeout ( flushAfterPaintEffects , 0 ) ; <nl> } <nl> <nl> - export function act ( cb ) { <nl> + export function setupRerender ( ) { <nl> Component . __test__previousDebounce = options . debounceRendering ; <nl> options . debounceRendering = cb = > Component . __test__drainQueue = cb ; <nl> + <nl> + return ( ) = > Component . __test__drainQueue & & Component . __test__drainQueue ( ) ; <nl> + } <nl> + <nl> + export function act ( cb ) { <nl> + const rerender = setupRerender ( ) ; <nl> options . afterPaint = ( fc ) = > fc ( ) ; <nl> cb ( ) ; <nl> + rerender ( ) ; <nl> + options . afterPaint = undefined ; <nl> } <nl> <nl> if ( typeof window ! = = ' undefined ' ) { <nl>\n", "msg": "use rerender from exissting test package\n", "score": 1}
{"diff_id": 32883, "repo": "alvarotrigo/fullPage.js\n", "sha": "1157da6b12adc58ad007078db32372e049b51907\n", "time": "2016-10-17T11:22:21Z\n", "diff": "mmm a / jquery . fullPage . js <nl> ppp b / jquery . fullPage . js <nl> <nl> loopTop : false , <nl> loopHorizontal : true , <nl> continuousVertical : false , <nl> - continuousHorizontal : true , <nl> + continuousHorizontal : false , <nl> scrollHorizontally : false , <nl> interlockedSlides : false , <nl> resetSliders : false , <nl> <nl> extensions . forEach ( function ( extension ) { <nl> / / is the option set to true ? <nl> if ( options [ extension ] ) { <nl> - showError ( ' warn ' , ' fullpage . js extensions require jquery . fullpage . extensions . min . js file instead of the usual jquery . fullpage . js ' ) ; <nl> + showError ( ' warn ' , ' fullpage . js extensions require jquery . fullpage . extensions . min . js file instead of the usual jquery . fullpage . js . Requested : ' + extension ) ; <nl> } <nl> } ) ; <nl> <nl>\n", "msg": "continuousHorizontal default set to false . Extension warning made clearer .\n", "score": 1}
{"diff_id": 32999, "repo": "RocketChat/Rocket.Chat\n", "sha": "d516cea8e46f377d3b1125269f2e059337a5bc9b\n", "time": "2016-11-07T11:50:25Z\n", "diff": "mmm a / packages / rocketchat - file - upload / lib / FileUpload . js <nl> ppp b / packages / rocketchat - file - upload / lib / FileUpload . js <nl> FileUpload = { <nl> return false ; <nl> } <nl> <nl> - if ( file . size > maxFileSize ) { <nl> - const reason = TAPi18n . __ ( ' File_exceeds_allowed_size_of_bytes ' , { <nl> - size : filesize ( maxFileSize ) <nl> - } , user . language ) ; <nl> - throw new Meteor . Error ( ' error - file - too - large ' , reason ) ; <nl> + if ( maxFileSize ! = = - 1 ) { <nl> + if ( file . size > maxFileSize ) { <nl> + const reason = TAPi18n . __ ( ' File_exceeds_allowed_size_of_bytes ' , { <nl> + size : filesize ( maxFileSize ) <nl> + } , user . language ) ; <nl> + throw new Meteor . Error ( ' error - file - too - large ' , reason ) ; <nl> + } <nl> } <nl> <nl> if ( ! RocketChat . fileUploadIsValidContentType ( file . type ) ) { <nl>\n", "msg": "added option to remove the filesize restriction\n", "score": 1}
{"diff_id": 34051, "repo": "facebook/react-native\n", "sha": "c6020a0ef4880bead15a0ed2f4058a70cc9b6ad5\n", "time": "2016-06-18T15:58:20Z\n", "diff": "mmm a / Libraries / PushNotificationIOS / PushNotificationIOS . js <nl> ppp b / Libraries / PushNotificationIOS / PushNotificationIOS . js <nl> const DEVICE_LOCAL_NOTIF_EVENT = ' localNotificationReceived ' ; <nl> * { <nl> * [ RCTPushNotificationManager didReceiveLocalNotification : notification ] ; <nl> * } <nl> + * - ( void ) application : ( UIApplication * ) application didFailToRegisterForRemoteNotificationsWithError : ( NSError * ) error <nl> + * { <nl> + * NSLog ( @ \" % @ \" , error ) ; <nl> + * } <nl> * ` ` ` <nl> * / <nl> class PushNotificationIOS { <nl>\n", "msg": "Added logging to push registration failure .\n", "score": 1}
{"diff_id": 34616, "repo": "meteor/meteor\n", "sha": "dc0563c620701f88f08310486d056407d191e832\n", "time": "2014-10-22T19:25:29Z\n", "diff": "mmm a / tools / commands - cordova . js <nl> ppp b / tools / commands - cordova . js <nl> var installPlugin = function ( cordovaPath , name , version , conf ) { <nl> <nl> _ . each ( conf | | { } , function ( value , variable ) { <nl> additionalArgs . push ( ' - - variable ' ) ; <nl> - additionalArgs . push ( variable + ' = ' + JSON . stringify ( value ) ) ; <nl> + additionalArgs . push ( variable + ' = \\ ' ' + value + ' \\ ' ' ) ; <nl> } ) ; <nl> <nl> var execRes = execFileSyncOrThrow ( localCordova , <nl>\n", "msg": "Properly escape command line arguments for cordova plugins\n", "score": 1}
{"diff_id": 34681, "repo": "RocketChat/Rocket.Chat\n", "sha": "1b5cff124bdd816edc6d4808b28ebd341cdbd26f\n", "time": "2020-04-01T16:36:50Z\n", "diff": "mmm a / app / models / server / models / Users . js <nl> ppp b / app / models / server / models / Users . js <nl> export class Users extends Base { <nl> this . tryEnsureIndex ( { statusText : 1 } ) ; <nl> this . tryEnsureIndex ( { active : 1 } , { sparse : 1 } ) ; <nl> this . tryEnsureIndex ( { statusConnection : 1 } , { sparse : 1 } ) ; <nl> + this . tryEnsureIndex ( { appId : 1 } , { sparse : 1 } ) ; <nl> this . tryEnsureIndex ( { type : 1 } ) ; <nl> this . tryEnsureIndex ( { ' visitorEmails . address ' : 1 } ) ; <nl> this . tryEnsureIndex ( { federation : 1 } , { sparse : true } ) ; <nl>\n", "msg": "Add User  s index for field ` appId ` ( )\n", "score": 1}
{"diff_id": 34901, "repo": "emberjs/ember.js\n", "sha": "6b3c05da9c5a8032fc00a5585a3d83daea26eb77\n", "time": "2012-06-03T21:42:37Z\n", "diff": "mmm a / packages / ember - states / lib / state_manager . js <nl> ppp b / packages / ember - states / lib / state_manager . js <nl> require ( ' ember - states / state ' ) ; <nl> <nl> / * * <nl> @ class <nl> - <nl> + <nl> StateManager is part of Ember ' s implementation of a finite state machine . A StateManager <nl> instance manages a number of properties that are instances of ` Ember . State ` , <nl> tracks the current active state , and triggers callbacks when states have changed . <nl> require ( ' ember - states / state ' ) ; <nl> <nl> # # The Initial State <nl> When created a StateManager instance will immediately enter into the state <nl> - defined as its ` start ` property or the state referenced by name in its <nl> + defined as its ` start ` property or the state referenced by name in its <nl> ` initialState ` property : <nl> <nl> managerA = Ember . StateManager . create ( { <nl> require ( ' ember - states / state ' ) ; <nl> robotManager . getPath ( ' currentState . name ' ) / / ' poweredUp ' <nl> <nl> Before transitioning into a new state the existing ` currentState ` will have its <nl> - ` exit ` method called with the StateManager instance as its first argument and <nl> + ` exit ` method called with the StateManager instance as its first argument and <nl> an object representing the transition as its second argument . <nl> <nl> After transitioning into a new state the new ` currentState ` will have its <nl> - ` enter ` method called with the StateManager instance as its first argument and <nl> + ` enter ` method called with the StateManager instance as its first argument and <nl> an object representing the transition as its second argument . <nl> <nl> robotManager = Ember . StateManager . create ( { <nl> require ( ' ember - states / state ' ) ; <nl> <nl> <nl> Once a StateManager is already in a state , subsequent attempts to enter that state will <nl> - not trigger enter or exit method calls . Attempts to transition into a state that the <nl> + not trigger enter or exit method calls . Attempts to transition into a state that the <nl> manager does not have will result in no changes in the StateManager ' s current state : <nl> <nl> robotManager = Ember . StateManager . create ( { <nl> require ( ' ember - states / state ' ) ; <nl> robotManager . getPath ( ' currentState . name ' ) / / ' poweredUp ' <nl> <nl> <nl> - Each state property may itself contain properties that are instances of Ember . State . <nl> - The StateManager can transition to specific sub - states in a series of transitionTo method calls or <nl> - via a single transitionTo with the full path to the specific state . The StateManager will also <nl> + Each state property may itself contain properties that are instances of Ember . State . <nl> + The StateManager can transition to specific sub - states in a series of goToState method calls or <nl> + via a single transitionTo with the full path to the specific state . The StateManager will also <nl> keep track of the full path to its currentState <nl> <nl> robotManager = Ember . StateManager . create ( { <nl> require ( ' ember - states / state ' ) ; <nl> can receive and route action messages to its states via the ` send ` method . Calling to ` send ` with <nl> an action name will begin searching for a method with the same name starting at the current state <nl> and moving up through the parent states in a state hierarchy until an appropriate method is found <nl> - or the StateManager instance itself is reached . <nl> + or the StateManager instance itself is reached . <nl> <nl> If an appropriately named method is found it will be called with the state manager as the first <nl> argument and an optional ` context ` object as the second argument . <nl> require ( ' ember - states / state ' ) ; <nl> robotManager . send ( ' beginExtermination ' , allHumans ) <nl> robotManager . getPath ( ' currentState . name ' ) / / ' rampaging ' <nl> <nl> + # # Async transitions <nl> + When a state ' s ` enter ` and ` exit ` methods are called they passed a argument representing <nl> + the transition . By calling ` async ( ) ` and ` resume ( ) ` on the transition object , the <nl> + transition can be delayed . This can be useful to account for an animation between states . <nl> + <nl> + robotManager = Ember . StateManager . create ( { <nl> + poweredUp : Ember . State . create ( { <nl> + exit : function ( stateManager , transition ) { <nl> + console . log ( \" beginning exit of the poweredUp state \" ) ; <nl> + transition . async ( ) ; <nl> + asyncStartShutdownDanceMoves ( ) . done ( function ( ) { <nl> + console . log ( \" completing exit of the poweredUp state \" ) ; <nl> + transition . resume ( ) ; <nl> + } ) ; <nl> + } <nl> + } ) ; <nl> + } ) ; <nl> + <nl> * * / <nl> Ember . StateManager = Ember . State . extend ( <nl> / * * @ scope Ember . StateManager . prototype * / { <nl> Ember . StateManager = Ember . State . extend ( <nl> Ember . assert ( ' Failed to transition to initial state \" ' + initialState + ' \" ' , get ( this , ' currentState ' ) ) ; <nl> } <nl> } , <nl> - <nl> + <nl> / * * <nl> The current state from among the manager ' s possible states . This property should <nl> not be set directly . Use ` transitionTo ` to move between states by name . <nl> - <nl> + <nl> @ property { Ember . State } <nl> @ readOnly <nl> * / <nl>\n", "msg": "Add API docs to StateManager for async transtitions\n", "score": 1}
{"diff_id": 34959, "repo": "lodash/lodash\n", "sha": "54f5ac7b8de57a8c55c08d92f3d308882aff8efa\n", "time": "2016-09-06T15:04:38Z\n", "diff": "mmm a / lib / main / build - site . js <nl> ppp b / lib / main / build - site . js <nl> function tidyHighlights ( $ ) { <nl> } ) ; <nl> / / Collapse nested highlights . <nl> _ . each ( [ ' comment ' , ' string ' ] , cls = > { <nl> - $ parent . find ( ` [ class ~ = \" $ { cls } \" ] > [ class ~ = \" $ { cls } \" ] ` ) . each ( function ( ) { <nl> - const $ parent = $ ( this ) . parent ( ) ; <nl> - $ parent . text ( $ parent . text ( ) ) ; <nl> + $ parent . find ( ` [ class ~ = \" $ { cls } \" ] ` ) . each ( function ( ) { <nl> + const $ element = $ ( this ) ; <nl> + $ element . text ( $ element . text ( ) ) ; <nl> } ) ; <nl> } ) ; <nl> / / Collapse nested spans . <nl>\n", "msg": "Simplify nested highlights selector .\n", "score": 1}
{"diff_id": 35077, "repo": "lodash/lodash\n", "sha": "a0c91b87544522edb521fd7ab5f8b1984c4a0781\n", "time": "2012-10-21T01:55:28Z\n", "diff": "mmm a / build / pre - compile . js <nl> ppp b / build / pre - compile . js <nl> <nl> ' bind ' , <nl> ' bindAll ' , <nl> ' chain ' , <nl> - ' clearTimeout ' , <nl> ' clone ' , <nl> ' collect ' , <nl> ' compact ' , <nl> <nl> ' rest ' , <nl> ' result ' , <nl> ' select ' , <nl> - ' setTimeout ' , <nl> ' shuffle ' , <nl> ' size ' , <nl> ' some ' , <nl>\n", "msg": "Remove ` clearTimeout ` and ` setTimeout ` from the list of properties to escape in pre - compile . js .\n", "score": 1}
{"diff_id": 35524, "repo": "adobe/brackets\n", "sha": "232ee9bb0e255f75b4778e3b74113e5dce814059\n", "time": "2013-04-24T14:16:19Z\n", "diff": "mmm a / src / extensions / default / JavaScriptCodeHints / main . js <nl> ppp b / src / extensions / default / JavaScriptCodeHints / main . js <nl> define ( function ( require , exports , module ) { <nl> scopeResponse . promise . done ( function ( ) { <nl> cachedLine = cursor . line ; <nl> cachedType = session . getType ( ) ; <nl> - matcher = new StringMatch . StringMatcher ( ) ; <nl> + matcher = new StringMatch . StringMatcher ( { <nl> + preferPrefixMatches : true <nl> + } ) ; <nl> cachedHints = session . getHints ( query , matcher ) ; <nl> <nl> if ( $ deferredHints . state ( ) = = = \" pending \" ) { <nl>\n", "msg": "Turn on preferPrefixMatches for JS code hints .\n", "score": 1}
{"diff_id": 35890, "repo": "meteor/meteor\n", "sha": "6247309daa0af96362aec5f9a93fcdec28c9f0bf\n", "time": "2015-07-17T20:29:25Z\n", "diff": "mmm a / tools / isobuild / package - source . js <nl> ppp b / tools / isobuild / package - source . js <nl> _ . extend ( PackageSource . prototype , { <nl> * @ param { String } options . documentation Optional Filepath to <nl> * documentation . Set to ' README . md ' by default . Set this to null to submit <nl> * no documentation . <nl> + * @ param { String } options . debugOnly A package with this flag set to true <nl> + * will not be bundled into production builds . This is useful for packages <nl> + * meant to be used in development only . <nl> * / <nl> describe : function ( options ) { <nl> _ . each ( options , function ( value , key ) { <nl>\n", "msg": "Document debugOnly option for Package . describe .\n", "score": 1}
{"diff_id": 35954, "repo": "transloadit/uppy\n", "sha": "f3a4deb7f511d70706725d236548a17db4673617\n", "time": "2020-09-26T12:28:16Z\n", "diff": "mmm a / packages / @ uppy / provider - views / src / index . js <nl> ppp b / packages / @ uppy / provider - views / src / index . js <nl> module . exports = class ProviderView { <nl> res . items . forEach ( ( item ) = > { <nl> if ( ! item . isFolder ) { <nl> files . push ( item ) <nl> + } else { <nl> + this . addFolder ( item ) <nl> } <nl> } ) <nl> const moreFiles = res . nextPagePath | | null <nl>\n", "msg": "Add support for uploading nested folders ( )\n", "score": 1}
{"diff_id": 36825, "repo": "hakimel/reveal.js\n", "sha": "b6030d5c7a83436e333719700f64909569c97062\n", "time": "2012-03-19T22:20:40Z\n", "diff": "mmm a / js / reveal . js <nl> ppp b / js / reveal . js <nl> var Reveal = ( function ( ) { <nl> / / instead of checking contentEditable ? <nl> <nl> if ( event . target . contentEditable = = = ' inherit ' ) { <nl> - if ( event . keyCode > = 37 & & event . keyCode < = 40 ) { <nl> + if ( event . keyCode > = 33 & & event . keyCode < = 40 ) { <nl> <nl> switch ( event . keyCode ) { <nl> + case 33 : navigateLeft ( ) ; break ; / / left for wireless presenter <nl> + case 34 : navigateRight ( ) ; break ; / / right for wireless presenter <nl> case 37 : navigateLeft ( ) ; break ; / / left <nl> case 39 : navigateRight ( ) ; break ; / / right <nl> case 38 : navigateUp ( ) ; break ; / / up <nl>\n", "msg": "added support for wireless presenter\n", "score": 1}
{"diff_id": 36974, "repo": "codemirror/CodeMirror\n", "sha": "c75344a8da55ba2cde3d4c790e6dd99b73093df2\n", "time": "2011-12-12T11:37:19Z\n", "diff": "mmm a / lib / codemirror . js <nl> ppp b / lib / codemirror . js <nl> var CodeMirror = ( function ( ) { <nl> doc . iter ( from . line , to . line , function ( line ) { <nl> if ( line . text . length = = maxLineLength ) { recomputeMaxLength = true ; return true ; } <nl> } ) ; <nl> + if ( from . line ! = to . line | | newText . length > 1 ) gutterDirty = true ; <nl> <nl> var nlines = to . line - from . line , firstLine = getLine ( from . line ) , lastLine = getLine ( to . line ) ; <nl> / / First adjust the line structure , taking some care to leave highlighting intact . <nl>\n", "msg": "Always refresh the gutter when a change was made that crosses line bounds\n", "score": 1}
{"diff_id": 37228, "repo": "meteor/meteor\n", "sha": "bee3112a63d0f0c9d034e1ec0b368460a396d1e8\n", "time": "2016-07-12T15:41:27Z\n", "diff": "mmm a / tools / cli / dev - bundle - links . js <nl> ppp b / tools / cli / dev - bundle - links . js <nl> exports . makeLink = function ( target , linkPath ) { <nl> fs . writeFileSync ( tempPath , target , \" utf8 \" ) ; <nl> } <nl> <nl> - fs . renameSync ( tempPath , linkPath ) ; <nl> + try { <nl> + fs . renameSync ( tempPath , linkPath ) ; <nl> + } catch ( e ) { <nl> + / / If renaming fails , try unlinking first . <nl> + fs . unlinkSync ( linkPath ) ; <nl> + fs . renameSync ( tempPath , linkPath ) ; <nl> + } <nl> } ; <nl> <nl> exports . readLink = function ( linkPath ) { <nl>\n", "msg": "Try harder to create . meteor / dev_bundle symlink .\n", "score": 1}
{"diff_id": 37403, "repo": "nolimits4web/swiper\n", "sha": "d474e98c4fef44da8d493a46daebdd5ff193a440\n", "time": "2017-12-13T14:16:44Z\n", "diff": "mmm a / src / components / autoplay / autoplay . js <nl> ppp b / src / components / autoplay / autoplay . js <nl> const Autoplay = { <nl> delay = $ activeSlideEl . attr ( ' data - swiper - autoplay ' ) | | swiper . params . autoplay . delay ; <nl> } <nl> swiper . autoplay . timeout = Utils . nextTick ( ( ) = > { <nl> - if ( swiper . params . loop ) { <nl> + if ( swiper . params . autoplay . reverseDirection ) { <nl> + if ( swiper . params . loop ) { <nl> + swiper . loopFix ( ) ; <nl> + swiper . slidePrev ( swiper . params . speed , true , true ) ; <nl> + swiper . emit ( ' autoplay ' ) ; <nl> + } else if ( ! swiper . isBeginning ) { <nl> + swiper . slidePrev ( swiper . params . speed , true , true ) ; <nl> + swiper . emit ( ' autoplay ' ) ; <nl> + } else if ( ! swiper . params . autoplay . stopOnLastSlide ) { <nl> + swiper . slideTo ( swiper . slides . length - 1 , swiper . params . speed , true , true ) ; <nl> + swiper . emit ( ' autoplay ' ) ; <nl> + } else { <nl> + swiper . autoplay . stop ( ) ; <nl> + } <nl> + } else if ( swiper . params . loop ) { <nl> swiper . loopFix ( ) ; <nl> swiper . slideNext ( swiper . params . speed , true , true ) ; <nl> swiper . emit ( ' autoplay ' ) ; <nl> export default { <nl> delay : 3000 , <nl> disableOnInteraction : true , <nl> stopOnLastSlide : false , <nl> + reverseDirection : false , <nl> } , <nl> } , <nl> create ( ) { <nl>\n", "msg": "Added support for reverse autoplay .\n", "score": 1}
{"diff_id": 37520, "repo": "serverless/serverless\n", "sha": "555aa6d1038c11514411a8868cd2645032cedd9b\n", "time": "2016-10-21T12:55:42Z\n", "diff": "mmm a / tests / integration / simple - integration - test . js <nl> ppp b / tests / integration / simple - integration - test . js <nl> describe ( ' Service Lifecyle Integration Test ' , ( ) = > { <nl> expect ( result . message ) . to . be . equal ( ' Service Update Succeeded ' ) ; <nl> } ) ; <nl> <nl> + it ( ' should list existing deployments and roll back to first deployment ' , function ( ) { <nl> + this . timeout ( 0 ) ; <nl> + let timestamp ; <nl> + const listDeploys = execSync ( ` $ { serverlessExec } deploy list ` ) ; <nl> + const output = listDeploys . toString ( ) ; <nl> + const match = output . match ( new RegExp ( ' Timestamp : ( . + ) ' ) ) ; <nl> + if ( match ) { <nl> + timestamp = match [ 1 ] ; <nl> + } <nl> + / / eslint - disable - next - line no - unused - expressions <nl> + expect ( timestamp ) . to . not . undefined ; <nl> + <nl> + execSync ( ` $ { serverlessExec } rollback - t $ { timestamp } ` ) ; <nl> + <nl> + const invoked = execSync ( ` $ { serverlessExec } invoke - - function hello - - noGreeting true ` ) ; <nl> + const result = JSON . parse ( new Buffer ( invoked , ' base64 ' ) . toString ( ) ) ; <nl> + / / parse it once again because the body is stringified to be LAMBDA - PROXY ready <nl> + const message = JSON . parse ( result . body ) . message ; <nl> + expect ( message ) . to . be . equal ( ' Go Serverless v1 . 0 ! Your function executed successfully ! ' ) ; <nl> + } ) ; <nl> + <nl> it ( ' should remove service from aws ' , function ( ) { <nl> this . timeout ( 0 ) ; <nl> execSync ( ` $ { serverlessExec } remove ` , { stdio : ' inherit ' } ) ; <nl>\n", "msg": "add rollback to simple integration test\n", "score": 1}
{"diff_id": 37522, "repo": "Automattic/mongoose\n", "sha": "67be49cd27d9d2cfab514533a90b9fb28265dd35\n", "time": "2011-01-07T00:11:11Z\n", "diff": "mmm a / lib / mongoose / schema / index . js <nl> ppp b / lib / mongoose / schema / index . js <nl> <nl> <nl> / * * <nl> * Module exports . <nl> - * <nl> * / <nl> <nl> - exports . object = require ( ' . / object ' ) ; <nl> - exports . string = require ( ' . / string ' ) ; <nl> - exports . number = require ( ' . / number ' ) ; <nl> - exports . array = require ( ' . / array ' ) ; <nl> - exports . oid = require ( ' . / objectid ' ) ; <nl> - exports . email = require ( ' . / email ' ) ; <nl> - exports . document = require ( ' . / document ' ) ; <nl> + exports . Object = require ( ' . / object ' ) ; <nl> + exports . String = require ( ' . / string ' ) ; <nl> + exports . Number = require ( ' . / number ' ) ; <nl> + exports . Array = require ( ' . / array ' ) ; <nl> + exports . ObjectId = require ( ' . / objectid ' ) ; <nl> + exports . DocumentArray = require ( ' . / documentarray ' ) ; <nl>\n", "msg": "Fixed exports for / schema / namespace\n", "score": 1}
{"diff_id": 37595, "repo": "ajaxorg/ace\n", "sha": "9654382294dce7bdde7fcbe70e6f2f2613662d3a\n", "time": "2015-02-24T16:02:06Z\n", "diff": "mmm a / lib / ace / mode / lean_highlight_rules . js <nl> ppp b / lib / ace / mode / lean_highlight_rules . js <nl> var leanHighlightRules = function ( ) { <nl> regex : \" \\ \\ s + \" <nl> } <nl> ] , <nl> - \" comment \" : [ <nl> - { <nl> - token : \" comment \" , / / closing comment <nl> - regex : \" . * ? - \\ \\ / \" , <nl> - next : \" start \" <nl> - } , { <nl> - token : \" comment \" , / / comment spanning whole line <nl> - regex : \" . + \" <nl> - } <nl> - ] , <nl> - \" qqstring \" : [ <nl> - { <nl> - token : \" string \" , <nl> - regex : ' ( ? : ( ? : \\ \\ \\ \\ . ) | ( ? : [ ^ \" \\ \\ \\ \\ ] ) ) * ? \" ' , <nl> - next : \" start \" <nl> - } , { <nl> - token : \" string \" , <nl> - regex : ' . + ' <nl> - } <nl> - ] , <nl> - \" qstring \" : [ <nl> - { <nl> - token : \" string \" , <nl> - regex : \" ( ? : ( ? : \\ \\ \\ \\ . ) | ( ? : [ ^ ' \\ \\ \\ \\ ] ) ) * ? ' \" , <nl> - next : \" start \" <nl> - } , { <nl> - token : \" string \" , <nl> - regex : ' . + ' <nl> - } <nl> - ] , <nl> + \" comment \" : [ { token : \" comment \" , regex : \" - / \" , next : \" start \" } , <nl> + { defaultToken : \" comment \" } ] , <nl> + \" qqstring \" : [ { token : \" string \" , regex : ' ( ? : ( ? : \\ \\ \\ \\ . ) | ( ? : [ ^ \" \\ \\ \\ \\ ] ) ) * ? \" ' , next : \" start \" } , <nl> + { defaultToken : \" qqstring \" } ] , <nl> + \" qstring \" : [ { token : \" string \" , regex : \" ( ? : ( ? : \\ \\ \\ \\ . ) | ( ? : [ ^ ' \\ \\ \\ \\ ] ) ) * ? ' \" , next : \" start \" } , <nl> + { defaultToken : \" qstring \" } ] , <nl> \" directive \" : [ <nl> { <nl> token : \" constant . other . multiline \" , <nl>\n", "msg": "use ' defaultToken ' for comment / qqstring / qstring in lean - mode\n", "score": 1}
{"diff_id": 37792, "repo": "adobe/brackets\n", "sha": "57f3085a3749cc2d944bb2ba2ee377a485514064\n", "time": "2013-11-26T22:20:14Z\n", "diff": "mmm a / src / search / FindInFiles . js <nl> ppp b / src / search / FindInFiles . js <nl> define ( function ( require , exports , module ) { <nl> <nl> / * * @ type { FindInFilesDialog } dialog having the modalbar for search * / <nl> var dialog = null ; <nl> + <nl> + / * * <nl> + * FileSystem change event handler . Updates the search results based on a changed <nl> + * entry and optionally sets of added and removed child entries . <nl> + * <nl> + * @ type { function ( FileSystemEntry , Array . < FileSystemEntry > = , Array . < FileSystemEntry > = ) } <nl> + * * / <nl> + var _fileSystemChangeHandler ; <nl> <nl> / * * <nl> * @ private <nl> define ( function ( require , exports , module ) { <nl> return Strings . FIND_IN_FILES_NO_SCOPE ; <nl> } <nl> } <nl> - <nl> + <nl> / * * <nl> * @ private <nl> * Hides the Search Results Panel <nl> define ( function ( require , exports , module ) { <nl> searchResultsPanel . hide ( ) ; <nl> $ ( DocumentModule ) . off ( \" . findInFiles \" ) ; <nl> } <nl> + <nl> + FileSystem . off ( \" change \" , _fileSystemChangeHandler ) ; <nl> } <nl> <nl> - <nl> / * * <nl> * @ private <nl> * Searches through the contents an returns an array of matches <nl> define ( function ( require , exports , module ) { <nl> * @ param { string } fullPath <nl> * @ param { string } contents <nl> * @ param { RegExp } queryExpr <nl> + * @ return { boolean } True iff matches were added to the search results <nl> * / <nl> function _addSearchMatches ( fullPath , contents , queryExpr ) { <nl> var matches = _getSearchMatches ( contents , queryExpr ) ; <nl> define ( function ( require , exports , module ) { <nl> matches : matches , <nl> collapsed : false <nl> } ; <nl> + return true ; <nl> } <nl> + return false ; <nl> } <nl> <nl> / * * <nl> define ( function ( require , exports , module ) { <nl> return Math . floor ( ( numMatches - 1 ) / RESULTS_PER_PAGE ) * RESULTS_PER_PAGE ; <nl> } <nl> <nl> - <nl> / * * <nl> * @ private <nl> * Shows the results in a table and adds the necessary event listeners <nl> define ( function ( require , exports , module ) { <nl> dialog . _close ( ) ; <nl> dialog = null ; <nl> } <nl> + <nl> + FileSystem . on ( \" change \" , _fileSystemChangeHandler ) ; <nl> } else { <nl> <nl> _hideSearchResults ( ) ; <nl> define ( function ( require , exports , module ) { <nl> } <nl> } <nl> } <nl> - <nl> - <nl> - <nl> + <nl> / * * <nl> * @ private <nl> * Shows the search results and tries to restore the previous scroll and selection <nl> define ( function ( require , exports , module ) { <nl> } <nl> } <nl> } <nl> - <nl> + <nl> / * * <nl> * @ private <nl> * Update the search results using the given list of changes fr the given document <nl> define ( function ( require , exports , module ) { <nl> } <nl> } <nl> } <nl> + <nl> + function _doSearchInOneFile ( addMatches , file ) { <nl> + var result = new $ . Deferred ( ) ; <nl> + <nl> + if ( ! _inScope ( file , currentScope ) ) { <nl> + result . resolve ( ) ; <nl> + } else { <nl> + DocumentManager . getDocumentText ( file ) <nl> + . done ( function ( text ) { <nl> + addMatches ( file . fullPath , text , currentQueryExpr ) ; <nl> + result . resolve ( ) ; <nl> + } ) <nl> + . fail ( function ( error ) { <nl> + / / Always resolve . If there is an error , this file <nl> + / / is skipped and we move on to the next file . <nl> + result . resolve ( ) ; <nl> + } ) ; <nl> + } <nl> + return result . promise ( ) ; <nl> + } <nl> <nl> / * * <nl> * @ private <nl> define ( function ( require , exports , module ) { <nl> perfTimer = PerfUtils . markStart ( \" FindIn : \" + scopeName + \" - \" + query ) ; <nl> <nl> ProjectManager . getAllFiles ( true ) <nl> - . done ( function ( fileListResult ) { <nl> - Async . doInParallel ( fileListResult , function ( file ) { <nl> - var result = new $ . Deferred ( ) ; <nl> - <nl> - if ( ! _inScope ( file , currentScope ) ) { <nl> - result . resolve ( ) ; <nl> - } else { <nl> - DocumentManager . getDocumentText ( file ) <nl> - . done ( function ( text ) { <nl> - _addSearchMatches ( file . fullPath , text , currentQueryExpr ) ; <nl> - result . resolve ( ) ; <nl> - } ) <nl> - . fail ( function ( error ) { <nl> - / / Always resolve . If there is an error , this file <nl> - / / is skipped and we move on to the next file . <nl> - result . resolve ( ) ; <nl> - } ) ; <nl> - } <nl> - return result . promise ( ) ; <nl> - } ) <nl> - . done ( function ( ) { <nl> - / / Done searching all files : show results <nl> - _showSearchResults ( ) ; <nl> - StatusBar . hideBusyIndicator ( ) ; <nl> - PerfUtils . addMeasurement ( perfTimer ) ; <nl> - $ ( DocumentModule ) . on ( \" documentChange . findInFiles \" , _documentChangeHandler ) ; <nl> - } ) <nl> - . fail ( function ( ) { <nl> - console . log ( \" find in files failed . \" ) ; <nl> - StatusBar . hideBusyIndicator ( ) ; <nl> - PerfUtils . finalizeMeasurement ( perfTimer ) ; <nl> - } ) ; <nl> + . then ( function ( fileListResult ) { <nl> + var doSearch = _doSearchInOneFile . bind ( undefined , _addSearchMatches ) ; <nl> + return Async . doInParallel ( fileListResult , doSearch ) ; <nl> + } ) <nl> + . done ( function ( ) { <nl> + / / Done searching all files : show results <nl> + _showSearchResults ( ) ; <nl> + StatusBar . hideBusyIndicator ( ) ; <nl> + PerfUtils . addMeasurement ( perfTimer ) ; <nl> + $ ( DocumentModule ) . on ( \" documentChange . findInFiles \" , _documentChangeHandler ) ; <nl> + } ) <nl> + . fail ( function ( err ) { <nl> + console . log ( \" find in files failed : \" , err ) ; <nl> + StatusBar . hideBusyIndicator ( ) ; <nl> + PerfUtils . finalizeMeasurement ( perfTimer ) ; <nl> } ) ; <nl> } <nl> <nl> define ( function ( require , exports , module ) { <nl> * Handle a FileSystem \" change \" event <nl> * @ param { $ . Event } event <nl> * @ param { FileSystemEntry } entry <nl> + * @ param { Array . < FileSystemEntry > = } added Added children <nl> + * @ param { Array . < FileSystemEntry > = } removed Removed children <nl> * / <nl> - function _fileSystemChangeHandler ( event , entry ) { <nl> + _fileSystemChangeHandler = function ( event , entry , added , removed ) { <nl> if ( entry & & entry . isDirectory ) { <nl> var resultsChanged = false ; <nl> <nl> - / / This is a temporary watcher implementation that needs to be updated <nl> - / / once we have our final watcher API . Specifically , we will be adding <nl> - / / ' added ' and ' removed ' parameters to this function to easily determine <nl> - / / which files / folders have been added or removed . <nl> - / / <nl> - / / In the meantime , do a quick check for directory changed events to see <nl> - / / if any of the search results files have been deleted . <nl> - if ( searchResultsPanel . isVisible ( ) ) { <nl> - entry . getContents ( function ( err , contents ) { <nl> - if ( ! err ) { <nl> - var _includesPath = function ( fullPath ) { <nl> - return _ . some ( contents , function ( item ) { <nl> - return item . fullPath = = = fullPath ; <nl> - } ) ; <nl> - } ; <nl> - <nl> - / / Update the search results <nl> - _ . forEach ( searchResults , function ( item , fullPath ) { <nl> - if ( fullPath . lastIndexOf ( \" / \" ) = = = entry . fullPath . length - 1 ) { <nl> - / / The changed directory includes this entry . Make sure the file still exits . <nl> - if ( ! _includesPath ( fullPath ) ) { <nl> - delete searchResults [ fullPath ] ; <nl> - resultsChanged = true ; <nl> - } <nl> - } <nl> - } ) ; <nl> - <nl> - / / Restore the results if needed <nl> - if ( resultsChanged ) { <nl> - _restoreSearchResults ( ) ; <nl> - } <nl> + if ( removed & & removed . length > 0 ) { <nl> + var _includesPath = function ( fullPath ) { <nl> + return _ . some ( removed , function ( item ) { <nl> + return item . fullPath = = = fullPath ; <nl> + } ) ; <nl> + } ; <nl> + <nl> + / / Clear removed entries from the search results <nl> + _ . forEach ( searchResults , function ( item , fullPath ) { <nl> + if ( fullPath . indexOf ( entry . fullPath ) = = = 0 & & _includesPath ( fullPath ) ) { <nl> + / / The changed directory includes this entry and it was not removed . <nl> + delete searchResults [ fullPath ] ; <nl> + resultsChanged = true ; <nl> } <nl> } ) ; <nl> } <nl> + <nl> + var addPromise ; <nl> + if ( added & & added . length > 0 ) { <nl> + var doSearch = _doSearchInOneFile . bind ( undefined , function ( ) { <nl> + var resultsAdded = _addSearchMatches . apply ( undefined , arguments ) ; <nl> + resultsChanged = resultsChanged | | resultsAdded ; <nl> + } ) ; <nl> + addPromise = Async . doInParallel ( added , doSearch ) ; <nl> + } else { <nl> + addPromise = $ . Deferred ( ) . resolve ( ) . promise ( ) ; <nl> + } <nl> + <nl> + addPromise . done ( function ( ) { <nl> + / / Restore the results if needed <nl> + if ( resultsChanged ) { <nl> + _restoreSearchResults ( ) ; <nl> + } <nl> + } ) ; <nl> } <nl> - } <nl> - <nl> - <nl> + } ; <nl> <nl> / / Initialize items dependent on HTML DOM <nl> AppInit . htmlReady ( function ( ) { <nl> define ( function ( require , exports , module ) { <nl> $ ( DocumentManager ) . on ( \" fileNameChange \" , _fileNameChangeHandler ) ; <nl> $ ( ProjectManager ) . on ( \" beforeProjectClose \" , _hideSearchResults ) ; <nl> <nl> - FileSystem . on ( \" change \" , _fileSystemChangeHandler ) ; <nl> - <nl> / / Initialize : command handlers <nl> CommandManager . register ( Strings . CMD_FIND_IN_FILES , Commands . EDIT_FIND_IN_FILES , _doFindInFiles ) ; <nl> CommandManager . register ( Strings . CMD_FIND_IN_SUBTREE , Commands . EDIT_FIND_IN_SUBTREE , _doFindInSubtree ) ; <nl>\n", "msg": "Update search results using filesystem change event added and removed sets\n", "score": 1}
{"diff_id": 37879, "repo": "gatsbyjs/gatsby\n", "sha": "ee2cc7e95fac9b22a79d65dce6f3f768584ae4f8\n", "time": "2017-01-25T22:40:24Z\n", "diff": "mmm a / packages / gatsby / lib / utils / webpack . config . js <nl> ppp b / packages / gatsby / lib / utils / webpack . config . js <nl> module . exports = async ( program , directory , suppliedStage , webpackPort = 1500 , p <nl> / / \" file \" loader makes sure those assets end up in the ` public ` folder . <nl> / / When you ` import ` an asset , you get its filename . <nl> config . loader ( ` file - loader ` , { <nl> - test : / \\ . ( ico | eot | otf | webp | ttf ) ( \\ ? . * ) ? $ / , <nl> + test : / \\ . ( ico | eot | otf | webp | ttf | woff ( 2 ) ? ) ( \\ ? . * ) ? $ / , <nl> loader : ` file ` , <nl> query : { <nl> name : ` static / [ name ] . [ hash : 8 ] . [ ext ] ` , <nl> module . exports = async ( program , directory , suppliedStage , webpackPort = 1500 , p <nl> name : ` static / [ name ] . [ hash : 8 ] . [ ext ] ` , <nl> } , <nl> } ) <nl> - / / Font loader . <nl> - config . loader ( ` woff ` , { <nl> - test : / \\ . woff ( 2 ) ? ( \\ ? v = [ 0 - 9 ] \\ . [ 0 - 9 ] \\ . [ 0 - 9 ] ) ? $ / , <nl> - loader : ` url ` , <nl> - query : { <nl> - limit : 15000 , / / Set high limit for inlining fonts as they ' re in the <nl> - / / critical path for rendering . <nl> - name : ` static / [ name ] . [ hash : 8 ] . [ ext ] ` , <nl> - mimetype : ` application / font - woff ` , <nl> - } <nl> - } ) <nl> <nl> const cssModulesConf = ` css ? modules & minimize & importLoaders = 1 ` <nl> const cssModulesConfDev = <nl>\n", "msg": "Make deciding to inline woff2 files an explicit decision\n", "score": 1}
{"diff_id": 37937, "repo": "meteor/meteor\n", "sha": "984e27e372ff4d9587ad9ad2dadfb047d5ba09b3\n", "time": "2016-04-11T22:26:37Z\n", "diff": "mmm a / tools / isobuild / import - scanner . js <nl> ppp b / tools / isobuild / import - scanner . js <nl> <nl> import assert from \" assert \" ; <nl> + import { inspect } from \" util \" ; <nl> import { Script } from \" vm \" ; <nl> import { <nl> - isString , isEmpty , has , keys , each , map , without <nl> + isString , isEmpty , has , keys , each , map , omit , <nl> } from \" underscore \" ; <nl> import { sha1 , readAndWatchFileWithHash } from \" . . / fs / watch . js \" ; <nl> import { matches as archMatches } from \" . . / utils / archinfo . js \" ; <nl> export default class ImportScanner { <nl> / / maps and updating all other properties appropriately . Once this <nl> / / combination is done , oldFile should be kept and newFile discarded . <nl> _combineFiles ( oldFile , newFile ) { <nl> + function checkProperty ( name ) { <nl> + if ( has ( oldFile , name ) ) { <nl> + if ( ! has ( newFile , name ) ) { <nl> + newFile [ name ] = oldFile [ name ] ; <nl> + } <nl> + } else if ( has ( newFile , name ) ) { <nl> + oldFile [ name ] = newFile [ name ] ; <nl> + } <nl> + <nl> + if ( oldFile [ name ] ! = = newFile [ name ] ) { <nl> + throw new Error ( <nl> + \" Attempting to combine different files : \\ n \" + <nl> + inspect ( omit ( oldFile , \" dataString \" ) ) + \" \\ n \" + <nl> + inspect ( omit ( newFile , \" dataString \" ) ) + \" \\ n \" <nl> + ) ; <nl> + } <nl> + } <nl> + <nl> / / Since we ' re concatenating the files together , they must be either <nl> / / both lazy or both eager . Same for bareness . <nl> - assert . strictEqual ( oldFile . lazy , newFile . lazy ) ; <nl> - assert . strictEqual ( oldFile . bare , newFile . bare ) ; <nl> + checkProperty ( \" lazy \" ) ; <nl> + checkProperty ( \" bare \" ) ; <nl> <nl> function getChunk ( file ) { <nl> const consumer = file . sourceMap & & <nl>\n", "msg": "Better error message for _combineFiles lazy / bare mismatch .\n", "score": 1}
{"diff_id": 38207, "repo": "photonstorm/phaser\n", "sha": "92982d810b6f17dbbbbd42645f6a8db221c3d4d4\n", "time": "2020-09-14T16:35:06Z\n", "diff": "mmm a / src / gameobjects / mesh / Face . js <nl> ppp b / src / gameobjects / mesh / Face . js <nl> <nl> * / <nl> <nl> var Class = require ( ' . . / . . / utils / Class ' ) ; <nl> + var Vector2 = require ( ' . . / . . / math / Vector2 ' ) ; <nl> + <nl> + function GetLength ( x1 , y1 , x2 , y2 ) <nl> + { <nl> + var x = x1 - x2 ; <nl> + var y = y1 - y2 ; <nl> + var magnitude = ( x * x ) + ( y * y ) ; <nl> + <nl> + return Math . sqrt ( magnitude ) ; <nl> + } <nl> <nl> / * * <nl> * @ classdesc <nl> var Face = new Class ( { <nl> * @ since 3 . 50 . 0 <nl> * / <nl> this . vertex3 = vertex3 ; <nl> + <nl> + / * * <nl> + * The face inCenter . Do not access directly , instead use the ` getInCenter ` method . <nl> + * <nl> + * @ name Phaser . GameObjects . Face # _inCenter <nl> + * @ type { Phaser . Math . Vector2 } <nl> + * @ private <nl> + * @ since 3 . 50 . 0 <nl> + * / <nl> + this . _inCenter = new Vector2 ( ) ; <nl> + } , <nl> + <nl> + getInCenter : function ( ) <nl> + { <nl> + var v1 = this . vertex1 ; <nl> + var v2 = this . vertex2 ; <nl> + var v3 = this . vertex3 ; <nl> + <nl> + var d1 = GetLength ( v3 . x , v3 . y , v2 . x , v2 . y ) ; <nl> + var d2 = GetLength ( v1 . x , v1 . y , v3 . x , v3 . y ) ; <nl> + var d3 = GetLength ( v2 . x , v2 . y , v1 . x , v1 . y ) ; <nl> + <nl> + var p = d1 + d2 + d3 ; <nl> + <nl> + return this . _inCenter . set ( <nl> + ( v1 . x * d1 + v2 . x * d2 + v3 . x * d3 ) / p , <nl> + ( v1 . y * d1 + v2 . y * d2 + v3 . y * d3 ) / p <nl> + ) ; <nl> + } , <nl> + <nl> + translate : function ( x , y ) <nl> + { <nl> + if ( y = = = undefined ) { y = 0 ; } <nl> + <nl> + var v1 = this . vertex1 ; <nl> + var v2 = this . vertex2 ; <nl> + var v3 = this . vertex3 ; <nl> + <nl> + v1 . translate ( x , y ) ; <nl> + v2 . translate ( x , y ) ; <nl> + v3 . translate ( x , y ) ; <nl> + <nl> + return this ; <nl> + } , <nl> + <nl> + rotate : function ( angle , cx , cy ) <nl> + { <nl> + var x ; <nl> + var y ; <nl> + <nl> + / / No point of rotation ? Use the inCenter instead , then . <nl> + if ( cx = = = undefined & & cy = = = undefined ) <nl> + { <nl> + var inCenter = this . getInCenter ( ) ; <nl> + <nl> + x = inCenter . x ; <nl> + y = inCenter . y ; <nl> + } <nl> + <nl> + var c = Math . cos ( angle ) ; <nl> + var s = Math . sin ( angle ) ; <nl> + <nl> + var v1 = this . vertex1 ; <nl> + var v2 = this . vertex2 ; <nl> + var v3 = this . vertex3 ; <nl> + <nl> + var tx = v1 . x - x ; <nl> + var ty = v1 . y - y ; <nl> + <nl> + v1 . setPosition ( tx * c - ty * s + x , tx * s + ty * c + y ) ; <nl> + <nl> + tx = v2 . x - x ; <nl> + ty = v2 . y - y ; <nl> + <nl> + v2 . setPosition ( tx * c - ty * s + x , tx * s + ty * c + y ) ; <nl> + <nl> + tx = v3 . x - x ; <nl> + ty = v3 . y - y ; <nl> + <nl> + v3 . setPosition ( tx * c - ty * s + x , tx * s + ty * c + y ) ; <nl> + <nl> + return this ; <nl> + } , <nl> + <nl> + x : { <nl> + <nl> + get : function ( ) <nl> + { <nl> + return this . getInCenter ( ) . x ; <nl> + } , <nl> + <nl> + set : function ( value ) <nl> + { <nl> + var current = this . getInCenter ( ) ; <nl> + <nl> + this . translate ( value - current . x , 0 ) ; <nl> + } <nl> + <nl> + } , <nl> + <nl> + y : { <nl> + <nl> + get : function ( ) <nl> + { <nl> + return this . getInCenter ( ) . y ; <nl> + } , <nl> + <nl> + set : function ( value ) <nl> + { <nl> + var current = this . getInCenter ( ) ; <nl> + <nl> + this . translate ( 0 , value - current . y ) ; <nl> + } <nl> + <nl> + } , <nl> + <nl> + destroy : function ( ) <nl> + { <nl> + this . vertex1 = null ; <nl> + this . vertex2 = null ; <nl> + this . vertex3 = null ; <nl> } <nl> <nl> } ) ; <nl>\n", "msg": "Added ability to get InCenter . translate and rotate Face\n", "score": 1}
{"diff_id": 38267, "repo": "twbs/bootstrap\n", "sha": "8d34bc136b54f4605595f228253463c90a3c5c97\n", "time": "2019-02-20T20:05:45Z\n", "diff": "mmm a / js / src / util . js <nl> ppp b / js / src / util . js <nl> function toType ( obj ) { <nl> return { } . toString . call ( obj ) . match ( / \\ s ( [ a - z ] + ) / i ) [ 1 ] . toLowerCase ( ) <nl> } <nl> <nl> - function getSpecialTransitionEndEvent ( ) { <nl> - return { <nl> - bindType : TRANSITION_END , <nl> - delegateType : TRANSITION_END , <nl> - handle ( event ) { <nl> - if ( $ ( event . target ) . is ( this ) ) { <nl> - return event . handleObj . handler . apply ( this , arguments ) / / eslint - disable - line prefer - rest - params <nl> - } <nl> - return undefined / / eslint - disable - line no - undefined <nl> - } <nl> - } <nl> - } <nl> - <nl> - function transitionEndEmulator ( duration ) { <nl> - let called = false <nl> - <nl> - $ ( this ) . one ( Util . TRANSITION_END , ( ) = > { <nl> - called = true <nl> - } ) <nl> - <nl> - setTimeout ( ( ) = > { <nl> - if ( ! called ) { <nl> - Util . triggerTransitionEnd ( this ) <nl> - } <nl> - } , duration ) <nl> - <nl> - return this <nl> - } <nl> - <nl> - function setTransitionEndSupport ( ) { <nl> - $ . fn . emulateTransitionEnd = transitionEndEmulator <nl> - $ . event . special [ Util . TRANSITION_END ] = getSpecialTransitionEndEvent ( ) <nl> - } <nl> - <nl> - / * * <nl> - * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - <nl> - * Public Util Api <nl> - * mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm - - <nl> - * / <nl> - <nl> const Util = { <nl> <nl> TRANSITION_END : ' bsTransitionEnd ' , <nl>\n", "msg": "Move transition end detection to dom / event . js instead of util . js\n", "score": 1}
{"diff_id": 38462, "repo": "photonstorm/phaser\n", "sha": "6fd2b6a7ec616529d3426363f7e25ef2b7fe00fb\n", "time": "2015-09-30T10:18:53Z\n", "diff": "mmm a / src / core / Create . js <nl> ppp b / src / core / Create . js <nl> Phaser . Create = function ( game ) { <nl> / * * <nl> * @ property { Phaser . BitmapData } bmd - The internal BitmapData Create uses to generate textures from . <nl> * / <nl> - this . bmd = game . make . bitmapData ( ) ; <nl> + this . bmd = null ; <nl> <nl> / * * <nl> * @ property { HTMLCanvasElement } canvas - The canvas the BitmapData uses . <nl> * / <nl> - this . canvas = this . bmd . canvas ; <nl> + this . canvas = null ; <nl> <nl> / * * <nl> * @ property { CanvasRenderingContext2D } context - The 2d context of the canvas . <nl> * / <nl> - this . ctx = this . bmd . context ; <nl> + this . ctx = null ; <nl> <nl> / * * <nl> * @ property { array } palettes - A range of 16 color palettes for use with sprite generation . <nl> Phaser . Create . prototype = { <nl> var w = data [ 0 ] . length * pixelWidth ; <nl> var h = data . length * pixelHeight ; <nl> <nl> + / / No bmd ? Let ' s make one <nl> + if ( this . bmd = = = null ) <nl> + { <nl> + this . bmd = game . make . bitmapData ( ) ; <nl> + this . canvas = this . bmd . canvas ; <nl> + this . ctx = this . bmd . context ; <nl> + } <nl> + <nl> this . bmd . resize ( w , h ) ; <nl> this . bmd . clear ( ) ; <nl> <nl> Phaser . Create . prototype = { <nl> * / <nl> grid : function ( key , width , height , cellWidth , cellHeight , color ) { <nl> <nl> + / / No bmd ? Let ' s make one <nl> + if ( this . bmd = = = null ) <nl> + { <nl> + this . bmd = game . make . bitmapData ( ) ; <nl> + this . canvas = this . bmd . canvas ; <nl> + this . ctx = this . bmd . context ; <nl> + } <nl> + <nl> this . bmd . resize ( width , height ) ; <nl> <nl> this . ctx . fillStyle = color ; <nl>\n", "msg": "Phaser . Create no longer automatically creates a BitmapData object when it starts . It now only does it when you first make a texture or grid .\n", "score": 1}
{"diff_id": 38557, "repo": "ReactTraining/react-router\n", "sha": "d5234f67139882972797082ea819500851d42773\n", "time": "2016-08-11T03:07:23Z\n", "diff": "mmm a / modules / BrowserHistory . js <nl> ppp b / modules / BrowserHistory . js <nl> import { <nl> supportsHistory , <nl> supportsPopStateOnHashChange <nl> } from ' . / DOMUtils ' <nl> - import { <nl> - stateStorage as stateStorageType <nl> - } from ' . / PropTypes ' <nl> <nl> const PopStateEvent = ' popstate ' <nl> const HashChangeEvent = ' hashchange ' <nl> const getHistoryState = ( ) = > { <nl> class BrowserHistory extends React . Component { <nl> static propTypes = { <nl> children : PropTypes . func . isRequired , <nl> - keyLength : PropTypes . number , <nl> - stateStorage : stateStorageType <nl> + keyLength : PropTypes . number <nl> } <nl> <nl> static defaultProps = { <nl> - keyLength : 6 , <nl> - stateStorage : DOMStateStorage <nl> + keyLength : 6 <nl> } <nl> <nl> state = { <nl> class BrowserHistory extends React . Component { <nl> } <nl> <nl> createLocation ( historyState ) { <nl> - const key = historyState & & historyState . key <nl> + const { key , state } = ( historyState | | { } ) <nl> const { pathname , search , hash } = window . location <nl> <nl> return { <nl> path : pathname + search + hash , <nl> - state : key ? this . props . stateStorage . readState ( key ) : undefined , <nl> + state , <nl> key <nl> } <nl> } <nl> class BrowserHistory extends React . Component { <nl> <nl> const key = this . createKey ( ) <nl> <nl> - if ( state ! = = undefined ) <nl> - this . props . stateStorage . saveState ( key , state ) <nl> - <nl> - window . history . pushState ( { key } , null , path ) <nl> + window . history . pushState ( { key , state } , null , path ) <nl> <nl> this . setState ( { <nl> action : ' PUSH ' , <nl> class BrowserHistory extends React . Component { <nl> <nl> const key = this . createKey ( ) <nl> <nl> - if ( state ! = = undefined ) <nl> - this . props . stateStorage . saveState ( key , state ) <nl> - <nl> - window . history . replaceState ( { key } , null , path ) <nl> + window . history . replaceState ( { key , state } , null , path ) <nl> <nl> this . setState ( { <nl> action : ' REPLACE ' , <nl>\n", "msg": "Use location state for storage\n", "score": 1}
{"diff_id": 38576, "repo": "Leaflet/Leaflet\n", "sha": "e4c801a514309ac0ee0d694c6a4b2d91ffd8576b\n", "time": "2013-07-20T01:30:05Z\n", "diff": "mmm a / src / layer / marker / Marker . js <nl> ppp b / src / layer / marker / Marker . js <nl> L . Marker = L . Class . extend ( { <nl> this . update ( ) ; <nl> } <nl> <nl> + if ( this . _popup ) { <nl> + this . bindPopup ( this . _popup ) ; <nl> + } <nl> + <nl> return this ; <nl> } , <nl> <nl>\n", "msg": "rebind popup when using setIcon to ensure proper popup anchor placement\n", "score": 1}
{"diff_id": 38711, "repo": "emberjs/ember.js\n", "sha": "03fa90f63e7e2c709c8adfb41a1cbff968dd8cb4\n", "time": "2015-02-03T02:31:25Z\n", "diff": "mmm a / packages / ember - views / lib / attr_nodes / legacy_bind . js <nl> ppp b / packages / ember - views / lib / attr_nodes / legacy_bind . js <nl> import AttrNode from \" . / attr_node \" ; <nl> import { fmt } from \" ember - runtime / system / string \" ; <nl> import { typeOf } from \" ember - metal / utils \" ; <nl> import { read } from \" ember - metal / streams / utils \" ; <nl> + import create from ' ember - metal / platform / create ' ; <nl> <nl> function LegacyBindAttrNode ( attrName , attrValue ) { <nl> this . init ( attrName , attrValue ) ; <nl> } <nl> <nl> - LegacyBindAttrNode . prototype = AttrNode . prototype ; <nl> + LegacyBindAttrNode . prototype = create ( AttrNode . prototype ) ; <nl> <nl> LegacyBindAttrNode . prototype . render = function render ( buffer ) { <nl> this . isDirty = false ; <nl>\n", "msg": "[ BUGFIX beta ] proto inherit for LegacyBindAttrNode missing Object . create\n", "score": 1}
{"diff_id": 38718, "repo": "styled-components/styled-components\n", "sha": "6d2bde6791b9ca5189a7c97474cf30941a380703\n", "time": "2018-09-18T13:14:37Z\n", "diff": "mmm a / src / constructors / injectGlobal . js <nl> ppp b / src / constructors / injectGlobal . js <nl> let warnInjectGlobalDeprecated <nl> if ( process . env . NODE_ENV ! = = ' production ' ) { <nl> warnInjectGlobalDeprecated = once ( ( ) = > { <nl> / / eslint - disable - next - line no - console <nl> - console . error ( <nl> + console . warn ( <nl> ' Notice : The \" injectGlobal \" API will be removed in the upcoming v4 . 0 release . Use \" createGlobalStyle \" instead . You can find more information here : https : / / github . com / styled - components / styled - components / issues / 1333 ' <nl> ) <nl> } ) <nl>\n", "msg": "Tone down dev warning for deprecated injectGlobal\n", "score": 1}
{"diff_id": 38947, "repo": "TryGhost/Ghost\n", "sha": "4a90d42132a169629113f4fc960c494eef195edd\n", "time": "2015-08-21T16:16:21Z\n", "diff": "mmm a / core / client / Brocfile . js <nl> ppp b / core / client / Brocfile . js <nl> app = new EmberApp ( { <nl> source : ' . / app / styles / app . css ' , <nl> inputFile : ' app . css ' , <nl> browsers : ' last 2 versions ' , <nl> - outputFile : ' ghost . css ' <nl> + outputFile : isProduction ? ' ghost . min . css ' : ' ghost . css ' <nl> } , <nl> hinting : false , <nl> fingerprint : disabled <nl>\n", "msg": "Use ` ghost . min . css ` when building for production .\n", "score": 1}
{"diff_id": 39425, "repo": "photonstorm/phaser\n", "sha": "8eebe518ad0ebb8a440b026b3b43944542faecbd\n", "time": "2018-12-18T13:36:05Z\n", "diff": "mmm a / src / renderer / webgl / WebGLRenderer . js <nl> ppp b / src / renderer / webgl / WebGLRenderer . js <nl> var WebGLRenderer = new Class ( { <nl> * @ param { string } pipelineName - A unique string - based key for the pipeline . <nl> * @ param { Phaser . Renderer . WebGL . WebGLPipeline } pipelineInstance - A pipeline instance which must extend WebGLPipeline . <nl> * <nl> - * @ return { Phaser . Renderer . WebGL . WebGLPipeline } The pipline instance that was passed . <nl> + * @ return { Phaser . Renderer . WebGL . WebGLPipeline } The pipeline instance that was passed . <nl> * / <nl> addPipeline : function ( pipelineName , pipelineInstance ) <nl> { <nl> var WebGLRenderer = new Class ( { <nl> * @ param { integer } y - The y position of the scissor . <nl> * @ param { integer } width - The width of the scissor . <nl> * @ param { integer } height - The height of the scissor . <nl> + * @ param { integer } [ drawingBufferHeight ] - Optional drawingBufferHeight override value . <nl> * <nl> * @ return { integer [ ] } An array containing the scissor values . <nl> * / <nl> - pushScissor : function ( x , y , width , height ) <nl> + pushScissor : function ( x , y , width , height , drawingBufferHeight ) <nl> { <nl> + if ( drawingBufferHeight = = = undefined ) { drawingBufferHeight = this . drawingBufferHeight ; } <nl> + <nl> var scissorStack = this . scissorStack ; <nl> <nl> var scissor = [ x , y , width , height ] ; <nl> <nl> scissorStack . push ( scissor ) ; <nl> <nl> - this . setScissor ( x , y , width , height ) ; <nl> + this . setScissor ( x , y , width , height , drawingBufferHeight ) ; <nl> <nl> this . currentScissor = scissor ; <nl> <nl> var WebGLRenderer = new Class ( { <nl> * @ param { integer } y - The y position of the scissor . <nl> * @ param { integer } width - The width of the scissor . <nl> * @ param { integer } height - The height of the scissor . <nl> + * @ param { integer } [ drawingBufferHeight ] - Optional drawingBufferHeight override value . <nl> * / <nl> - setScissor : function ( x , y , width , height ) <nl> + setScissor : function ( x , y , width , height , drawingBufferHeight ) <nl> { <nl> var gl = this . gl ; <nl> <nl> var WebGLRenderer = new Class ( { <nl> this . flush ( ) ; <nl> <nl> / / https : / / developer . mozilla . org / en - US / docs / Web / API / WebGLRenderingContext / scissor <nl> - gl . scissor ( x , ( this . drawingBufferHeight - y - height ) , width , height ) ; <nl> + gl . scissor ( x , ( drawingBufferHeight - y - height ) , width , height ) ; <nl> } <nl> } , <nl> <nl>\n", "msg": "Added optional drawingBufferHeight argument to scissor methods .\n", "score": 1}
{"diff_id": 39596, "repo": "hakimel/reveal.js\n", "sha": "6831f6c17415c6c20269f3d61e673482442319b6\n", "time": "2016-12-12T14:30:07Z\n", "diff": "mmm a / js / reveal . js <nl> ppp b / js / reveal . js <nl> <nl> <nl> / / HTML5 media elements <nl> toArray ( slide . querySelectorAll ( ' video , audio ' ) ) . forEach ( function ( el ) { <nl> - if ( el . hasAttribute ( ' data - autoplay ' ) & & typeof el . play = = = ' function ' ) { <nl> + if ( ( el . hasAttribute ( ' data - autoplay ' ) | | el . hasAttribute ( ' data - paused - by - reveal ' ) ) & & typeof el . play = = = ' function ' ) { <nl> + el . removeAttribute ( ' data - paused - by - reveal ' ) ; <nl> el . play ( ) ; <nl> } <nl> } ) ; <nl> <nl> / / HTML5 media elements <nl> toArray ( slide . querySelectorAll ( ' video , audio ' ) ) . forEach ( function ( el ) { <nl> if ( ! el . hasAttribute ( ' data - ignore ' ) & & typeof el . pause = = = ' function ' ) { <nl> + el . addAttribute ( ' data - paused - by - reveal ' ) ; <nl> el . pause ( ) ; <nl> } <nl> } ) ; <nl>\n", "msg": ", resume playback for paused media .\n", "score": 1}
